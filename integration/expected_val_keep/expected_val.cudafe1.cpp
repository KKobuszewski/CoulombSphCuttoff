# 1 "expected_val.cu"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 1
#pragma GCC diagnostic push
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"
# 1
#pragma GCC diagnostic ignored "-Wunused-function"
# 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
# 1
#pragma GCC diagnostic pop
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"

# 1
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false

# 1
# 56 "/usr/local/cuda/include/cuda_runtime.h"
#pragma GCC diagnostic push
# 59
#pragma GCC diagnostic ignored "-Wunused-function"
# 61 "/usr/local/cuda/include/device_types.h"
#if 0
# 61
enum cudaRoundMode { 
# 63
cudaRoundNearest, 
# 64
cudaRoundZero, 
# 65
cudaRoundPosInf, 
# 66
cudaRoundMinInf
# 67
}; 
#endif
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3
typedef long ptrdiff_t; 
# 216
typedef unsigned long size_t; 
#include "crt/host_runtime.h"
# 156 "/usr/local/cuda/include/driver_types.h"
#if 0
# 156
enum cudaError { 
# 163
cudaSuccess, 
# 169
cudaErrorMissingConfiguration, 
# 175
cudaErrorMemoryAllocation, 
# 181
cudaErrorInitializationError, 
# 191
cudaErrorLaunchFailure, 
# 200
cudaErrorPriorLaunchFailure, 
# 210
cudaErrorLaunchTimeout, 
# 219
cudaErrorLaunchOutOfResources, 
# 225
cudaErrorInvalidDeviceFunction, 
# 234
cudaErrorInvalidConfiguration, 
# 240
cudaErrorInvalidDevice, 
# 246
cudaErrorInvalidValue, 
# 252
cudaErrorInvalidPitchValue, 
# 258
cudaErrorInvalidSymbol, 
# 263
cudaErrorMapBufferObjectFailed, 
# 268
cudaErrorUnmapBufferObjectFailed, 
# 274
cudaErrorInvalidHostPointer, 
# 280
cudaErrorInvalidDevicePointer, 
# 286
cudaErrorInvalidTexture, 
# 292
cudaErrorInvalidTextureBinding, 
# 299
cudaErrorInvalidChannelDescriptor, 
# 305
cudaErrorInvalidMemcpyDirection, 
# 315
cudaErrorAddressOfConstant, 
# 324
cudaErrorTextureFetchFailed, 
# 333
cudaErrorTextureNotBound, 
# 342
cudaErrorSynchronizationError, 
# 348
cudaErrorInvalidFilterSetting, 
# 354
cudaErrorInvalidNormSetting, 
# 362
cudaErrorMixedDeviceExecution, 
# 369
cudaErrorCudartUnloading, 
# 374
cudaErrorUnknown, 
# 382
cudaErrorNotYetImplemented, 
# 391
cudaErrorMemoryValueTooLarge, 
# 398
cudaErrorInvalidResourceHandle, 
# 406
cudaErrorNotReady, 
# 413
cudaErrorInsufficientDriver, 
# 426
cudaErrorSetOnActiveProcess, 
# 432
cudaErrorInvalidSurface, 
# 438
cudaErrorNoDevice, 
# 444
cudaErrorECCUncorrectable, 
# 449
cudaErrorSharedObjectSymbolNotFound, 
# 454
cudaErrorSharedObjectInitFailed, 
# 460
cudaErrorUnsupportedLimit, 
# 466
cudaErrorDuplicateVariableName, 
# 472
cudaErrorDuplicateTextureName, 
# 478
cudaErrorDuplicateSurfaceName, 
# 488
cudaErrorDevicesUnavailable, 
# 493
cudaErrorInvalidKernelImage, 
# 501
cudaErrorNoKernelImageForDevice, 
# 514
cudaErrorIncompatibleDriverContext, 
# 521
cudaErrorPeerAccessAlreadyEnabled, 
# 528
cudaErrorPeerAccessNotEnabled, 
# 534
cudaErrorDeviceAlreadyInUse = 54, 
# 541
cudaErrorProfilerDisabled, 
# 549
cudaErrorProfilerNotInitialized, 
# 556
cudaErrorProfilerAlreadyStarted, 
# 563
cudaErrorProfilerAlreadyStopped, 
# 571
cudaErrorAssert, 
# 578
cudaErrorTooManyPeers, 
# 584
cudaErrorHostMemoryAlreadyRegistered, 
# 590
cudaErrorHostMemoryNotRegistered, 
# 595
cudaErrorOperatingSystem, 
# 601
cudaErrorPeerAccessUnsupported, 
# 608
cudaErrorLaunchMaxDepthExceeded, 
# 616
cudaErrorLaunchFileScopedTex, 
# 624
cudaErrorLaunchFileScopedSurf, 
# 639
cudaErrorSyncDepthExceeded, 
# 651
cudaErrorLaunchPendingCountExceeded, 
# 656
cudaErrorNotPermitted, 
# 662
cudaErrorNotSupported, 
# 671
cudaErrorHardwareStackError, 
# 679
cudaErrorIllegalInstruction, 
# 688
cudaErrorMisalignedAddress, 
# 699
cudaErrorInvalidAddressSpace, 
# 707
cudaErrorInvalidPc, 
# 715
cudaErrorIllegalAddress, 
# 721
cudaErrorInvalidPtx, 
# 726
cudaErrorInvalidGraphicsContext, 
# 732
cudaErrorNvlinkUncorrectable, 
# 737
cudaErrorStartupFailure = 127, 
# 745
cudaErrorApiFailureBase = 10000
# 746
}; 
#endif
# 751 "/usr/local/cuda/include/driver_types.h"
#if 0
# 751
enum cudaChannelFormatKind { 
# 753
cudaChannelFormatKindSigned, 
# 754
cudaChannelFormatKindUnsigned, 
# 755
cudaChannelFormatKindFloat, 
# 756
cudaChannelFormatKindNone
# 757
}; 
#endif
# 762 "/usr/local/cuda/include/driver_types.h"
#if 0
# 762
struct cudaChannelFormatDesc { 
# 764
int x; 
# 765
int y; 
# 766
int z; 
# 767
int w; 
# 768
cudaChannelFormatKind f; 
# 769
}; 
#endif
# 774 "/usr/local/cuda/include/driver_types.h"
typedef struct cudaArray *cudaArray_t; 
# 779
typedef const cudaArray *cudaArray_const_t; 
# 781
struct cudaArray; 
# 786
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
# 791
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
# 793
struct cudaMipmappedArray; 
# 798
#if 0
# 798
enum cudaMemoryType { 
# 800
cudaMemoryTypeHost = 1, 
# 801
cudaMemoryTypeDevice
# 802
}; 
#endif
# 807 "/usr/local/cuda/include/driver_types.h"
#if 0
# 807
enum cudaMemcpyKind { 
# 809
cudaMemcpyHostToHost, 
# 810
cudaMemcpyHostToDevice, 
# 811
cudaMemcpyDeviceToHost, 
# 812
cudaMemcpyDeviceToDevice, 
# 813
cudaMemcpyDefault
# 814
}; 
#endif
# 821 "/usr/local/cuda/include/driver_types.h"
#if 0
# 821
struct cudaPitchedPtr { 
# 823
void *ptr; 
# 824
size_t pitch; 
# 825
size_t xsize; 
# 826
size_t ysize; 
# 827
}; 
#endif
# 834 "/usr/local/cuda/include/driver_types.h"
#if 0
# 834
struct cudaExtent { 
# 836
size_t width; 
# 837
size_t height; 
# 838
size_t depth; 
# 839
}; 
#endif
# 846 "/usr/local/cuda/include/driver_types.h"
#if 0
# 846
struct cudaPos { 
# 848
size_t x; 
# 849
size_t y; 
# 850
size_t z; 
# 851
}; 
#endif
# 856 "/usr/local/cuda/include/driver_types.h"
#if 0
# 856
struct cudaMemcpy3DParms { 
# 858
cudaArray_t srcArray; 
# 859
cudaPos srcPos; 
# 860
cudaPitchedPtr srcPtr; 
# 862
cudaArray_t dstArray; 
# 863
cudaPos dstPos; 
# 864
cudaPitchedPtr dstPtr; 
# 866
cudaExtent extent; 
# 867
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 868
}; 
#endif
# 873 "/usr/local/cuda/include/driver_types.h"
#if 0
# 873
struct cudaMemcpy3DPeerParms { 
# 875
cudaArray_t srcArray; 
# 876
cudaPos srcPos; 
# 877
cudaPitchedPtr srcPtr; 
# 878
int srcDevice; 
# 880
cudaArray_t dstArray; 
# 881
cudaPos dstPos; 
# 882
cudaPitchedPtr dstPtr; 
# 883
int dstDevice; 
# 885
cudaExtent extent; 
# 886
}; 
#endif
# 891 "/usr/local/cuda/include/driver_types.h"
struct cudaGraphicsResource; 
# 896
#if 0
# 896
enum cudaGraphicsRegisterFlags { 
# 898
cudaGraphicsRegisterFlagsNone, 
# 899
cudaGraphicsRegisterFlagsReadOnly, 
# 900
cudaGraphicsRegisterFlagsWriteDiscard, 
# 901
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
# 902
cudaGraphicsRegisterFlagsTextureGather = 8
# 903
}; 
#endif
# 908 "/usr/local/cuda/include/driver_types.h"
#if 0
# 908
enum cudaGraphicsMapFlags { 
# 910
cudaGraphicsMapFlagsNone, 
# 911
cudaGraphicsMapFlagsReadOnly, 
# 912
cudaGraphicsMapFlagsWriteDiscard
# 913
}; 
#endif
# 918 "/usr/local/cuda/include/driver_types.h"
#if 0
# 918
enum cudaGraphicsCubeFace { 
# 920
cudaGraphicsCubeFacePositiveX, 
# 921
cudaGraphicsCubeFaceNegativeX, 
# 922
cudaGraphicsCubeFacePositiveY, 
# 923
cudaGraphicsCubeFaceNegativeY, 
# 924
cudaGraphicsCubeFacePositiveZ, 
# 925
cudaGraphicsCubeFaceNegativeZ
# 926
}; 
#endif
# 931 "/usr/local/cuda/include/driver_types.h"
#if 0
# 931
enum cudaResourceType { 
# 933
cudaResourceTypeArray, 
# 934
cudaResourceTypeMipmappedArray, 
# 935
cudaResourceTypeLinear, 
# 936
cudaResourceTypePitch2D
# 937
}; 
#endif
# 942 "/usr/local/cuda/include/driver_types.h"
#if 0
# 942
enum cudaResourceViewFormat { 
# 944
cudaResViewFormatNone, 
# 945
cudaResViewFormatUnsignedChar1, 
# 946
cudaResViewFormatUnsignedChar2, 
# 947
cudaResViewFormatUnsignedChar4, 
# 948
cudaResViewFormatSignedChar1, 
# 949
cudaResViewFormatSignedChar2, 
# 950
cudaResViewFormatSignedChar4, 
# 951
cudaResViewFormatUnsignedShort1, 
# 952
cudaResViewFormatUnsignedShort2, 
# 953
cudaResViewFormatUnsignedShort4, 
# 954
cudaResViewFormatSignedShort1, 
# 955
cudaResViewFormatSignedShort2, 
# 956
cudaResViewFormatSignedShort4, 
# 957
cudaResViewFormatUnsignedInt1, 
# 958
cudaResViewFormatUnsignedInt2, 
# 959
cudaResViewFormatUnsignedInt4, 
# 960
cudaResViewFormatSignedInt1, 
# 961
cudaResViewFormatSignedInt2, 
# 962
cudaResViewFormatSignedInt4, 
# 963
cudaResViewFormatHalf1, 
# 964
cudaResViewFormatHalf2, 
# 965
cudaResViewFormatHalf4, 
# 966
cudaResViewFormatFloat1, 
# 967
cudaResViewFormatFloat2, 
# 968
cudaResViewFormatFloat4, 
# 969
cudaResViewFormatUnsignedBlockCompressed1, 
# 970
cudaResViewFormatUnsignedBlockCompressed2, 
# 971
cudaResViewFormatUnsignedBlockCompressed3, 
# 972
cudaResViewFormatUnsignedBlockCompressed4, 
# 973
cudaResViewFormatSignedBlockCompressed4, 
# 974
cudaResViewFormatUnsignedBlockCompressed5, 
# 975
cudaResViewFormatSignedBlockCompressed5, 
# 976
cudaResViewFormatUnsignedBlockCompressed6H, 
# 977
cudaResViewFormatSignedBlockCompressed6H, 
# 978
cudaResViewFormatUnsignedBlockCompressed7
# 979
}; 
#endif
# 984 "/usr/local/cuda/include/driver_types.h"
#if 0
# 984
struct cudaResourceDesc { 
# 985
cudaResourceType resType; 
# 987
union { 
# 988
struct { 
# 989
cudaArray_t array; 
# 990
} array; 
# 991
struct { 
# 992
cudaMipmappedArray_t mipmap; 
# 993
} mipmap; 
# 994
struct { 
# 995
void *devPtr; 
# 996
cudaChannelFormatDesc desc; 
# 997
size_t sizeInBytes; 
# 998
} linear; 
# 999
struct { 
# 1000
void *devPtr; 
# 1001
cudaChannelFormatDesc desc; 
# 1002
size_t width; 
# 1003
size_t height; 
# 1004
size_t pitchInBytes; 
# 1005
} pitch2D; 
# 1006
} res; 
# 1007
}; 
#endif
# 1012 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1012
struct cudaResourceViewDesc { 
# 1014
cudaResourceViewFormat format; 
# 1015
size_t width; 
# 1016
size_t height; 
# 1017
size_t depth; 
# 1018
unsigned firstMipmapLevel; 
# 1019
unsigned lastMipmapLevel; 
# 1020
unsigned firstLayer; 
# 1021
unsigned lastLayer; 
# 1022
}; 
#endif
# 1027 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1027
struct cudaPointerAttributes { 
# 1033
cudaMemoryType memoryType; 
# 1044
int device; 
# 1050
void *devicePointer; 
# 1056
void *hostPointer; 
# 1061
int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1062
}; 
#endif
# 1067 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1067
struct cudaFuncAttributes { 
# 1074
size_t sharedSizeBytes; 
# 1080
size_t constSizeBytes; 
# 1085
size_t localSizeBytes; 
# 1092
int maxThreadsPerBlock; 
# 1097
int numRegs; 
# 1104
int ptxVersion; 
# 1111
int binaryVersion; 
# 1117
int cacheModeCA; 
# 1118
}; 
#endif
# 1123 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1123
enum cudaFuncCache { 
# 1125
cudaFuncCachePreferNone, 
# 1126
cudaFuncCachePreferShared, 
# 1127
cudaFuncCachePreferL1, 
# 1128
cudaFuncCachePreferEqual
# 1129
}; 
#endif
# 1135 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1135
enum cudaSharedMemConfig { 
# 1137
cudaSharedMemBankSizeDefault, 
# 1138
cudaSharedMemBankSizeFourByte, 
# 1139
cudaSharedMemBankSizeEightByte
# 1140
}; 
#endif
# 1145 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1145
enum cudaComputeMode { 
# 1147
cudaComputeModeDefault, 
# 1148
cudaComputeModeExclusive, 
# 1149
cudaComputeModeProhibited, 
# 1150
cudaComputeModeExclusiveProcess
# 1151
}; 
#endif
# 1156 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1156
enum cudaLimit { 
# 1158
cudaLimitStackSize, 
# 1159
cudaLimitPrintfFifoSize, 
# 1160
cudaLimitMallocHeapSize, 
# 1161
cudaLimitDevRuntimeSyncDepth, 
# 1162
cudaLimitDevRuntimePendingLaunchCount
# 1163
}; 
#endif
# 1168 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1168
enum cudaMemoryAdvise { 
# 1170
cudaMemAdviseSetReadMostly = 1, 
# 1171
cudaMemAdviseUnsetReadMostly, 
# 1172
cudaMemAdviseSetPreferredLocation, 
# 1173
cudaMemAdviseUnsetPreferredLocation, 
# 1174
cudaMemAdviseSetAccessedBy, 
# 1175
cudaMemAdviseUnsetAccessedBy
# 1176
}; 
#endif
# 1181 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1181
enum cudaMemRangeAttribute { 
# 1183
cudaMemRangeAttributeReadMostly = 1, 
# 1184
cudaMemRangeAttributePreferredLocation, 
# 1185
cudaMemRangeAttributeAccessedBy, 
# 1186
cudaMemRangeAttributeLastPrefetchLocation
# 1187
}; 
#endif
# 1192 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1192
enum cudaOutputMode { 
# 1194
cudaKeyValuePair, 
# 1195
cudaCSV
# 1196
}; 
#endif
# 1201 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1201
enum cudaDeviceAttr { 
# 1203
cudaDevAttrMaxThreadsPerBlock = 1, 
# 1204
cudaDevAttrMaxBlockDimX, 
# 1205
cudaDevAttrMaxBlockDimY, 
# 1206
cudaDevAttrMaxBlockDimZ, 
# 1207
cudaDevAttrMaxGridDimX, 
# 1208
cudaDevAttrMaxGridDimY, 
# 1209
cudaDevAttrMaxGridDimZ, 
# 1210
cudaDevAttrMaxSharedMemoryPerBlock, 
# 1211
cudaDevAttrTotalConstantMemory, 
# 1212
cudaDevAttrWarpSize, 
# 1213
cudaDevAttrMaxPitch, 
# 1214
cudaDevAttrMaxRegistersPerBlock, 
# 1215
cudaDevAttrClockRate, 
# 1216
cudaDevAttrTextureAlignment, 
# 1217
cudaDevAttrGpuOverlap, 
# 1218
cudaDevAttrMultiProcessorCount, 
# 1219
cudaDevAttrKernelExecTimeout, 
# 1220
cudaDevAttrIntegrated, 
# 1221
cudaDevAttrCanMapHostMemory, 
# 1222
cudaDevAttrComputeMode, 
# 1223
cudaDevAttrMaxTexture1DWidth, 
# 1224
cudaDevAttrMaxTexture2DWidth, 
# 1225
cudaDevAttrMaxTexture2DHeight, 
# 1226
cudaDevAttrMaxTexture3DWidth, 
# 1227
cudaDevAttrMaxTexture3DHeight, 
# 1228
cudaDevAttrMaxTexture3DDepth, 
# 1229
cudaDevAttrMaxTexture2DLayeredWidth, 
# 1230
cudaDevAttrMaxTexture2DLayeredHeight, 
# 1231
cudaDevAttrMaxTexture2DLayeredLayers, 
# 1232
cudaDevAttrSurfaceAlignment, 
# 1233
cudaDevAttrConcurrentKernels, 
# 1234
cudaDevAttrEccEnabled, 
# 1235
cudaDevAttrPciBusId, 
# 1236
cudaDevAttrPciDeviceId, 
# 1237
cudaDevAttrTccDriver, 
# 1238
cudaDevAttrMemoryClockRate, 
# 1239
cudaDevAttrGlobalMemoryBusWidth, 
# 1240
cudaDevAttrL2CacheSize, 
# 1241
cudaDevAttrMaxThreadsPerMultiProcessor, 
# 1242
cudaDevAttrAsyncEngineCount, 
# 1243
cudaDevAttrUnifiedAddressing, 
# 1244
cudaDevAttrMaxTexture1DLayeredWidth, 
# 1245
cudaDevAttrMaxTexture1DLayeredLayers, 
# 1246
cudaDevAttrMaxTexture2DGatherWidth = 45, 
# 1247
cudaDevAttrMaxTexture2DGatherHeight, 
# 1248
cudaDevAttrMaxTexture3DWidthAlt, 
# 1249
cudaDevAttrMaxTexture3DHeightAlt, 
# 1250
cudaDevAttrMaxTexture3DDepthAlt, 
# 1251
cudaDevAttrPciDomainId, 
# 1252
cudaDevAttrTexturePitchAlignment, 
# 1253
cudaDevAttrMaxTextureCubemapWidth, 
# 1254
cudaDevAttrMaxTextureCubemapLayeredWidth, 
# 1255
cudaDevAttrMaxTextureCubemapLayeredLayers, 
# 1256
cudaDevAttrMaxSurface1DWidth, 
# 1257
cudaDevAttrMaxSurface2DWidth, 
# 1258
cudaDevAttrMaxSurface2DHeight, 
# 1259
cudaDevAttrMaxSurface3DWidth, 
# 1260
cudaDevAttrMaxSurface3DHeight, 
# 1261
cudaDevAttrMaxSurface3DDepth, 
# 1262
cudaDevAttrMaxSurface1DLayeredWidth, 
# 1263
cudaDevAttrMaxSurface1DLayeredLayers, 
# 1264
cudaDevAttrMaxSurface2DLayeredWidth, 
# 1265
cudaDevAttrMaxSurface2DLayeredHeight, 
# 1266
cudaDevAttrMaxSurface2DLayeredLayers, 
# 1267
cudaDevAttrMaxSurfaceCubemapWidth, 
# 1268
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
# 1269
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
# 1270
cudaDevAttrMaxTexture1DLinearWidth, 
# 1271
cudaDevAttrMaxTexture2DLinearWidth, 
# 1272
cudaDevAttrMaxTexture2DLinearHeight, 
# 1273
cudaDevAttrMaxTexture2DLinearPitch, 
# 1274
cudaDevAttrMaxTexture2DMipmappedWidth, 
# 1275
cudaDevAttrMaxTexture2DMipmappedHeight, 
# 1276
cudaDevAttrComputeCapabilityMajor, 
# 1277
cudaDevAttrComputeCapabilityMinor, 
# 1278
cudaDevAttrMaxTexture1DMipmappedWidth, 
# 1279
cudaDevAttrStreamPrioritiesSupported, 
# 1280
cudaDevAttrGlobalL1CacheSupported, 
# 1281
cudaDevAttrLocalL1CacheSupported, 
# 1282
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
# 1283
cudaDevAttrMaxRegistersPerMultiprocessor, 
# 1284
cudaDevAttrManagedMemory, 
# 1285
cudaDevAttrIsMultiGpuBoard, 
# 1286
cudaDevAttrMultiGpuBoardGroupID, 
# 1287
cudaDevAttrHostNativeAtomicSupported, 
# 1288
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
# 1289
cudaDevAttrPageableMemoryAccess, 
# 1290
cudaDevAttrConcurrentManagedAccess, 
# 1291
cudaDevAttrComputePreemptionSupported, 
# 1292
cudaDevAttrCanUseHostPointerForRegisteredMem
# 1293
}; 
#endif
# 1299 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1299
enum cudaDeviceP2PAttr { 
# 1300
cudaDevP2PAttrPerformanceRank = 1, 
# 1301
cudaDevP2PAttrAccessSupported, 
# 1302
cudaDevP2PAttrNativeAtomicSupported
# 1303
}; 
#endif
# 1307 "/usr/local/cuda/include/driver_types.h"
#if 0
# 1307
struct cudaDeviceProp { 
# 1309
char name[256]; 
# 1310
size_t totalGlobalMem; 
# 1311
size_t sharedMemPerBlock; 
# 1312
int regsPerBlock; 
# 1313
int warpSize; 
# 1314
size_t memPitch; 
# 1315
int maxThreadsPerBlock; 
# 1316
int maxThreadsDim[3]; 
# 1317
int maxGridSize[3]; 
# 1318
int clockRate; 
# 1319
size_t totalConstMem; 
# 1320
int major; 
# 1321
int minor; 
# 1322
size_t textureAlignment; 
# 1323
size_t texturePitchAlignment; 
# 1324
int deviceOverlap; 
# 1325
int multiProcessorCount; 
# 1326
int kernelExecTimeoutEnabled; 
# 1327
int integrated; 
# 1328
int canMapHostMemory; 
# 1329
int computeMode; 
# 1330
int maxTexture1D; 
# 1331
int maxTexture1DMipmap; 
# 1332
int maxTexture1DLinear; 
# 1333
int maxTexture2D[2]; 
# 1334
int maxTexture2DMipmap[2]; 
# 1335
int maxTexture2DLinear[3]; 
# 1336
int maxTexture2DGather[2]; 
# 1337
int maxTexture3D[3]; 
# 1338
int maxTexture3DAlt[3]; 
# 1339
int maxTextureCubemap; 
# 1340
int maxTexture1DLayered[2]; 
# 1341
int maxTexture2DLayered[3]; 
# 1342
int maxTextureCubemapLayered[2]; 
# 1343
int maxSurface1D; 
# 1344
int maxSurface2D[2]; 
# 1345
int maxSurface3D[3]; 
# 1346
int maxSurface1DLayered[2]; 
# 1347
int maxSurface2DLayered[3]; 
# 1348
int maxSurfaceCubemap; 
# 1349
int maxSurfaceCubemapLayered[2]; 
# 1350
size_t surfaceAlignment; 
# 1351
int concurrentKernels; 
# 1352
int ECCEnabled; 
# 1353
int pciBusID; 
# 1354
int pciDeviceID; 
# 1355
int pciDomainID; 
# 1356
int tccDriver; 
# 1357
int asyncEngineCount; 
# 1358
int unifiedAddressing; 
# 1359
int memoryClockRate; 
# 1360
int memoryBusWidth; 
# 1361
int l2CacheSize; 
# 1362
int maxThreadsPerMultiProcessor; 
# 1363
int streamPrioritiesSupported; 
# 1364
int globalL1CacheSupported; 
# 1365
int localL1CacheSupported; 
# 1366
size_t sharedMemPerMultiprocessor; 
# 1367
int regsPerMultiprocessor; 
# 1368
int managedMemory; 
# 1369
int isMultiGpuBoard; 
# 1370
int multiGpuBoardGroupID; 
# 1371
int hostNativeAtomicSupported; 
# 1372
int singleToDoublePrecisionPerfRatio; 
# 1373
int pageableMemoryAccess; 
# 1374
int concurrentManagedAccess; 
# 1375
}; 
#endif
# 1458 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef 
# 1455
struct cudaIpcEventHandle_st { 
# 1457
char reserved[64]; 
# 1458
} cudaIpcEventHandle_t; 
#endif
# 1466 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef 
# 1463
struct cudaIpcMemHandle_st { 
# 1465
char reserved[64]; 
# 1466
} cudaIpcMemHandle_t; 
#endif
# 1477 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef cudaError 
# 1477
cudaError_t; 
#endif
# 1482 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef struct CUstream_st *
# 1482
cudaStream_t; 
#endif
# 1487 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef struct CUevent_st *
# 1487
cudaEvent_t; 
#endif
# 1492 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef cudaGraphicsResource *
# 1492
cudaGraphicsResource_t; 
#endif
# 1497 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef struct CUuuid_st 
# 1497
cudaUUID_t; 
#endif
# 1502 "/usr/local/cuda/include/driver_types.h"
#if 0
typedef cudaOutputMode 
# 1502
cudaOutputMode_t; 
#endif
# 84 "/usr/local/cuda/include/surface_types.h"
#if 0
# 84
enum cudaSurfaceBoundaryMode { 
# 86
cudaBoundaryModeZero, 
# 87
cudaBoundaryModeClamp, 
# 88
cudaBoundaryModeTrap
# 89
}; 
#endif
# 94 "/usr/local/cuda/include/surface_types.h"
#if 0
# 94
enum cudaSurfaceFormatMode { 
# 96
cudaFormatModeForced, 
# 97
cudaFormatModeAuto
# 98
}; 
#endif
# 103 "/usr/local/cuda/include/surface_types.h"
#if 0
# 103
struct surfaceReference { 
# 108
cudaChannelFormatDesc channelDesc; 
# 109
}; 
#endif
# 114 "/usr/local/cuda/include/surface_types.h"
#if 0
typedef unsigned long long 
# 114
cudaSurfaceObject_t; 
#endif
# 84 "/usr/local/cuda/include/texture_types.h"
#if 0
# 84
enum cudaTextureAddressMode { 
# 86
cudaAddressModeWrap, 
# 87
cudaAddressModeClamp, 
# 88
cudaAddressModeMirror, 
# 89
cudaAddressModeBorder
# 90
}; 
#endif
# 95 "/usr/local/cuda/include/texture_types.h"
#if 0
# 95
enum cudaTextureFilterMode { 
# 97
cudaFilterModePoint, 
# 98
cudaFilterModeLinear
# 99
}; 
#endif
# 104 "/usr/local/cuda/include/texture_types.h"
#if 0
# 104
enum cudaTextureReadMode { 
# 106
cudaReadModeElementType, 
# 107
cudaReadModeNormalizedFloat
# 108
}; 
#endif
# 113 "/usr/local/cuda/include/texture_types.h"
#if 0
# 113
struct textureReference { 
# 118
int normalized; 
# 122
cudaTextureFilterMode filterMode; 
# 126
cudaTextureAddressMode addressMode[3]; 
# 130
cudaChannelFormatDesc channelDesc; 
# 134
int sRGB; 
# 138
unsigned maxAnisotropy; 
# 142
cudaTextureFilterMode mipmapFilterMode; 
# 146
float mipmapLevelBias; 
# 150
float minMipmapLevelClamp; 
# 154
float maxMipmapLevelClamp; 
# 155
int __cudaReserved[15]; 
# 156
}; 
#endif
# 161 "/usr/local/cuda/include/texture_types.h"
#if 0
# 161
struct cudaTextureDesc { 
# 166
cudaTextureAddressMode addressMode[3]; 
# 170
cudaTextureFilterMode filterMode; 
# 174
cudaTextureReadMode readMode; 
# 178
int sRGB; 
# 182
float borderColor[4]; 
# 186
int normalizedCoords; 
# 190
unsigned maxAnisotropy; 
# 194
cudaTextureFilterMode mipmapFilterMode; 
# 198
float mipmapLevelBias; 
# 202
float minMipmapLevelClamp; 
# 206
float maxMipmapLevelClamp; 
# 207
}; 
#endif
# 212 "/usr/local/cuda/include/texture_types.h"
#if 0
typedef unsigned long long 
# 212
cudaTextureObject_t; 
#endif
# 98 "/usr/local/cuda/include/vector_types.h"
#if 0
# 98
struct char1 { 
# 100
signed char x; 
# 101
}; 
#endif
# 103 "/usr/local/cuda/include/vector_types.h"
#if 0
# 103
struct uchar1 { 
# 105
unsigned char x; 
# 106
}; 
#endif
# 109 "/usr/local/cuda/include/vector_types.h"
#if 0
# 109
struct __attribute((aligned(2))) char2 { 
# 111
signed char x, y; 
# 112
}; 
#endif
# 114 "/usr/local/cuda/include/vector_types.h"
#if 0
# 114
struct __attribute((aligned(2))) uchar2 { 
# 116
unsigned char x, y; 
# 117
}; 
#endif
# 119 "/usr/local/cuda/include/vector_types.h"
#if 0
# 119
struct char3 { 
# 121
signed char x, y, z; 
# 122
}; 
#endif
# 124 "/usr/local/cuda/include/vector_types.h"
#if 0
# 124
struct uchar3 { 
# 126
unsigned char x, y, z; 
# 127
}; 
#endif
# 129 "/usr/local/cuda/include/vector_types.h"
#if 0
# 129
struct __attribute((aligned(4))) char4 { 
# 131
signed char x, y, z, w; 
# 132
}; 
#endif
# 134 "/usr/local/cuda/include/vector_types.h"
#if 0
# 134
struct __attribute((aligned(4))) uchar4 { 
# 136
unsigned char x, y, z, w; 
# 137
}; 
#endif
# 139 "/usr/local/cuda/include/vector_types.h"
#if 0
# 139
struct short1 { 
# 141
short x; 
# 142
}; 
#endif
# 144 "/usr/local/cuda/include/vector_types.h"
#if 0
# 144
struct ushort1 { 
# 146
unsigned short x; 
# 147
}; 
#endif
# 149 "/usr/local/cuda/include/vector_types.h"
#if 0
# 149
struct __attribute((aligned(4))) short2 { 
# 151
short x, y; 
# 152
}; 
#endif
# 154 "/usr/local/cuda/include/vector_types.h"
#if 0
# 154
struct __attribute((aligned(4))) ushort2 { 
# 156
unsigned short x, y; 
# 157
}; 
#endif
# 159 "/usr/local/cuda/include/vector_types.h"
#if 0
# 159
struct short3 { 
# 161
short x, y, z; 
# 162
}; 
#endif
# 164 "/usr/local/cuda/include/vector_types.h"
#if 0
# 164
struct ushort3 { 
# 166
unsigned short x, y, z; 
# 167
}; 
#endif
# 169 "/usr/local/cuda/include/vector_types.h"
#if 0
# 169
struct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; 
#endif
# 170 "/usr/local/cuda/include/vector_types.h"
#if 0
# 170
struct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
# 172 "/usr/local/cuda/include/vector_types.h"
#if 0
# 172
struct int1 { 
# 174
int x; 
# 175
}; 
#endif
# 177 "/usr/local/cuda/include/vector_types.h"
#if 0
# 177
struct uint1 { 
# 179
unsigned x; 
# 180
}; 
#endif
# 182 "/usr/local/cuda/include/vector_types.h"
#if 0
# 182
struct __attribute((aligned(8))) int2 { int x; int y; }; 
#endif
# 183 "/usr/local/cuda/include/vector_types.h"
#if 0
# 183
struct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; 
#endif
# 185 "/usr/local/cuda/include/vector_types.h"
#if 0
# 185
struct int3 { 
# 187
int x, y, z; 
# 188
}; 
#endif
# 190 "/usr/local/cuda/include/vector_types.h"
#if 0
# 190
struct uint3 { 
# 192
unsigned x, y, z; 
# 193
}; 
#endif
# 195 "/usr/local/cuda/include/vector_types.h"
#if 0
# 195
struct __attribute((aligned(16))) int4 { 
# 197
int x, y, z, w; 
# 198
}; 
#endif
# 200 "/usr/local/cuda/include/vector_types.h"
#if 0
# 200
struct __attribute((aligned(16))) uint4 { 
# 202
unsigned x, y, z, w; 
# 203
}; 
#endif
# 205 "/usr/local/cuda/include/vector_types.h"
#if 0
# 205
struct long1 { 
# 207
long x; 
# 208
}; 
#endif
# 210 "/usr/local/cuda/include/vector_types.h"
#if 0
# 210
struct ulong1 { 
# 212
unsigned long x; 
# 213
}; 
#endif
# 220 "/usr/local/cuda/include/vector_types.h"
#if 0
# 220
struct __attribute((aligned((2) * sizeof(long)))) long2 { 
# 222
long x, y; 
# 223
}; 
#endif
# 225 "/usr/local/cuda/include/vector_types.h"
#if 0
# 225
struct __attribute((aligned((2) * sizeof(unsigned long)))) ulong2 { 
# 227
unsigned long x, y; 
# 228
}; 
#endif
# 232 "/usr/local/cuda/include/vector_types.h"
#if 0
# 232
struct long3 { 
# 234
long x, y, z; 
# 235
}; 
#endif
# 237 "/usr/local/cuda/include/vector_types.h"
#if 0
# 237
struct ulong3 { 
# 239
unsigned long x, y, z; 
# 240
}; 
#endif
# 242 "/usr/local/cuda/include/vector_types.h"
#if 0
# 242
struct __attribute((aligned(16))) long4 { 
# 244
long x, y, z, w; 
# 245
}; 
#endif
# 247 "/usr/local/cuda/include/vector_types.h"
#if 0
# 247
struct __attribute((aligned(16))) ulong4 { 
# 249
unsigned long x, y, z, w; 
# 250
}; 
#endif
# 252 "/usr/local/cuda/include/vector_types.h"
#if 0
# 252
struct float1 { 
# 254
float x; 
# 255
}; 
#endif
# 274 "/usr/local/cuda/include/vector_types.h"
#if 0
# 274
struct __attribute((aligned(8))) float2 { float x; float y; }; 
#endif
# 279 "/usr/local/cuda/include/vector_types.h"
#if 0
# 279
struct float3 { 
# 281
float x, y, z; 
# 282
}; 
#endif
# 284 "/usr/local/cuda/include/vector_types.h"
#if 0
# 284
struct __attribute((aligned(16))) float4 { 
# 286
float x, y, z, w; 
# 287
}; 
#endif
# 289 "/usr/local/cuda/include/vector_types.h"
#if 0
# 289
struct longlong1 { 
# 291
long long x; 
# 292
}; 
#endif
# 294 "/usr/local/cuda/include/vector_types.h"
#if 0
# 294
struct ulonglong1 { 
# 296
unsigned long long x; 
# 297
}; 
#endif
# 299 "/usr/local/cuda/include/vector_types.h"
#if 0
# 299
struct __attribute((aligned(16))) longlong2 { 
# 301
long long x, y; 
# 302
}; 
#endif
# 304 "/usr/local/cuda/include/vector_types.h"
#if 0
# 304
struct __attribute((aligned(16))) ulonglong2 { 
# 306
unsigned long long x, y; 
# 307
}; 
#endif
# 309 "/usr/local/cuda/include/vector_types.h"
#if 0
# 309
struct longlong3 { 
# 311
long long x, y, z; 
# 312
}; 
#endif
# 314 "/usr/local/cuda/include/vector_types.h"
#if 0
# 314
struct ulonglong3 { 
# 316
unsigned long long x, y, z; 
# 317
}; 
#endif
# 319 "/usr/local/cuda/include/vector_types.h"
#if 0
# 319
struct __attribute((aligned(16))) longlong4 { 
# 321
long long x, y, z, w; 
# 322
}; 
#endif
# 324 "/usr/local/cuda/include/vector_types.h"
#if 0
# 324
struct __attribute((aligned(16))) ulonglong4 { 
# 326
unsigned long long x, y, z, w; 
# 327
}; 
#endif
# 329 "/usr/local/cuda/include/vector_types.h"
#if 0
# 329
struct double1 { 
# 331
double x; 
# 332
}; 
#endif
# 334 "/usr/local/cuda/include/vector_types.h"
#if 0
# 334
struct __attribute((aligned(16))) double2 { 
# 336
double x, y; 
# 337
}; 
#endif
# 339 "/usr/local/cuda/include/vector_types.h"
#if 0
# 339
struct double3 { 
# 341
double x, y, z; 
# 342
}; 
#endif
# 344 "/usr/local/cuda/include/vector_types.h"
#if 0
# 344
struct __attribute((aligned(16))) double4 { 
# 346
double x, y, z, w; 
# 347
}; 
#endif
# 362 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef char1 
# 362
char1; 
#endif
# 363 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uchar1 
# 363
uchar1; 
#endif
# 364 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef char2 
# 364
char2; 
#endif
# 365 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uchar2 
# 365
uchar2; 
#endif
# 366 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef char3 
# 366
char3; 
#endif
# 367 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uchar3 
# 367
uchar3; 
#endif
# 368 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef char4 
# 368
char4; 
#endif
# 369 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uchar4 
# 369
uchar4; 
#endif
# 370 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef short1 
# 370
short1; 
#endif
# 371 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ushort1 
# 371
ushort1; 
#endif
# 372 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef short2 
# 372
short2; 
#endif
# 373 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ushort2 
# 373
ushort2; 
#endif
# 374 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef short3 
# 374
short3; 
#endif
# 375 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ushort3 
# 375
ushort3; 
#endif
# 376 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef short4 
# 376
short4; 
#endif
# 377 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ushort4 
# 377
ushort4; 
#endif
# 378 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef int1 
# 378
int1; 
#endif
# 379 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uint1 
# 379
uint1; 
#endif
# 380 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef int2 
# 380
int2; 
#endif
# 381 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uint2 
# 381
uint2; 
#endif
# 382 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef int3 
# 382
int3; 
#endif
# 383 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uint3 
# 383
uint3; 
#endif
# 384 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef int4 
# 384
int4; 
#endif
# 385 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef uint4 
# 385
uint4; 
#endif
# 386 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef long1 
# 386
long1; 
#endif
# 387 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulong1 
# 387
ulong1; 
#endif
# 388 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef long2 
# 388
long2; 
#endif
# 389 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulong2 
# 389
ulong2; 
#endif
# 390 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef long3 
# 390
long3; 
#endif
# 391 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulong3 
# 391
ulong3; 
#endif
# 392 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef long4 
# 392
long4; 
#endif
# 393 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulong4 
# 393
ulong4; 
#endif
# 394 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef float1 
# 394
float1; 
#endif
# 395 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef float2 
# 395
float2; 
#endif
# 396 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef float3 
# 396
float3; 
#endif
# 397 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef float4 
# 397
float4; 
#endif
# 398 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef longlong1 
# 398
longlong1; 
#endif
# 399 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulonglong1 
# 399
ulonglong1; 
#endif
# 400 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef longlong2 
# 400
longlong2; 
#endif
# 401 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulonglong2 
# 401
ulonglong2; 
#endif
# 402 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef longlong3 
# 402
longlong3; 
#endif
# 403 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulonglong3 
# 403
ulonglong3; 
#endif
# 404 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef longlong4 
# 404
longlong4; 
#endif
# 405 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef ulonglong4 
# 405
ulonglong4; 
#endif
# 406 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef double1 
# 406
double1; 
#endif
# 407 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef double2 
# 407
double2; 
#endif
# 408 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef double3 
# 408
double3; 
#endif
# 409 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef double4 
# 409
double4; 
#endif
# 417 "/usr/local/cuda/include/vector_types.h"
#if 0
# 417
struct dim3 { 
# 419
unsigned x, y, z; 
# 425
}; 
#endif
# 427 "/usr/local/cuda/include/vector_types.h"
#if 0
typedef dim3 
# 427
dim3; 
#endif
# 70 "/usr/local/cuda/include/library_types.h"
typedef 
# 54
enum cudaDataType_t { 
# 56
CUDA_R_16F = 2, 
# 57
CUDA_C_16F = 6, 
# 58
CUDA_R_32F = 0, 
# 59
CUDA_C_32F = 4, 
# 60
CUDA_R_64F = 1, 
# 61
CUDA_C_64F = 5, 
# 62
CUDA_R_8I = 3, 
# 63
CUDA_C_8I = 7, 
# 64
CUDA_R_8U, 
# 65
CUDA_C_8U, 
# 66
CUDA_R_32I, 
# 67
CUDA_C_32I, 
# 68
CUDA_R_32U, 
# 69
CUDA_C_32U
# 70
} cudaDataType; 
# 78
typedef 
# 73
enum libraryPropertyType_t { 
# 75
MAJOR_VERSION, 
# 76
MINOR_VERSION, 
# 77
PATCH_LEVEL
# 78
} libraryPropertyType; 
# 104 "/usr/local/cuda/include/cuda_device_runtime_api.h"
extern "C" {
# 106
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 107
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 108
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 109
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 110
extern cudaError_t cudaDeviceSynchronize(); 
# 111
extern cudaError_t cudaGetLastError(); 
# 112
extern cudaError_t cudaPeekAtLastError(); 
# 113
extern const char *cudaGetErrorString(cudaError_t error); 
# 114
extern const char *cudaGetErrorName(cudaError_t error); 
# 115
extern cudaError_t cudaGetDeviceCount(int * count); 
# 116
extern cudaError_t cudaGetDevice(int * device); 
# 117
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 118
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 119
extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 120
__attribute__((unused)) extern cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 121
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 122
extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
# 123
__attribute__((unused)) extern cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
# 124
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 125
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 126
extern cudaError_t cudaFree(void * devPtr); 
# 127
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 128
extern cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 129
__attribute__((unused)) extern cudaError_t cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 130
extern cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 131
__attribute__((unused)) extern cudaError_t cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 132
extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 133
__attribute__((unused)) extern cudaError_t cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 134
extern cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 135
__attribute__((unused)) extern cudaError_t cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 136
extern cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 137
__attribute__((unused)) extern cudaError_t cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 138
extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 139
__attribute__((unused)) extern cudaError_t cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 140
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 161
__attribute__((unused)) extern void *cudaGetParameterBuffer(size_t alignment, size_t size); 
# 189
__attribute__((unused)) extern void *cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
# 190
__attribute__((unused)) extern cudaError_t cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 191
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
# 209
__attribute__((unused)) extern cudaError_t cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 210
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
# 213
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
# 214
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 216
}
# 218
template< class T> static inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
# 219
template< class T> static inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
# 220
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
# 221
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 219 "/usr/local/cuda/include/cuda_runtime_api.h"
extern "C" {
# 252
extern cudaError_t cudaDeviceReset(); 
# 269
extern cudaError_t cudaDeviceSynchronize(); 
# 344
extern cudaError_t cudaDeviceSetLimit(cudaLimit limit, size_t value); 
# 373
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 404
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 439
extern cudaError_t cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 481
extern cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
# 510
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 552
extern cudaError_t cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
# 575
extern cudaError_t cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
# 602
extern cudaError_t cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
# 644
extern cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
# 679
extern cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
# 717
extern cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
# 767
extern cudaError_t cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
# 797
extern cudaError_t cudaIpcCloseMemHandle(void * devPtr); 
# 837
extern cudaError_t cudaThreadExit(); 
# 861
extern cudaError_t cudaThreadSynchronize(); 
# 908
extern cudaError_t cudaThreadSetLimit(cudaLimit limit, size_t value); 
# 939
extern cudaError_t cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
# 974
extern cudaError_t cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 1020
extern cudaError_t cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
# 1074
extern cudaError_t cudaGetLastError(); 
# 1115
extern cudaError_t cudaPeekAtLastError(); 
# 1130
extern const char *cudaGetErrorName(cudaError_t error); 
# 1145
extern const char *cudaGetErrorString(cudaError_t error); 
# 1175
extern cudaError_t cudaGetDeviceCount(int * count); 
# 1421
extern cudaError_t cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
# 1593
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 1628
extern cudaError_t cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
# 1647
extern cudaError_t cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
# 1681
extern cudaError_t cudaSetDevice(int device); 
# 1698
extern cudaError_t cudaGetDevice(int * device); 
# 1727
extern cudaError_t cudaSetValidDevices(int * device_arr, int len); 
# 1789
extern cudaError_t cudaSetDeviceFlags(unsigned flags); 
# 1830
extern cudaError_t cudaGetDeviceFlags(unsigned * flags); 
# 1867
extern cudaError_t cudaStreamCreate(cudaStream_t * pStream); 
# 1896
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 1939
extern cudaError_t cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
# 1963
extern cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
# 1984
extern cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
# 2005
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 2037
extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 2051
typedef void (*cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
# 2108
extern cudaError_t cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
# 2128
extern cudaError_t cudaStreamSynchronize(cudaStream_t stream); 
# 2149
extern cudaError_t cudaStreamQuery(cudaStream_t stream); 
# 2220
extern cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
# 2256
extern cudaError_t cudaEventCreate(cudaEvent_t * event); 
# 2290
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 2321
extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
# 2353
extern cudaError_t cudaEventQuery(cudaEvent_t event); 
# 2385
extern cudaError_t cudaEventSynchronize(cudaEvent_t event); 
# 2410
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 2451
extern cudaError_t cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
# 2510
extern cudaError_t cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 2560
extern cudaError_t cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
# 2614
extern cudaError_t cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
# 2648
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 2671
extern cudaError_t cudaSetDoubleForDevice(double * d); 
# 2694
extern cudaError_t cudaSetDoubleForHost(double * d); 
# 2750
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
# 2794
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 2845
extern cudaError_t cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0); 
# 2874
extern cudaError_t cudaSetupArgument(const void * arg, size_t size, size_t offset); 
# 2912
extern cudaError_t cudaLaunch(const void * func); 
# 3030
extern cudaError_t cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
# 3056
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 3085
extern cudaError_t cudaMallocHost(void ** ptr, size_t size); 
# 3124
extern cudaError_t cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
# 3166
extern cudaError_t cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
# 3193
extern cudaError_t cudaFree(void * devPtr); 
# 3213
extern cudaError_t cudaFreeHost(void * ptr); 
# 3235
extern cudaError_t cudaFreeArray(cudaArray_t array); 
# 3257
extern cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
# 3316
extern cudaError_t cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
# 3393
extern cudaError_t cudaHostRegister(void * ptr, size_t size, unsigned flags); 
# 3412
extern cudaError_t cudaHostUnregister(void * ptr); 
# 3454
extern cudaError_t cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
# 3473
extern cudaError_t cudaHostGetFlags(unsigned * pFlags, void * pHost); 
# 3508
extern cudaError_t cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
# 3643
extern cudaError_t cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
# 3764
extern cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
# 3790
extern cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
# 3890
extern cudaError_t cudaMemcpy3D(const cudaMemcpy3DParms * p); 
# 3918
extern cudaError_t cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
# 4029
extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
# 4052
extern cudaError_t cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
# 4071
extern cudaError_t cudaMemGetInfo(size_t * free, size_t * total); 
# 4092
extern cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
# 4130
extern cudaError_t cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 4162
extern cudaError_t cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
# 4200
extern cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
# 4237
extern cudaError_t cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
# 4275
extern cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4320
extern cudaError_t cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4366
extern cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 4412
extern cudaError_t cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
# 4455
extern cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 4493
extern cudaError_t cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
# 4531
extern cudaError_t cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
# 4582
extern cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4614
extern cudaError_t cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
# 4660
extern cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4705
extern cudaError_t cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4765
extern cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4820
extern cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4874
extern cudaError_t cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4920
extern cudaError_t cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4966
extern cudaError_t cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 4992
extern cudaError_t cudaMemset(void * devPtr, int value, size_t count); 
# 5022
extern cudaError_t cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
# 5065
extern cudaError_t cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
# 5097
extern cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
# 5134
extern cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
# 5184
extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
# 5207
extern cudaError_t cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
# 5229
extern cudaError_t cudaGetSymbolSize(size_t * size, const void * symbol); 
# 5296
extern cudaError_t cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
# 5382
extern cudaError_t cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
# 5438
extern cudaError_t cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
# 5474
extern cudaError_t cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
# 5627
extern cudaError_t cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
# 5665
extern cudaError_t cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
# 5704
extern cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
# 5723
extern cudaError_t cudaDeviceDisablePeerAccess(int peerDevice); 
# 5783
extern cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
# 5815
extern cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
# 5851
extern cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 5883
extern cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 5912
extern cudaError_t cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
# 5946
extern cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
# 5971
extern cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
# 6011
extern cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
# 6046
extern cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
# 6093
extern cudaError_t cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = ((2147483647) * 2U) + 1U); 
# 6144
extern cudaError_t cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
# 6172
extern cudaError_t cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 6200
extern cudaError_t cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
# 6221
extern cudaError_t cudaUnbindTexture(const textureReference * texref); 
# 6246
extern cudaError_t cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
# 6271
extern cudaError_t cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
# 6311
extern cudaError_t cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 6330
extern cudaError_t cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
# 6556
extern cudaError_t cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
# 6571
extern cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject); 
# 6587
extern cudaError_t cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
# 6603
extern cudaError_t cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
# 6620
extern cudaError_t cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
# 6659
extern cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
# 6674
extern cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
# 6689
extern cudaError_t cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
# 6716
extern cudaError_t cudaDriverGetVersion(int * driverVersion); 
# 6733
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 6738
extern cudaError_t cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
# 6964
}
# 107 "/usr/local/cuda/include/channel_descriptor.h"
template< class T> inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 108
{ 
# 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 110
} 
# 112
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
# 113
{ 
# 114
int e = (((int)sizeof(unsigned short)) * 8); 
# 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 117
} 
# 119
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
# 120
{ 
# 121
int e = (((int)sizeof(unsigned short)) * 8); 
# 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 124
} 
# 126
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
# 127
{ 
# 128
int e = (((int)sizeof(unsigned short)) * 8); 
# 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 131
} 
# 133
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
# 134
{ 
# 135
int e = (((int)sizeof(unsigned short)) * 8); 
# 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 138
} 
# 140
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
# 141
{ 
# 142
int e = (((int)sizeof(char)) * 8); 
# 147
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 149
} 
# 151
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
# 152
{ 
# 153
int e = (((int)sizeof(signed char)) * 8); 
# 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 156
} 
# 158
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
# 159
{ 
# 160
int e = (((int)sizeof(unsigned char)) * 8); 
# 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 163
} 
# 165
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
# 166
{ 
# 167
int e = (((int)sizeof(signed char)) * 8); 
# 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 170
} 
# 172
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
# 173
{ 
# 174
int e = (((int)sizeof(unsigned char)) * 8); 
# 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 177
} 
# 179
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
# 180
{ 
# 181
int e = (((int)sizeof(signed char)) * 8); 
# 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 184
} 
# 186
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
# 187
{ 
# 188
int e = (((int)sizeof(unsigned char)) * 8); 
# 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 191
} 
# 193
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
# 194
{ 
# 195
int e = (((int)sizeof(signed char)) * 8); 
# 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 198
} 
# 200
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
# 201
{ 
# 202
int e = (((int)sizeof(unsigned char)) * 8); 
# 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 205
} 
# 207
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
# 208
{ 
# 209
int e = (((int)sizeof(short)) * 8); 
# 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 212
} 
# 214
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
# 215
{ 
# 216
int e = (((int)sizeof(unsigned short)) * 8); 
# 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 219
} 
# 221
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
# 222
{ 
# 223
int e = (((int)sizeof(short)) * 8); 
# 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 226
} 
# 228
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
# 229
{ 
# 230
int e = (((int)sizeof(unsigned short)) * 8); 
# 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 233
} 
# 235
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
# 236
{ 
# 237
int e = (((int)sizeof(short)) * 8); 
# 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 240
} 
# 242
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
# 243
{ 
# 244
int e = (((int)sizeof(unsigned short)) * 8); 
# 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 247
} 
# 249
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
# 250
{ 
# 251
int e = (((int)sizeof(short)) * 8); 
# 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 254
} 
# 256
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
# 257
{ 
# 258
int e = (((int)sizeof(unsigned short)) * 8); 
# 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 261
} 
# 263
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
# 264
{ 
# 265
int e = (((int)sizeof(int)) * 8); 
# 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 268
} 
# 270
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
# 271
{ 
# 272
int e = (((int)sizeof(unsigned)) * 8); 
# 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 275
} 
# 277
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
# 278
{ 
# 279
int e = (((int)sizeof(int)) * 8); 
# 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 282
} 
# 284
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
# 285
{ 
# 286
int e = (((int)sizeof(unsigned)) * 8); 
# 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 289
} 
# 291
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
# 292
{ 
# 293
int e = (((int)sizeof(int)) * 8); 
# 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 296
} 
# 298
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
# 299
{ 
# 300
int e = (((int)sizeof(unsigned)) * 8); 
# 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 303
} 
# 305
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
# 306
{ 
# 307
int e = (((int)sizeof(int)) * 8); 
# 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 310
} 
# 312
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
# 313
{ 
# 314
int e = (((int)sizeof(unsigned)) * 8); 
# 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 317
} 
# 379
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
# 380
{ 
# 381
int e = (((int)sizeof(float)) * 8); 
# 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 384
} 
# 386
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
# 387
{ 
# 388
int e = (((int)sizeof(float)) * 8); 
# 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 391
} 
# 393
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
# 394
{ 
# 395
int e = (((int)sizeof(float)) * 8); 
# 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 398
} 
# 400
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
# 401
{ 
# 402
int e = (((int)sizeof(float)) * 8); 
# 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 405
} 
# 79 "/usr/local/cuda/include/driver_functions.h"
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
# 80
{ 
# 81
cudaPitchedPtr s; 
# 83
(s.ptr) = d; 
# 84
(s.pitch) = p; 
# 85
(s.xsize) = xsz; 
# 86
(s.ysize) = ysz; 
# 88
return s; 
# 89
} 
# 106
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
# 107
{ 
# 108
cudaPos p; 
# 110
(p.x) = x; 
# 111
(p.y) = y; 
# 112
(p.z) = z; 
# 114
return p; 
# 115
} 
# 132
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
# 133
{ 
# 134
cudaExtent e; 
# 136
(e.width) = w; 
# 137
(e.height) = h; 
# 138
(e.depth) = d; 
# 140
return e; 
# 141
} 
# 75 "/usr/local/cuda/include/vector_functions.hpp"
static inline char1 make_char1(signed char x) 
# 76
{ 
# 77
char1 t; (t.x) = x; return t; 
# 78
} 
# 80
static inline uchar1 make_uchar1(unsigned char x) 
# 81
{ 
# 82
uchar1 t; (t.x) = x; return t; 
# 83
} 
# 85
static inline char2 make_char2(signed char x, signed char y) 
# 86
{ 
# 87
char2 t; (t.x) = x; (t.y) = y; return t; 
# 88
} 
# 90
static inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
# 91
{ 
# 92
uchar2 t; (t.x) = x; (t.y) = y; return t; 
# 93
} 
# 95
static inline char3 make_char3(signed char x, signed char y, signed char z) 
# 96
{ 
# 97
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 98
} 
# 100
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
# 101
{ 
# 102
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 103
} 
# 105
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
# 106
{ 
# 107
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 108
} 
# 110
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
# 111
{ 
# 112
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 113
} 
# 115
static inline short1 make_short1(short x) 
# 116
{ 
# 117
short1 t; (t.x) = x; return t; 
# 118
} 
# 120
static inline ushort1 make_ushort1(unsigned short x) 
# 121
{ 
# 122
ushort1 t; (t.x) = x; return t; 
# 123
} 
# 125
static inline short2 make_short2(short x, short y) 
# 126
{ 
# 127
short2 t; (t.x) = x; (t.y) = y; return t; 
# 128
} 
# 130
static inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
# 131
{ 
# 132
ushort2 t; (t.x) = x; (t.y) = y; return t; 
# 133
} 
# 135
static inline short3 make_short3(short x, short y, short z) 
# 136
{ 
# 137
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 138
} 
# 140
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
# 141
{ 
# 142
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 143
} 
# 145
static inline short4 make_short4(short x, short y, short z, short w) 
# 146
{ 
# 147
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 148
} 
# 150
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
# 151
{ 
# 152
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 153
} 
# 155
static inline int1 make_int1(int x) 
# 156
{ 
# 157
int1 t; (t.x) = x; return t; 
# 158
} 
# 160
static inline uint1 make_uint1(unsigned x) 
# 161
{ 
# 162
uint1 t; (t.x) = x; return t; 
# 163
} 
# 165
static inline int2 make_int2(int x, int y) 
# 166
{ 
# 167
int2 t; (t.x) = x; (t.y) = y; return t; 
# 168
} 
# 170
static inline uint2 make_uint2(unsigned x, unsigned y) 
# 171
{ 
# 172
uint2 t; (t.x) = x; (t.y) = y; return t; 
# 173
} 
# 175
static inline int3 make_int3(int x, int y, int z) 
# 176
{ 
# 177
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 178
} 
# 180
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
# 181
{ 
# 182
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 183
} 
# 185
static inline int4 make_int4(int x, int y, int z, int w) 
# 186
{ 
# 187
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 188
} 
# 190
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
# 191
{ 
# 192
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 193
} 
# 195
static inline long1 make_long1(long x) 
# 196
{ 
# 197
long1 t; (t.x) = x; return t; 
# 198
} 
# 200
static inline ulong1 make_ulong1(unsigned long x) 
# 201
{ 
# 202
ulong1 t; (t.x) = x; return t; 
# 203
} 
# 205
static inline long2 make_long2(long x, long y) 
# 206
{ 
# 207
long2 t; (t.x) = x; (t.y) = y; return t; 
# 208
} 
# 210
static inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
# 211
{ 
# 212
ulong2 t; (t.x) = x; (t.y) = y; return t; 
# 213
} 
# 215
static inline long3 make_long3(long x, long y, long z) 
# 216
{ 
# 217
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 218
} 
# 220
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
# 221
{ 
# 222
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 223
} 
# 225
static inline long4 make_long4(long x, long y, long z, long w) 
# 226
{ 
# 227
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 228
} 
# 230
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
# 231
{ 
# 232
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 233
} 
# 235
static inline float1 make_float1(float x) 
# 236
{ 
# 237
float1 t; (t.x) = x; return t; 
# 238
} 
# 240
static inline float2 make_float2(float x, float y) 
# 241
{ 
# 242
float2 t; (t.x) = x; (t.y) = y; return t; 
# 243
} 
# 245
static inline float3 make_float3(float x, float y, float z) 
# 246
{ 
# 247
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 248
} 
# 250
static inline float4 make_float4(float x, float y, float z, float w) 
# 251
{ 
# 252
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 253
} 
# 255
static inline longlong1 make_longlong1(long long x) 
# 256
{ 
# 257
longlong1 t; (t.x) = x; return t; 
# 258
} 
# 260
static inline ulonglong1 make_ulonglong1(unsigned long long x) 
# 261
{ 
# 262
ulonglong1 t; (t.x) = x; return t; 
# 263
} 
# 265
static inline longlong2 make_longlong2(long long x, long long y) 
# 266
{ 
# 267
longlong2 t; (t.x) = x; (t.y) = y; return t; 
# 268
} 
# 270
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y) 
# 271
{ 
# 272
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
# 273
} 
# 275
static inline longlong3 make_longlong3(long long x, long long y, long long z) 
# 276
{ 
# 277
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 278
} 
# 280
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z) 
# 281
{ 
# 282
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 283
} 
# 285
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w) 
# 286
{ 
# 287
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 288
} 
# 290
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w) 
# 291
{ 
# 292
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 293
} 
# 295
static inline double1 make_double1(double x) 
# 296
{ 
# 297
double1 t; (t.x) = x; return t; 
# 298
} 
# 300
static inline double2 make_double2(double x, double y) 
# 301
{ 
# 302
double2 t; (t.x) = x; (t.y) = y; return t; 
# 303
} 
# 305
static inline double3 make_double3(double x, double y, double z) 
# 306
{ 
# 307
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 308
} 
# 310
static inline double4 make_double4(double x, double y, double z, double w) 
# 311
{ 
# 312
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 313
} 
# 27 "/usr/include/string.h" 3
extern "C" {
# 42
extern __attribute((gnu_inline)) inline void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 43
 __attribute((__nonnull__(1, 2))); 
# 46
extern __attribute((gnu_inline)) inline void *memmove(void * __dest, const void * __src, size_t __n) throw()
# 47
 __attribute((__nonnull__(1, 2))); 
# 54
extern void *memccpy(void *__restrict__ __dest, const void *__restrict__ __src, int __c, size_t __n) throw()
# 56
 __attribute((__nonnull__(1, 2))); 
# 62
extern __attribute((gnu_inline)) inline void *memset(void * __s, int __c, size_t __n) throw() __attribute((__nonnull__(1))); 
# 65
extern int memcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 66
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 70
extern "C++" {
# 72
extern __attribute((gnu_inline)) inline void *memchr(void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 73
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 74
extern __attribute((gnu_inline)) inline const void *memchr(const void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 75
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 78
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline void *
# 79
memchr(void *__s, int __c, size_t __n) throw() 
# 80
{ 
# 81
return __builtin_memchr(__s, __c, __n); 
# 82
} 
# 84
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const void *
# 85
memchr(const void *__s, int __c, size_t __n) throw() 
# 86
{ 
# 87
return __builtin_memchr(__s, __c, __n); 
# 88
} 
# 90
}
# 101
extern "C++" void *rawmemchr(void * __s, int __c) throw() __asm__("rawmemchr")
# 102
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 103
extern "C++" const void *rawmemchr(const void * __s, int __c) throw() __asm__("rawmemchr")
# 104
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 112
extern "C++" void *memrchr(void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 113
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 114
extern "C++" const void *memrchr(const void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 115
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 125
extern __attribute((gnu_inline)) inline char *strcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 126
 __attribute((__nonnull__(1, 2))); 
# 128
extern __attribute((gnu_inline)) inline char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 130
 __attribute((__nonnull__(1, 2))); 
# 133
extern __attribute((gnu_inline)) inline char *strcat(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 134
 __attribute((__nonnull__(1, 2))); 
# 136
extern __attribute((gnu_inline)) inline char *strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 137
 __attribute((__nonnull__(1, 2))); 
# 140
extern int strcmp(const char * __s1, const char * __s2) throw()
# 141
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 143
extern int strncmp(const char * __s1, const char * __s2, size_t __n) throw()
# 144
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 147
extern int strcoll(const char * __s1, const char * __s2) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 150
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 152
 __attribute((__nonnull__(2))); 
# 39 "/usr/include/xlocale.h" 3
typedef 
# 27
struct __locale_struct { 
# 30
struct __locale_data *__locales[13]; 
# 33
const unsigned short *__ctype_b; 
# 34
const int *__ctype_tolower; 
# 35
const int *__ctype_toupper; 
# 38
const char *__names[13]; 
# 39
} *__locale_t; 
# 42
typedef __locale_t locale_t; 
# 162 "/usr/include/string.h" 3
extern int strcoll_l(const char * __s1, const char * __s2, __locale_t __l) throw()
# 163
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 165
extern size_t strxfrm_l(char * __dest, const char * __src, size_t __n, __locale_t __l) throw()
# 166
 __attribute((__nonnull__(2, 4))); 
# 171
extern char *strdup(const char * __s) throw()
# 172
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 179
extern char *strndup(const char * __string, size_t __n) throw()
# 180
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 209
extern "C++" {
# 211
extern __attribute((gnu_inline)) inline char *strchr(char * __s, int __c) throw() __asm__("strchr")
# 212
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 213
extern __attribute((gnu_inline)) inline const char *strchr(const char * __s, int __c) throw() __asm__("strchr")
# 214
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 217
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 218
strchr(char *__s, int __c) throw() 
# 219
{ 
# 220
return __builtin_strchr(__s, __c); 
# 221
} 
# 223
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 224
strchr(const char *__s, int __c) throw() 
# 225
{ 
# 226
return __builtin_strchr(__s, __c); 
# 227
} 
# 229
}
# 236
extern "C++" {
# 238
extern __attribute((gnu_inline)) inline char *strrchr(char * __s, int __c) throw() __asm__("strrchr")
# 239
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 240
extern __attribute((gnu_inline)) inline const char *strrchr(const char * __s, int __c) throw() __asm__("strrchr")
# 241
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 244
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 245
strrchr(char *__s, int __c) throw() 
# 246
{ 
# 247
return __builtin_strrchr(__s, __c); 
# 248
} 
# 250
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 251
strrchr(const char *__s, int __c) throw() 
# 252
{ 
# 253
return __builtin_strrchr(__s, __c); 
# 254
} 
# 256
}
# 267
extern "C++" char *strchrnul(char * __s, int __c) throw() __asm__("strchrnul")
# 268
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 269
extern "C++" const char *strchrnul(const char * __s, int __c) throw() __asm__("strchrnul")
# 270
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 280
extern size_t strcspn(const char * __s, const char * __reject) throw()
# 281
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 284
extern size_t strspn(const char * __s, const char * __accept) throw()
# 285
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 288
extern "C++" {
# 290
extern __attribute((gnu_inline)) inline char *strpbrk(char * __s, const char * __accept) throw() __asm__("strpbrk")
# 291
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 292
extern __attribute((gnu_inline)) inline const char *strpbrk(const char * __s, const char * __accept) throw() __asm__("strpbrk")
# 293
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 296
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 297
strpbrk(char *__s, const char *__accept) throw() 
# 298
{ 
# 299
return __builtin_strpbrk(__s, __accept); 
# 300
} 
# 302
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 303
strpbrk(const char *__s, const char *__accept) throw() 
# 304
{ 
# 305
return __builtin_strpbrk(__s, __accept); 
# 306
} 
# 308
}
# 315
extern "C++" {
# 317
extern __attribute((gnu_inline)) inline char *strstr(char * __haystack, const char * __needle) throw() __asm__("strstr")
# 318
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 319
extern __attribute((gnu_inline)) inline const char *strstr(const char * __haystack, const char * __needle) throw() __asm__("strstr")
# 320
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 323
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 324
strstr(char *__haystack, const char *__needle) throw() 
# 325
{ 
# 326
return __builtin_strstr(__haystack, __needle); 
# 327
} 
# 329
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 330
strstr(const char *__haystack, const char *__needle) throw() 
# 331
{ 
# 332
return __builtin_strstr(__haystack, __needle); 
# 333
} 
# 335
}
# 343
extern char *strtok(char *__restrict__ __s, const char *__restrict__ __delim) throw()
# 344
 __attribute((__nonnull__(2))); 
# 349
extern char *__strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 352
 __attribute((__nonnull__(2, 3))); 
# 354
extern char *strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 356
 __attribute((__nonnull__(2, 3))); 
# 362
extern "C++" char *strcasestr(char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 363
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 364
extern "C++" const char *strcasestr(const char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 366
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 377
extern void *memmem(const void * __haystack, size_t __haystacklen, const void * __needle, size_t __needlelen) throw()
# 379
 __attribute((__pure__)) __attribute((__nonnull__(1, 3))); 
# 383
extern void *__mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 385
 __attribute((__nonnull__(1, 2))); 
# 386
extern __attribute((gnu_inline)) inline void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 388
 __attribute((__nonnull__(1, 2))); 
# 394
extern size_t strlen(const char * __s) throw()
# 395
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 401
extern size_t strnlen(const char * __string, size_t __maxlen) throw()
# 402
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 408
extern char *strerror(int __errnum) throw(); 
# 433
extern char *strerror_r(int __errnum, char * __buf, size_t __buflen) throw()
# 434
 __attribute((__nonnull__(2))) __attribute((__warn_unused_result__)); 
# 440
extern char *strerror_l(int __errnum, __locale_t __l) throw(); 
# 446
extern void __bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 450
extern __attribute((gnu_inline)) inline void bcopy(const void * __src, void * __dest, size_t __n) throw()
# 451
 __attribute((__nonnull__(1, 2))); 
# 454
extern __attribute((gnu_inline)) inline void bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 457
extern int bcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 458
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 462
extern "C++" {
# 464
extern __attribute((gnu_inline)) inline char *index(char * __s, int __c) throw() __asm__("index")
# 465
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 466
extern __attribute((gnu_inline)) inline const char *index(const char * __s, int __c) throw() __asm__("index")
# 467
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 470
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 471
index(char *__s, int __c) throw() 
# 472
{ 
# 473
return __builtin_index(__s, __c); 
# 474
} 
# 476
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 477
index(const char *__s, int __c) throw() 
# 478
{ 
# 479
return __builtin_index(__s, __c); 
# 480
} 
# 482
}
# 490
extern "C++" {
# 492
extern __attribute((gnu_inline)) inline char *rindex(char * __s, int __c) throw() __asm__("rindex")
# 493
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 494
extern __attribute((gnu_inline)) inline const char *rindex(const char * __s, int __c) throw() __asm__("rindex")
# 495
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 498
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline char *
# 499
rindex(char *__s, int __c) throw() 
# 500
{ 
# 501
return __builtin_rindex(__s, __c); 
# 502
} 
# 504
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline const char *
# 505
rindex(const char *__s, int __c) throw() 
# 506
{ 
# 507
return __builtin_rindex(__s, __c); 
# 508
} 
# 510
}
# 518
extern int ffs(int __i) throw() __attribute((const)); 
# 523
extern int ffsl(long __l) throw() __attribute((const)); 
# 524
__extension__ extern int ffsll(long long __ll) throw()
# 525
 __attribute((const)); 
# 529
extern int strcasecmp(const char * __s1, const char * __s2) throw()
# 530
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 533
extern int strncasecmp(const char * __s1, const char * __s2, size_t __n) throw()
# 534
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 540
extern int strcasecmp_l(const char * __s1, const char * __s2, __locale_t __loc) throw()
# 542
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 544
extern int strncasecmp_l(const char * __s1, const char * __s2, size_t __n, __locale_t __loc) throw()
# 546
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 4))); 
# 552
extern char *strsep(char **__restrict__ __stringp, const char *__restrict__ __delim) throw()
# 554
 __attribute((__nonnull__(1, 2))); 
# 559
extern char *strsignal(int __sig) throw(); 
# 562
extern char *__stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 563
 __attribute((__nonnull__(1, 2))); 
# 564
extern __attribute((gnu_inline)) inline char *stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 565
 __attribute((__nonnull__(1, 2))); 
# 569
extern char *__stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 571
 __attribute((__nonnull__(1, 2))); 
# 572
extern __attribute((gnu_inline)) inline char *stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 574
 __attribute((__nonnull__(1, 2))); 
# 579
extern int strverscmp(const char * __s1, const char * __s2) throw()
# 580
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 583
extern char *strfry(char * __string) throw() __attribute((__nonnull__(1))); 
# 586
extern void *memfrob(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 594
extern "C++" char *basename(char * __filename) throw() __asm__("basename")
# 595
 __attribute((__nonnull__(1))); 
# 596
extern "C++" const char *basename(const char * __filename) throw() __asm__("basename")
# 597
 __attribute((__nonnull__(1))); 
# 49 "/usr/include/x86_64-linux-gnu/bits/string3.h" 3
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 50
__attribute((__leaf__)) extern inline void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __len) throw() 
# 52
{ 
# 53
return __builtin___memcpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 0)); 
# 54
} 
# 56
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 57
__attribute((__leaf__)) extern inline void *memmove(void *__dest, const void *__src, size_t __len) throw() 
# 58
{ 
# 59
return __builtin___memmove_chk(__dest, __src, __len, __builtin_object_size(__dest, 0)); 
# 60
} 
# 63
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 64
__attribute((__leaf__)) extern inline void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __len) throw() 
# 66
{ 
# 67
return __builtin___mempcpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 0)); 
# 68
} 
# 77
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 78
__attribute((__leaf__)) extern inline void *memset(void *__dest, int __ch, size_t __len) throw() 
# 79
{ 
# 90
return __builtin___memset_chk(__dest, __ch, __len, __builtin_object_size(__dest, 0)); 
# 91
} 
# 94
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline void
# 95
 __attribute((__leaf__)) bcopy(const void *__src, void *__dest, size_t __len) throw() 
# 96
{ 
# 97
(void)__builtin___memmove_chk(__dest, __src, __len, __builtin_object_size(__dest, 0)); 
# 98
} 
# 100
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline void
# 101
 __attribute((__leaf__)) bzero(void *__dest, size_t __len) throw() 
# 102
{ 
# 103
(void)__builtin___memset_chk(__dest, '\000', __len, __builtin_object_size(__dest, 0)); 
# 104
} 
# 107
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 108
__attribute((__leaf__)) extern inline char *strcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw() 
# 109
{ 
# 110
return __builtin___strcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1)); 
# 111
} 
# 114
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 115
__attribute((__leaf__)) extern inline char *stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw() 
# 116
{ 
# 117
return __builtin___stpcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1)); 
# 118
} 
# 122
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 123
__attribute((__leaf__)) extern inline char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __len) throw() 
# 125
{ 
# 126
return __builtin___strncpy_chk(__dest, __src, __len, __builtin_object_size(__dest, 2 > 1)); 
# 127
} 
# 130
extern char *__stpncpy_chk(char * __dest, const char * __src, size_t __n, size_t __destlen) throw(); 
# 132
extern char *__stpncpy_alias(char * __dest, const char * __src, size_t __n) throw() __asm__("stpncpy"); 
# 135
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 136
__attribute((__leaf__)) extern inline char *stpncpy(char *__dest, const char *__src, size_t __n) throw() 
# 137
{ 
# 138
if ((__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) && ((!(0)) || (__n > __builtin_object_size(__dest, 2 > 1)))) { 
# 140
return __stpncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1)); }  
# 141
return __stpncpy_alias(__dest, __src, __n); 
# 142
} 
# 145
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 146
__attribute((__leaf__)) extern inline char *strcat(char *__restrict__ __dest, const char *__restrict__ __src) throw() 
# 147
{ 
# 148
return __builtin___strcat_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1)); 
# 149
} 
# 152
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 153
__attribute((__leaf__)) extern inline char *strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t __len) throw() 
# 155
{ 
# 156
return __builtin___strncat_chk(__dest, __src, __len, __builtin_object_size(__dest, 2 > 1)); 
# 157
} 
# 648 "/usr/include/string.h" 3
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline void *
# 649
__mempcpy_inline(void *__restrict__ __dest, const void *__restrict__ 
# 650
__src, size_t __n) 
# 651
{ 
# 652
return ((char *)memcpy(__dest, __src, __n)) + __n; 
# 653
} 
# 658
}
# 29 "/usr/include/time.h" 3
extern "C" {
# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3
typedef unsigned char __u_char; 
# 31
typedef unsigned short __u_short; 
# 32
typedef unsigned __u_int; 
# 33
typedef unsigned long __u_long; 
# 36
typedef signed char __int8_t; 
# 37
typedef unsigned char __uint8_t; 
# 38
typedef signed short __int16_t; 
# 39
typedef unsigned short __uint16_t; 
# 40
typedef signed int __int32_t; 
# 41
typedef unsigned __uint32_t; 
# 43
typedef signed long __int64_t; 
# 44
typedef unsigned long __uint64_t; 
# 52
typedef long __quad_t; 
# 53
typedef unsigned long __u_quad_t; 
# 124
typedef unsigned long __dev_t; 
# 125
typedef unsigned __uid_t; 
# 126
typedef unsigned __gid_t; 
# 127
typedef unsigned long __ino_t; 
# 128
typedef unsigned long __ino64_t; 
# 129
typedef unsigned __mode_t; 
# 130
typedef unsigned long __nlink_t; 
# 131
typedef long __off_t; 
# 132
typedef long __off64_t; 
# 133
typedef int __pid_t; 
# 134
typedef struct { int __val[2]; } __fsid_t; 
# 135
typedef long __clock_t; 
# 136
typedef unsigned long __rlim_t; 
# 137
typedef unsigned long __rlim64_t; 
# 138
typedef unsigned __id_t; 
# 139
typedef long __time_t; 
# 140
typedef unsigned __useconds_t; 
# 141
typedef long __suseconds_t; 
# 143
typedef int __daddr_t; 
# 144
typedef int __key_t; 
# 147
typedef int __clockid_t; 
# 150
typedef void *__timer_t; 
# 153
typedef long __blksize_t; 
# 158
typedef long __blkcnt_t; 
# 159
typedef long __blkcnt64_t; 
# 162
typedef unsigned long __fsblkcnt_t; 
# 163
typedef unsigned long __fsblkcnt64_t; 
# 166
typedef unsigned long __fsfilcnt_t; 
# 167
typedef unsigned long __fsfilcnt64_t; 
# 170
typedef long __fsword_t; 
# 172
typedef long __ssize_t; 
# 175
typedef long __syscall_slong_t; 
# 177
typedef unsigned long __syscall_ulong_t; 
# 181
typedef __off64_t __loff_t; 
# 182
typedef __quad_t *__qaddr_t; 
# 183
typedef char *__caddr_t; 
# 186
typedef long __intptr_t; 
# 189
typedef unsigned __socklen_t; 
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3
struct timeval { 
# 32
__time_t tv_sec; 
# 33
__suseconds_t tv_usec; 
# 34
}; 
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3
struct timex { 
# 27
unsigned modes; 
# 28
__syscall_slong_t offset; 
# 29
__syscall_slong_t freq; 
# 30
__syscall_slong_t maxerror; 
# 31
__syscall_slong_t esterror; 
# 32
int status; 
# 33
__syscall_slong_t constant; 
# 34
__syscall_slong_t precision; 
# 35
__syscall_slong_t tolerance; 
# 36
timeval time; 
# 37
__syscall_slong_t tick; 
# 38
__syscall_slong_t ppsfreq; 
# 39
__syscall_slong_t jitter; 
# 40
int shift; 
# 41
__syscall_slong_t stabil; 
# 42
__syscall_slong_t jitcnt; 
# 43
__syscall_slong_t calcnt; 
# 44
__syscall_slong_t errcnt; 
# 45
__syscall_slong_t stbcnt; 
# 47
int tai; 
# 50
int:32; int:32; int:32; int:32; 
# 51
int:32; int:32; int:32; int:32; 
# 52
int:32; int:32; int:32; 
# 53
}; 
# 90 "/usr/include/x86_64-linux-gnu/bits/time.h" 3
extern "C" {
# 93
extern int clock_adjtime(__clockid_t __clock_id, timex * __utx) throw(); 
# 95
}
# 59 "/usr/include/time.h" 3
typedef __clock_t clock_t; 
# 75
typedef __time_t time_t; 
# 91
typedef __clockid_t clockid_t; 
# 103
typedef __timer_t timer_t; 
# 120
struct timespec { 
# 122
__time_t tv_sec; 
# 123
__syscall_slong_t tv_nsec; 
# 124
}; 
# 133
struct tm { 
# 135
int tm_sec; 
# 136
int tm_min; 
# 137
int tm_hour; 
# 138
int tm_mday; 
# 139
int tm_mon; 
# 140
int tm_year; 
# 141
int tm_wday; 
# 142
int tm_yday; 
# 143
int tm_isdst; 
# 146
long tm_gmtoff; 
# 147
const char *tm_zone; 
# 152
}; 
# 161
struct itimerspec { 
# 163
timespec it_interval; 
# 164
timespec it_value; 
# 165
}; 
# 168
struct sigevent; 
# 174
typedef __pid_t pid_t; 
# 189
extern clock_t clock() throw(); 
# 192
extern time_t time(time_t * __timer) throw(); 
# 195
extern double difftime(time_t __time1, time_t __time0) throw()
# 196
 __attribute((const)); 
# 199
extern time_t mktime(tm * __tp) throw(); 
# 205
extern size_t strftime(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 213
extern char *strptime(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp) throw(); 
# 223
extern size_t strftime_l(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp, __locale_t __loc) throw(); 
# 230
extern char *strptime_l(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp, __locale_t __loc) throw(); 
# 239
extern tm *gmtime(const time_t * __timer) throw(); 
# 243
extern tm *localtime(const time_t * __timer) throw(); 
# 249
extern tm *gmtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 254
extern tm *localtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 261
extern char *asctime(const tm * __tp) throw(); 
# 264
extern char *ctime(const time_t * __timer) throw(); 
# 272
extern char *asctime_r(const tm *__restrict__ __tp, char *__restrict__ __buf) throw(); 
# 276
extern char *ctime_r(const time_t *__restrict__ __timer, char *__restrict__ __buf) throw(); 
# 282
extern char *__tzname[2]; 
# 283
extern int __daylight; 
# 284
extern long __timezone; 
# 289
extern char *tzname[2]; 
# 293
extern void tzset() throw(); 
# 297
extern int daylight; 
# 298
extern long timezone; 
# 304
extern int stime(const time_t * __when) throw(); 
# 319
extern time_t timegm(tm * __tp) throw(); 
# 322
extern time_t timelocal(tm * __tp) throw(); 
# 325
extern int dysize(int __year) throw() __attribute((const)); 
# 334
extern int nanosleep(const timespec * __requested_time, timespec * __remaining); 
# 339
extern int clock_getres(clockid_t __clock_id, timespec * __res) throw(); 
# 342
extern int clock_gettime(clockid_t __clock_id, timespec * __tp) throw(); 
# 345
extern int clock_settime(clockid_t __clock_id, const timespec * __tp) throw(); 
# 353
extern int clock_nanosleep(clockid_t __clock_id, int __flags, const timespec * __req, timespec * __rem); 
# 358
extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id) throw(); 
# 363
extern int timer_create(clockid_t __clock_id, sigevent *__restrict__ __evp, timer_t *__restrict__ __timerid) throw(); 
# 368
extern int timer_delete(timer_t __timerid) throw(); 
# 371
extern int timer_settime(timer_t __timerid, int __flags, const itimerspec *__restrict__ __value, itimerspec *__restrict__ __ovalue) throw(); 
# 376
extern int timer_gettime(timer_t __timerid, itimerspec * __value) throw(); 
# 380
extern int timer_getoverrun(timer_t __timerid) throw(); 
# 386
extern int timespec_get(timespec * __ts, int __base) throw()
# 387
 __attribute((__nonnull__(1))); 
# 403
extern int getdate_err; 
# 412
extern tm *getdate(const char * __string); 
# 426
extern int getdate_r(const char *__restrict__ __string, tm *__restrict__ __resbufp); 
# 430
}
# 68 "/usr/local/cuda/include/common_functions.h"
extern "C" {
# 71
extern clock_t clock() throw(); 
# 72
extern void *memset(void *, int, size_t) throw(); 
# 73
extern void *memcpy(void *, const void *, size_t) throw(); 
# 75
}
# 93 "/usr/local/cuda/include/math_functions.h"
extern "C" {
# 164
extern int abs(int) throw(); 
# 165
extern long labs(long) throw(); 
# 166
extern long long llabs(long long) throw(); 
# 216
extern double fabs(double x) throw(); 
# 257
extern float fabsf(float x) throw(); 
# 261
extern inline int min(int, int); 
# 263
extern inline unsigned umin(unsigned, unsigned); 
# 264
extern inline long long llmin(long long, long long); 
# 265
extern inline unsigned long long ullmin(unsigned long long, unsigned long long); 
# 286
extern float fminf(float x, float y) throw(); 
# 306
extern double fmin(double x, double y) throw(); 
# 313
extern inline int max(int, int); 
# 315
extern inline unsigned umax(unsigned, unsigned); 
# 316
extern inline long long llmax(long long, long long); 
# 317
extern inline unsigned long long ullmax(unsigned long long, unsigned long long); 
# 338
extern float fmaxf(float x, float y) throw(); 
# 358
extern double fmax(double, double) throw(); 
# 402
extern double sin(double x) throw(); 
# 435
extern double cos(double x) throw(); 
# 454
extern void sincos(double x, double * sptr, double * cptr) throw(); 
# 470
extern void sincosf(float x, float * sptr, float * cptr) throw(); 
# 515
extern double tan(double x) throw(); 
# 584
extern double sqrt(double x) throw(); 
# 656
extern double rsqrt(double x); 
# 726
extern float rsqrtf(float x); 
# 782
extern double log2(double x) throw(); 
# 807
extern double exp2(double x) throw(); 
# 832
extern float exp2f(float x) throw(); 
# 859
extern double exp10(double x) throw(); 
# 882
extern float exp10f(float x) throw(); 
# 928
extern double expm1(double x) throw(); 
# 973
extern float expm1f(float x) throw(); 
# 1028
extern float log2f(float x) throw(); 
# 1082
extern double log10(double x) throw(); 
# 1153
extern double log(double x) throw(); 
# 1247
extern double log1p(double x) throw(); 
# 1344
extern float log1pf(float x) throw(); 
# 1419
extern double floor(double x) throw(); 
# 1458
extern double exp(double x) throw(); 
# 1489
extern double cosh(double x) throw(); 
# 1519
extern double sinh(double x) throw(); 
# 1549
extern double tanh(double x) throw(); 
# 1584
extern double acosh(double x) throw(); 
# 1622
extern float acoshf(float x) throw(); 
# 1638
extern double asinh(double x) throw(); 
# 1654
extern float asinhf(float x) throw(); 
# 1708
extern double atanh(double x) throw(); 
# 1762
extern float atanhf(float x) throw(); 
# 1821
extern double ldexp(double x, int exp) throw(); 
# 1877
extern float ldexpf(float x, int exp) throw(); 
# 1929
extern double logb(double x) throw(); 
# 1984
extern float logbf(float x) throw(); 
# 2014
extern int ilogb(double x) throw(); 
# 2044
extern int ilogbf(float x) throw(); 
# 2120
extern double scalbn(double x, int n) throw(); 
# 2196
extern float scalbnf(float x, int n) throw(); 
# 2272
extern double scalbln(double x, long n) throw(); 
# 2348
extern float scalblnf(float x, long n) throw(); 
# 2426
extern double frexp(double x, int * nptr) throw(); 
# 2501
extern float frexpf(float x, int * nptr) throw(); 
# 2515
extern double round(double x) throw(); 
# 2532
extern float roundf(float x) throw(); 
# 2550
extern long lround(double x) throw(); 
# 2568
extern long lroundf(float x) throw(); 
# 2586
extern long long llround(double x) throw(); 
# 2604
extern long long llroundf(float x) throw(); 
# 2656
extern float rintf(float x) throw(); 
# 2672
extern long lrint(double x) throw(); 
# 2688
extern long lrintf(float x) throw(); 
# 2704
extern long long llrint(double x) throw(); 
# 2720
extern long long llrintf(float x) throw(); 
# 2773
extern double nearbyint(double x) throw(); 
# 2826
extern float nearbyintf(float x) throw(); 
# 2888
extern double ceil(double x) throw(); 
# 2900
extern double trunc(double x) throw(); 
# 2915
extern float truncf(float x) throw(); 
# 2941
extern double fdim(double x, double y) throw(); 
# 2967
extern float fdimf(float x, float y) throw(); 
# 3003
extern double atan2(double y, double x) throw(); 
# 3034
extern double atan(double x) throw(); 
# 3057
extern double acos(double x) throw(); 
# 3089
extern double asin(double x) throw(); 
# 3135
extern double hypot(double x, double y) throw(); 
# 3187
extern double rhypot(double x, double y) throw(); 
# 3233
extern float hypotf(float x, float y) throw(); 
# 3285
extern float rhypotf(float x, float y) throw(); 
# 3332
extern double norm3d(double a, double b, double c) throw(); 
# 3383
extern double rnorm3d(double a, double b, double c) throw(); 
# 3432
extern double norm4d(double a, double b, double c, double d) throw(); 
# 3488
extern double rnorm4d(double a, double b, double c, double d) throw(); 
# 3533
extern double norm(int dim, const double * t) throw(); 
# 3584
extern double rnorm(int dim, const double * t) throw(); 
# 3636
extern float rnormf(int dim, const float * a) throw(); 
# 3680
extern float normf(int dim, const float * a) throw(); 
# 3725
extern float norm3df(float a, float b, float c) throw(); 
# 3776
extern float rnorm3df(float a, float b, float c) throw(); 
# 3825
extern float norm4df(float a, float b, float c, float d) throw(); 
# 3881
extern float rnorm4df(float a, float b, float c, float d) throw(); 
# 3965
extern double cbrt(double x) throw(); 
# 4051
extern float cbrtf(float x) throw(); 
# 4106
extern double rcbrt(double x); 
# 4156
extern float rcbrtf(float x); 
# 4216
extern double sinpi(double x); 
# 4276
extern float sinpif(float x); 
# 4328
extern double cospi(double x); 
# 4380
extern float cospif(float x); 
# 4410
extern void sincospi(double x, double * sptr, double * cptr); 
# 4440
extern void sincospif(float x, float * sptr, float * cptr); 
# 4752
extern double pow(double x, double y) throw(); 
# 4808
extern double modf(double x, double * iptr) throw(); 
# 4867
extern double fmod(double x, double y) throw(); 
# 4953
extern double remainder(double x, double y) throw(); 
# 5043
extern float remainderf(float x, float y) throw(); 
# 5097
extern double remquo(double x, double y, int * quo) throw(); 
# 5151
extern float remquof(float x, float y, int * quo) throw(); 
# 5192
extern double j0(double x) throw(); 
# 5234
extern float j0f(float x) throw(); 
# 5295
extern double j1(double x) throw(); 
# 5356
extern float j1f(float x) throw(); 
# 5399
extern double jn(int n, double x) throw(); 
# 5442
extern float jnf(int n, float x) throw(); 
# 5494
extern double y0(double x) throw(); 
# 5546
extern float y0f(float x) throw(); 
# 5598
extern double y1(double x) throw(); 
# 5650
extern float y1f(float x) throw(); 
# 5703
extern double yn(int n, double x) throw(); 
# 5756
extern float ynf(int n, float x) throw(); 
# 5783
extern double cyl_bessel_i0(double x) throw(); 
# 5809
extern float cyl_bessel_i0f(float x) throw(); 
# 5836
extern double cyl_bessel_i1(double x) throw(); 
# 5862
extern float cyl_bessel_i1f(float x) throw(); 
# 5945
extern double erf(double x) throw(); 
# 6027
extern float erff(float x) throw(); 
# 6091
extern double erfinv(double y); 
# 6148
extern float erfinvf(float y); 
# 6187
extern double erfc(double x) throw(); 
# 6225
extern float erfcf(float x) throw(); 
# 6353
extern double lgamma(double x) throw(); 
# 6416
extern double erfcinv(double y); 
# 6472
extern float erfcinvf(float y); 
# 6530
extern double normcdfinv(double y); 
# 6588
extern float normcdfinvf(float y); 
# 6631
extern double normcdf(double y); 
# 6674
extern float normcdff(float y); 
# 6749
extern double erfcx(double x); 
# 6824
extern float erfcxf(float x); 
# 6958
extern float lgammaf(float x) throw(); 
# 7067
extern double tgamma(double x) throw(); 
# 7176
extern float tgammaf(float x) throw(); 
# 7189
extern double copysign(double x, double y) throw(); 
# 7202
extern float copysignf(float x, float y) throw(); 
# 7239
extern double nextafter(double x, double y) throw(); 
# 7276
extern float nextafterf(float x, float y) throw(); 
# 7292
extern double nan(const char * tagp) throw(); 
# 7308
extern float nanf(const char * tagp) throw(); 
# 7315
extern int __isinff(float) throw(); 
# 7316
extern int __isnanf(float) throw(); 
# 7326
extern int __finite(double) throw(); 
# 7327
extern int __finitef(float) throw(); 
# 7328
extern __attribute((gnu_inline)) inline int __signbit(double) throw(); 
# 7329
extern int __isnan(double) throw(); 
# 7330
extern int __isinf(double) throw(); 
# 7333
extern __attribute((gnu_inline)) inline int __signbitf(float) throw(); 
# 7492
extern double fma(double x, double y, double z) throw(); 
# 7650
extern float fmaf(float x, float y, float z) throw(); 
# 7661
extern __attribute((gnu_inline)) inline int __signbitl(long double) throw(); 
# 7667
extern int __finitel(long double) throw(); 
# 7668
extern int __isinfl(long double) throw(); 
# 7669
extern int __isnanl(long double) throw(); 
# 7719
extern float acosf(float x) throw(); 
# 7759
extern float asinf(float x) throw(); 
# 7799
extern float atanf(float x) throw(); 
# 7832
extern float atan2f(float y, float x) throw(); 
# 7856
extern float cosf(float x) throw(); 
# 7898
extern float sinf(float x) throw(); 
# 7940
extern float tanf(float x) throw(); 
# 7964
extern float coshf(float x) throw(); 
# 8005
extern float sinhf(float x) throw(); 
# 8035
extern float tanhf(float x) throw(); 
# 8086
extern float logf(float x) throw(); 
# 8136
extern float expf(float x) throw(); 
# 8187
extern float log10f(float x) throw(); 
# 8242
extern float modff(float x, float * iptr) throw(); 
# 8550
extern float powf(float x, float y) throw(); 
# 8619
extern float sqrtf(float x) throw(); 
# 8678
extern float ceilf(float x) throw(); 
# 8750
extern float floorf(float x) throw(); 
# 8809
extern float fmodf(float x, float y) throw(); 
# 8823
}
# 28 "/usr/include/math.h" 3
extern "C" {
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3
typedef float float_t; 
# 29
typedef double double_t; 
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern double acos(double __x) throw(); extern double __acos(double __x) throw(); 
# 56
extern double asin(double __x) throw(); extern double __asin(double __x) throw(); 
# 58
extern double atan(double __x) throw(); extern double __atan(double __x) throw(); 
# 60
extern double atan2(double __y, double __x) throw(); extern double __atan2(double __y, double __x) throw(); 
# 63
extern double cos(double __x) throw(); extern double __cos(double __x) throw(); 
# 65
extern double sin(double __x) throw(); extern double __sin(double __x) throw(); 
# 67
extern double tan(double __x) throw(); extern double __tan(double __x) throw(); 
# 72
extern double cosh(double __x) throw(); extern double __cosh(double __x) throw(); 
# 74
extern double sinh(double __x) throw(); extern double __sinh(double __x) throw(); 
# 76
extern double tanh(double __x) throw(); extern double __tanh(double __x) throw(); 
# 81
extern void sincos(double __x, double * __sinx, double * __cosx) throw(); extern void __sincos(double __x, double * __sinx, double * __cosx) throw(); 
# 88
extern double acosh(double __x) throw(); extern double __acosh(double __x) throw(); 
# 90
extern double asinh(double __x) throw(); extern double __asinh(double __x) throw(); 
# 92
extern double atanh(double __x) throw(); extern double __atanh(double __x) throw(); 
# 100
extern double exp(double __x) throw(); extern double __exp(double __x) throw(); 
# 103
extern double frexp(double __x, int * __exponent) throw(); extern double __frexp(double __x, int * __exponent) throw(); 
# 106
extern double ldexp(double __x, int __exponent) throw(); extern double __ldexp(double __x, int __exponent) throw(); 
# 109
extern double log(double __x) throw(); extern double __log(double __x) throw(); 
# 112
extern double log10(double __x) throw(); extern double __log10(double __x) throw(); 
# 115
extern double modf(double __x, double * __iptr) throw(); extern double __modf(double __x, double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern double exp10(double __x) throw(); extern double __exp10(double __x) throw(); 
# 122
extern double pow10(double __x) throw(); extern double __pow10(double __x) throw(); 
# 128
extern double expm1(double __x) throw(); extern double __expm1(double __x) throw(); 
# 131
extern double log1p(double __x) throw(); extern double __log1p(double __x) throw(); 
# 134
extern double logb(double __x) throw(); extern double __logb(double __x) throw(); 
# 141
extern double exp2(double __x) throw(); extern double __exp2(double __x) throw(); 
# 144
extern double log2(double __x) throw(); extern double __log2(double __x) throw(); 
# 153
extern double pow(double __x, double __y) throw(); extern double __pow(double __x, double __y) throw(); 
# 156
extern double sqrt(double __x) throw(); extern double __sqrt(double __x) throw(); 
# 162
extern double hypot(double __x, double __y) throw(); extern double __hypot(double __x, double __y) throw(); 
# 169
extern double cbrt(double __x) throw(); extern double __cbrt(double __x) throw(); 
# 178
extern double ceil(double __x) throw() __attribute((const)); extern double __ceil(double __x) throw() __attribute((const)); 
# 181
extern double fabs(double __x) throw() __attribute((const)); extern double __fabs(double __x) throw() __attribute((const)); 
# 184
extern double floor(double __x) throw() __attribute((const)); extern double __floor(double __x) throw() __attribute((const)); 
# 187
extern double fmod(double __x, double __y) throw(); extern double __fmod(double __x, double __y) throw(); 
# 192
extern int __isinf(double __value) throw() __attribute((const)); 
# 195
extern int __finite(double __value) throw() __attribute((const)); 
# 204
extern inline int isinf(double __value) throw() __attribute((const)); 
# 208
extern int finite(double __value) throw() __attribute((const)); 
# 211
extern double drem(double __x, double __y) throw(); extern double __drem(double __x, double __y) throw(); 
# 215
extern double significand(double __x) throw(); extern double __significand(double __x) throw(); 
# 221
extern double copysign(double __x, double __y) throw() __attribute((const)); extern double __copysign(double __x, double __y) throw() __attribute((const)); 
# 228
extern double nan(const char * __tagb) throw() __attribute((const)); extern double __nan(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnan(double __value) throw() __attribute((const)); 
# 241
extern inline int isnan(double __value) throw() __attribute((const)); 
# 247
extern double j0(double) throw(); extern double __j0(double) throw(); 
# 248
extern double j1(double) throw(); extern double __j1(double) throw(); 
# 249
extern double jn(int, double) throw(); extern double __jn(int, double) throw(); 
# 250
extern double y0(double) throw(); extern double __y0(double) throw(); 
# 251
extern double y1(double) throw(); extern double __y1(double) throw(); 
# 252
extern double yn(int, double) throw(); extern double __yn(int, double) throw(); 
# 259
extern double erf(double) throw(); extern double __erf(double) throw(); 
# 260
extern double erfc(double) throw(); extern double __erfc(double) throw(); 
# 261
extern double lgamma(double) throw(); extern double __lgamma(double) throw(); 
# 268
extern double tgamma(double) throw(); extern double __tgamma(double) throw(); 
# 274
extern double gamma(double) throw(); extern double __gamma(double) throw(); 
# 281
extern double lgamma_r(double, int * __signgamp) throw(); extern double __lgamma_r(double, int * __signgamp) throw(); 
# 289
extern double rint(double __x) throw(); extern double __rint(double __x) throw(); 
# 292
extern double nextafter(double __x, double __y) throw() __attribute((const)); extern double __nextafter(double __x, double __y) throw() __attribute((const)); 
# 294
extern double nexttoward(double __x, long double __y) throw() __attribute((const)); extern double __nexttoward(double __x, long double __y) throw() __attribute((const)); 
# 298
extern double remainder(double __x, double __y) throw(); extern double __remainder(double __x, double __y) throw(); 
# 302
extern double scalbn(double __x, int __n) throw(); extern double __scalbn(double __x, int __n) throw(); 
# 306
extern int ilogb(double __x) throw(); extern int __ilogb(double __x) throw(); 
# 311
extern double scalbln(double __x, long __n) throw(); extern double __scalbln(double __x, long __n) throw(); 
# 315
extern double nearbyint(double __x) throw(); extern double __nearbyint(double __x) throw(); 
# 319
extern double round(double __x) throw() __attribute((const)); extern double __round(double __x) throw() __attribute((const)); 
# 323
extern double trunc(double __x) throw() __attribute((const)); extern double __trunc(double __x) throw() __attribute((const)); 
# 328
extern double remquo(double __x, double __y, int * __quo) throw(); extern double __remquo(double __x, double __y, int * __quo) throw(); 
# 335
extern long lrint(double __x) throw(); extern long __lrint(double __x) throw(); 
# 337
__extension__ extern long long llrint(double __x) throw(); extern long long __llrint(double __x) throw(); 
# 341
extern long lround(double __x) throw(); extern long __lround(double __x) throw(); 
# 343
__extension__ extern long long llround(double __x) throw(); extern long long __llround(double __x) throw(); 
# 347
extern double fdim(double __x, double __y) throw(); extern double __fdim(double __x, double __y) throw(); 
# 350
extern double fmax(double __x, double __y) throw() __attribute((const)); extern double __fmax(double __x, double __y) throw() __attribute((const)); 
# 353
extern double fmin(double __x, double __y) throw() __attribute((const)); extern double __fmin(double __x, double __y) throw() __attribute((const)); 
# 357
extern int __fpclassify(double __value) throw()
# 358
 __attribute((const)); 
# 361
extern __attribute((gnu_inline)) inline int __signbit(double __value) throw()
# 362
 __attribute((const)); 
# 366
extern double fma(double __x, double __y, double __z) throw(); extern double __fma(double __x, double __y, double __z) throw(); 
# 375
extern int __issignaling(double __value) throw()
# 376
 __attribute((const)); 
# 383
extern double scalb(double __x, double __n) throw(); extern double __scalb(double __x, double __n) throw(); 
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern float acosf(float __x) throw(); extern float __acosf(float __x) throw(); 
# 56
extern float asinf(float __x) throw(); extern float __asinf(float __x) throw(); 
# 58
extern float atanf(float __x) throw(); extern float __atanf(float __x) throw(); 
# 60
extern float atan2f(float __y, float __x) throw(); extern float __atan2f(float __y, float __x) throw(); 
# 63
extern float cosf(float __x) throw(); 
# 65
extern float sinf(float __x) throw(); 
# 67
extern float tanf(float __x) throw(); 
# 72
extern float coshf(float __x) throw(); extern float __coshf(float __x) throw(); 
# 74
extern float sinhf(float __x) throw(); extern float __sinhf(float __x) throw(); 
# 76
extern float tanhf(float __x) throw(); extern float __tanhf(float __x) throw(); 
# 81
extern void sincosf(float __x, float * __sinx, float * __cosx) throw(); 
# 88
extern float acoshf(float __x) throw(); extern float __acoshf(float __x) throw(); 
# 90
extern float asinhf(float __x) throw(); extern float __asinhf(float __x) throw(); 
# 92
extern float atanhf(float __x) throw(); extern float __atanhf(float __x) throw(); 
# 100
extern float expf(float __x) throw(); 
# 103
extern float frexpf(float __x, int * __exponent) throw(); extern float __frexpf(float __x, int * __exponent) throw(); 
# 106
extern float ldexpf(float __x, int __exponent) throw(); extern float __ldexpf(float __x, int __exponent) throw(); 
# 109
extern float logf(float __x) throw(); 
# 112
extern float log10f(float __x) throw(); 
# 115
extern float modff(float __x, float * __iptr) throw(); extern float __modff(float __x, float * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern float exp10f(float __x) throw(); 
# 122
extern float pow10f(float __x) throw(); extern float __pow10f(float __x) throw(); 
# 128
extern float expm1f(float __x) throw(); extern float __expm1f(float __x) throw(); 
# 131
extern float log1pf(float __x) throw(); extern float __log1pf(float __x) throw(); 
# 134
extern float logbf(float __x) throw(); extern float __logbf(float __x) throw(); 
# 141
extern float exp2f(float __x) throw(); extern float __exp2f(float __x) throw(); 
# 144
extern float log2f(float __x) throw(); 
# 153
extern float powf(float __x, float __y) throw(); 
# 156
extern float sqrtf(float __x) throw(); extern float __sqrtf(float __x) throw(); 
# 162
extern float hypotf(float __x, float __y) throw(); extern float __hypotf(float __x, float __y) throw(); 
# 169
extern float cbrtf(float __x) throw(); extern float __cbrtf(float __x) throw(); 
# 178
extern float ceilf(float __x) throw() __attribute((const)); extern float __ceilf(float __x) throw() __attribute((const)); 
# 181
extern float fabsf(float __x) throw() __attribute((const)); extern float __fabsf(float __x) throw() __attribute((const)); 
# 184
extern float floorf(float __x) throw() __attribute((const)); extern float __floorf(float __x) throw() __attribute((const)); 
# 187
extern float fmodf(float __x, float __y) throw(); extern float __fmodf(float __x, float __y) throw(); 
# 192
extern int __isinff(float __value) throw() __attribute((const)); 
# 195
extern int __finitef(float __value) throw() __attribute((const)); 
# 204
extern int isinff(float __value) throw() __attribute((const)); 
# 208
extern int finitef(float __value) throw() __attribute((const)); 
# 211
extern float dremf(float __x, float __y) throw(); extern float __dremf(float __x, float __y) throw(); 
# 215
extern float significandf(float __x) throw(); extern float __significandf(float __x) throw(); 
# 221
extern float copysignf(float __x, float __y) throw() __attribute((const)); extern float __copysignf(float __x, float __y) throw() __attribute((const)); 
# 228
extern float nanf(const char * __tagb) throw() __attribute((const)); extern float __nanf(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnanf(float __value) throw() __attribute((const)); 
# 241
extern int isnanf(float __value) throw() __attribute((const)); 
# 247
extern float j0f(float) throw(); extern float __j0f(float) throw(); 
# 248
extern float j1f(float) throw(); extern float __j1f(float) throw(); 
# 249
extern float jnf(int, float) throw(); extern float __jnf(int, float) throw(); 
# 250
extern float y0f(float) throw(); extern float __y0f(float) throw(); 
# 251
extern float y1f(float) throw(); extern float __y1f(float) throw(); 
# 252
extern float ynf(int, float) throw(); extern float __ynf(int, float) throw(); 
# 259
extern float erff(float) throw(); extern float __erff(float) throw(); 
# 260
extern float erfcf(float) throw(); extern float __erfcf(float) throw(); 
# 261
extern float lgammaf(float) throw(); extern float __lgammaf(float) throw(); 
# 268
extern float tgammaf(float) throw(); extern float __tgammaf(float) throw(); 
# 274
extern float gammaf(float) throw(); extern float __gammaf(float) throw(); 
# 281
extern float lgammaf_r(float, int * __signgamp) throw(); extern float __lgammaf_r(float, int * __signgamp) throw(); 
# 289
extern float rintf(float __x) throw(); extern float __rintf(float __x) throw(); 
# 292
extern float nextafterf(float __x, float __y) throw() __attribute((const)); extern float __nextafterf(float __x, float __y) throw() __attribute((const)); 
# 294
extern float nexttowardf(float __x, long double __y) throw() __attribute((const)); extern float __nexttowardf(float __x, long double __y) throw() __attribute((const)); 
# 298
extern float remainderf(float __x, float __y) throw(); extern float __remainderf(float __x, float __y) throw(); 
# 302
extern float scalbnf(float __x, int __n) throw(); extern float __scalbnf(float __x, int __n) throw(); 
# 306
extern int ilogbf(float __x) throw(); extern int __ilogbf(float __x) throw(); 
# 311
extern float scalblnf(float __x, long __n) throw(); extern float __scalblnf(float __x, long __n) throw(); 
# 315
extern float nearbyintf(float __x) throw(); extern float __nearbyintf(float __x) throw(); 
# 319
extern float roundf(float __x) throw() __attribute((const)); extern float __roundf(float __x) throw() __attribute((const)); 
# 323
extern float truncf(float __x) throw() __attribute((const)); extern float __truncf(float __x) throw() __attribute((const)); 
# 328
extern float remquof(float __x, float __y, int * __quo) throw(); extern float __remquof(float __x, float __y, int * __quo) throw(); 
# 335
extern long lrintf(float __x) throw(); extern long __lrintf(float __x) throw(); 
# 337
__extension__ extern long long llrintf(float __x) throw(); extern long long __llrintf(float __x) throw(); 
# 341
extern long lroundf(float __x) throw(); extern long __lroundf(float __x) throw(); 
# 343
__extension__ extern long long llroundf(float __x) throw(); extern long long __llroundf(float __x) throw(); 
# 347
extern float fdimf(float __x, float __y) throw(); extern float __fdimf(float __x, float __y) throw(); 
# 350
extern float fmaxf(float __x, float __y) throw() __attribute((const)); extern float __fmaxf(float __x, float __y) throw() __attribute((const)); 
# 353
extern float fminf(float __x, float __y) throw() __attribute((const)); extern float __fminf(float __x, float __y) throw() __attribute((const)); 
# 357
extern int __fpclassifyf(float __value) throw()
# 358
 __attribute((const)); 
# 361
extern __attribute((gnu_inline)) inline int __signbitf(float __value) throw()
# 362
 __attribute((const)); 
# 366
extern float fmaf(float __x, float __y, float __z) throw(); extern float __fmaf(float __x, float __y, float __z) throw(); 
# 375
extern int __issignalingf(float __value) throw()
# 376
 __attribute((const)); 
# 383
extern float scalbf(float __x, float __n) throw(); extern float __scalbf(float __x, float __n) throw(); 
# 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern long double acosl(long double __x) throw(); extern long double __acosl(long double __x) throw(); 
# 56
extern long double asinl(long double __x) throw(); extern long double __asinl(long double __x) throw(); 
# 58
extern long double atanl(long double __x) throw(); extern long double __atanl(long double __x) throw(); 
# 60
extern long double atan2l(long double __y, long double __x) throw(); extern long double __atan2l(long double __y, long double __x) throw(); 
# 63
extern long double cosl(long double __x) throw(); extern long double __cosl(long double __x) throw(); 
# 65
extern long double sinl(long double __x) throw(); extern long double __sinl(long double __x) throw(); 
# 67
extern long double tanl(long double __x) throw(); extern long double __tanl(long double __x) throw(); 
# 72
extern long double coshl(long double __x) throw(); extern long double __coshl(long double __x) throw(); 
# 74
extern long double sinhl(long double __x) throw(); extern long double __sinhl(long double __x) throw(); 
# 76
extern long double tanhl(long double __x) throw(); extern long double __tanhl(long double __x) throw(); 
# 81
extern void sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); extern void __sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); 
# 88
extern long double acoshl(long double __x) throw(); extern long double __acoshl(long double __x) throw(); 
# 90
extern long double asinhl(long double __x) throw(); extern long double __asinhl(long double __x) throw(); 
# 92
extern long double atanhl(long double __x) throw(); extern long double __atanhl(long double __x) throw(); 
# 100
extern long double expl(long double __x) throw(); extern long double __expl(long double __x) throw(); 
# 103
extern long double frexpl(long double __x, int * __exponent) throw(); extern long double __frexpl(long double __x, int * __exponent) throw(); 
# 106
extern long double ldexpl(long double __x, int __exponent) throw(); extern long double __ldexpl(long double __x, int __exponent) throw(); 
# 109
extern long double logl(long double __x) throw(); extern long double __logl(long double __x) throw(); 
# 112
extern long double log10l(long double __x) throw(); extern long double __log10l(long double __x) throw(); 
# 115
extern long double modfl(long double __x, long double * __iptr) throw(); extern long double __modfl(long double __x, long double * __iptr) throw() __attribute((__nonnull__(2))); 
# 120
extern long double exp10l(long double __x) throw(); extern long double __exp10l(long double __x) throw(); 
# 122
extern long double pow10l(long double __x) throw(); extern long double __pow10l(long double __x) throw(); 
# 128
extern long double expm1l(long double __x) throw(); extern long double __expm1l(long double __x) throw(); 
# 131
extern long double log1pl(long double __x) throw(); extern long double __log1pl(long double __x) throw(); 
# 134
extern long double logbl(long double __x) throw(); extern long double __logbl(long double __x) throw(); 
# 141
extern long double exp2l(long double __x) throw(); extern long double __exp2l(long double __x) throw(); 
# 144
extern long double log2l(long double __x) throw(); extern long double __log2l(long double __x) throw(); 
# 153
extern long double powl(long double __x, long double __y) throw(); extern long double __powl(long double __x, long double __y) throw(); 
# 156
extern long double sqrtl(long double __x) throw(); extern long double __sqrtl(long double __x) throw(); 
# 162
extern long double hypotl(long double __x, long double __y) throw(); extern long double __hypotl(long double __x, long double __y) throw(); 
# 169
extern long double cbrtl(long double __x) throw(); extern long double __cbrtl(long double __x) throw(); 
# 178
extern long double ceill(long double __x) throw() __attribute((const)); extern long double __ceill(long double __x) throw() __attribute((const)); 
# 181
extern long double fabsl(long double __x) throw() __attribute((const)); extern long double __fabsl(long double __x) throw() __attribute((const)); 
# 184
extern long double floorl(long double __x) throw() __attribute((const)); extern long double __floorl(long double __x) throw() __attribute((const)); 
# 187
extern long double fmodl(long double __x, long double __y) throw(); extern long double __fmodl(long double __x, long double __y) throw(); 
# 192
extern int __isinfl(long double __value) throw() __attribute((const)); 
# 195
extern int __finitel(long double __value) throw() __attribute((const)); 
# 204
extern int isinfl(long double __value) throw() __attribute((const)); 
# 208
extern int finitel(long double __value) throw() __attribute((const)); 
# 211
extern long double dreml(long double __x, long double __y) throw(); extern long double __dreml(long double __x, long double __y) throw(); 
# 215
extern long double significandl(long double __x) throw(); extern long double __significandl(long double __x) throw(); 
# 221
extern long double copysignl(long double __x, long double __y) throw() __attribute((const)); extern long double __copysignl(long double __x, long double __y) throw() __attribute((const)); 
# 228
extern long double nanl(const char * __tagb) throw() __attribute((const)); extern long double __nanl(const char * __tagb) throw() __attribute((const)); 
# 234
extern int __isnanl(long double __value) throw() __attribute((const)); 
# 241
extern int isnanl(long double __value) throw() __attribute((const)); 
# 247
extern long double j0l(long double) throw(); extern long double __j0l(long double) throw(); 
# 248
extern long double j1l(long double) throw(); extern long double __j1l(long double) throw(); 
# 249
extern long double jnl(int, long double) throw(); extern long double __jnl(int, long double) throw(); 
# 250
extern long double y0l(long double) throw(); extern long double __y0l(long double) throw(); 
# 251
extern long double y1l(long double) throw(); extern long double __y1l(long double) throw(); 
# 252
extern long double ynl(int, long double) throw(); extern long double __ynl(int, long double) throw(); 
# 259
extern long double erfl(long double) throw(); extern long double __erfl(long double) throw(); 
# 260
extern long double erfcl(long double) throw(); extern long double __erfcl(long double) throw(); 
# 261
extern long double lgammal(long double) throw(); extern long double __lgammal(long double) throw(); 
# 268
extern long double tgammal(long double) throw(); extern long double __tgammal(long double) throw(); 
# 274
extern long double gammal(long double) throw(); extern long double __gammal(long double) throw(); 
# 281
extern long double lgammal_r(long double, int * __signgamp) throw(); extern long double __lgammal_r(long double, int * __signgamp) throw(); 
# 289
extern long double rintl(long double __x) throw(); extern long double __rintl(long double __x) throw(); 
# 292
extern long double nextafterl(long double __x, long double __y) throw() __attribute((const)); extern long double __nextafterl(long double __x, long double __y) throw() __attribute((const)); 
# 294
extern long double nexttowardl(long double __x, long double __y) throw() __attribute((const)); extern long double __nexttowardl(long double __x, long double __y) throw() __attribute((const)); 
# 298
extern long double remainderl(long double __x, long double __y) throw(); extern long double __remainderl(long double __x, long double __y) throw(); 
# 302
extern long double scalbnl(long double __x, int __n) throw(); extern long double __scalbnl(long double __x, int __n) throw(); 
# 306
extern int ilogbl(long double __x) throw(); extern int __ilogbl(long double __x) throw(); 
# 311
extern long double scalblnl(long double __x, long __n) throw(); extern long double __scalblnl(long double __x, long __n) throw(); 
# 315
extern long double nearbyintl(long double __x) throw(); extern long double __nearbyintl(long double __x) throw(); 
# 319
extern long double roundl(long double __x) throw() __attribute((const)); extern long double __roundl(long double __x) throw() __attribute((const)); 
# 323
extern long double truncl(long double __x) throw() __attribute((const)); extern long double __truncl(long double __x) throw() __attribute((const)); 
# 328
extern long double remquol(long double __x, long double __y, int * __quo) throw(); extern long double __remquol(long double __x, long double __y, int * __quo) throw(); 
# 335
extern long lrintl(long double __x) throw(); extern long __lrintl(long double __x) throw(); 
# 337
__extension__ extern long long llrintl(long double __x) throw(); extern long long __llrintl(long double __x) throw(); 
# 341
extern long lroundl(long double __x) throw(); extern long __lroundl(long double __x) throw(); 
# 343
__extension__ extern long long llroundl(long double __x) throw(); extern long long __llroundl(long double __x) throw(); 
# 347
extern long double fdiml(long double __x, long double __y) throw(); extern long double __fdiml(long double __x, long double __y) throw(); 
# 350
extern long double fmaxl(long double __x, long double __y) throw() __attribute((const)); extern long double __fmaxl(long double __x, long double __y) throw() __attribute((const)); 
# 353
extern long double fminl(long double __x, long double __y) throw() __attribute((const)); extern long double __fminl(long double __x, long double __y) throw() __attribute((const)); 
# 357
extern int __fpclassifyl(long double __value) throw()
# 358
 __attribute((const)); 
# 361
extern __attribute((gnu_inline)) inline int __signbitl(long double __value) throw()
# 362
 __attribute((const)); 
# 366
extern long double fmal(long double __x, long double __y, long double __z) throw(); extern long double __fmal(long double __x, long double __y, long double __z) throw(); 
# 375
extern int __issignalingl(long double __value) throw()
# 376
 __attribute((const)); 
# 383
extern long double scalbl(long double __x, long double __n) throw(); extern long double __scalbl(long double __x, long double __n) throw(); 
# 168 "/usr/include/math.h" 3
extern int signgam; 
# 210
enum { 
# 211
FP_NAN, 
# 214
FP_INFINITE, 
# 217
FP_ZERO, 
# 220
FP_SUBNORMAL, 
# 223
FP_NORMAL
# 226
}; 
# 354
typedef 
# 348
enum { 
# 349
_IEEE_ = (-1), 
# 350
_SVID_ = 0, 
# 351
_XOPEN_, 
# 352
_POSIX_, 
# 353
_ISOC_
# 354
} _LIB_VERSION_TYPE; 
# 359
extern _LIB_VERSION_TYPE _LIB_VERSION; 
# 370
struct __exception { 
# 375
int type; 
# 376
char *name; 
# 377
double arg1; 
# 378
double arg2; 
# 379
double retval; 
# 380
}; 
# 383
extern int matherr(__exception * __exc) throw(); 
# 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 3
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline int
# 127
 __attribute((__leaf__)) __signbitf(float __x) throw() 
# 128
{ 
# 130
int __m; 
# 131
__asm__("pmovmskb %1, %0" : "=r" (__m) : "x" (__x)); 
# 132
return (__m & 8) != 0; 
# 137
} 
# 138
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline int
# 139
 __attribute((__leaf__)) __signbit(double __x) throw() 
# 140
{ 
# 142
int __m; 
# 143
__asm__("pmovmskb %1, %0" : "=r" (__m) : "x" (__x)); 
# 144
return (__m & 128) != 0; 
# 149
} 
# 150
__attribute((__always_inline__)) __attribute((__gnu_inline__)) extern inline int
# 151
 __attribute((__leaf__)) __signbitl(long double __x) throw() 
# 152
{ 
# 153
__extension__ union { long double __l; int __i[3]; } __u = {__l: __x}; 
# 154
return (((__u.__i)[2]) & 32768) != 0; 
# 155
} 
# 534 "/usr/include/math.h" 3
}
# 34 "/usr/include/stdlib.h" 3
extern "C" {
# 55 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3
typedef 
# 51
enum { 
# 52
P_ALL, 
# 53
P_PID, 
# 54
P_PGID
# 55
} idtype_t; 
# 45 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3
static inline unsigned __bswap_32(unsigned __bsx) 
# 46
{ 
# 47
return __builtin_bswap32(__bsx); 
# 48
} 
# 109
static inline __uint64_t __bswap_64(__uint64_t __bsx) 
# 110
{ 
# 111
return __builtin_bswap64(__bsx); 
# 112
} 
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3
union wait { 
# 68
int w_status; 
# 70
struct { 
# 72
unsigned __w_termsig:7; 
# 73
unsigned __w_coredump:1; 
# 74
unsigned __w_retcode:8; 
# 75
unsigned:16; 
# 83
} __wait_terminated; 
# 85
struct { 
# 87
unsigned __w_stopval:8; 
# 88
unsigned __w_stopsig:8; 
# 89
unsigned:16; 
# 96
} __wait_stopped; 
# 97
}; 
# 101 "/usr/include/stdlib.h" 3
typedef 
# 98
struct { 
# 99
int quot; 
# 100
int rem; 
# 101
} div_t; 
# 109
typedef 
# 106
struct { 
# 107
long quot; 
# 108
long rem; 
# 109
} ldiv_t; 
# 121
__extension__ typedef 
# 118
struct { 
# 119
long long quot; 
# 120
long long rem; 
# 121
} lldiv_t; 
# 139
extern size_t __ctype_get_mb_cur_max() throw() __attribute((__warn_unused_result__)); 
# 144
extern __attribute((gnu_inline)) inline double atof(const char * __nptr) throw()
# 145
 __attribute((__pure__)) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 147
extern __attribute((gnu_inline)) inline int atoi(const char * __nptr) throw()
# 148
 __attribute((__pure__)) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 150
extern __attribute((gnu_inline)) inline long atol(const char * __nptr) throw()
# 151
 __attribute((__pure__)) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 157
__extension__ extern __attribute((gnu_inline)) inline long long atoll(const char * __nptr) throw()
# 158
 __attribute((__pure__)) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 164
extern double strtod(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 166
 __attribute((__nonnull__(1))); 
# 172
extern float strtof(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 173
 __attribute((__nonnull__(1))); 
# 175
extern long double strtold(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 177
 __attribute((__nonnull__(1))); 
# 183
extern long strtol(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 185
 __attribute((__nonnull__(1))); 
# 187
extern unsigned long strtoul(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 189
 __attribute((__nonnull__(1))); 
# 195
__extension__ extern long long strtoq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 197
 __attribute((__nonnull__(1))); 
# 200
__extension__ extern unsigned long long strtouq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 202
 __attribute((__nonnull__(1))); 
# 209
__extension__ extern long long strtoll(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 211
 __attribute((__nonnull__(1))); 
# 214
__extension__ extern unsigned long long strtoull(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 216
 __attribute((__nonnull__(1))); 
# 239
extern long strtol_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 241
 __attribute((__nonnull__(1, 4))); 
# 243
extern unsigned long strtoul_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 246
 __attribute((__nonnull__(1, 4))); 
# 249
__extension__ extern long long strtoll_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 252
 __attribute((__nonnull__(1, 4))); 
# 255
__extension__ extern unsigned long long strtoull_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, __locale_t __loc) throw()
# 258
 __attribute((__nonnull__(1, 4))); 
# 260
extern double strtod_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 262
 __attribute((__nonnull__(1, 3))); 
# 264
extern float strtof_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 266
 __attribute((__nonnull__(1, 3))); 
# 268
extern long double strtold_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, __locale_t __loc) throw()
# 271
 __attribute((__nonnull__(1, 3))); 
# 277
__attribute((__gnu_inline__)) extern inline int
# 278
 __attribute((__leaf__)) atoi(const char *__nptr) throw() 
# 279
{ 
# 280
return (int)strtol(__nptr, (char **)__null, 10); 
# 281
} 
# 282
__attribute((__gnu_inline__)) extern inline long
# 283
 __attribute((__leaf__)) atol(const char *__nptr) throw() 
# 284
{ 
# 285
return strtol(__nptr, (char **)__null, 10); 
# 286
} 
# 292
__extension__ 
# 291
__attribute((__gnu_inline__)) extern inline long long
# 292
 __attribute((__leaf__)) atoll(const char *__nptr) throw() 
# 293
{ 
# 294
return strtoll(__nptr, (char **)__null, 10); 
# 295
} 
# 305
extern char *l64a(long __n) throw() __attribute((__warn_unused_result__)); 
# 308
extern long a64l(const char * __s) throw()
# 309
 __attribute((__pure__)) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" {
# 33
typedef __u_char u_char; 
# 34
typedef __u_short u_short; 
# 35
typedef __u_int u_int; 
# 36
typedef __u_long u_long; 
# 37
typedef __quad_t quad_t; 
# 38
typedef __u_quad_t u_quad_t; 
# 39
typedef __fsid_t fsid_t; 
# 44
typedef __loff_t loff_t; 
# 48
typedef __ino_t ino_t; 
# 55
typedef __ino64_t ino64_t; 
# 60
typedef __dev_t dev_t; 
# 65
typedef __gid_t gid_t; 
# 70
typedef __mode_t mode_t; 
# 75
typedef __nlink_t nlink_t; 
# 80
typedef __uid_t uid_t; 
# 86
typedef __off_t off_t; 
# 93
typedef __off64_t off64_t; 
# 104
typedef __id_t id_t; 
# 109
typedef __ssize_t ssize_t; 
# 115
typedef __daddr_t daddr_t; 
# 116
typedef __caddr_t caddr_t; 
# 122
typedef __key_t key_t; 
# 136
typedef __useconds_t useconds_t; 
# 140
typedef __suseconds_t suseconds_t; 
# 150
typedef unsigned long ulong; 
# 151
typedef unsigned short ushort; 
# 152
typedef unsigned uint; 
# 194
typedef signed char int8_t __attribute((__mode__(__QI__))); 
# 195
typedef short int16_t __attribute((__mode__(__HI__))); 
# 196
typedef int int32_t __attribute((__mode__(__SI__))); 
# 197
typedef long int64_t __attribute((__mode__(__DI__))); 
# 200
typedef unsigned char u_int8_t __attribute((__mode__(__QI__))); 
# 201
typedef unsigned short u_int16_t __attribute((__mode__(__HI__))); 
# 202
typedef unsigned u_int32_t __attribute((__mode__(__SI__))); 
# 203
typedef unsigned long u_int64_t __attribute((__mode__(__DI__))); 
# 205
typedef long register_t __attribute((__mode__(__word__))); 
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3
typedef int __sig_atomic_t; 
# 30
typedef 
# 28
struct { 
# 29
unsigned long __val[(1024) / ((8) * sizeof(unsigned long))]; 
# 30
} __sigset_t; 
# 37 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
typedef __sigset_t sigset_t; 
# 54
typedef long __fd_mask; 
# 75
typedef 
# 65
struct { 
# 69
__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))]; 
# 75
} fd_set; 
# 82
typedef __fd_mask fd_mask; 
# 96
extern "C" {
# 106
extern int select(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, timeval *__restrict__ __timeout); 
# 118
extern int pselect(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, const timespec *__restrict__ __timeout, const __sigset_t *__restrict__ __sigmask); 
# 24 "/usr/include/x86_64-linux-gnu/bits/select2.h" 3
extern long __fdelt_chk(long __d); 
# 25
extern long __fdelt_warn(long __d)
# 26
 __attribute((__warning__("bit outside of fd_set selected"))); 
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
}
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3
extern "C" {
# 27
__extension__ extern __attribute((gnu_inline)) inline unsigned gnu_dev_major(unsigned long long __dev) throw()
# 28
 __attribute((const)); 
# 30
__extension__ extern __attribute((gnu_inline)) inline unsigned gnu_dev_minor(unsigned long long __dev) throw()
# 31
 __attribute((const)); 
# 33
__extension__ extern __attribute((gnu_inline)) inline unsigned long long gnu_dev_makedev(unsigned __major, unsigned __minor) throw()
# 35
 __attribute((const)); 
# 39
__extension__ 
# 38
__attribute((__gnu_inline__)) __attribute((const)) extern inline unsigned
# 39
 __attribute((__leaf__)) gnu_dev_major(unsigned long long __dev) throw() 
# 40
{ 
# 41
return ((__dev >> 8) & (4095)) | (((unsigned)(__dev >> 32)) & (~4095)); 
# 42
} 
# 45
__extension__ 
# 44
__attribute((__gnu_inline__)) __attribute((const)) extern inline unsigned
# 45
 __attribute((__leaf__)) gnu_dev_minor(unsigned long long __dev) throw() 
# 46
{ 
# 47
return (__dev & (255)) | (((unsigned)(__dev >> 12)) & (~255)); 
# 48
} 
# 51
__extension__ 
# 50
__attribute((__gnu_inline__)) __attribute((const)) extern inline unsigned long long
# 51
 __attribute((__leaf__)) gnu_dev_makedev(unsigned __major, unsigned __minor) throw() 
# 52
{ 
# 53
return (((__minor & (255)) | ((__major & (4095)) << 8)) | (((unsigned long long)(__minor & (~255))) << 12)) | (((unsigned long long)(__major & (~4095))) << 32); 
# 56
} 
# 58
}
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __blksize_t blksize_t; 
# 235
typedef __blkcnt_t blkcnt_t; 
# 239
typedef __fsblkcnt_t fsblkcnt_t; 
# 243
typedef __fsfilcnt_t fsfilcnt_t; 
# 262
typedef __blkcnt64_t blkcnt64_t; 
# 263
typedef __fsblkcnt64_t fsblkcnt64_t; 
# 264
typedef __fsfilcnt64_t fsfilcnt64_t; 
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
typedef unsigned long pthread_t; 
# 63
union pthread_attr_t { 
# 65
char __size[56]; 
# 66
long __align; 
# 67
}; 
# 69
typedef pthread_attr_t pthread_attr_t; 
# 79
typedef 
# 75
struct __pthread_internal_list { 
# 77
__pthread_internal_list *__prev; 
# 78
__pthread_internal_list *__next; 
# 79
} __pthread_list_t; 
# 128
typedef 
# 91
union { 
# 92
struct __pthread_mutex_s { 
# 94
int __lock; 
# 95
unsigned __count; 
# 96
int __owner; 
# 98
unsigned __nusers; 
# 102
int __kind; 
# 104
short __spins; 
# 105
short __elision; 
# 106
__pthread_list_t __list; 
# 125
} __data; 
# 126
char __size[40]; 
# 127
long __align; 
# 128
} pthread_mutex_t; 
# 134
typedef 
# 131
union { 
# 132
char __size[4]; 
# 133
int __align; 
# 134
} pthread_mutexattr_t; 
# 154
typedef 
# 140
union { 
# 142
struct { 
# 143
int __lock; 
# 144
unsigned __futex; 
# 145
__extension__ unsigned long long __total_seq; 
# 146
__extension__ unsigned long long __wakeup_seq; 
# 147
__extension__ unsigned long long __woken_seq; 
# 148
void *__mutex; 
# 149
unsigned __nwaiters; 
# 150
unsigned __broadcast_seq; 
# 151
} __data; 
# 152
char __size[48]; 
# 153
__extension__ long long __align; 
# 154
} pthread_cond_t; 
# 160
typedef 
# 157
union { 
# 158
char __size[4]; 
# 159
int __align; 
# 160
} pthread_condattr_t; 
# 164
typedef unsigned pthread_key_t; 
# 168
typedef int pthread_once_t; 
# 222
typedef 
# 175
union { 
# 178
struct { 
# 179
int __lock; 
# 180
unsigned __nr_readers; 
# 181
unsigned __readers_wakeup; 
# 182
unsigned __writer_wakeup; 
# 183
unsigned __nr_readers_queued; 
# 184
unsigned __nr_writers_queued; 
# 185
int __writer; 
# 186
int __shared; 
# 187
signed char __rwelision; 
# 192
unsigned char __pad1[7]; 
# 195
unsigned long __pad2; 
# 198
unsigned __flags; 
# 200
} __data; 
# 220
char __size[56]; 
# 221
long __align; 
# 222
} pthread_rwlock_t; 
# 228
typedef 
# 225
union { 
# 226
char __size[8]; 
# 227
long __align; 
# 228
} pthread_rwlockattr_t; 
# 234
typedef volatile int pthread_spinlock_t; 
# 243
typedef 
# 240
union { 
# 241
char __size[32]; 
# 242
long __align; 
# 243
} pthread_barrier_t; 
# 249
typedef 
# 246
union { 
# 247
char __size[4]; 
# 248
int __align; 
# 249
} pthread_barrierattr_t; 
# 273 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
}
# 321 "/usr/include/stdlib.h" 3
extern long random() throw(); 
# 324
extern void srandom(unsigned __seed) throw(); 
# 330
extern char *initstate(unsigned __seed, char * __statebuf, size_t __statelen) throw()
# 331
 __attribute((__nonnull__(2))); 
# 335
extern char *setstate(char * __statebuf) throw() __attribute((__nonnull__(1))); 
# 343
struct random_data { 
# 345
int32_t *fptr; 
# 346
int32_t *rptr; 
# 347
int32_t *state; 
# 348
int rand_type; 
# 349
int rand_deg; 
# 350
int rand_sep; 
# 351
int32_t *end_ptr; 
# 352
}; 
# 354
extern int random_r(random_data *__restrict__ __buf, int32_t *__restrict__ __result) throw()
# 355
 __attribute((__nonnull__(1, 2))); 
# 357
extern int srandom_r(unsigned __seed, random_data * __buf) throw()
# 358
 __attribute((__nonnull__(2))); 
# 360
extern int initstate_r(unsigned __seed, char *__restrict__ __statebuf, size_t __statelen, random_data *__restrict__ __buf) throw()
# 363
 __attribute((__nonnull__(2, 4))); 
# 365
extern int setstate_r(char *__restrict__ __statebuf, random_data *__restrict__ __buf) throw()
# 367
 __attribute((__nonnull__(1, 2))); 
# 374
extern int rand() throw(); 
# 376
extern void srand(unsigned __seed) throw(); 
# 381
extern int rand_r(unsigned * __seed) throw(); 
# 389
extern double drand48() throw(); 
# 390
extern double erand48(unsigned short  __xsubi[3]) throw() __attribute((__nonnull__(1))); 
# 393
extern long lrand48() throw(); 
# 394
extern long nrand48(unsigned short  __xsubi[3]) throw()
# 395
 __attribute((__nonnull__(1))); 
# 398
extern long mrand48() throw(); 
# 399
extern long jrand48(unsigned short  __xsubi[3]) throw()
# 400
 __attribute((__nonnull__(1))); 
# 403
extern void srand48(long __seedval) throw(); 
# 404
extern unsigned short *seed48(unsigned short  __seed16v[3]) throw()
# 405
 __attribute((__nonnull__(1))); 
# 406
extern void lcong48(unsigned short  __param[7]) throw() __attribute((__nonnull__(1))); 
# 412
struct drand48_data { 
# 414
unsigned short __x[3]; 
# 415
unsigned short __old_x[3]; 
# 416
unsigned short __c; 
# 417
unsigned short __init; 
# 418
__extension__ unsigned long long __a; 
# 420
}; 
# 423
extern int drand48_r(drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 424
 __attribute((__nonnull__(1, 2))); 
# 425
extern int erand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 427
 __attribute((__nonnull__(1, 2))); 
# 430
extern int lrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 432
 __attribute((__nonnull__(1, 2))); 
# 433
extern int nrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 436
 __attribute((__nonnull__(1, 2))); 
# 439
extern int mrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 441
 __attribute((__nonnull__(1, 2))); 
# 442
extern int jrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 445
 __attribute((__nonnull__(1, 2))); 
# 448
extern int srand48_r(long __seedval, drand48_data * __buffer) throw()
# 449
 __attribute((__nonnull__(2))); 
# 451
extern int seed48_r(unsigned short  __seed16v[3], drand48_data * __buffer) throw()
# 452
 __attribute((__nonnull__(1, 2))); 
# 454
extern int lcong48_r(unsigned short  __param[7], drand48_data * __buffer) throw()
# 456
 __attribute((__nonnull__(1, 2))); 
# 466
extern void *malloc(size_t __size) throw() __attribute((__malloc__)) __attribute((__warn_unused_result__)); 
# 468
extern void *calloc(size_t __nmemb, size_t __size) throw()
# 469
 __attribute((__malloc__)) __attribute((__warn_unused_result__)); 
# 480
extern void *realloc(void * __ptr, size_t __size) throw()
# 481
 __attribute((__warn_unused_result__)); 
# 483
extern void free(void * __ptr) throw(); 
# 488
extern void cfree(void * __ptr) throw(); 
# 26 "/usr/include/alloca.h" 3
extern "C" {
# 32
extern void *alloca(size_t __size) throw(); 
# 38
}
# 498 "/usr/include/stdlib.h" 3
extern void *valloc(size_t __size) throw() __attribute((__malloc__)) __attribute((__warn_unused_result__)); 
# 503
extern int posix_memalign(void ** __memptr, size_t __alignment, size_t __size) throw()
# 504
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 509
extern void *aligned_alloc(size_t __alignment, size_t __size) throw()
# 510
 __attribute((__malloc__)) __attribute((__alloc_size__(2))) __attribute((__warn_unused_result__)); 
# 515
extern void abort() throw() __attribute((__noreturn__)); 
# 519
extern int atexit(void (* __func)(void)) throw() __attribute((__nonnull__(1))); 
# 524
extern "C++" int at_quick_exit(void (* __func)(void)) throw() __asm__("at_quick_exit")
# 525
 __attribute((__nonnull__(1))); 
# 535
extern int on_exit(void (* __func)(int __status, void * __arg), void * __arg) throw()
# 536
 __attribute((__nonnull__(1))); 
# 543
extern void exit(int __status) throw() __attribute((__noreturn__)); 
# 549
extern void quick_exit(int __status) throw() __attribute((__noreturn__)); 
# 557
extern void _Exit(int __status) throw() __attribute((__noreturn__)); 
# 564
extern char *getenv(const char * __name) throw() __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 570
extern char *secure_getenv(const char * __name) throw()
# 571
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 578
extern int putenv(char * __string) throw() __attribute((__nonnull__(1))); 
# 584
extern int setenv(const char * __name, const char * __value, int __replace) throw()
# 585
 __attribute((__nonnull__(2))); 
# 588
extern int unsetenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 595
extern int clearenv() throw(); 
# 606
extern char *mktemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 619
extern int mkstemp(char * __template) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 629
extern int mkstemp64(char * __template) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 641
extern int mkstemps(char * __template, int __suffixlen) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 651
extern int mkstemps64(char * __template, int __suffixlen)
# 652
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 662
extern char *mkdtemp(char * __template) throw() __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 673
extern int mkostemp(char * __template, int __flags) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 683
extern int mkostemp64(char * __template, int __flags) __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 693
extern int mkostemps(char * __template, int __suffixlen, int __flags)
# 694
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 705
extern int mkostemps64(char * __template, int __suffixlen, int __flags)
# 706
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 716
extern int system(const char * __command) __attribute((__warn_unused_result__)); 
# 723
extern char *canonicalize_file_name(const char * __name) throw()
# 724
 __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 733
extern __attribute((gnu_inline)) inline char *realpath(const char *__restrict__ __name, char *__restrict__ __resolved) throw()
# 734
 __attribute((__warn_unused_result__)); 
# 741
typedef int (*__compar_fn_t)(const void *, const void *); 
# 744
typedef __compar_fn_t comparison_fn_t; 
# 748
typedef int (*__compar_d_fn_t)(const void *, const void *, void *); 
# 754
extern __attribute((gnu_inline)) inline void *bsearch(const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 756
 __attribute((__nonnull__(1, 2, 5))) __attribute((__warn_unused_result__)); 
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3
__attribute((__gnu_inline__)) extern inline void *
# 20
bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t 
# 21
__compar) 
# 22
{ 
# 23
size_t __l, __u, __idx; 
# 24
const void *__p; 
# 25
int __comparison; 
# 27
__l = (0); 
# 28
__u = __nmemb; 
# 29
while (__l < __u) 
# 30
{ 
# 31
__idx = ((__l + __u) / (2)); 
# 32
__p = ((void *)(((const char *)__base) + (__idx * __size))); 
# 33
__comparison = (*__compar)(__key, __p); 
# 34
if (__comparison < 0) { 
# 35
__u = __idx; } else { 
# 36
if (__comparison > 0) { 
# 37
__l = (__idx + (1)); } else { 
# 39
return (void *)__p; }  }  
# 40
}  
# 42
return __null; 
# 43
} 
# 764 "/usr/include/stdlib.h" 3
extern void qsort(void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 765
 __attribute((__nonnull__(1, 4))); 
# 767
extern void qsort_r(void * __base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void * __arg)
# 769
 __attribute((__nonnull__(1, 4))); 
# 774
extern int abs(int __x) throw() __attribute((const)) __attribute((__warn_unused_result__)); 
# 775
extern long labs(long __x) throw() __attribute((const)) __attribute((__warn_unused_result__)); 
# 779
__extension__ extern long long llabs(long long __x) throw()
# 780
 __attribute((const)) __attribute((__warn_unused_result__)); 
# 788
extern div_t div(int __numer, int __denom) throw()
# 789
 __attribute((const)) __attribute((__warn_unused_result__)); 
# 790
extern ldiv_t ldiv(long __numer, long __denom) throw()
# 791
 __attribute((const)) __attribute((__warn_unused_result__)); 
# 796
__extension__ extern lldiv_t lldiv(long long __numer, long long __denom) throw()
# 798
 __attribute((const)) __attribute((__warn_unused_result__)); 
# 811
extern char *ecvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 812
 __attribute((__nonnull__(3, 4))) __attribute((__warn_unused_result__)); 
# 817
extern char *fcvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 818
 __attribute((__nonnull__(3, 4))) __attribute((__warn_unused_result__)); 
# 823
extern char *gcvt(double __value, int __ndigit, char * __buf) throw()
# 824
 __attribute((__nonnull__(3))) __attribute((__warn_unused_result__)); 
# 829
extern char *qecvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 831
 __attribute((__nonnull__(3, 4))) __attribute((__warn_unused_result__)); 
# 832
extern char *qfcvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 834
 __attribute((__nonnull__(3, 4))) __attribute((__warn_unused_result__)); 
# 835
extern char *qgcvt(long double __value, int __ndigit, char * __buf) throw()
# 836
 __attribute((__nonnull__(3))) __attribute((__warn_unused_result__)); 
# 841
extern int ecvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 843
 __attribute((__nonnull__(3, 4, 5))); 
# 844
extern int fcvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 846
 __attribute((__nonnull__(3, 4, 5))); 
# 848
extern int qecvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 851
 __attribute((__nonnull__(3, 4, 5))); 
# 852
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 855
 __attribute((__nonnull__(3, 4, 5))); 
# 862
extern int mblen(const char * __s, size_t __n) throw(); 
# 865
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n) throw(); 
# 869
extern __attribute((gnu_inline)) inline int wctomb(char * __s, wchar_t __wchar) throw(); 
# 873
extern __attribute((gnu_inline)) inline size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t __n) throw(); 
# 876
extern __attribute((gnu_inline)) inline size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t __n) throw(); 
# 887
extern int rpmatch(const char * __response) throw() __attribute((__nonnull__(1))) __attribute((__warn_unused_result__)); 
# 898
extern int getsubopt(char **__restrict__ __optionp, char *const *__restrict__ __tokens, char **__restrict__ __valuep) throw()
# 901
 __attribute((__nonnull__(1, 2, 3))) __attribute((__warn_unused_result__)); 
# 907
extern void setkey(const char * __key) throw() __attribute((__nonnull__(1))); 
# 915
extern int posix_openpt(int __oflag) __attribute((__warn_unused_result__)); 
# 923
extern int grantpt(int __fd) throw(); 
# 927
extern int unlockpt(int __fd) throw(); 
# 932
extern char *ptsname(int __fd) throw() __attribute((__warn_unused_result__)); 
# 939
extern __attribute((gnu_inline)) inline int ptsname_r(int __fd, char * __buf, size_t __buflen) throw()
# 940
 __attribute((__nonnull__(2))); 
# 943
extern int getpt(); 
# 950
extern int getloadavg(double  __loadavg[], int __nelem) throw()
# 951
 __attribute((__nonnull__(1))); 
# 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3
__attribute((__gnu_inline__)) extern inline double
# 26
 __attribute((__leaf__)) atof(const char *__nptr) throw() 
# 27
{ 
# 28
return strtod(__nptr, (char **)__null); 
# 29
} 
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3
extern char *__realpath_chk(const char *__restrict__ __name, char *__restrict__ __resolved, size_t __resolvedlen) throw()
# 25
 __attribute((__warn_unused_result__)); 
# 26
extern char *__realpath_alias(const char *__restrict__ __name, char *__restrict__ __resolved) throw() __asm__("realpath")
# 28
 __attribute((__warn_unused_result__)); 
# 29
extern char *__realpath_chk_warn(const char *__restrict__ __name, char *__restrict__ __resolved, size_t __resolvedlen) throw() __asm__("__realpath_chk")
# 32
 __attribute((__warn_unused_result__))
# 33
 __attribute((__warning__("second argument of realpath must be either NULL or at least PATH_MAX bytes long buffer"))); 
# 36
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) 
# 37
__attribute((__leaf__)) extern inline char *realpath(const char *__restrict__ __name, char *__restrict__ __resolved) throw() 
# 38
{ 
# 39
if (__builtin_object_size(__resolved, 2 > 1) != ((size_t)(-1))) 
# 40
{ 
# 42
if (__builtin_object_size(__resolved, 2 > 1) < (4096)) { 
# 43
return __realpath_chk_warn(__name, __resolved, __builtin_object_size(__resolved, 2 > 1)); }  
# 45
return __realpath_chk(__name, __resolved, __builtin_object_size(__resolved, 2 > 1)); 
# 46
}  
# 48
return __realpath_alias(__name, __resolved); 
# 49
} 
# 52
extern int __ptsname_r_chk(int __fd, char * __buf, size_t __buflen, size_t __nreal) throw()
# 53
 __attribute((__nonnull__(2))); 
# 54
extern int __ptsname_r_alias(int __fd, char * __buf, size_t __buflen) throw() __asm__("ptsname_r")
# 56
 __attribute((__nonnull__(2))); 
# 57
extern int __ptsname_r_chk_warn(int __fd, char * __buf, size_t __buflen, size_t __nreal) throw() __asm__("__ptsname_r_chk")
# 60
 __attribute((__nonnull__(2))) __attribute((__warning__("ptsname_r called with buflen bigger than size of buf"))); 
# 63
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 64
 __attribute((__leaf__)) ptsname_r(int __fd, char *__buf, size_t __buflen) throw() 
# 65
{ 
# 66
if (__builtin_object_size(__buf, 2 > 1) != ((size_t)(-1))) 
# 67
{ 
# 68
if (!(0)) { 
# 69
return __ptsname_r_chk(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1)); }  
# 70
if (__buflen > __builtin_object_size(__buf, 2 > 1)) { 
# 71
return __ptsname_r_chk_warn(__fd, __buf, __buflen, __builtin_object_size(__buf, 2 > 1)); }  
# 72
}  
# 73
return __ptsname_r_alias(__fd, __buf, __buflen); 
# 74
} 
# 77
extern int __wctomb_chk(char * __s, wchar_t __wchar, size_t __buflen) throw()
# 78
 __attribute((__warn_unused_result__)); 
# 79
extern int __wctomb_alias(char * __s, wchar_t __wchar) throw() __asm__("wctomb")
# 80
 __attribute((__warn_unused_result__)); 
# 82
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline int
# 83
 __attribute((__leaf__)) wctomb(char *__s, wchar_t __wchar) throw() 
# 84
{ 
# 92
if ((__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) && ((16) > __builtin_object_size(__s, 2 > 1))) { 
# 93
return __wctomb_chk(__s, __wchar, __builtin_object_size(__s, 2 > 1)); }  
# 94
return __wctomb_alias(__s, __wchar); 
# 95
} 
# 98
extern size_t __mbstowcs_chk(wchar_t *__restrict__ __dst, const char *__restrict__ __src, size_t __len, size_t __dstlen) throw(); 
# 101
extern size_t __mbstowcs_alias(wchar_t *__restrict__ __dst, const char *__restrict__ __src, size_t __len) throw() __asm__("mbstowcs"); 
# 105
extern size_t __mbstowcs_chk_warn(wchar_t *__restrict__ __dst, const char *__restrict__ __src, size_t __len, size_t __dstlen) throw() __asm__("__mbstowcs_chk")
# 109
 __attribute((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))); 
# 112
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 113
 __attribute((__leaf__)) mbstowcs(wchar_t *__restrict__ __dst, const char *__restrict__ __src, size_t __len) throw() 
# 115
{ 
# 116
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 117
{ 
# 118
if (!(0)) { 
# 119
return __mbstowcs_chk(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 122
if (__len > (__builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))) { 
# 123
return __mbstowcs_chk_warn(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 125
}  
# 126
return __mbstowcs_alias(__dst, __src, __len); 
# 127
} 
# 130
extern size_t __wcstombs_chk(char *__restrict__ __dst, const wchar_t *__restrict__ __src, size_t __len, size_t __dstlen) throw(); 
# 133
extern size_t __wcstombs_alias(char *__restrict__ __dst, const wchar_t *__restrict__ __src, size_t __len) throw() __asm__("wcstombs"); 
# 137
extern size_t __wcstombs_chk_warn(char *__restrict__ __dst, const wchar_t *__restrict__ __src, size_t __len, size_t __dstlen) throw() __asm__("__wcstombs_chk")
# 141
 __attribute((__warning__("wcstombs called with dst buffer smaller than len"))); 
# 143
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 144
 __attribute((__leaf__)) wcstombs(char *__restrict__ __dst, const wchar_t *__restrict__ __src, size_t __len) throw() 
# 146
{ 
# 147
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 148
{ 
# 149
if (!(0)) { 
# 150
return __wcstombs_chk(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1)); }  
# 151
if (__len > __builtin_object_size(__dst, 2 > 1)) { 
# 152
return __wcstombs_chk_warn(__dst, __src, __len, __builtin_object_size(__dst, 2 > 1)); }  
# 153
}  
# 154
return __wcstombs_alias(__dst, __src, __len); 
# 155
} 
# 967 "/usr/include/stdlib.h" 3
}
# 194 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++config.h" 3
namespace std { 
# 196
typedef unsigned long size_t; 
# 197
typedef long ptrdiff_t; 
# 202
}
# 216
namespace std { 
# 218
inline namespace __cxx11 __attribute((__abi_tag__("cxx11" ))) { }
# 219
}
# 220
namespace __gnu_cxx { 
# 222
inline namespace __cxx11 __attribute((__abi_tag__("cxx11" ))) { }
# 223
}
# 68 "/usr/include/c++/5/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 72
template< class _Iterator, class _Container> class __normal_iterator; 
# 76
}
# 78
namespace std __attribute((__visibility__("default"))) { 
# 82
struct __true_type { }; 
# 83
struct __false_type { }; 
# 85
template< bool > 
# 86
struct __truth_type { 
# 87
typedef __false_type __type; }; 
# 90
template<> struct __truth_type< true>  { 
# 91
typedef __true_type __type; }; 
# 95
template< class _Sp, class _Tp> 
# 96
struct __traitor { 
# 98
enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value)}; 
# 99
typedef typename __truth_type< __value> ::__type __type; 
# 100
}; 
# 103
template< class , class > 
# 104
struct __are_same { 
# 106
enum { __value}; 
# 107
typedef __false_type __type; 
# 108
}; 
# 110
template< class _Tp> 
# 111
struct __are_same< _Tp, _Tp>  { 
# 113
enum { __value = 1}; 
# 114
typedef __true_type __type; 
# 115
}; 
# 118
template< class _Tp> 
# 119
struct __is_void { 
# 121
enum { __value}; 
# 122
typedef __false_type __type; 
# 123
}; 
# 126
template<> struct __is_void< void>  { 
# 128
enum { __value = 1}; 
# 129
typedef __true_type __type; 
# 130
}; 
# 135
template< class _Tp> 
# 136
struct __is_integer { 
# 138
enum { __value}; 
# 139
typedef __false_type __type; 
# 140
}; 
# 147
template<> struct __is_integer< bool>  { 
# 149
enum { __value = 1}; 
# 150
typedef __true_type __type; 
# 151
}; 
# 154
template<> struct __is_integer< char>  { 
# 156
enum { __value = 1}; 
# 157
typedef __true_type __type; 
# 158
}; 
# 161
template<> struct __is_integer< signed char>  { 
# 163
enum { __value = 1}; 
# 164
typedef __true_type __type; 
# 165
}; 
# 168
template<> struct __is_integer< unsigned char>  { 
# 170
enum { __value = 1}; 
# 171
typedef __true_type __type; 
# 172
}; 
# 176
template<> struct __is_integer< wchar_t>  { 
# 178
enum { __value = 1}; 
# 179
typedef __true_type __type; 
# 180
}; 
# 200
template<> struct __is_integer< short>  { 
# 202
enum { __value = 1}; 
# 203
typedef __true_type __type; 
# 204
}; 
# 207
template<> struct __is_integer< unsigned short>  { 
# 209
enum { __value = 1}; 
# 210
typedef __true_type __type; 
# 211
}; 
# 214
template<> struct __is_integer< int>  { 
# 216
enum { __value = 1}; 
# 217
typedef __true_type __type; 
# 218
}; 
# 221
template<> struct __is_integer< unsigned>  { 
# 223
enum { __value = 1}; 
# 224
typedef __true_type __type; 
# 225
}; 
# 228
template<> struct __is_integer< long>  { 
# 230
enum { __value = 1}; 
# 231
typedef __true_type __type; 
# 232
}; 
# 235
template<> struct __is_integer< unsigned long>  { 
# 237
enum { __value = 1}; 
# 238
typedef __true_type __type; 
# 239
}; 
# 242
template<> struct __is_integer< long long>  { 
# 244
enum { __value = 1}; 
# 245
typedef __true_type __type; 
# 246
}; 
# 249
template<> struct __is_integer< unsigned long long>  { 
# 251
enum { __value = 1}; 
# 252
typedef __true_type __type; 
# 253
}; 
# 270
template<> struct __is_integer< __int128_t>  { enum { __value = 1}; typedef __true_type __type; }; template<> struct __is_integer< __uint128_t>  { enum { __value = 1}; typedef __true_type __type; }; 
# 287
template< class _Tp> 
# 288
struct __is_floating { 
# 290
enum { __value}; 
# 291
typedef __false_type __type; 
# 292
}; 
# 296
template<> struct __is_floating< float>  { 
# 298
enum { __value = 1}; 
# 299
typedef __true_type __type; 
# 300
}; 
# 303
template<> struct __is_floating< double>  { 
# 305
enum { __value = 1}; 
# 306
typedef __true_type __type; 
# 307
}; 
# 310
template<> struct __is_floating< long double>  { 
# 312
enum { __value = 1}; 
# 313
typedef __true_type __type; 
# 314
}; 
# 319
template< class _Tp> 
# 320
struct __is_pointer { 
# 322
enum { __value}; 
# 323
typedef __false_type __type; 
# 324
}; 
# 326
template< class _Tp> 
# 327
struct __is_pointer< _Tp *>  { 
# 329
enum { __value = 1}; 
# 330
typedef __true_type __type; 
# 331
}; 
# 336
template< class _Tp> 
# 337
struct __is_normal_iterator { 
# 339
enum { __value}; 
# 340
typedef __false_type __type; 
# 341
}; 
# 343
template< class _Iterator, class _Container> 
# 344
struct __is_normal_iterator< __gnu_cxx::__normal_iterator< _Iterator, _Container> >  { 
# 347
enum { __value = 1}; 
# 348
typedef __true_type __type; 
# 349
}; 
# 354
template< class _Tp> 
# 355
struct __is_arithmetic : public __traitor< __is_integer< _Tp> , __is_floating< _Tp> >  { 
# 357
}; 
# 362
template< class _Tp> 
# 363
struct __is_scalar : public __traitor< __is_arithmetic< _Tp> , __is_pointer< _Tp> >  { 
# 365
}; 
# 370
template< class _Tp> 
# 371
struct __is_char { 
# 373
enum { __value}; 
# 374
typedef __false_type __type; 
# 375
}; 
# 378
template<> struct __is_char< char>  { 
# 380
enum { __value = 1}; 
# 381
typedef __true_type __type; 
# 382
}; 
# 386
template<> struct __is_char< wchar_t>  { 
# 388
enum { __value = 1}; 
# 389
typedef __true_type __type; 
# 390
}; 
# 393
template< class _Tp> 
# 394
struct __is_byte { 
# 396
enum { __value}; 
# 397
typedef __false_type __type; 
# 398
}; 
# 401
template<> struct __is_byte< char>  { 
# 403
enum { __value = 1}; 
# 404
typedef __true_type __type; 
# 405
}; 
# 408
template<> struct __is_byte< signed char>  { 
# 410
enum { __value = 1}; 
# 411
typedef __true_type __type; 
# 412
}; 
# 415
template<> struct __is_byte< unsigned char>  { 
# 417
enum { __value = 1}; 
# 418
typedef __true_type __type; 
# 419
}; 
# 424
template< class _Tp> 
# 425
struct __is_move_iterator { 
# 427
enum { __value}; 
# 428
typedef __false_type __type; 
# 429
}; 
# 444
}
# 37 "/usr/include/c++/5/ext/type_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 42
template< bool , class > 
# 43
struct __enable_if { 
# 44
}; 
# 46
template< class _Tp> 
# 47
struct __enable_if< true, _Tp>  { 
# 48
typedef _Tp __type; }; 
# 52
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 53
struct __conditional_type { 
# 54
typedef _Iftrue __type; }; 
# 56
template< class _Iftrue, class _Iffalse> 
# 57
struct __conditional_type< false, _Iftrue, _Iffalse>  { 
# 58
typedef _Iffalse __type; }; 
# 62
template< class _Tp> 
# 63
struct __add_unsigned { 
# 66
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 69
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 70
}; 
# 73
template<> struct __add_unsigned< char>  { 
# 74
typedef unsigned char __type; }; 
# 77
template<> struct __add_unsigned< signed char>  { 
# 78
typedef unsigned char __type; }; 
# 81
template<> struct __add_unsigned< short>  { 
# 82
typedef unsigned short __type; }; 
# 85
template<> struct __add_unsigned< int>  { 
# 86
typedef unsigned __type; }; 
# 89
template<> struct __add_unsigned< long>  { 
# 90
typedef unsigned long __type; }; 
# 93
template<> struct __add_unsigned< long long>  { 
# 94
typedef unsigned long long __type; }; 
# 98
template<> struct __add_unsigned< bool> ; 
# 101
template<> struct __add_unsigned< wchar_t> ; 
# 105
template< class _Tp> 
# 106
struct __remove_unsigned { 
# 109
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 112
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 113
}; 
# 116
template<> struct __remove_unsigned< char>  { 
# 117
typedef signed char __type; }; 
# 120
template<> struct __remove_unsigned< unsigned char>  { 
# 121
typedef signed char __type; }; 
# 124
template<> struct __remove_unsigned< unsigned short>  { 
# 125
typedef short __type; }; 
# 128
template<> struct __remove_unsigned< unsigned>  { 
# 129
typedef int __type; }; 
# 132
template<> struct __remove_unsigned< unsigned long>  { 
# 133
typedef long __type; }; 
# 136
template<> struct __remove_unsigned< unsigned long long>  { 
# 137
typedef long long __type; }; 
# 141
template<> struct __remove_unsigned< bool> ; 
# 144
template<> struct __remove_unsigned< wchar_t> ; 
# 148
template< class _Type> inline bool 
# 150
__is_null_pointer(_Type *__ptr) 
# 151
{ return __ptr == 0; } 
# 153
template< class _Type> inline bool 
# 155
__is_null_pointer(_Type) 
# 156
{ return false; } 
# 165
template< class _Tp, bool  = std::__is_integer< _Tp> ::__value> 
# 166
struct __promote { 
# 167
typedef double __type; }; 
# 172
template< class _Tp> 
# 173
struct __promote< _Tp, false>  { 
# 174
}; 
# 177
template<> struct __promote< long double>  { 
# 178
typedef long double __type; }; 
# 181
template<> struct __promote< double>  { 
# 182
typedef double __type; }; 
# 185
template<> struct __promote< float>  { 
# 186
typedef float __type; }; 
# 188
template< class _Tp, class _Up, class 
# 189
_Tp2 = typename __promote< _Tp> ::__type, class 
# 190
_Up2 = typename __promote< _Up> ::__type> 
# 191
struct __promote_2 { 
# 193
typedef __typeof__(_Tp2() + _Up2()) __type; 
# 194
}; 
# 196
template< class _Tp, class _Up, class _Vp, class 
# 197
_Tp2 = typename __promote< _Tp> ::__type, class 
# 198
_Up2 = typename __promote< _Up> ::__type, class 
# 199
_Vp2 = typename __promote< _Vp> ::__type> 
# 200
struct __promote_3 { 
# 202
typedef __typeof__((_Tp2() + _Up2()) + _Vp2()) __type; 
# 203
}; 
# 205
template< class _Tp, class _Up, class _Vp, class _Wp, class 
# 206
_Tp2 = typename __promote< _Tp> ::__type, class 
# 207
_Up2 = typename __promote< _Up> ::__type, class 
# 208
_Vp2 = typename __promote< _Vp> ::__type, class 
# 209
_Wp2 = typename __promote< _Wp> ::__type> 
# 210
struct __promote_4 { 
# 212
typedef __typeof__(((_Tp2() + _Up2()) + _Vp2()) + _Wp2()) __type; 
# 213
}; 
# 216
}
# 75 "/usr/include/c++/5/cmath" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
inline double abs(double __x) 
# 82
{ return __builtin_fabs(__x); } 
# 87
inline float abs(float __x) 
# 88
{ return __builtin_fabsf(__x); } 
# 91
inline long double abs(long double __x) 
# 92
{ return __builtin_fabsl(__x); } 
# 95
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 99
abs(_Tp __x) 
# 100
{ return __builtin_fabs(__x); } 
# 102
using ::acos;
# 106
inline float acos(float __x) 
# 107
{ return __builtin_acosf(__x); } 
# 110
inline long double acos(long double __x) 
# 111
{ return __builtin_acosl(__x); } 
# 114
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 118
acos(_Tp __x) 
# 119
{ return __builtin_acos(__x); } 
# 121
using ::asin;
# 125
inline float asin(float __x) 
# 126
{ return __builtin_asinf(__x); } 
# 129
inline long double asin(long double __x) 
# 130
{ return __builtin_asinl(__x); } 
# 133
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 137
asin(_Tp __x) 
# 138
{ return __builtin_asin(__x); } 
# 140
using ::atan;
# 144
inline float atan(float __x) 
# 145
{ return __builtin_atanf(__x); } 
# 148
inline long double atan(long double __x) 
# 149
{ return __builtin_atanl(__x); } 
# 152
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 156
atan(_Tp __x) 
# 157
{ return __builtin_atan(__x); } 
# 159
using ::atan2;
# 163
inline float atan2(float __y, float __x) 
# 164
{ return __builtin_atan2f(__y, __x); } 
# 167
inline long double atan2(long double __y, long double __x) 
# 168
{ return __builtin_atan2l(__y, __x); } 
# 171
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 174
atan2(_Tp __y, _Up __x) 
# 175
{ 
# 176
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 177
return atan2((__type)__y, (__type)__x); 
# 178
} 
# 180
using ::ceil;
# 184
inline float ceil(float __x) 
# 185
{ return __builtin_ceilf(__x); } 
# 188
inline long double ceil(long double __x) 
# 189
{ return __builtin_ceill(__x); } 
# 192
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 196
ceil(_Tp __x) 
# 197
{ return __builtin_ceil(__x); } 
# 199
using ::cos;
# 203
inline float cos(float __x) 
# 204
{ return __builtin_cosf(__x); } 
# 207
inline long double cos(long double __x) 
# 208
{ return __builtin_cosl(__x); } 
# 211
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 215
cos(_Tp __x) 
# 216
{ return __builtin_cos(__x); } 
# 218
using ::cosh;
# 222
inline float cosh(float __x) 
# 223
{ return __builtin_coshf(__x); } 
# 226
inline long double cosh(long double __x) 
# 227
{ return __builtin_coshl(__x); } 
# 230
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 234
cosh(_Tp __x) 
# 235
{ return __builtin_cosh(__x); } 
# 237
using ::exp;
# 241
inline float exp(float __x) 
# 242
{ return __builtin_expf(__x); } 
# 245
inline long double exp(long double __x) 
# 246
{ return __builtin_expl(__x); } 
# 249
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 253
exp(_Tp __x) 
# 254
{ return __builtin_exp(__x); } 
# 256
using ::fabs;
# 260
inline float fabs(float __x) 
# 261
{ return __builtin_fabsf(__x); } 
# 264
inline long double fabs(long double __x) 
# 265
{ return __builtin_fabsl(__x); } 
# 268
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 272
fabs(_Tp __x) 
# 273
{ return __builtin_fabs(__x); } 
# 275
using ::floor;
# 279
inline float floor(float __x) 
# 280
{ return __builtin_floorf(__x); } 
# 283
inline long double floor(long double __x) 
# 284
{ return __builtin_floorl(__x); } 
# 287
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 291
floor(_Tp __x) 
# 292
{ return __builtin_floor(__x); } 
# 294
using ::fmod;
# 298
inline float fmod(float __x, float __y) 
# 299
{ return __builtin_fmodf(__x, __y); } 
# 302
inline long double fmod(long double __x, long double __y) 
# 303
{ return __builtin_fmodl(__x, __y); } 
# 306
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 309
fmod(_Tp __x, _Up __y) 
# 310
{ 
# 311
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 312
return fmod((__type)__x, (__type)__y); 
# 313
} 
# 315
using ::frexp;
# 319
inline float frexp(float __x, int *__exp) 
# 320
{ return __builtin_frexpf(__x, __exp); } 
# 323
inline long double frexp(long double __x, int *__exp) 
# 324
{ return __builtin_frexpl(__x, __exp); } 
# 327
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 331
frexp(_Tp __x, int *__exp) 
# 332
{ return __builtin_frexp(__x, __exp); } 
# 334
using ::ldexp;
# 338
inline float ldexp(float __x, int __exp) 
# 339
{ return __builtin_ldexpf(__x, __exp); } 
# 342
inline long double ldexp(long double __x, int __exp) 
# 343
{ return __builtin_ldexpl(__x, __exp); } 
# 346
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 350
ldexp(_Tp __x, int __exp) 
# 351
{ return __builtin_ldexp(__x, __exp); } 
# 353
using ::log;
# 357
inline float log(float __x) 
# 358
{ return __builtin_logf(__x); } 
# 361
inline long double log(long double __x) 
# 362
{ return __builtin_logl(__x); } 
# 365
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 369
log(_Tp __x) 
# 370
{ return __builtin_log(__x); } 
# 372
using ::log10;
# 376
inline float log10(float __x) 
# 377
{ return __builtin_log10f(__x); } 
# 380
inline long double log10(long double __x) 
# 381
{ return __builtin_log10l(__x); } 
# 384
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 388
log10(_Tp __x) 
# 389
{ return __builtin_log10(__x); } 
# 391
using ::modf;
# 395
inline float modf(float __x, float *__iptr) 
# 396
{ return __builtin_modff(__x, __iptr); } 
# 399
inline long double modf(long double __x, long double *__iptr) 
# 400
{ return __builtin_modfl(__x, __iptr); } 
# 403
using ::pow;
# 407
inline float pow(float __x, float __y) 
# 408
{ return __builtin_powf(__x, __y); } 
# 411
inline long double pow(long double __x, long double __y) 
# 412
{ return __builtin_powl(__x, __y); } 
# 418
inline double pow(double __x, int __i) 
# 419
{ return __builtin_powi(__x, __i); } 
# 422
inline float pow(float __x, int __n) 
# 423
{ return __builtin_powif(__x, __n); } 
# 426
inline long double pow(long double __x, int __n) 
# 427
{ return __builtin_powil(__x, __n); } 
# 431
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 434
pow(_Tp __x, _Up __y) 
# 435
{ 
# 436
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 437
return pow((__type)__x, (__type)__y); 
# 438
} 
# 440
using ::sin;
# 444
inline float sin(float __x) 
# 445
{ return __builtin_sinf(__x); } 
# 448
inline long double sin(long double __x) 
# 449
{ return __builtin_sinl(__x); } 
# 452
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 456
sin(_Tp __x) 
# 457
{ return __builtin_sin(__x); } 
# 459
using ::sinh;
# 463
inline float sinh(float __x) 
# 464
{ return __builtin_sinhf(__x); } 
# 467
inline long double sinh(long double __x) 
# 468
{ return __builtin_sinhl(__x); } 
# 471
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 475
sinh(_Tp __x) 
# 476
{ return __builtin_sinh(__x); } 
# 478
using ::sqrt;
# 482
inline float sqrt(float __x) 
# 483
{ return __builtin_sqrtf(__x); } 
# 486
inline long double sqrt(long double __x) 
# 487
{ return __builtin_sqrtl(__x); } 
# 490
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 494
sqrt(_Tp __x) 
# 495
{ return __builtin_sqrt(__x); } 
# 497
using ::tan;
# 501
inline float tan(float __x) 
# 502
{ return __builtin_tanf(__x); } 
# 505
inline long double tan(long double __x) 
# 506
{ return __builtin_tanl(__x); } 
# 509
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 513
tan(_Tp __x) 
# 514
{ return __builtin_tan(__x); } 
# 516
using ::tanh;
# 520
inline float tanh(float __x) 
# 521
{ return __builtin_tanhf(__x); } 
# 524
inline long double tanh(long double __x) 
# 525
{ return __builtin_tanhl(__x); } 
# 528
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 532
tanh(_Tp __x) 
# 533
{ return __builtin_tanh(__x); } 
# 536
}
# 555
namespace std __attribute((__visibility__("default"))) { 
# 831
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 834
fpclassify(_Tp __f) 
# 835
{ 
# 836
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 837
return __builtin_fpclassify(0, 1, 4, 3, 2, (__type)__f); 
# 839
} 
# 841
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 844
isfinite(_Tp __f) 
# 845
{ 
# 846
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 847
return __builtin_isfinite((__type)__f); 
# 848
} 
# 850
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 853
isinf(_Tp __f) 
# 854
{ 
# 855
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 856
return __builtin_isinf((__type)__f); 
# 857
} 
# 859
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 862
isnan(_Tp __f) 
# 863
{ 
# 864
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 865
return __builtin_isnan((__type)__f); 
# 866
} 
# 868
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 871
isnormal(_Tp __f) 
# 872
{ 
# 873
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 874
return __builtin_isnormal((__type)__f); 
# 875
} 
# 877
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 880
signbit(_Tp __f) 
# 881
{ 
# 882
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 883
return (sizeof(__type) == sizeof(float)) ? __builtin_signbitf((__type)__f) : ((sizeof(__type) == sizeof(double)) ? __builtin_signbit((__type)__f) : __builtin_signbitl((__type)__f)); 
# 888
} 
# 890
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 893
isgreater(_Tp __f1, _Tp __f2) 
# 894
{ 
# 895
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 896
return __builtin_isgreater((__type)__f1, (__type)__f2); 
# 897
} 
# 899
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 902
isgreaterequal(_Tp __f1, _Tp __f2) 
# 903
{ 
# 904
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 905
return __builtin_isgreaterequal((__type)__f1, (__type)__f2); 
# 906
} 
# 908
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 911
isless(_Tp __f1, _Tp __f2) 
# 912
{ 
# 913
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 914
return __builtin_isless((__type)__f1, (__type)__f2); 
# 915
} 
# 917
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 920
islessequal(_Tp __f1, _Tp __f2) 
# 921
{ 
# 922
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 923
return __builtin_islessequal((__type)__f1, (__type)__f2); 
# 924
} 
# 926
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 929
islessgreater(_Tp __f1, _Tp __f2) 
# 930
{ 
# 931
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 932
return __builtin_islessgreater((__type)__f1, (__type)__f2); 
# 933
} 
# 935
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value, int> ::__type 
# 938
isunordered(_Tp __f1, _Tp __f2) 
# 939
{ 
# 940
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 941
return __builtin_isunordered((__type)__f1, (__type)__f2); 
# 942
} 
# 947
}
# 114 "/usr/include/c++/5/cstdlib" 3
namespace std __attribute((__visibility__("default"))) { 
# 118
using ::div_t;
# 119
using ::ldiv_t;
# 121
using ::abort;
# 122
using ::abs;
# 123
using ::atexit;
# 129
using ::atof;
# 130
using ::atoi;
# 131
using ::atol;
# 132
using ::bsearch;
# 133
using ::calloc;
# 134
using ::div;
# 135
using ::exit;
# 136
using ::free;
# 137
using ::getenv;
# 138
using ::labs;
# 139
using ::ldiv;
# 140
using ::malloc;
# 142
using ::mblen;
# 143
using ::mbstowcs;
# 144
using ::mbtowc;
# 146
using ::qsort;
# 152
using ::rand;
# 153
using ::realloc;
# 154
using ::srand;
# 155
using ::strtod;
# 156
using ::strtol;
# 157
using ::strtoul;
# 158
using ::system;
# 160
using ::wcstombs;
# 161
using ::wctomb;
# 166
inline long abs(long __i) { return __builtin_labs(__i); } 
# 169
inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 
# 174
inline long long abs(long long __x) { return __builtin_llabs(__x); } 
# 179
inline __int128_t abs(__int128_t __x) { return (__x >= (0)) ? __x : (-__x); } 
# 196
}
# 209
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 214
using ::lldiv_t;
# 220
using ::_Exit;
# 224
using ::llabs;
# 227
inline lldiv_t div(long long __n, long long __d) 
# 228
{ lldiv_t __q; (__q.quot) = (__n / __d); (__q.rem) = (__n % __d); return __q; } 
# 230
using ::lldiv;
# 241
using ::atoll;
# 242
using ::strtoll;
# 243
using ::strtoull;
# 245
using ::strtof;
# 246
using ::strtold;
# 249
}
# 251
namespace std { 
# 254
using __gnu_cxx::lldiv_t;
# 256
using __gnu_cxx::_Exit;
# 258
using __gnu_cxx::llabs;
# 259
using __gnu_cxx::div;
# 260
using __gnu_cxx::lldiv;
# 262
using __gnu_cxx::atoll;
# 263
using __gnu_cxx::strtof;
# 264
using __gnu_cxx::strtoll;
# 265
using __gnu_cxx::strtoull;
# 266
using __gnu_cxx::strtold;
# 267
}
# 8925 "/usr/local/cuda/include/math_functions.h"
__attribute((always_inline)) inline int signbit(float x); 
# 8929
__attribute((always_inline)) inline int signbit(double x); 
# 8931
__attribute((always_inline)) inline int signbit(long double x); 
# 8933
__attribute((always_inline)) inline int isfinite(float x); 
# 8937
__attribute((always_inline)) inline int isfinite(double x); 
# 8939
__attribute((always_inline)) inline int isfinite(long double x); 
# 8941
__attribute((always_inline)) inline int isnan(float x); 
# 8945
extern "C" __attribute((always_inline)) inline int isnan(double x) throw(); 
# 8947
__attribute((always_inline)) inline int isnan(long double x); 
# 8949
__attribute((always_inline)) inline int isinf(float x); 
# 8953
extern "C" __attribute((always_inline)) inline int isinf(double x) throw(); 
# 8955
__attribute((always_inline)) inline int isinf(long double x); 
# 9002
namespace std { 
# 9004
template< class T> extern T __pow_helper(T, int); 
# 9005
template< class T> extern T __cmath_power(T, unsigned); 
# 9006
}
# 9008
using std::abs;
# 9009
using std::fabs;
# 9010
using std::ceil;
# 9011
using std::floor;
# 9012
using std::sqrt;
# 9013
using std::pow;
# 9014
using std::log;
# 9015
using std::log10;
# 9016
using std::fmod;
# 9017
using std::modf;
# 9018
using std::exp;
# 9019
using std::frexp;
# 9020
using std::ldexp;
# 9021
using std::asin;
# 9022
using std::sin;
# 9023
using std::sinh;
# 9024
using std::acos;
# 9025
using std::cos;
# 9026
using std::cosh;
# 9027
using std::atan;
# 9028
using std::atan2;
# 9029
using std::tan;
# 9030
using std::tanh;
# 9393
namespace std { 
# 9406
extern inline long long abs(long long); 
# 9412
extern inline long abs(long); 
# 9413
extern inline float abs(float); 
# 9414
extern inline double abs(double); 
# 9415
extern inline float fabs(float); 
# 9416
extern inline float ceil(float); 
# 9417
extern inline float floor(float); 
# 9418
extern inline float sqrt(float); 
# 9419
extern inline float pow(float, float); 
# 9428
extern inline float pow(float, int); 
# 9429
extern inline double pow(double, int); 
# 9434
extern inline float log(float); 
# 9435
extern inline float log10(float); 
# 9436
extern inline float fmod(float, float); 
# 9437
extern inline float modf(float, float *); 
# 9438
extern inline float exp(float); 
# 9439
extern inline float frexp(float, int *); 
# 9440
extern inline float ldexp(float, int); 
# 9441
extern inline float asin(float); 
# 9442
extern inline float sin(float); 
# 9443
extern inline float sinh(float); 
# 9444
extern inline float acos(float); 
# 9445
extern inline float cos(float); 
# 9446
extern inline float cosh(float); 
# 9447
extern inline float atan(float); 
# 9448
extern inline float atan2(float, float); 
# 9449
extern inline float tan(float); 
# 9450
extern inline float tanh(float); 
# 9518
}
# 9609
static inline float logb(float a); 
# 9611
static inline int ilogb(float a); 
# 9613
static inline float scalbn(float a, int b); 
# 9615
static inline float scalbln(float a, long b); 
# 9617
static inline float exp2(float a); 
# 9619
static inline float expm1(float a); 
# 9621
static inline float log2(float a); 
# 9623
static inline float log1p(float a); 
# 9625
static inline float acosh(float a); 
# 9627
static inline float asinh(float a); 
# 9629
static inline float atanh(float a); 
# 9631
static inline float hypot(float a, float b); 
# 9633
static inline float norm3d(float a, float b, float c); 
# 9635
static inline float norm4d(float a, float b, float c, float d); 
# 9637
static inline float cbrt(float a); 
# 9639
static inline float erf(float a); 
# 9641
static inline float erfc(float a); 
# 9643
static inline float lgamma(float a); 
# 9645
static inline float tgamma(float a); 
# 9647
static inline float copysign(float a, float b); 
# 9649
static inline float nextafter(float a, float b); 
# 9651
static inline float remainder(float a, float b); 
# 9653
static inline float remquo(float a, float b, int * quo); 
# 9655
static inline float round(float a); 
# 9657
static inline long lround(float a); 
# 9659
static inline long long llround(float a); 
# 9661
static inline float trunc(float a); 
# 9663
static inline float rint(float a); 
# 9665
static inline long lrint(float a); 
# 9667
static inline long long llrint(float a); 
# 9669
static inline float nearbyint(float a); 
# 9671
static inline float fdim(float a, float b); 
# 9673
static inline float fma(float a, float b, float c); 
# 9675
static inline float fmax(float a, float b); 
# 9677
static inline float fmin(float a, float b); 
# 9718
static inline float exp10(float a); 
# 9720
static inline float rsqrt(float a); 
# 9722
static inline float rcbrt(float a); 
# 9724
static inline float sinpi(float a); 
# 9726
static inline float cospi(float a); 
# 9728
static inline void sincospi(float a, float * sptr, float * cptr); 
# 9730
static inline void sincos(float a, float * sptr, float * cptr); 
# 9732
static inline float j0(float a); 
# 9734
static inline float j1(float a); 
# 9736
static inline float jn(int n, float a); 
# 9738
static inline float y0(float a); 
# 9740
static inline float y1(float a); 
# 9742
static inline float yn(int n, float a); 
# 9744
static inline float cyl_bessel_i0(float a); 
# 9746
static inline float cyl_bessel_i1(float a); 
# 9748
static inline float erfinv(float a); 
# 9750
static inline float erfcinv(float a); 
# 9752
static inline float normcdfinv(float a); 
# 9754
static inline float normcdf(float a); 
# 9756
static inline float erfcx(float a); 
# 9758
static inline double copysign(double a, float b); 
# 9760
static inline float copysign(float a, double b); 
# 9762
static inline unsigned min(unsigned a, unsigned b); 
# 9764
static inline unsigned min(int a, unsigned b); 
# 9766
static inline unsigned min(unsigned a, int b); 
# 9768
static inline long min(long a, long b); 
# 9770
static inline unsigned long min(unsigned long a, unsigned long b); 
# 9772
static inline unsigned long min(long a, unsigned long b); 
# 9774
static inline unsigned long min(unsigned long a, long b); 
# 9776
static inline long long min(long long a, long long b); 
# 9778
static inline unsigned long long min(unsigned long long a, unsigned long long b); 
# 9780
static inline unsigned long long min(long long a, unsigned long long b); 
# 9782
static inline unsigned long long min(unsigned long long a, long long b); 
# 9784
static inline float min(float a, float b); 
# 9786
static inline double min(double a, double b); 
# 9788
static inline double min(float a, double b); 
# 9790
static inline double min(double a, float b); 
# 9792
static inline unsigned max(unsigned a, unsigned b); 
# 9794
static inline unsigned max(int a, unsigned b); 
# 9796
static inline unsigned max(unsigned a, int b); 
# 9798
static inline long max(long a, long b); 
# 9800
static inline unsigned long max(unsigned long a, unsigned long b); 
# 9802
static inline unsigned long max(long a, unsigned long b); 
# 9804
static inline unsigned long max(unsigned long a, long b); 
# 9806
static inline long long max(long long a, long long b); 
# 9808
static inline unsigned long long max(unsigned long long a, unsigned long long b); 
# 9810
static inline unsigned long long max(long long a, unsigned long long b); 
# 9812
static inline unsigned long long max(unsigned long long a, long long b); 
# 9814
static inline float max(float a, float b); 
# 9816
static inline double max(double a, double b); 
# 9818
static inline double max(float a, double b); 
# 9820
static inline double max(double a, float b); 
# 248 "/usr/local/cuda/include/math_functions.hpp"
__attribute((always_inline)) inline int signbit(float x) { return __signbitf(x); } 
# 252
__attribute((always_inline)) inline int signbit(double x) { return __signbit(x); } 
# 254
__attribute((always_inline)) inline int signbit(long double x) { return __signbitl(x); } 
# 265
__attribute((always_inline)) inline int isfinite(float x) { return __finitef(x); } 
# 280
__attribute((always_inline)) inline int isfinite(double x) { return __finite(x); } 
# 293
__attribute((always_inline)) inline int isfinite(long double x) { return __finitel(x); } 
# 296
__attribute((always_inline)) inline int isnan(float x) { return __isnanf(x); } 
# 300
extern "C" __attribute((always_inline)) inline int isnan(double x) throw() { return __isnan(x); } 
# 302
__attribute((always_inline)) inline int isnan(long double x) { return __isnanl(x); } 
# 304
__attribute((always_inline)) inline int isinf(float x) { return __isinff(x); } 
# 308
extern "C" __attribute((always_inline)) inline int isinf(double x) throw() { return __isinf(x); } 
# 310
__attribute((always_inline)) inline int isinf(long double x) { return __isinfl(x); } 
# 503
static inline float logb(float a) 
# 504
{ 
# 505
return logbf(a); 
# 506
} 
# 508
static inline int ilogb(float a) 
# 509
{ 
# 510
return ilogbf(a); 
# 511
} 
# 513
static inline float scalbn(float a, int b) 
# 514
{ 
# 515
return scalbnf(a, b); 
# 516
} 
# 518
static inline float scalbln(float a, long b) 
# 519
{ 
# 520
return scalblnf(a, b); 
# 521
} 
# 523
static inline float exp2(float a) 
# 524
{ 
# 525
return exp2f(a); 
# 526
} 
# 528
static inline float expm1(float a) 
# 529
{ 
# 530
return expm1f(a); 
# 531
} 
# 533
static inline float log2(float a) 
# 534
{ 
# 535
return log2f(a); 
# 536
} 
# 538
static inline float log1p(float a) 
# 539
{ 
# 540
return log1pf(a); 
# 541
} 
# 543
static inline float acosh(float a) 
# 544
{ 
# 545
return acoshf(a); 
# 546
} 
# 548
static inline float asinh(float a) 
# 549
{ 
# 550
return asinhf(a); 
# 551
} 
# 553
static inline float atanh(float a) 
# 554
{ 
# 555
return atanhf(a); 
# 556
} 
# 558
static inline float hypot(float a, float b) 
# 559
{ 
# 560
return hypotf(a, b); 
# 561
} 
# 563
static inline float norm3d(float a, float b, float c) 
# 564
{ 
# 565
return norm3df(a, b, c); 
# 566
} 
# 568
static inline float norm4d(float a, float b, float c, float d) 
# 569
{ 
# 570
return norm4df(a, b, c, d); 
# 571
} 
# 573
static inline float cbrt(float a) 
# 574
{ 
# 575
return cbrtf(a); 
# 576
} 
# 578
static inline float erf(float a) 
# 579
{ 
# 580
return erff(a); 
# 581
} 
# 583
static inline float erfc(float a) 
# 584
{ 
# 585
return erfcf(a); 
# 586
} 
# 588
static inline float lgamma(float a) 
# 589
{ 
# 590
return lgammaf(a); 
# 591
} 
# 593
static inline float tgamma(float a) 
# 594
{ 
# 595
return tgammaf(a); 
# 596
} 
# 598
static inline float copysign(float a, float b) 
# 599
{ 
# 600
return copysignf(a, b); 
# 601
} 
# 603
static inline float nextafter(float a, float b) 
# 604
{ 
# 605
return nextafterf(a, b); 
# 606
} 
# 608
static inline float remainder(float a, float b) 
# 609
{ 
# 610
return remainderf(a, b); 
# 611
} 
# 613
static inline float remquo(float a, float b, int *quo) 
# 614
{ 
# 615
return remquof(a, b, quo); 
# 616
} 
# 618
static inline float round(float a) 
# 619
{ 
# 620
return roundf(a); 
# 621
} 
# 623
static inline long lround(float a) 
# 624
{ 
# 625
return lroundf(a); 
# 626
} 
# 628
static inline long long llround(float a) 
# 629
{ 
# 630
return llroundf(a); 
# 631
} 
# 633
static inline float trunc(float a) 
# 634
{ 
# 635
return truncf(a); 
# 636
} 
# 638
static inline float rint(float a) 
# 639
{ 
# 640
return rintf(a); 
# 641
} 
# 643
static inline long lrint(float a) 
# 644
{ 
# 645
return lrintf(a); 
# 646
} 
# 648
static inline long long llrint(float a) 
# 649
{ 
# 650
return llrintf(a); 
# 651
} 
# 653
static inline float nearbyint(float a) 
# 654
{ 
# 655
return nearbyintf(a); 
# 656
} 
# 658
static inline float fdim(float a, float b) 
# 659
{ 
# 660
return fdimf(a, b); 
# 661
} 
# 663
static inline float fma(float a, float b, float c) 
# 664
{ 
# 665
return fmaf(a, b, c); 
# 666
} 
# 668
static inline float fmax(float a, float b) 
# 669
{ 
# 670
return fmaxf(a, b); 
# 671
} 
# 673
static inline float fmin(float a, float b) 
# 674
{ 
# 675
return fminf(a, b); 
# 676
} 
# 681
static inline float exp10(float a) 
# 682
{ 
# 683
return exp10f(a); 
# 684
} 
# 686
static inline float rsqrt(float a) 
# 687
{ 
# 688
return rsqrtf(a); 
# 689
} 
# 691
static inline float rcbrt(float a) 
# 692
{ 
# 693
return rcbrtf(a); 
# 694
} 
# 696
static inline float sinpi(float a) 
# 697
{ 
# 698
return sinpif(a); 
# 699
} 
# 701
static inline float cospi(float a) 
# 702
{ 
# 703
return cospif(a); 
# 704
} 
# 706
static inline void sincospi(float a, float *sptr, float *cptr) 
# 707
{ 
# 708
sincospif(a, sptr, cptr); 
# 709
} 
# 711
static inline void sincos(float a, float *sptr, float *cptr) 
# 712
{ 
# 713
sincosf(a, sptr, cptr); 
# 714
} 
# 716
static inline float j0(float a) 
# 717
{ 
# 718
return j0f(a); 
# 719
} 
# 721
static inline float j1(float a) 
# 722
{ 
# 723
return j1f(a); 
# 724
} 
# 726
static inline float jn(int n, float a) 
# 727
{ 
# 728
return jnf(n, a); 
# 729
} 
# 731
static inline float y0(float a) 
# 732
{ 
# 733
return y0f(a); 
# 734
} 
# 736
static inline float y1(float a) 
# 737
{ 
# 738
return y1f(a); 
# 739
} 
# 741
static inline float yn(int n, float a) 
# 742
{ 
# 743
return ynf(n, a); 
# 744
} 
# 746
static inline float cyl_bessel_i0(float a) 
# 747
{ 
# 748
return cyl_bessel_i0f(a); 
# 749
} 
# 751
static inline float cyl_bessel_i1(float a) 
# 752
{ 
# 753
return cyl_bessel_i1f(a); 
# 754
} 
# 756
static inline float erfinv(float a) 
# 757
{ 
# 758
return erfinvf(a); 
# 759
} 
# 761
static inline float erfcinv(float a) 
# 762
{ 
# 763
return erfcinvf(a); 
# 764
} 
# 766
static inline float normcdfinv(float a) 
# 767
{ 
# 768
return normcdfinvf(a); 
# 769
} 
# 771
static inline float normcdf(float a) 
# 772
{ 
# 773
return normcdff(a); 
# 774
} 
# 776
static inline float erfcx(float a) 
# 777
{ 
# 778
return erfcxf(a); 
# 779
} 
# 781
static inline double copysign(double a, float b) 
# 782
{ 
# 783
return copysign(a, (double)b); 
# 784
} 
# 786
static inline float copysign(float a, double b) 
# 787
{ 
# 788
return copysignf(a, (float)b); 
# 789
} 
# 791
static inline unsigned min(unsigned a, unsigned b) 
# 792
{ 
# 793
return umin(a, b); 
# 794
} 
# 796
static inline unsigned min(int a, unsigned b) 
# 797
{ 
# 798
return umin((unsigned)a, b); 
# 799
} 
# 801
static inline unsigned min(unsigned a, int b) 
# 802
{ 
# 803
return umin(a, (unsigned)b); 
# 804
} 
# 806
static inline long min(long a, long b) 
# 807
{ 
# 813
if (sizeof(long) == sizeof(int)) { 
# 817
return (long)min((int)a, (int)b); 
# 818
} else { 
# 819
return (long)llmin((long long)a, (long long)b); 
# 820
}  
# 821
} 
# 823
static inline unsigned long min(unsigned long a, unsigned long b) 
# 824
{ 
# 828
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 832
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 833
} else { 
# 834
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 835
}  
# 836
} 
# 838
static inline unsigned long min(long a, unsigned long b) 
# 839
{ 
# 843
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 847
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 848
} else { 
# 849
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 850
}  
# 851
} 
# 853
static inline unsigned long min(unsigned long a, long b) 
# 854
{ 
# 858
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 862
return (unsigned long)umin((unsigned)a, (unsigned)b); 
# 863
} else { 
# 864
return (unsigned long)ullmin((unsigned long long)a, (unsigned long long)b); 
# 865
}  
# 866
} 
# 868
static inline long long min(long long a, long long b) 
# 869
{ 
# 870
return llmin(a, b); 
# 871
} 
# 873
static inline unsigned long long min(unsigned long long a, unsigned long long b) 
# 874
{ 
# 875
return ullmin(a, b); 
# 876
} 
# 878
static inline unsigned long long min(long long a, unsigned long long b) 
# 879
{ 
# 880
return ullmin((unsigned long long)a, b); 
# 881
} 
# 883
static inline unsigned long long min(unsigned long long a, long long b) 
# 884
{ 
# 885
return ullmin(a, (unsigned long long)b); 
# 886
} 
# 888
static inline float min(float a, float b) 
# 889
{ 
# 890
return fminf(a, b); 
# 891
} 
# 893
static inline double min(double a, double b) 
# 894
{ 
# 895
return fmin(a, b); 
# 896
} 
# 898
static inline double min(float a, double b) 
# 899
{ 
# 900
return fmin((double)a, b); 
# 901
} 
# 903
static inline double min(double a, float b) 
# 904
{ 
# 905
return fmin(a, (double)b); 
# 906
} 
# 908
static inline unsigned max(unsigned a, unsigned b) 
# 909
{ 
# 910
return umax(a, b); 
# 911
} 
# 913
static inline unsigned max(int a, unsigned b) 
# 914
{ 
# 915
return umax((unsigned)a, b); 
# 916
} 
# 918
static inline unsigned max(unsigned a, int b) 
# 919
{ 
# 920
return umax(a, (unsigned)b); 
# 921
} 
# 923
static inline long max(long a, long b) 
# 924
{ 
# 929
if (sizeof(long) == sizeof(int)) { 
# 933
return (long)max((int)a, (int)b); 
# 934
} else { 
# 935
return (long)llmax((long long)a, (long long)b); 
# 936
}  
# 937
} 
# 939
static inline unsigned long max(unsigned long a, unsigned long b) 
# 940
{ 
# 944
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 948
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 949
} else { 
# 950
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 951
}  
# 952
} 
# 954
static inline unsigned long max(long a, unsigned long b) 
# 955
{ 
# 959
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 963
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 964
} else { 
# 965
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 966
}  
# 967
} 
# 969
static inline unsigned long max(unsigned long a, long b) 
# 970
{ 
# 974
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 978
return (unsigned long)umax((unsigned)a, (unsigned)b); 
# 979
} else { 
# 980
return (unsigned long)ullmax((unsigned long long)a, (unsigned long long)b); 
# 981
}  
# 982
} 
# 984
static inline long long max(long long a, long long b) 
# 985
{ 
# 986
return llmax(a, b); 
# 987
} 
# 989
static inline unsigned long long max(unsigned long long a, unsigned long long b) 
# 990
{ 
# 991
return ullmax(a, b); 
# 992
} 
# 994
static inline unsigned long long max(long long a, unsigned long long b) 
# 995
{ 
# 996
return ullmax((unsigned long long)a, b); 
# 997
} 
# 999
static inline unsigned long long max(unsigned long long a, long long b) 
# 1000
{ 
# 1001
return ullmax(a, (unsigned long long)b); 
# 1002
} 
# 1004
static inline float max(float a, float b) 
# 1005
{ 
# 1006
return fmaxf(a, b); 
# 1007
} 
# 1009
static inline double max(double a, double b) 
# 1010
{ 
# 1011
return fmax(a, b); 
# 1012
} 
# 1014
static inline double max(float a, double b) 
# 1015
{ 
# 1016
return fmax((double)a, b); 
# 1017
} 
# 1019
static inline double max(double a, float b) 
# 1020
{ 
# 1021
return fmax(a, (double)b); 
# 1022
} 
# 1033
extern "C" inline int min(int a, int b) 
# 1034
{ 
# 1035
return (a < b) ? a : b; 
# 1036
} 
# 1038
extern "C" inline unsigned umin(unsigned a, unsigned b) 
# 1039
{ 
# 1040
return (a < b) ? a : b; 
# 1041
} 
# 1043
extern "C" inline long long llmin(long long a, long long b) 
# 1044
{ 
# 1045
return (a < b) ? a : b; 
# 1046
} 
# 1048
extern "C" inline unsigned long long ullmin(unsigned long long a, unsigned long long 
# 1049
b) 
# 1050
{ 
# 1051
return (a < b) ? a : b; 
# 1052
} 
# 1054
extern "C" inline int max(int a, int b) 
# 1055
{ 
# 1056
return (a > b) ? a : b; 
# 1057
} 
# 1059
extern "C" inline unsigned umax(unsigned a, unsigned b) 
# 1060
{ 
# 1061
return (a > b) ? a : b; 
# 1062
} 
# 1064
extern "C" inline long long llmax(long long a, long long b) 
# 1065
{ 
# 1066
return (a > b) ? a : b; 
# 1067
} 
# 1069
extern "C" inline unsigned long long ullmax(unsigned long long a, unsigned long long 
# 1070
b) 
# 1071
{ 
# 1072
return (a > b) ? a : b; 
# 1073
} 
# 77 "/usr/local/cuda/include/cuda_surface_types.h"
template< class T, int dim = 1> 
# 78
struct surface : public surfaceReference { 
# 81
surface() 
# 82
{ 
# 83
(surfaceReference::channelDesc) = cudaCreateChannelDesc< T> (); 
# 84
} 
# 86
surface(cudaChannelFormatDesc desc) 
# 87
{ 
# 88
(surfaceReference::channelDesc) = desc; 
# 89
} 
# 91
}; 
# 93
template< int dim> 
# 94
struct surface< void, dim>  : public surfaceReference { 
# 97
surface() 
# 98
{ 
# 99
(surfaceReference::channelDesc) = cudaCreateChannelDesc< void> (); 
# 100
} 
# 102
}; 
# 77 "/usr/local/cuda/include/cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
# 78
struct texture : public textureReference { 
# 81
texture(int norm = 0, cudaTextureFilterMode 
# 82
fMode = cudaFilterModePoint, cudaTextureAddressMode 
# 83
aMode = cudaAddressModeClamp) 
# 84
{ 
# 85
(textureReference::normalized) = norm; 
# 86
(textureReference::filterMode) = fMode; 
# 87
((textureReference::addressMode)[0]) = aMode; 
# 88
((textureReference::addressMode)[1]) = aMode; 
# 89
((textureReference::addressMode)[2]) = aMode; 
# 90
(textureReference::channelDesc) = cudaCreateChannelDesc< T> (); 
# 91
(textureReference::sRGB) = 0; 
# 92
} 
# 94
texture(int norm, cudaTextureFilterMode 
# 95
fMode, cudaTextureAddressMode 
# 96
aMode, cudaChannelFormatDesc 
# 97
desc) 
# 98
{ 
# 99
(textureReference::normalized) = norm; 
# 100
(textureReference::filterMode) = fMode; 
# 101
((textureReference::addressMode)[0]) = aMode; 
# 102
((textureReference::addressMode)[1]) = aMode; 
# 103
((textureReference::addressMode)[2]) = aMode; 
# 104
(textureReference::channelDesc) = desc; 
# 105
(textureReference::sRGB) = 0; 
# 106
} 
# 108
}; 
# 90 "/usr/local/cuda/include/device_functions.h"
extern "C" {
# 3230
}
# 3238
__attribute__((unused)) static inline int mulhi(int a, int b); 
# 3240
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b); 
# 3242
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b); 
# 3244
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b); 
# 3246
__attribute__((unused)) static inline long long mul64hi(long long a, long long b); 
# 3248
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b); 
# 3250
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b); 
# 3252
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b); 
# 3254
__attribute__((unused)) static inline int float_as_int(float a); 
# 3256
__attribute__((unused)) static inline float int_as_float(int a); 
# 3258
__attribute__((unused)) static inline unsigned float_as_uint(float a); 
# 3260
__attribute__((unused)) static inline float uint_as_float(unsigned a); 
# 3262
__attribute__((unused)) static inline float saturate(float a); 
# 3264
__attribute__((unused)) static inline int mul24(int a, int b); 
# 3266
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b); 
# 3268
__attribute((deprecated("Please use __trap() instead."))) __attribute__((unused)) static inline void trap(); 
# 3271
__attribute((deprecated("Please use __brkpt() instead."))) __attribute__((unused)) static inline void brkpt(int c = 0); 
# 3273
__attribute((deprecated("Please use __syncthreads() instead."))) __attribute__((unused)) static inline void syncthreads(); 
# 3275
__attribute((deprecated("Please use __prof_trigger() instead."))) __attribute__((unused)) static inline void prof_trigger(int e); 
# 3277
__attribute((deprecated("Please use __threadfence() instead."))) __attribute__((unused)) static inline void threadfence(bool global = true); 
# 3279
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
# 3281
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
# 3283
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
# 3285
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 83 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline int mulhi(int a, int b) 
# 84
{int volatile ___ = 1;(void)a;(void)b;
# 86
::exit(___);}
#if 0
# 84
{ 
# 85
return __mulhi(a, b); 
# 86
} 
#endif
# 88 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, unsigned b) 
# 89
{int volatile ___ = 1;(void)a;(void)b;
# 91
::exit(___);}
#if 0
# 89
{ 
# 90
return __umulhi(a, b); 
# 91
} 
#endif
# 93 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(int a, unsigned b) 
# 94
{int volatile ___ = 1;(void)a;(void)b;
# 96
::exit(___);}
#if 0
# 94
{ 
# 95
return __umulhi((unsigned)a, b); 
# 96
} 
#endif
# 98 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(unsigned a, int b) 
# 99
{int volatile ___ = 1;(void)a;(void)b;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return __umulhi(a, (unsigned)b); 
# 101
} 
#endif
# 103 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline long long mul64hi(long long a, long long b) 
# 104
{int volatile ___ = 1;(void)a;(void)b;
# 106
::exit(___);}
#if 0
# 104
{ 
# 105
return __mul64hi(a, b); 
# 106
} 
#endif
# 108 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, unsigned long long b) 
# 109
{int volatile ___ = 1;(void)a;(void)b;
# 111
::exit(___);}
#if 0
# 109
{ 
# 110
return __umul64hi(a, b); 
# 111
} 
#endif
# 113 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(long long a, unsigned long long b) 
# 114
{int volatile ___ = 1;(void)a;(void)b;
# 116
::exit(___);}
#if 0
# 114
{ 
# 115
return __umul64hi((unsigned long long)a, b); 
# 116
} 
#endif
# 118 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(unsigned long long a, long long b) 
# 119
{int volatile ___ = 1;(void)a;(void)b;
# 121
::exit(___);}
#if 0
# 119
{ 
# 120
return __umul64hi(a, (unsigned long long)b); 
# 121
} 
#endif
# 123 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline int float_as_int(float a) 
# 124
{int volatile ___ = 1;(void)a;
# 126
::exit(___);}
#if 0
# 124
{ 
# 125
return __float_as_int(a); 
# 126
} 
#endif
# 128 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline float int_as_float(int a) 
# 129
{int volatile ___ = 1;(void)a;
# 131
::exit(___);}
#if 0
# 129
{ 
# 130
return __int_as_float(a); 
# 131
} 
#endif
# 133 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned float_as_uint(float a) 
# 134
{int volatile ___ = 1;(void)a;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
return __float_as_uint(a); 
# 136
} 
#endif
# 138 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline float uint_as_float(unsigned a) 
# 139
{int volatile ___ = 1;(void)a;
# 141
::exit(___);}
#if 0
# 139
{ 
# 140
return __uint_as_float(a); 
# 141
} 
#endif
# 142 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline float saturate(float a) 
# 143
{int volatile ___ = 1;(void)a;
# 145
::exit(___);}
#if 0
# 143
{ 
# 144
return __saturatef(a); 
# 145
} 
#endif
# 147 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline int mul24(int a, int b) 
# 148
{int volatile ___ = 1;(void)a;(void)b;
# 150
::exit(___);}
#if 0
# 148
{ 
# 149
return __mul24(a, b); 
# 150
} 
#endif
# 152 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned umul24(unsigned a, unsigned b) 
# 153
{int volatile ___ = 1;(void)a;(void)b;
# 155
::exit(___);}
#if 0
# 153
{ 
# 154
return __umul24(a, b); 
# 155
} 
#endif
# 157 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline void trap() 
# 158
{int volatile ___ = 1;
# 160
::exit(___);}
#if 0
# 158
{ 
# 159
__trap(); 
# 160
} 
#endif
# 163 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline void brkpt(int c) 
# 164
{int volatile ___ = 1;(void)c;
# 166
::exit(___);}
#if 0
# 164
{ 
# 165
__brkpt(c); 
# 166
} 
#endif
# 168 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline void syncthreads() 
# 169
{int volatile ___ = 1;
# 171
::exit(___);}
#if 0
# 169
{ 
# 170
__syncthreads(); 
# 171
} 
#endif
# 173 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline void prof_trigger(int e) 
# 174
{int volatile ___ = 1;(void)e;
# 191
::exit(___);}
#if 0
# 174
{ 
# 175
if (e == 0) { __prof_trigger(0); } else { 
# 176
if (e == 1) { __prof_trigger(1); } else { 
# 177
if (e == 2) { __prof_trigger(2); } else { 
# 178
if (e == 3) { __prof_trigger(3); } else { 
# 179
if (e == 4) { __prof_trigger(4); } else { 
# 180
if (e == 5) { __prof_trigger(5); } else { 
# 181
if (e == 6) { __prof_trigger(6); } else { 
# 182
if (e == 7) { __prof_trigger(7); } else { 
# 183
if (e == 8) { __prof_trigger(8); } else { 
# 184
if (e == 9) { __prof_trigger(9); } else { 
# 185
if (e == 10) { __prof_trigger(10); } else { 
# 186
if (e == 11) { __prof_trigger(11); } else { 
# 187
if (e == 12) { __prof_trigger(12); } else { 
# 188
if (e == 13) { __prof_trigger(13); } else { 
# 189
if (e == 14) { __prof_trigger(14); } else { 
# 190
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
# 191
} 
#endif
# 193 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline void threadfence(bool global) 
# 194
{int volatile ___ = 1;(void)global;
# 196
::exit(___);}
#if 0
# 194
{ 
# 195
global ? __threadfence() : __threadfence_block(); 
# 196
} 
#endif
# 198 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline int float2int(float a, cudaRoundMode mode) 
# 199
{int volatile ___ = 1;(void)a;(void)mode;
# 204
::exit(___);}
#if 0
# 199
{ 
# 200
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
# 204
} 
#endif
# 206 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline unsigned float2uint(float a, cudaRoundMode mode) 
# 207
{int volatile ___ = 1;(void)a;(void)mode;
# 212
::exit(___);}
#if 0
# 207
{ 
# 208
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
# 212
} 
#endif
# 214 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline float int2float(int a, cudaRoundMode mode) 
# 215
{int volatile ___ = 1;(void)a;(void)mode;
# 220
::exit(___);}
#if 0
# 215
{ 
# 216
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
# 220
} 
#endif
# 222 "/usr/local/cuda/include/device_functions.hpp"
__attribute__((unused)) static inline float uint2float(unsigned a, cudaRoundMode mode) 
# 223
{int volatile ___ = 1;(void)a;(void)mode;
# 228
::exit(___);}
#if 0
# 223
{ 
# 224
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
# 228
} 
#endif
# 111 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 111
{ } 
#endif
# 113 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 113
{ } 
#endif
# 115 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 117
{ } 
#endif
# 119 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 119
{ } 
#endif
# 121 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 121
{ } 
#endif
# 123 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 123
{ } 
#endif
# 125 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 125
{ } 
#endif
# 127 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 127
{ } 
#endif
# 129 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 129
{ } 
#endif
# 131 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 131
{ } 
#endif
# 133 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 133
{ } 
#endif
# 135 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 135
{ } 
#endif
# 137 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 137
{ } 
#endif
# 139 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 139
{ } 
#endif
# 141 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 141
{ } 
#endif
# 143 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 143
{ } 
#endif
# 145 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 145
{ } 
#endif
# 147 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 147
{ } 
#endif
# 149 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 149
{ } 
#endif
# 151 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 151
{ } 
#endif
# 164 "/usr/local/cuda/include/device_atomic_functions.h"
extern "C" {
# 175
}
# 185
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 185
{ } 
#endif
# 187 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 187
{ } 
#endif
# 189 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long *address, unsigned long long compare, unsigned long long val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 189
{ } 
#endif
# 191 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 191
{ } 
#endif
# 193 "/usr/local/cuda/include/device_atomic_functions.h"
__attribute__((unused)) static inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 193
{ } 
#endif
# 80 "/usr/local/cuda/include/device_double_functions.h"
extern "C" {
# 1134
}
# 1143
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode); 
# 1145
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1147
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1149
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1151
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
# 1153
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
# 1155
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
# 1157
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
# 1159
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1161
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1163
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
# 1165
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 1167
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
# 85 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode) 
# 86
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
# 91
::exit(___);}
#if 0
# 86
{ 
# 87
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
# 91
} 
#endif
# 93 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode) 
# 94
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 99
::exit(___);}
#if 0
# 94
{ 
# 95
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
# 99
} 
#endif
# 101 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode) 
# 102
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 107
::exit(___);}
#if 0
# 102
{ 
# 103
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
# 107
} 
#endif
# 109 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode) 
# 110
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 115
::exit(___);}
#if 0
# 110
{ 
# 111
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
# 115
} 
#endif
# 117 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode) 
# 118
{int volatile ___ = 1;(void)a;(void)mode;
# 123
::exit(___);}
#if 0
# 118
{ 
# 119
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
# 123
} 
#endif
# 125 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode) 
# 126
{int volatile ___ = 1;(void)a;(void)mode;
# 131
::exit(___);}
#if 0
# 126
{ 
# 127
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
# 131
} 
#endif
# 133 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode) 
# 134
{int volatile ___ = 1;(void)a;(void)mode;
# 139
::exit(___);}
#if 0
# 134
{ 
# 135
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
# 139
} 
#endif
# 141 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode) 
# 142
{int volatile ___ = 1;(void)a;(void)mode;
# 147
::exit(___);}
#if 0
# 142
{ 
# 143
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
# 147
} 
#endif
# 149 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode) 
# 150
{int volatile ___ = 1;(void)a;(void)mode;
# 155
::exit(___);}
#if 0
# 150
{ 
# 151
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
# 155
} 
#endif
# 157 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode) 
# 158
{int volatile ___ = 1;(void)a;(void)mode;
# 163
::exit(___);}
#if 0
# 158
{ 
# 159
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
# 163
} 
#endif
# 165 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode) 
# 166
{int volatile ___ = 1;(void)a;(void)mode;
# 168
::exit(___);}
#if 0
# 166
{ 
# 167
return (double)a; 
# 168
} 
#endif
# 170 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode) 
# 171
{int volatile ___ = 1;(void)a;(void)mode;
# 173
::exit(___);}
#if 0
# 171
{ 
# 172
return (double)a; 
# 173
} 
#endif
# 175 "/usr/local/cuda/include/device_double_functions.hpp"
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode) 
# 176
{int volatile ___ = 1;(void)a;(void)mode;
# 178
::exit(___);}
#if 0
# 176
{ 
# 177
return (double)a; 
# 178
} 
#endif
# 94 "/usr/local/cuda/include/sm_20_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 94
{ } 
#endif
# 102 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 102
{ } 
#endif
# 104 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 104
{ } 
#endif
# 106 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 106
{ } 
#endif
# 108 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 108
{ } 
#endif
# 110 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 110
{ } 
#endif
# 112 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 112
{ } 
#endif
# 114 "/usr/local/cuda/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 114
{ } 
#endif
# 308 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 308
{ } 
#endif
# 311 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 311
{ } 
#endif
# 314 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 314
{ } 
#endif
# 317 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 317
{ } 
#endif
# 320 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 320
{ } 
#endif
# 323 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 323
{ } 
#endif
# 326 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 326
{ } 
#endif
# 329 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 329
{ } 
#endif
# 332 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 332
{ } 
#endif
# 335 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 335
{ } 
#endif
# 338 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 338
{ } 
#endif
# 341 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 341
{ } 
#endif
# 344 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 344
{ } 
#endif
# 347 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 347
{ } 
#endif
# 350 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 350
{ } 
#endif
# 353 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 353
{ } 
#endif
# 356 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 356
{ } 
#endif
# 359 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 359
{ } 
#endif
# 362 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 362
{ } 
#endif
# 365 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 365
{ } 
#endif
# 368 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 368
{ } 
#endif
# 371 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 371
{ } 
#endif
# 374 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 374
{ } 
#endif
# 377 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 377
{ } 
#endif
# 380 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 380
{ } 
#endif
# 383 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 383
{ } 
#endif
# 386 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 386
{ } 
#endif
# 389 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 389
{ } 
#endif
# 392 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 392
{ } 
#endif
# 395 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 395
{ } 
#endif
# 398 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 398
{ } 
#endif
# 401 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 401
{ } 
#endif
# 404 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 404
{ } 
#endif
# 407 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 407
{ } 
#endif
# 410 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 410
{ } 
#endif
# 413 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 413
{ } 
#endif
# 416 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 416
{ } 
#endif
# 419 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 419
{ } 
#endif
# 422 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 422
{ } 
#endif
# 425 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 425
{ } 
#endif
# 428 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 428
{ } 
#endif
# 431 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
# 432
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 432
{ } 
#endif
# 435 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
# 436
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 436
{ } 
#endif
# 439 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_block(unsigned long long *address, unsigned long long 
# 440
compare, unsigned long long 
# 441
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 441
{ } 
#endif
# 444 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_system(unsigned long long *address, unsigned long long 
# 445
compare, unsigned long long 
# 446
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 446
{ } 
#endif
# 449 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 449
{ } 
#endif
# 452 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 452
{ } 
#endif
# 455 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 455
{ } 
#endif
# 458 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 458
{ } 
#endif
# 461 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 461
{ } 
#endif
# 464 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 464
{ } 
#endif
# 467 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 467
{ } 
#endif
# 470 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 470
{ } 
#endif
# 473 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 473
{ } 
#endif
# 476 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 476
{ } 
#endif
# 479 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 479
{ } 
#endif
# 482 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 482
{ } 
#endif
# 485 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 485
{ } 
#endif
# 488 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 488
{ } 
#endif
# 491 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 491
{ } 
#endif
# 494 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 494
{ } 
#endif
# 497 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 497
{ } 
#endif
# 500 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 500
{ } 
#endif
# 503 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 503
{ } 
#endif
# 506 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 506
{ } 
#endif
# 509 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 509
{ } 
#endif
# 512 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 512
{ } 
#endif
# 515 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 515
{ } 
#endif
# 518 "/usr/local/cuda/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 518
{ } 
#endif
# 79 "/usr/local/cuda/include/sm_20_intrinsics.h"
extern "C" {
# 1466
}
# 1475
__attribute__((unused)) static inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1475
{ } 
#endif
# 1477 "/usr/local/cuda/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1477
{ } 
#endif
# 1479 "/usr/local/cuda/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1479
{ } 
#endif
# 1481 "/usr/local/cuda/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1481
{ } 
#endif
# 1486 "/usr/local/cuda/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1486
{ } 
#endif
# 98 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 98
{ } 
#endif
# 100 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 100
{ } 
#endif
# 102 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 103
{ } 
#endif
# 105 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 105
{ } 
#endif
# 107 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 107
{ } 
#endif
# 109 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 111
{ } 
#endif
# 113 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 113
{ } 
#endif
# 115 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 117
{ } 
#endif
# 119 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 119
{ } 
#endif
# 122 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl(long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 122
{ } 
#endif
# 124 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl(unsigned long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 124
{ } 
#endif
# 126 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_up(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 126
{ } 
#endif
# 128 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_up(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 128
{ } 
#endif
# 130 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_down(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 130
{ } 
#endif
# 132 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_down(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 132
{ } 
#endif
# 134 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_xor(long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 134
{ } 
#endif
# 136 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 136
{ } 
#endif
# 138 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 138
{ } 
#endif
# 140 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 140
{ } 
#endif
# 142 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 142
{ } 
#endif
# 144 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 144
{ } 
#endif
# 148 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 148
{ } 
#endif
# 150 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 150
{ } 
#endif
# 152 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 152
{ } 
#endif
# 154 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 154
{ } 
#endif
# 156 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 156
{ } 
#endif
# 158 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 158
{ } 
#endif
# 160 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 160
{ } 
#endif
# 162 "/usr/local/cuda/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 162
{ } 
#endif
# 89 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 89
{ } 
#endif
# 90 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 90
{ } 
#endif
# 92 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 92
{ } 
#endif
# 93 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 96
{ } 
#endif
# 97 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 99
{ } 
#endif
# 100 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 100
{ } 
#endif
# 101 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 101
{ } 
#endif
# 102 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 103
{ } 
#endif
# 105 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 105
{ } 
#endif
# 106 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 110
{ } 
#endif
# 111 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 112
{ } 
#endif
# 113 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 113
{ } 
#endif
# 114 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 114
{ } 
#endif
# 115 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 115
{ } 
#endif
# 117 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 117
{ } 
#endif
# 118 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 118
{ } 
#endif
# 119 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 119
{ } 
#endif
# 120 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 120
{ } 
#endif
# 121 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 121
{ } 
#endif
# 125 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 125
{ } 
#endif
# 126 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 126
{ } 
#endif
# 128 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 128
{ } 
#endif
# 129 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 129
{ } 
#endif
# 130 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 130
{ } 
#endif
# 131 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 131
{ } 
#endif
# 132 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 132
{ } 
#endif
# 133 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 133
{ } 
#endif
# 134 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 134
{ } 
#endif
# 135 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 135
{ } 
#endif
# 136 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 136
{ } 
#endif
# 137 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 137
{ } 
#endif
# 138 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 138
{ } 
#endif
# 139 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 139
{ } 
#endif
# 141 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 141
{ } 
#endif
# 142 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 142
{ } 
#endif
# 143 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 143
{ } 
#endif
# 144 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 144
{ } 
#endif
# 145 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 145
{ } 
#endif
# 146 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 146
{ } 
#endif
# 147 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 147
{ } 
#endif
# 148 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 148
{ } 
#endif
# 149 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 149
{ } 
#endif
# 150 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 150
{ } 
#endif
# 151 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 151
{ } 
#endif
# 153 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 153
{ } 
#endif
# 154 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 154
{ } 
#endif
# 155 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 155
{ } 
#endif
# 156 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 156
{ } 
#endif
# 157 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 157
{ } 
#endif
# 161 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 161
{ } 
#endif
# 162 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 162
{ } 
#endif
# 164 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 164
{ } 
#endif
# 165 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 165
{ } 
#endif
# 166 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 166
{ } 
#endif
# 167 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 167
{ } 
#endif
# 168 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldca(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 168
{ } 
#endif
# 169 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 169
{ } 
#endif
# 170 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 170
{ } 
#endif
# 171 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 171
{ } 
#endif
# 172 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 172
{ } 
#endif
# 173 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 173
{ } 
#endif
# 174 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 174
{ } 
#endif
# 175 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 175
{ } 
#endif
# 177 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 177
{ } 
#endif
# 178 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 178
{ } 
#endif
# 179 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 179
{ } 
#endif
# 180 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldca(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 180
{ } 
#endif
# 181 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 181
{ } 
#endif
# 182 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 182
{ } 
#endif
# 183 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 183
{ } 
#endif
# 184 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 184
{ } 
#endif
# 185 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 185
{ } 
#endif
# 186 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 186
{ } 
#endif
# 187 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 187
{ } 
#endif
# 189 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 189
{ } 
#endif
# 190 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 190
{ } 
#endif
# 191 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 191
{ } 
#endif
# 192 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 192
{ } 
#endif
# 193 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 193
{ } 
#endif
# 197 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 197
{ } 
#endif
# 198 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 198
{ } 
#endif
# 200 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 200
{ } 
#endif
# 201 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 201
{ } 
#endif
# 202 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 202
{ } 
#endif
# 203 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 203
{ } 
#endif
# 204 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcs(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 204
{ } 
#endif
# 205 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 205
{ } 
#endif
# 206 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 206
{ } 
#endif
# 207 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 207
{ } 
#endif
# 208 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 208
{ } 
#endif
# 209 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 209
{ } 
#endif
# 210 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 210
{ } 
#endif
# 211 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 211
{ } 
#endif
# 213 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 213
{ } 
#endif
# 214 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 214
{ } 
#endif
# 215 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 215
{ } 
#endif
# 216 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcs(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 216
{ } 
#endif
# 217 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 217
{ } 
#endif
# 218 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 218
{ } 
#endif
# 219 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 219
{ } 
#endif
# 220 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 220
{ } 
#endif
# 221 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 221
{ } 
#endif
# 222 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 222
{ } 
#endif
# 223 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 223
{ } 
#endif
# 225 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 225
{ } 
#endif
# 226 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 226
{ } 
#endif
# 227 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 227
{ } 
#endif
# 228 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 228
{ } 
#endif
# 229 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 229
{ } 
#endif
# 236 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 236
{ } 
#endif
# 237 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 237
{ } 
#endif
# 240 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 240
{ } 
#endif
# 241 "/usr/local/cuda/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 241
{ } 
#endif
# 91 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 91
{ } 
#endif
# 92 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 92
{ } 
#endif
# 94 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 95
{ } 
#endif
# 97 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 98
{ } 
#endif
# 100 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 100
{ } 
#endif
# 101 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 101
{ } 
#endif
# 108 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 112
{ } 
#endif
# 100 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 101
__attribute((always_inline)) __attribute__((unused)) inline void surf1Dread(T *res, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 102
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
# 111
::exit(___);}
#if 0
# 102
{ 
# 111
} 
#endif
# 113 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 114
__attribute((always_inline)) __attribute__((unused)) inline T surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 115
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 123
::exit(___);}
#if 0
# 115
{ 
# 123
} 
#endif
# 125 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 126
__attribute((always_inline)) __attribute__((unused)) inline void surf1Dread(T *res, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 127
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
# 131
::exit(___);}
#if 0
# 127
{ 
# 131
} 
#endif
# 260 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 261
__attribute((always_inline)) __attribute__((unused)) inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 262
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 271
::exit(___);}
#if 0
# 262
{ 
# 271
} 
#endif
# 273 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 274
__attribute((always_inline)) __attribute__((unused)) inline T surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 283
::exit(___);}
#if 0
# 275
{ 
# 283
} 
#endif
# 285 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 286
__attribute((always_inline)) __attribute__((unused)) inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 287
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
# 291
::exit(___);}
#if 0
# 287
{ 
# 291
} 
#endif
# 422 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 423
__attribute((always_inline)) __attribute__((unused)) inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 424
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 433
::exit(___);}
#if 0
# 424
{ 
# 433
} 
#endif
# 435 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 436
__attribute((always_inline)) __attribute__((unused)) inline T surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 437
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 445
::exit(___);}
#if 0
# 437
{ 
# 445
} 
#endif
# 447 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 448
__attribute((always_inline)) __attribute__((unused)) inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 449
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 453
::exit(___);}
#if 0
# 449
{ 
# 453
} 
#endif
# 582 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 583
__attribute((always_inline)) __attribute__((unused)) inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 584
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 593
::exit(___);}
#if 0
# 584
{ 
# 593
} 
#endif
# 595 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 596
__attribute((always_inline)) __attribute__((unused)) inline T surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 597
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 605
::exit(___);}
#if 0
# 597
{ 
# 605
} 
#endif
# 607 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 608
__attribute((always_inline)) __attribute__((unused)) inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 609
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
# 613
::exit(___);}
#if 0
# 609
{ 
# 613
} 
#endif
# 768 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 769
__attribute((always_inline)) __attribute__((unused)) inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 770
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 779
::exit(___);}
#if 0
# 770
{ 
# 779
} 
#endif
# 781 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 782
__attribute((always_inline)) __attribute__((unused)) inline T surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 783
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 791
::exit(___);}
#if 0
# 783
{ 
# 791
} 
#endif
# 793 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 794
__attribute((always_inline)) __attribute__((unused)) inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 795
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 799
::exit(___);}
#if 0
# 795
{ 
# 799
} 
#endif
# 919 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 920
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 921
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 930
::exit(___);}
#if 0
# 921
{ 
# 930
} 
#endif
# 932 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 933
__attribute((always_inline)) __attribute__((unused)) inline T surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 934
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 942
::exit(___);}
#if 0
# 934
{ 
# 942
} 
#endif
# 944 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 945
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 946
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 950
::exit(___);}
#if 0
# 946
{ 
# 950
} 
#endif
# 1070 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1071
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1072
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 1081
::exit(___);}
#if 0
# 1072
{ 
# 1081
} 
#endif
# 1083 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1084
__attribute((always_inline)) __attribute__((unused)) inline T surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1085
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1093
::exit(___);}
#if 0
# 1085
{ 
# 1093
} 
#endif
# 1095 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1096
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1097
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 1101
::exit(___);}
#if 0
# 1097
{ 
# 1101
} 
#endif
# 1232 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1233
__attribute((always_inline)) __attribute__((unused)) inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1234
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
# 1254
::exit(___);}
#if 0
# 1234
{ 
# 1254
} 
#endif
# 1256 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1257
__attribute((always_inline)) __attribute__((unused)) inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1258
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 1262
::exit(___);}
#if 0
# 1258
{ 
# 1262
} 
#endif
# 1377 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1378
__attribute((always_inline)) __attribute__((unused)) inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1379
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 1399
::exit(___);}
#if 0
# 1379
{ 
# 1399
} 
#endif
# 1401 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1402
__attribute((always_inline)) __attribute__((unused)) inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1403
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 1407
::exit(___);}
#if 0
# 1403
{ 
# 1407
} 
#endif
# 1520 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1521
__attribute((always_inline)) __attribute__((unused)) inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1522
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 1542
::exit(___);}
#if 0
# 1522
{ 
# 1542
} 
#endif
# 1544 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1545
__attribute((always_inline)) __attribute__((unused)) inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1546
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 1550
::exit(___);}
#if 0
# 1546
{ 
# 1550
} 
#endif
# 1666 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1667
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1668
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 1688
::exit(___);}
#if 0
# 1668
{ 
# 1688
} 
#endif
# 1690 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1691
__attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 1696
::exit(___);}
#if 0
# 1692
{ 
# 1696
} 
#endif
# 1822 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1823
__attribute((always_inline)) __attribute__((unused)) inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1824
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 1844
::exit(___);}
#if 0
# 1824
{ 
# 1844
} 
#endif
# 1846 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1847
__attribute((always_inline)) __attribute__((unused)) inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1848
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 1852
::exit(___);}
#if 0
# 1848
{ 
# 1852
} 
#endif
# 1958 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1959
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1960
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 1980
::exit(___);}
#if 0
# 1960
{ 
# 1980
} 
#endif
# 1982 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 1983
__attribute((always_inline)) __attribute__((unused)) inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 1984
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 1988
::exit(___);}
#if 0
# 1984
{ 
# 1988
} 
#endif
# 2093 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 2094
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2095
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 2115
::exit(___);}
#if 0
# 2095
{ 
# 2115
} 
#endif
# 2117 "/usr/local/cuda/include/surface_functions.h"
template< class T> 
# 2118
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 2119
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 2123
::exit(___);}
#if 0
# 2119
{ 
# 2123
} 
#endif
# 70 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 71
tex1Dfetch(texture< T, 1, cudaReadModeElementType> , int) {int volatile ___ = 1;::exit(___);}
#if 0
# 71
{ } 
#endif
# 73 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> 
# 74
struct __nv_tex_rmnf_ret { }; 
# 76
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
# 77
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
# 78
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
# 79
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
# 80
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
# 81
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
# 82
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
# 83
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
# 84
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
# 85
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
# 86
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
# 87
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
# 88
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
# 89
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
# 90
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
# 91
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
# 92
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
# 94
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 95
tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat> , int) {int volatile ___ = 1;::exit(___);}
#if 0
# 95
{ } 
#endif
# 215 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 216
tex1D(texture< T, 1, cudaReadModeElementType> , float) {int volatile ___ = 1;::exit(___);}
#if 0
# 216
{ } 
#endif
# 218 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 219
tex1D(texture< T, 1, cudaReadModeNormalizedFloat> , float) {int volatile ___ = 1;::exit(___);}
#if 0
# 219
{ } 
#endif
# 345 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 346
tex2D(texture< T, 2, cudaReadModeElementType> , float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 346
{ } 
#endif
# 348 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 349
tex2D(texture< T, 2, cudaReadModeNormalizedFloat> , float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 349
{ } 
#endif
# 475 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 476
tex1DLayered(texture< T, 241, cudaReadModeElementType> , float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 476
{ } 
#endif
# 478 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 479
tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat> , float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 479
{ } 
#endif
# 603 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 604
tex2DLayered(texture< T, 242, cudaReadModeElementType> , float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 604
{ } 
#endif
# 606 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 607
tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat> , float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 607
{ } 
#endif
# 735 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 736
tex3D(texture< T, 3, cudaReadModeElementType> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 736
{ } 
#endif
# 738 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 739
tex3D(texture< T, 3, cudaReadModeNormalizedFloat> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 739
{ } 
#endif
# 864 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 865
texCubemap(texture< T, 12, cudaReadModeElementType> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 865
{ } 
#endif
# 867 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 868
texCubemap(texture< T, 12, cudaReadModeNormalizedFloat> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 868
{ } 
#endif
# 992 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 993
texCubemapLayered(texture< T, 252, cudaReadModeElementType> , float, float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 993
{ } 
#endif
# 995 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 996
texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat> , float, float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 996
{ } 
#endif
# 1121 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> 
# 1122
struct __nv_tex2dgather_ret { }; 
# 1123
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
# 1124
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
# 1125
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
# 1126
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
# 1127
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
# 1128
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
# 1129
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
# 1130
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
# 1131
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
# 1132
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
# 1133
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
# 1135
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
# 1136
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
# 1137
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
# 1138
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
# 1139
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
# 1140
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
# 1141
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
# 1142
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
# 1143
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
# 1144
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
# 1146
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
# 1147
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
# 1148
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
# 1149
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
# 1150
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
# 1151
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
# 1152
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
# 1153
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
# 1154
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
# 1155
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
# 1157
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
# 1158
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
# 1159
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
# 1160
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
# 1161
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
# 1163
template< class T> __attribute__((unused)) static typename __nv_tex2dgather_ret< T> ::type 
# 1164
tex2Dgather(texture< T, 2, cudaReadModeElementType> , float, float, int = 0) {int volatile ___ = 1;::exit(___);}
#if 0
# 1164
{ } 
#endif
# 1166 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static float4 
# 1167
tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat> , float, float, int = 0) {int volatile ___ = 1;::exit(___);}
#if 0
# 1167
{ } 
#endif
# 1232 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1233
tex1DLod(texture< T, 1, cudaReadModeElementType> , float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1233
{ } 
#endif
# 1235 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1236
tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat> , float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1236
{ } 
#endif
# 1360 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1361
tex2DLod(texture< T, 2, cudaReadModeElementType> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1361
{ } 
#endif
# 1363 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1364
tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1364
{ } 
#endif
# 1484 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1485
tex1DLayeredLod(texture< T, 241, cudaReadModeElementType> , float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1485
{ } 
#endif
# 1487 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1488
tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat> , float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1488
{ } 
#endif
# 1612 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1613
tex2DLayeredLod(texture< T, 242, cudaReadModeElementType> , float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1613
{ } 
#endif
# 1615 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1616
tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat> , float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1616
{ } 
#endif
# 1740 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1741
tex3DLod(texture< T, 3, cudaReadModeElementType> , float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1741
{ } 
#endif
# 1743 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1744
tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat> , float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1744
{ } 
#endif
# 1868 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1869
texCubemapLod(texture< T, 12, cudaReadModeElementType> , float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1869
{ } 
#endif
# 1871 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 1872
texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat> , float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1872
{ } 
#endif
# 1996 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 1997
texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType> , float, float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1997
{ } 
#endif
# 1999 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2000
texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat> , float, float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 2000
{ } 
#endif
# 2124 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 2125
tex1DGrad(texture< T, 1, cudaReadModeElementType> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 2125
{ } 
#endif
# 2127 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2128
tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat> , float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 2128
{ } 
#endif
# 2252 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 2253
tex2DGrad(texture< T, 2, cudaReadModeElementType> , float, float, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 2253
{ } 
#endif
# 2255 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2256
tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat> , float, float, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 2256
{ } 
#endif
# 2380 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 2381
tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType> , float, int, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 2381
{ } 
#endif
# 2383 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2384
tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat> , float, int, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 2384
{ } 
#endif
# 2509 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 2510
tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType> , float, float, int, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 2510
{ } 
#endif
# 2512 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2513
tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat> , float, float, int, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 2513
{ } 
#endif
# 2637 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static T 
# 2638
tex3DGrad(texture< T, 3, cudaReadModeElementType> , float, float, float, float4, float4) {int volatile ___ = 1;::exit(___);}
#if 0
# 2638
{ } 
#endif
# 2640 "/usr/local/cuda/include/texture_fetch_functions.h"
template< class T> __attribute__((unused)) static typename __nv_tex_rmnf_ret< T> ::type 
# 2641
tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat> , float, float, float, float4, float4) {int volatile ___ = 1;::exit(___);}
#if 0
# 2641
{ } 
#endif
# 67 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 68
tex1Dfetch(T *, cudaTextureObject_t, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 68
{ } 
#endif
# 121 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 122
tex1Dfetch(cudaTextureObject_t texObject, int x) 
# 123
{int volatile ___ = 1;(void)texObject;(void)x;
# 127
::exit(___);}
#if 0
# 123
{ 
# 124
T ret; 
# 125
tex1Dfetch(&ret, texObject, x); 
# 126
return ret; 
# 127
} 
#endif
# 135 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 136
tex1D(T *, cudaTextureObject_t, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 136
{ } 
#endif
# 190 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 191
tex1D(cudaTextureObject_t texObject, float x) 
# 192
{int volatile ___ = 1;(void)texObject;(void)x;
# 196
::exit(___);}
#if 0
# 192
{ 
# 193
T ret; 
# 194
tex1D(&ret, texObject, x); 
# 195
return ret; 
# 196
} 
#endif
# 205 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 206
tex2D(T *, cudaTextureObject_t, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 206
{ } 
#endif
# 258 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 259
tex2D(cudaTextureObject_t texObject, float x, float y) 
# 260
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
# 264
::exit(___);}
#if 0
# 260
{ 
# 261
T ret; 
# 262
tex2D(&ret, texObject, x, y); 
# 263
return ret; 
# 264
} 
#endif
# 272 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 273
tex3D(T *, cudaTextureObject_t, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 273
{ } 
#endif
# 325 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 326
tex3D(cudaTextureObject_t texObject, float x, float y, float z) 
# 327
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 331
::exit(___);}
#if 0
# 327
{ 
# 328
T ret; 
# 329
tex3D(&ret, texObject, x, y, z); 
# 330
return ret; 
# 331
} 
#endif
# 340 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 341
tex1DLayered(T *, cudaTextureObject_t, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 341
{ } 
#endif
# 393 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 394
tex1DLayered(cudaTextureObject_t texObject, float x, int layer) 
# 395
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
# 399
::exit(___);}
#if 0
# 395
{ 
# 396
T ret; 
# 397
tex1DLayered(&ret, texObject, x, layer); 
# 398
return ret; 
# 399
} 
#endif
# 408 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 409
tex2DLayered(T *, cudaTextureObject_t, float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 409
{ } 
#endif
# 461 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 462
tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer) 
# 463
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
# 467
::exit(___);}
#if 0
# 463
{ 
# 464
T ret; 
# 465
tex2DLayered(&ret, texObject, x, y, layer); 
# 466
return ret; 
# 467
} 
#endif
# 476 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 477
texCubemap(T *, cudaTextureObject_t, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 477
{ } 
#endif
# 529 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 530
texCubemap(cudaTextureObject_t texObject, float x, float y, float z) 
# 531
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 535
::exit(___);}
#if 0
# 531
{ 
# 532
T ret; 
# 533
texCubemap(&ret, texObject, x, y, z); 
# 534
return ret; 
# 535
} 
#endif
# 544 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 545
texCubemapLayered(T *, cudaTextureObject_t, float, float, float, int) {int volatile ___ = 1;::exit(___);}
#if 0
# 545
{ } 
#endif
# 598 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 599
texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 600
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 604
::exit(___);}
#if 0
# 600
{ 
# 601
T ret; 
# 602
texCubemapLayered(&ret, texObject, x, y, z, layer); 
# 603
return ret; 
# 604
} 
#endif
# 613 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 614
tex2Dgather(T *, cudaTextureObject_t, float, float, int = 0) {int volatile ___ = 1;::exit(___);}
#if 0
# 614
{ } 
#endif
# 660 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 661
tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0) 
# 662
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
# 666
::exit(___);}
#if 0
# 662
{ 
# 663
T ret; 
# 664
tex2Dgather(&ret, to, x, y, comp); 
# 665
return ret; 
# 666
} 
#endif
# 675 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 676
tex1DLod(T *, cudaTextureObject_t, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 676
{ } 
#endif
# 728 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 729
tex1DLod(cudaTextureObject_t texObject, float x, float level) 
# 730
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
# 734
::exit(___);}
#if 0
# 730
{ 
# 731
T ret; 
# 732
tex1DLod(&ret, texObject, x, level); 
# 733
return ret; 
# 734
} 
#endif
# 743 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 744
tex2DLod(T *, cudaTextureObject_t, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 744
{ } 
#endif
# 797 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 798
tex2DLod(cudaTextureObject_t texObject, float x, float y, float level) 
# 799
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
# 803
::exit(___);}
#if 0
# 799
{ 
# 800
T ret; 
# 801
tex2DLod(&ret, texObject, x, y, level); 
# 802
return ret; 
# 803
} 
#endif
# 812 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 813
tex3DLod(T *, cudaTextureObject_t, float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 813
{ } 
#endif
# 865 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 866
tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 867
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 871
::exit(___);}
#if 0
# 867
{ 
# 868
T ret; 
# 869
tex3DLod(&ret, texObject, x, y, z, level); 
# 870
return ret; 
# 871
} 
#endif
# 879 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 880
tex1DLayeredLod(T *, cudaTextureObject_t, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 880
{ } 
#endif
# 932 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 933
tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level) 
# 934
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
# 938
::exit(___);}
#if 0
# 934
{ 
# 935
T ret; 
# 936
tex1DLayeredLod(&ret, texObject, x, layer, level); 
# 937
return ret; 
# 938
} 
#endif
# 947 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 948
tex2DLayeredLod(T *, cudaTextureObject_t, float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 948
{ } 
#endif
# 1000 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1001
tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 1002
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 1006
::exit(___);}
#if 0
# 1002
{ 
# 1003
T ret; 
# 1004
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
# 1005
return ret; 
# 1006
} 
#endif
# 1014 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1015
texCubemapLod(T *, cudaTextureObject_t, float, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1015
{ } 
#endif
# 1067 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1068
texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 1069
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 1073
::exit(___);}
#if 0
# 1069
{ 
# 1070
T ret; 
# 1071
texCubemapLod(&ret, texObject, x, y, z, level); 
# 1072
return ret; 
# 1073
} 
#endif
# 1081 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1082
texCubemapLayeredLod(T *, cudaTextureObject_t, float, float, float, int, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1082
{ } 
#endif
# 1134 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1135
texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 1136
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 1140
::exit(___);}
#if 0
# 1136
{ 
# 1137
T ret; 
# 1138
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
# 1139
return ret; 
# 1140
} 
#endif
# 1148 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1149
tex1DGrad(T *, cudaTextureObject_t, float, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1149
{ } 
#endif
# 1202 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1203
tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 1204
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 1208
::exit(___);}
#if 0
# 1204
{ 
# 1205
T ret; 
# 1206
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
# 1207
return ret; 
# 1208
} 
#endif
# 1216 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1217
tex2DGrad(T *, cudaTextureObject_t, float, float, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 1217
{ } 
#endif
# 1269 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1270
tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 1271
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 1275
::exit(___);}
#if 0
# 1271
{ 
# 1272
T ret; 
# 1273
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
# 1274
return ret; 
# 1275
} 
#endif
# 1283 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1284
tex3DGrad(T *, cudaTextureObject_t, float, float, float, float4, float4) {int volatile ___ = 1;::exit(___);}
#if 0
# 1284
{ } 
#endif
# 1336 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1337
tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 1338
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 1342
::exit(___);}
#if 0
# 1338
{ 
# 1339
T ret; 
# 1340
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
# 1341
return ret; 
# 1342
} 
#endif
# 1350 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1351
tex1DLayeredGrad(T *, cudaTextureObject_t, float, int, float, float) {int volatile ___ = 1;::exit(___);}
#if 0
# 1351
{ } 
#endif
# 1404 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1405
tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 1406
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 1410
::exit(___);}
#if 0
# 1406
{ 
# 1407
T ret; 
# 1408
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
# 1409
return ret; 
# 1410
} 
#endif
# 1418 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 1419
tex2DLayeredGrad(T *, cudaTextureObject_t, float, float, int, float2, float2) {int volatile ___ = 1;::exit(___);}
#if 0
# 1419
{ } 
#endif
# 1471 "/usr/local/cuda/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 1472
tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 1473
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 1477
::exit(___);}
#if 0
# 1473
{ 
# 1474
T ret; 
# 1475
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
# 1476
return ret; 
# 1477
} 
#endif
# 68 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 69
surf1Dread(T *, cudaSurfaceObject_t, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 69
{ } 
#endif
# 111 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 112
surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 113
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
# 119
::exit(___);}
#if 0
# 113
{ 
# 119
} 
#endif
# 128 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 129
surf2Dread(T *, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 129
{ } 
#endif
# 172 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 173
surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 174
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 180
::exit(___);}
#if 0
# 174
{ 
# 180
} 
#endif
# 189 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 190
surf3Dread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 190
{ } 
#endif
# 231 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 232
surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 233
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 239
::exit(___);}
#if 0
# 233
{ 
# 239
} 
#endif
# 247 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 248
surf1DLayeredread(T *, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 248
{ } 
#endif
# 290 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 291
surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 292
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 298
::exit(___);}
#if 0
# 292
{ 
# 298
} 
#endif
# 306 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 307
surf2DLayeredread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 307
{ } 
#endif
# 348 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 349
surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 350
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 356
::exit(___);}
#if 0
# 350
{ 
# 356
} 
#endif
# 364 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 365
surfCubemapread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 365
{ } 
#endif
# 406 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 407
surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 408
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 414
::exit(___);}
#if 0
# 408
{ 
# 414
} 
#endif
# 422 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 423
surfCubemapLayeredread(T *, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 423
{ } 
#endif
# 464 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 465
surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 466
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 472
::exit(___);}
#if 0
# 466
{ 
# 472
} 
#endif
# 480 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 481
surf1Dwrite(T, cudaSurfaceObject_t, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 481
{ } 
#endif
# 528 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 529
surf2Dwrite(T, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 529
{ } 
#endif
# 576 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 577
surf3Dwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 577
{ } 
#endif
# 626 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 627
surf1DLayeredwrite(T, cudaSurfaceObject_t, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 627
{ } 
#endif
# 675 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 676
surf2DLayeredwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 676
{ } 
#endif
# 723 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 724
surfCubemapwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 724
{ } 
#endif
# 771 "/usr/local/cuda/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static void 
# 772
surfCubemapLayeredwrite(T, cudaSurfaceObject_t, int, int, int, cudaSurfaceBoundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;::exit(___);}
#if 0
# 772
{ } 
#endif
# 68 "/usr/local/cuda/include/device_launch_parameters.h"
extern "C" {
# 71
extern const uint3 __device_builtin_variable_threadIdx; 
# 72
extern const uint3 __device_builtin_variable_blockIdx; 
# 73
extern const dim3 __device_builtin_variable_blockDim; 
# 74
extern const dim3 __device_builtin_variable_gridDim; 
# 75
extern const int __device_builtin_variable_warpSize; 
# 80
}
# 183 "/usr/local/cuda/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 184
cudaLaunchKernel(const T *
# 185
func, dim3 
# 186
gridDim, dim3 
# 187
blockDim, void **
# 188
args, size_t 
# 189
sharedMem = 0, cudaStream_t 
# 190
stream = 0) 
# 192
{ 
# 193
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 194
} 
# 221
template< class T> static inline cudaError_t 
# 222
cudaSetupArgument(T 
# 223
arg, size_t 
# 224
offset) 
# 226
{ 
# 227
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
# 228
} 
# 260
static inline cudaError_t cudaEventCreate(cudaEvent_t *
# 261
event, unsigned 
# 262
flags) 
# 264
{ 
# 265
return ::cudaEventCreateWithFlags(event, flags); 
# 266
} 
# 323
static inline cudaError_t cudaMallocHost(void **
# 324
ptr, size_t 
# 325
size, unsigned 
# 326
flags) 
# 328
{ 
# 329
return ::cudaHostAlloc(ptr, size, flags); 
# 330
} 
# 332
template< class T> static inline cudaError_t 
# 333
cudaHostAlloc(T **
# 334
ptr, size_t 
# 335
size, unsigned 
# 336
flags) 
# 338
{ 
# 339
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
# 340
} 
# 342
template< class T> static inline cudaError_t 
# 343
cudaHostGetDevicePointer(T **
# 344
pDevice, void *
# 345
pHost, unsigned 
# 346
flags) 
# 348
{ 
# 349
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
# 350
} 
# 449
template< class T> static inline cudaError_t 
# 450
cudaMallocManaged(T **
# 451
devPtr, size_t 
# 452
size, unsigned 
# 453
flags = 1) 
# 455
{ 
# 456
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
# 457
} 
# 528
template< class T> static inline cudaError_t 
# 529
cudaStreamAttachMemAsync(cudaStream_t 
# 530
stream, T *
# 531
devPtr, size_t 
# 532
length = 0, unsigned 
# 533
flags = 4) 
# 535
{ 
# 536
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
# 537
} 
# 539
template< class T> inline cudaError_t 
# 540
cudaMalloc(T **
# 541
devPtr, size_t 
# 542
size) 
# 544
{ 
# 545
return ::cudaMalloc((void **)((void *)devPtr), size); 
# 546
} 
# 548
template< class T> static inline cudaError_t 
# 549
cudaMallocHost(T **
# 550
ptr, size_t 
# 551
size, unsigned 
# 552
flags = 0) 
# 554
{ 
# 555
return cudaMallocHost((void **)((void *)ptr), size, flags); 
# 556
} 
# 558
template< class T> static inline cudaError_t 
# 559
cudaMallocPitch(T **
# 560
devPtr, size_t *
# 561
pitch, size_t 
# 562
width, size_t 
# 563
height) 
# 565
{ 
# 566
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
# 567
} 
# 604
template< class T> static inline cudaError_t 
# 605
cudaMemcpyToSymbol(const T &
# 606
symbol, const void *
# 607
src, size_t 
# 608
count, size_t 
# 609
offset = 0, cudaMemcpyKind 
# 610
kind = cudaMemcpyHostToDevice) 
# 612
{ 
# 613
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
# 614
} 
# 656
template< class T> static inline cudaError_t 
# 657
cudaMemcpyToSymbolAsync(const T &
# 658
symbol, const void *
# 659
src, size_t 
# 660
count, size_t 
# 661
offset = 0, cudaMemcpyKind 
# 662
kind = cudaMemcpyHostToDevice, cudaStream_t 
# 663
stream = 0) 
# 665
{ 
# 666
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
# 667
} 
# 702
template< class T> static inline cudaError_t 
# 703
cudaMemcpyFromSymbol(void *
# 704
dst, const T &
# 705
symbol, size_t 
# 706
count, size_t 
# 707
offset = 0, cudaMemcpyKind 
# 708
kind = cudaMemcpyDeviceToHost) 
# 710
{ 
# 711
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
# 712
} 
# 754
template< class T> static inline cudaError_t 
# 755
cudaMemcpyFromSymbolAsync(void *
# 756
dst, const T &
# 757
symbol, size_t 
# 758
count, size_t 
# 759
offset = 0, cudaMemcpyKind 
# 760
kind = cudaMemcpyDeviceToHost, cudaStream_t 
# 761
stream = 0) 
# 763
{ 
# 764
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
# 765
} 
# 787
template< class T> static inline cudaError_t 
# 788
cudaGetSymbolAddress(void **
# 789
devPtr, const T &
# 790
symbol) 
# 792
{ 
# 793
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
# 794
} 
# 816
template< class T> static inline cudaError_t 
# 817
cudaGetSymbolSize(size_t *
# 818
size, const T &
# 819
symbol) 
# 821
{ 
# 822
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
# 823
} 
# 859
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 860
cudaBindTexture(size_t *
# 861
offset, const texture< T, dim, readMode>  &
# 862
tex, const void *
# 863
devPtr, const cudaChannelFormatDesc &
# 864
desc, size_t 
# 865
size = ((2147483647) * 2U) + 1U) 
# 867
{ 
# 868
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
# 869
} 
# 904
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 905
cudaBindTexture(size_t *
# 906
offset, const texture< T, dim, readMode>  &
# 907
tex, const void *
# 908
devPtr, size_t 
# 909
size = ((2147483647) * 2U) + 1U) 
# 911
{ 
# 912
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
# 913
} 
# 960
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 961
cudaBindTexture2D(size_t *
# 962
offset, const texture< T, dim, readMode>  &
# 963
tex, const void *
# 964
devPtr, const cudaChannelFormatDesc &
# 965
desc, size_t 
# 966
width, size_t 
# 967
height, size_t 
# 968
pitch) 
# 970
{ 
# 971
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
# 972
} 
# 1018
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1019
cudaBindTexture2D(size_t *
# 1020
offset, const texture< T, dim, readMode>  &
# 1021
tex, const void *
# 1022
devPtr, size_t 
# 1023
width, size_t 
# 1024
height, size_t 
# 1025
pitch) 
# 1027
{ 
# 1028
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
# 1029
} 
# 1060
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1061
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1062
tex, cudaArray_const_t 
# 1063
array, const cudaChannelFormatDesc &
# 1064
desc) 
# 1066
{ 
# 1067
return ::cudaBindTextureToArray(&tex, array, &desc); 
# 1068
} 
# 1098
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1099
cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1100
tex, cudaArray_const_t 
# 1101
array) 
# 1103
{ 
# 1104
cudaChannelFormatDesc desc; 
# 1105
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1107
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
# 1108
} 
# 1139
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1140
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1141
tex, cudaMipmappedArray_const_t 
# 1142
mipmappedArray, const cudaChannelFormatDesc &
# 1143
desc) 
# 1145
{ 
# 1146
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
# 1147
} 
# 1177
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1178
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1179
tex, cudaMipmappedArray_const_t 
# 1180
mipmappedArray) 
# 1182
{ 
# 1183
cudaChannelFormatDesc desc; 
# 1184
cudaArray_t levelArray; 
# 1185
cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
# 1187
if (err != (cudaSuccess)) { 
# 1188
return err; 
# 1189
}  
# 1190
err = ::cudaGetChannelDesc(&desc, levelArray); 
# 1192
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
# 1193
} 
# 1216
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1217
cudaUnbindTexture(const texture< T, dim, readMode>  &
# 1218
tex) 
# 1220
{ 
# 1221
return ::cudaUnbindTexture(&tex); 
# 1222
} 
# 1250
template< class T, int dim, cudaTextureReadMode readMode> static inline cudaError_t 
# 1251
cudaGetTextureAlignmentOffset(size_t *
# 1252
offset, const texture< T, dim, readMode>  &
# 1253
tex) 
# 1255
{ 
# 1256
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
# 1257
} 
# 1302
template< class T> static inline cudaError_t 
# 1303
cudaFuncSetCacheConfig(T *
# 1304
func, cudaFuncCache 
# 1305
cacheConfig) 
# 1307
{ 
# 1308
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
# 1309
} 
# 1311
template< class T> static inline cudaError_t 
# 1312
cudaFuncSetSharedMemConfig(T *
# 1313
func, cudaSharedMemConfig 
# 1314
config) 
# 1316
{ 
# 1317
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
# 1318
} 
# 1347
template< class T> inline cudaError_t 
# 1348
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
# 1349
numBlocks, T 
# 1350
func, int 
# 1351
blockSize, size_t 
# 1352
dynamicSMemSize) 
# 1353
{ 
# 1354
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
# 1355
} 
# 1398
template< class T> inline cudaError_t 
# 1399
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
# 1400
numBlocks, T 
# 1401
func, int 
# 1402
blockSize, size_t 
# 1403
dynamicSMemSize, unsigned 
# 1404
flags) 
# 1405
{ 
# 1406
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
# 1407
} 
# 1412
class __cudaOccupancyB2DHelper { 
# 1413
size_t n; 
# 1415
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
# 1416
size_t operator()(int) 
# 1417
{ 
# 1418
return n; 
# 1419
} 
# 1420
}; 
# 1467
template< class UnaryFunction, class T> static inline cudaError_t 
# 1468
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
# 1469
minGridSize, int *
# 1470
blockSize, T 
# 1471
func, UnaryFunction 
# 1472
blockSizeToDynamicSMemSize, int 
# 1473
blockSizeLimit = 0, unsigned 
# 1474
flags = 0) 
# 1475
{ 
# 1476
cudaError_t status; 
# 1479
int device; 
# 1480
cudaFuncAttributes attr; 
# 1483
int maxThreadsPerMultiProcessor; 
# 1484
int warpSize; 
# 1485
int devMaxThreadsPerBlock; 
# 1486
int multiProcessorCount; 
# 1487
int funcMaxThreadsPerBlock; 
# 1488
int occupancyLimit; 
# 1489
int granularity; 
# 1492
int maxBlockSize = 0; 
# 1493
int numBlocks = 0; 
# 1494
int maxOccupancy = 0; 
# 1497
int blockSizeToTryAligned; 
# 1498
int blockSizeToTry; 
# 1499
int blockSizeLimitAligned; 
# 1500
int occupancyInBlocks; 
# 1501
int occupancyInThreads; 
# 1502
size_t dynamicSMemSize; 
# 1508
if (((!minGridSize) || (!blockSize)) || (!func)) { 
# 1509
return cudaErrorInvalidValue; 
# 1510
}  
# 1516
status = ::cudaGetDevice(&device); 
# 1517
if (status != (cudaSuccess)) { 
# 1518
return status; 
# 1519
}  
# 1521
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
# 1525
if (status != (cudaSuccess)) { 
# 1526
return status; 
# 1527
}  
# 1529
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
# 1533
if (status != (cudaSuccess)) { 
# 1534
return status; 
# 1535
}  
# 1537
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
# 1541
if (status != (cudaSuccess)) { 
# 1542
return status; 
# 1543
}  
# 1545
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
# 1549
if (status != (cudaSuccess)) { 
# 1550
return status; 
# 1551
}  
# 1553
status = cudaFuncGetAttributes(&attr, func); 
# 1554
if (status != (cudaSuccess)) { 
# 1555
return status; 
# 1556
}  
# 1558
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
# 1564
occupancyLimit = maxThreadsPerMultiProcessor; 
# 1565
granularity = warpSize; 
# 1567
if (blockSizeLimit == 0) { 
# 1568
blockSizeLimit = devMaxThreadsPerBlock; 
# 1569
}  
# 1571
if (devMaxThreadsPerBlock < blockSizeLimit) { 
# 1572
blockSizeLimit = devMaxThreadsPerBlock; 
# 1573
}  
# 1575
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
# 1576
blockSizeLimit = funcMaxThreadsPerBlock; 
# 1577
}  
# 1579
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
# 1581
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
# 1585
if (blockSizeLimit < blockSizeToTryAligned) { 
# 1586
blockSizeToTry = blockSizeLimit; 
# 1587
} else { 
# 1588
blockSizeToTry = blockSizeToTryAligned; 
# 1589
}  
# 1591
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
# 1593
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
# 1600
if (status != (cudaSuccess)) { 
# 1601
return status; 
# 1602
}  
# 1604
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
# 1606
if (occupancyInThreads > maxOccupancy) { 
# 1607
maxBlockSize = blockSizeToTry; 
# 1608
numBlocks = occupancyInBlocks; 
# 1609
maxOccupancy = occupancyInThreads; 
# 1610
}  
# 1614
if (occupancyLimit == maxOccupancy) { 
# 1615
break; 
# 1616
}  
# 1617
}  
# 1625
(*minGridSize) = (numBlocks * multiProcessorCount); 
# 1626
(*blockSize) = maxBlockSize; 
# 1628
return status; 
# 1629
} 
# 1662
template< class UnaryFunction, class T> static inline cudaError_t 
# 1663
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
# 1664
minGridSize, int *
# 1665
blockSize, T 
# 1666
func, UnaryFunction 
# 1667
blockSizeToDynamicSMemSize, int 
# 1668
blockSizeLimit = 0) 
# 1669
{ 
# 1670
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
# 1671
} 
# 1707
template< class T> static inline cudaError_t 
# 1708
cudaOccupancyMaxPotentialBlockSize(int *
# 1709
minGridSize, int *
# 1710
blockSize, T 
# 1711
func, size_t 
# 1712
dynamicSMemSize = 0, int 
# 1713
blockSizeLimit = 0) 
# 1714
{ 
# 1715
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
# 1716
} 
# 1766
template< class T> static inline cudaError_t 
# 1767
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
# 1768
minGridSize, int *
# 1769
blockSize, T 
# 1770
func, size_t 
# 1771
dynamicSMemSize = 0, int 
# 1772
blockSizeLimit = 0, unsigned 
# 1773
flags = 0) 
# 1774
{ 
# 1775
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
# 1776
} 
# 1814
template< class T> static inline cudaError_t 
# 1815
cudaLaunch(T *
# 1816
func) 
# 1818
{ 
# 1819
return ::cudaLaunch((const void *)func); 
# 1820
} 
# 1851
template< class T> inline cudaError_t 
# 1852
cudaFuncGetAttributes(cudaFuncAttributes *
# 1853
attr, T *
# 1854
entry) 
# 1856
{ 
# 1857
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
# 1858
} 
# 1880
template< class T, int dim> static inline cudaError_t 
# 1881
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1882
surf, cudaArray_const_t 
# 1883
array, const cudaChannelFormatDesc &
# 1884
desc) 
# 1886
{ 
# 1887
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
# 1888
} 
# 1909
template< class T, int dim> static inline cudaError_t 
# 1910
cudaBindSurfaceToArray(const surface< T, dim>  &
# 1911
surf, cudaArray_const_t 
# 1912
array) 
# 1914
{ 
# 1915
cudaChannelFormatDesc desc; 
# 1916
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1918
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
# 1919
} 
# 1930
#pragma GCC diagnostic pop
# 48 "/usr/include/stdint.h" 3
typedef unsigned char uint8_t; 
# 49
typedef unsigned short uint16_t; 
# 51
typedef unsigned uint32_t; 
# 55
typedef unsigned long uint64_t; 
# 65
typedef signed char int_least8_t; 
# 66
typedef short int_least16_t; 
# 67
typedef int int_least32_t; 
# 69
typedef long int_least64_t; 
# 76
typedef unsigned char uint_least8_t; 
# 77
typedef unsigned short uint_least16_t; 
# 78
typedef unsigned uint_least32_t; 
# 80
typedef unsigned long uint_least64_t; 
# 90
typedef signed char int_fast8_t; 
# 92
typedef long int_fast16_t; 
# 93
typedef long int_fast32_t; 
# 94
typedef long int_fast64_t; 
# 103
typedef unsigned char uint_fast8_t; 
# 105
typedef unsigned long uint_fast16_t; 
# 106
typedef unsigned long uint_fast32_t; 
# 107
typedef unsigned long uint_fast64_t; 
# 119
typedef long intptr_t; 
# 122
typedef unsigned long uintptr_t; 
# 134
typedef long intmax_t; 
# 135
typedef unsigned long uintmax_t; 
# 59 "/usr/local/cuda/include/cuda.h"
typedef uint32_t cuuint32_t; 
# 60
typedef uint64_t cuuint64_t; 
# 211
extern "C" {
# 221
typedef unsigned long long CUdeviceptr; 
# 228
typedef int CUdevice; 
# 229
typedef struct CUctx_st *CUcontext; 
# 230
typedef struct CUmod_st *CUmodule; 
# 231
typedef struct CUfunc_st *CUfunction; 
# 232
typedef struct CUarray_st *CUarray; 
# 233
typedef struct CUmipmappedArray_st *CUmipmappedArray; 
# 234
typedef struct CUtexref_st *CUtexref; 
# 235
typedef struct CUsurfref_st *CUsurfref; 
# 236
typedef CUevent_st *CUevent; 
# 237
typedef CUstream_st *CUstream; 
# 238
typedef struct CUgraphicsResource_st *CUgraphicsResource; 
# 239
typedef unsigned long long CUtexObject; 
# 240
typedef unsigned long long CUsurfObject; 
# 244
typedef 
# 242
struct CUuuid_st { 
# 243
char bytes[16]; 
# 244
} CUuuid; 
# 259
typedef 
# 257
struct CUipcEventHandle_st { 
# 258
char reserved[64]; 
# 259
} CUipcEventHandle; 
# 266
typedef 
# 264
struct CUipcMemHandle_st { 
# 265
char reserved[64]; 
# 266
} CUipcMemHandle; 
# 273
typedef 
# 271
enum CUipcMem_flags_enum { 
# 272
CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 1
# 273
} CUipcMem_flags; 
# 284
typedef 
# 280
enum CUmemAttach_flags_enum { 
# 281
CU_MEM_ATTACH_GLOBAL = 1, 
# 282
CU_MEM_ATTACH_HOST, 
# 283
CU_MEM_ATTACH_SINGLE = 4
# 284
} CUmemAttach_flags; 
# 301
typedef 
# 289
enum CUctx_flags_enum { 
# 290
CU_CTX_SCHED_AUTO, 
# 291
CU_CTX_SCHED_SPIN, 
# 292
CU_CTX_SCHED_YIELD, 
# 293
CU_CTX_SCHED_BLOCKING_SYNC = 4, 
# 294
CU_CTX_BLOCKING_SYNC = 4, 
# 297
CU_CTX_SCHED_MASK = 7, 
# 298
CU_CTX_MAP_HOST, 
# 299
CU_CTX_LMEM_RESIZE_TO_MAX = 16, 
# 300
CU_CTX_FLAGS_MASK = 31
# 301
} CUctx_flags; 
# 309
typedef 
# 306
enum CUstream_flags_enum { 
# 307
CU_STREAM_DEFAULT, 
# 308
CU_STREAM_NON_BLOCKING
# 309
} CUstream_flags; 
# 339
typedef 
# 334
enum CUevent_flags_enum { 
# 335
CU_EVENT_DEFAULT, 
# 336
CU_EVENT_BLOCKING_SYNC, 
# 337
CU_EVENT_DISABLE_TIMING, 
# 338
CU_EVENT_INTERPROCESS = 4
# 339
} CUevent_flags; 
# 357
typedef 
# 345
enum CUstreamWaitValue_flags_enum { 
# 346
CU_STREAM_WAIT_VALUE_GEQ, 
# 348
CU_STREAM_WAIT_VALUE_EQ, 
# 349
CU_STREAM_WAIT_VALUE_AND, 
# 350
CU_STREAM_WAIT_VALUE_FLUSH = 1073741824
# 357
} CUstreamWaitValue_flags; 
# 370
typedef 
# 362
enum CUstreamWriteValue_flags_enum { 
# 363
CU_STREAM_WRITE_VALUE_DEFAULT, 
# 364
CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER
# 370
} CUstreamWriteValue_flags; 
# 380
typedef 
# 375
enum CUstreamBatchMemOpType_enum { 
# 376
CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1, 
# 377
CU_STREAM_MEM_OP_WRITE_VALUE_32, 
# 378
CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES
# 380
} CUstreamBatchMemOpType; 
# 412
typedef 
# 385
union CUstreamBatchMemOpParams_union { 
# 386
CUstreamBatchMemOpType operation; 
# 387
struct CUstreamMemOpWaitValueParams_st { 
# 388
CUstreamBatchMemOpType operation; 
# 389
CUdeviceptr address; 
# 390
union { 
# 391
cuuint32_t value; 
# 392
cuuint64_t pad; 
# 393
}; 
# 394
unsigned flags; 
# 395
CUdeviceptr alias; 
# 396
} waitValue; 
# 397
struct CUstreamMemOpWriteValueParams_st { 
# 398
CUstreamBatchMemOpType operation; 
# 399
CUdeviceptr address; 
# 400
union { 
# 401
cuuint32_t value; 
# 402
cuuint64_t pad; 
# 403
}; 
# 404
unsigned flags; 
# 405
CUdeviceptr alias; 
# 406
} writeValue; 
# 407
struct CUstreamMemOpFlushRemoteWritesParams_st { 
# 408
CUstreamBatchMemOpType operation; 
# 409
unsigned flags; 
# 410
} flushRemoteWrites; 
# 411
cuuint64_t pad[6]; 
# 412
} CUstreamBatchMemOpParams; 
# 421
typedef 
# 418
enum CUoccupancy_flags_enum { 
# 419
CU_OCCUPANCY_DEFAULT, 
# 420
CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE
# 421
} CUoccupancy_flags; 
# 435
typedef 
# 426
enum CUarray_format_enum { 
# 427
CU_AD_FORMAT_UNSIGNED_INT8 = 1, 
# 428
CU_AD_FORMAT_UNSIGNED_INT16, 
# 429
CU_AD_FORMAT_UNSIGNED_INT32, 
# 430
CU_AD_FORMAT_SIGNED_INT8 = 8, 
# 431
CU_AD_FORMAT_SIGNED_INT16, 
# 432
CU_AD_FORMAT_SIGNED_INT32, 
# 433
CU_AD_FORMAT_HALF = 16, 
# 434
CU_AD_FORMAT_FLOAT = 32
# 435
} CUarray_format; 
# 445
typedef 
# 440
enum CUaddress_mode_enum { 
# 441
CU_TR_ADDRESS_MODE_WRAP, 
# 442
CU_TR_ADDRESS_MODE_CLAMP, 
# 443
CU_TR_ADDRESS_MODE_MIRROR, 
# 444
CU_TR_ADDRESS_MODE_BORDER
# 445
} CUaddress_mode; 
# 453
typedef 
# 450
enum CUfilter_mode_enum { 
# 451
CU_TR_FILTER_MODE_POINT, 
# 452
CU_TR_FILTER_MODE_LINEAR
# 453
} CUfilter_mode; 
# 556
typedef 
# 458
enum CUdevice_attribute_enum { 
# 459
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1, 
# 460
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X, 
# 461
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y, 
# 462
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z, 
# 463
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X, 
# 464
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y, 
# 465
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z, 
# 466
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK, 
# 467
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8, 
# 468
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY, 
# 469
CU_DEVICE_ATTRIBUTE_WARP_SIZE, 
# 470
CU_DEVICE_ATTRIBUTE_MAX_PITCH, 
# 471
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, 
# 472
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12, 
# 473
CU_DEVICE_ATTRIBUTE_CLOCK_RATE, 
# 474
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT, 
# 475
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, 
# 476
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, 
# 477
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, 
# 478
CU_DEVICE_ATTRIBUTE_INTEGRATED, 
# 479
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, 
# 480
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, 
# 481
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH, 
# 482
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH, 
# 483
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT, 
# 484
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH, 
# 485
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT, 
# 486
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH, 
# 487
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH, 
# 488
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT, 
# 489
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS, 
# 490
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27, 
# 491
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT, 
# 492
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES, 
# 493
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, 
# 494
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, 
# 495
CU_DEVICE_ATTRIBUTE_ECC_ENABLED, 
# 496
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, 
# 497
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, 
# 498
CU_DEVICE_ATTRIBUTE_TCC_DRIVER, 
# 499
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, 
# 500
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, 
# 501
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, 
# 502
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, 
# 503
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, 
# 504
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, 
# 505
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH, 
# 506
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS, 
# 507
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER, 
# 508
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH, 
# 509
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT, 
# 510
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE, 
# 511
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE, 
# 512
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE, 
# 513
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, 
# 514
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT, 
# 515
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH, 
# 516
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH, 
# 517
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS, 
# 518
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH, 
# 519
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH, 
# 520
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT, 
# 521
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH, 
# 522
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT, 
# 523
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH, 
# 524
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH, 
# 525
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS, 
# 526
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH, 
# 527
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT, 
# 528
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS, 
# 529
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH, 
# 530
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH, 
# 531
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS, 
# 532
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH, 
# 533
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH, 
# 534
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT, 
# 535
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH, 
# 536
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH, 
# 537
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT, 
# 538
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR, 
# 539
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR, 
# 540
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH, 
# 541
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED, 
# 542
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED, 
# 543
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED, 
# 544
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR, 
# 545
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR, 
# 546
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY, 
# 547
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD, 
# 548
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID, 
# 549
CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED, 
# 550
CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO, 
# 551
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS, 
# 552
CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS, 
# 553
CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED, 
# 554
CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM, 
# 555
CU_DEVICE_ATTRIBUTE_MAX
# 556
} CUdevice_attribute; 
# 572
typedef 
# 561
struct CUdevprop_st { 
# 562
int maxThreadsPerBlock; 
# 563
int maxThreadsDim[3]; 
# 564
int maxGridSize[3]; 
# 565
int sharedMemPerBlock; 
# 566
int totalConstantMemory; 
# 567
int SIMDWidth; 
# 568
int memPitch; 
# 569
int regsPerBlock; 
# 570
int clockRate; 
# 571
int textureAlign; 
# 572
} CUdevprop; 
# 586
typedef 
# 577
enum CUpointer_attribute_enum { 
# 578
CU_POINTER_ATTRIBUTE_CONTEXT = 1, 
# 579
CU_POINTER_ATTRIBUTE_MEMORY_TYPE, 
# 580
CU_POINTER_ATTRIBUTE_DEVICE_POINTER, 
# 581
CU_POINTER_ATTRIBUTE_HOST_POINTER, 
# 582
CU_POINTER_ATTRIBUTE_P2P_TOKENS, 
# 583
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, 
# 584
CU_POINTER_ATTRIBUTE_BUFFER_ID, 
# 585
CU_POINTER_ATTRIBUTE_IS_MANAGED
# 586
} CUpointer_attribute; 
# 647
typedef 
# 591
enum CUfunction_attribute_enum { 
# 597
CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, 
# 604
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES, 
# 610
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES, 
# 615
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, 
# 620
CU_FUNC_ATTRIBUTE_NUM_REGS, 
# 629
CU_FUNC_ATTRIBUTE_PTX_VERSION, 
# 638
CU_FUNC_ATTRIBUTE_BINARY_VERSION, 
# 644
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA, 
# 646
CU_FUNC_ATTRIBUTE_MAX
# 647
} CUfunction_attribute; 
# 657
typedef 
# 652
enum CUfunc_cache_enum { 
# 653
CU_FUNC_CACHE_PREFER_NONE, 
# 654
CU_FUNC_CACHE_PREFER_SHARED, 
# 655
CU_FUNC_CACHE_PREFER_L1, 
# 656
CU_FUNC_CACHE_PREFER_EQUAL
# 657
} CUfunc_cache; 
# 666
typedef 
# 662
enum CUsharedconfig_enum { 
# 663
CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE, 
# 664
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE, 
# 665
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE
# 666
} CUsharedconfig; 
# 676
typedef 
# 671
enum CUmemorytype_enum { 
# 672
CU_MEMORYTYPE_HOST = 1, 
# 673
CU_MEMORYTYPE_DEVICE, 
# 674
CU_MEMORYTYPE_ARRAY, 
# 675
CU_MEMORYTYPE_UNIFIED
# 676
} CUmemorytype; 
# 685
typedef 
# 681
enum CUcomputemode_enum { 
# 682
CU_COMPUTEMODE_DEFAULT, 
# 683
CU_COMPUTEMODE_PROHIBITED = 2, 
# 684
CU_COMPUTEMODE_EXCLUSIVE_PROCESS
# 685
} CUcomputemode; 
# 697
typedef 
# 690
enum CUmem_advise_enum { 
# 691
CU_MEM_ADVISE_SET_READ_MOSTLY = 1, 
# 692
CU_MEM_ADVISE_UNSET_READ_MOSTLY, 
# 693
CU_MEM_ADVISE_SET_PREFERRED_LOCATION, 
# 694
CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION, 
# 695
CU_MEM_ADVISE_SET_ACCESSED_BY, 
# 696
CU_MEM_ADVISE_UNSET_ACCESSED_BY
# 697
} CUmem_advise; 
# 704
typedef 
# 699
enum CUmem_range_attribute_enum { 
# 700
CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1, 
# 701
CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION, 
# 702
CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY, 
# 703
CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION
# 704
} CUmem_range_attribute; 
# 848
typedef 
# 709
enum CUjit_option_enum { 
# 716
CU_JIT_MAX_REGISTERS, 
# 731
CU_JIT_THREADS_PER_BLOCK, 
# 739
CU_JIT_WALL_TIME, 
# 748
CU_JIT_INFO_LOG_BUFFER, 
# 757
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES, 
# 766
CU_JIT_ERROR_LOG_BUFFER, 
# 775
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES, 
# 783
CU_JIT_OPTIMIZATION_LEVEL, 
# 791
CU_JIT_TARGET_FROM_CUCONTEXT, 
# 799
CU_JIT_TARGET, 
# 808
CU_JIT_FALLBACK_STRATEGY, 
# 816
CU_JIT_GENERATE_DEBUG_INFO, 
# 823
CU_JIT_LOG_VERBOSE, 
# 830
CU_JIT_GENERATE_LINE_INFO, 
# 838
CU_JIT_CACHE_MODE, 
# 843
CU_JIT_NEW_SM3X_OPT, 
# 844
CU_JIT_FAST_COMPILE, 
# 846
CU_JIT_NUM_OPTIONS
# 848
} CUjit_option; 
# 871
typedef 
# 853
enum CUjit_target_enum { 
# 855
CU_TARGET_COMPUTE_10 = 10, 
# 856
CU_TARGET_COMPUTE_11, 
# 857
CU_TARGET_COMPUTE_12, 
# 858
CU_TARGET_COMPUTE_13, 
# 859
CU_TARGET_COMPUTE_20 = 20, 
# 860
CU_TARGET_COMPUTE_21, 
# 861
CU_TARGET_COMPUTE_30 = 30, 
# 862
CU_TARGET_COMPUTE_32 = 32, 
# 863
CU_TARGET_COMPUTE_35 = 35, 
# 864
CU_TARGET_COMPUTE_37 = 37, 
# 865
CU_TARGET_COMPUTE_50 = 50, 
# 866
CU_TARGET_COMPUTE_52 = 52, 
# 867
CU_TARGET_COMPUTE_53, 
# 868
CU_TARGET_COMPUTE_60 = 60, 
# 869
CU_TARGET_COMPUTE_61, 
# 870
CU_TARGET_COMPUTE_62
# 871
} CUjit_target; 
# 882
typedef 
# 876
enum CUjit_fallback_enum { 
# 878
CU_PREFER_PTX, 
# 880
CU_PREFER_BINARY
# 882
} CUjit_fallback; 
# 892
typedef 
# 887
enum CUjit_cacheMode_enum { 
# 889
CU_JIT_CACHE_OPTION_NONE, 
# 890
CU_JIT_CACHE_OPTION_CG, 
# 891
CU_JIT_CACHE_OPTION_CA
# 892
} CUjit_cacheMode; 
# 930
typedef 
# 897
enum CUjitInputType_enum { 
# 903
CU_JIT_INPUT_CUBIN, 
# 909
CU_JIT_INPUT_PTX, 
# 915
CU_JIT_INPUT_FATBINARY, 
# 921
CU_JIT_INPUT_OBJECT, 
# 927
CU_JIT_INPUT_LIBRARY, 
# 929
CU_JIT_NUM_INPUT_TYPES
# 930
} CUjitInputType; 
# 933
typedef struct CUlinkState_st *CUlinkState; 
# 945
typedef 
# 939
enum CUgraphicsRegisterFlags_enum { 
# 940
CU_GRAPHICS_REGISTER_FLAGS_NONE, 
# 941
CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY, 
# 942
CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD, 
# 943
CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 4, 
# 944
CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 8
# 945
} CUgraphicsRegisterFlags; 
# 954
typedef 
# 950
enum CUgraphicsMapResourceFlags_enum { 
# 951
CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE, 
# 952
CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY, 
# 953
CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD
# 954
} CUgraphicsMapResourceFlags; 
# 966
typedef 
# 959
enum CUarray_cubemap_face_enum { 
# 960
CU_CUBEMAP_FACE_POSITIVE_X, 
# 961
CU_CUBEMAP_FACE_NEGATIVE_X, 
# 962
CU_CUBEMAP_FACE_POSITIVE_Y, 
# 963
CU_CUBEMAP_FACE_NEGATIVE_Y, 
# 964
CU_CUBEMAP_FACE_POSITIVE_Z, 
# 965
CU_CUBEMAP_FACE_NEGATIVE_Z
# 966
} CUarray_cubemap_face; 
# 978
typedef 
# 971
enum CUlimit_enum { 
# 972
CU_LIMIT_STACK_SIZE, 
# 973
CU_LIMIT_PRINTF_FIFO_SIZE, 
# 974
CU_LIMIT_MALLOC_HEAP_SIZE, 
# 975
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH, 
# 976
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT, 
# 977
CU_LIMIT_MAX
# 978
} CUlimit; 
# 988
typedef 
# 983
enum CUresourcetype_enum { 
# 984
CU_RESOURCE_TYPE_ARRAY, 
# 985
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY, 
# 986
CU_RESOURCE_TYPE_LINEAR, 
# 987
CU_RESOURCE_TYPE_PITCH2D
# 988
} CUresourcetype; 
# 1390
typedef 
# 993
enum cudaError_enum { 
# 999
CUDA_SUCCESS, 
# 1005
CUDA_ERROR_INVALID_VALUE, 
# 1011
CUDA_ERROR_OUT_OF_MEMORY, 
# 1017
CUDA_ERROR_NOT_INITIALIZED, 
# 1022
CUDA_ERROR_DEINITIALIZED, 
# 1029
CUDA_ERROR_PROFILER_DISABLED, 
# 1037
CUDA_ERROR_PROFILER_NOT_INITIALIZED, 
# 1044
CUDA_ERROR_PROFILER_ALREADY_STARTED, 
# 1051
CUDA_ERROR_PROFILER_ALREADY_STOPPED, 
# 1057
CUDA_ERROR_NO_DEVICE = 100, 
# 1063
CUDA_ERROR_INVALID_DEVICE, 
# 1070
CUDA_ERROR_INVALID_IMAGE = 200, 
# 1080
CUDA_ERROR_INVALID_CONTEXT, 
# 1089
CUDA_ERROR_CONTEXT_ALREADY_CURRENT, 
# 1094
CUDA_ERROR_MAP_FAILED = 205, 
# 1099
CUDA_ERROR_UNMAP_FAILED, 
# 1105
CUDA_ERROR_ARRAY_IS_MAPPED, 
# 1110
CUDA_ERROR_ALREADY_MAPPED, 
# 1118
CUDA_ERROR_NO_BINARY_FOR_GPU, 
# 1123
CUDA_ERROR_ALREADY_ACQUIRED, 
# 1128
CUDA_ERROR_NOT_MAPPED, 
# 1134
CUDA_ERROR_NOT_MAPPED_AS_ARRAY, 
# 1140
CUDA_ERROR_NOT_MAPPED_AS_POINTER, 
# 1146
CUDA_ERROR_ECC_UNCORRECTABLE, 
# 1152
CUDA_ERROR_UNSUPPORTED_LIMIT, 
# 1159
CUDA_ERROR_CONTEXT_ALREADY_IN_USE, 
# 1165
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED, 
# 1170
CUDA_ERROR_INVALID_PTX, 
# 1175
CUDA_ERROR_INVALID_GRAPHICS_CONTEXT, 
# 1181
CUDA_ERROR_NVLINK_UNCORRECTABLE, 
# 1186
CUDA_ERROR_INVALID_SOURCE = 300, 
# 1191
CUDA_ERROR_FILE_NOT_FOUND, 
# 1196
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND, 
# 1201
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED, 
# 1206
CUDA_ERROR_OPERATING_SYSTEM, 
# 1212
CUDA_ERROR_INVALID_HANDLE = 400, 
# 1218
CUDA_ERROR_NOT_FOUND = 500, 
# 1226
CUDA_ERROR_NOT_READY = 600, 
# 1235
CUDA_ERROR_ILLEGAL_ADDRESS = 700, 
# 1246
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES, 
# 1257
CUDA_ERROR_LAUNCH_TIMEOUT, 
# 1263
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING, 
# 1270
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED, 
# 1277
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED, 
# 1283
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708, 
# 1290
CUDA_ERROR_CONTEXT_IS_DESTROYED, 
# 1298
CUDA_ERROR_ASSERT, 
# 1305
CUDA_ERROR_TOO_MANY_PEERS, 
# 1311
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED, 
# 1317
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED, 
# 1326
CUDA_ERROR_HARDWARE_STACK_ERROR, 
# 1334
CUDA_ERROR_ILLEGAL_INSTRUCTION, 
# 1343
CUDA_ERROR_MISALIGNED_ADDRESS, 
# 1354
CUDA_ERROR_INVALID_ADDRESS_SPACE, 
# 1362
CUDA_ERROR_INVALID_PC, 
# 1372
CUDA_ERROR_LAUNCH_FAILED, 
# 1378
CUDA_ERROR_NOT_PERMITTED = 800, 
# 1384
CUDA_ERROR_NOT_SUPPORTED, 
# 1389
CUDA_ERROR_UNKNOWN = 999
# 1390
} CUresult; 
# 1399
typedef 
# 1395
enum CUdevice_P2PAttribute_enum { 
# 1396
CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 1, 
# 1397
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED, 
# 1398
CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED
# 1399
} CUdevice_P2PAttribute; 
# 1413
typedef void (*CUstreamCallback)(CUstream hStream, CUresult status, void * userData); 
# 1421
typedef size_t (*CUoccupancyB2DSize)(int blockSize); 
# 1497
typedef 
# 1476
struct CUDA_MEMCPY2D_st { 
# 1477
size_t srcXInBytes; 
# 1478
size_t srcY; 
# 1480
CUmemorytype srcMemoryType; 
# 1481
const void *srcHost; 
# 1482
CUdeviceptr srcDevice; 
# 1483
CUarray srcArray; 
# 1484
size_t srcPitch; 
# 1486
size_t dstXInBytes; 
# 1487
size_t dstY; 
# 1489
CUmemorytype dstMemoryType; 
# 1490
void *dstHost; 
# 1491
CUdeviceptr dstDevice; 
# 1492
CUarray dstArray; 
# 1493
size_t dstPitch; 
# 1495
size_t WidthInBytes; 
# 1496
size_t Height; 
# 1497
} CUDA_MEMCPY2D; 
# 1530
typedef 
# 1502
struct CUDA_MEMCPY3D_st { 
# 1503
size_t srcXInBytes; 
# 1504
size_t srcY; 
# 1505
size_t srcZ; 
# 1506
size_t srcLOD; 
# 1507
CUmemorytype srcMemoryType; 
# 1508
const void *srcHost; 
# 1509
CUdeviceptr srcDevice; 
# 1510
CUarray srcArray; 
# 1511
void *reserved0; 
# 1512
size_t srcPitch; 
# 1513
size_t srcHeight; 
# 1515
size_t dstXInBytes; 
# 1516
size_t dstY; 
# 1517
size_t dstZ; 
# 1518
size_t dstLOD; 
# 1519
CUmemorytype dstMemoryType; 
# 1520
void *dstHost; 
# 1521
CUdeviceptr dstDevice; 
# 1522
CUarray dstArray; 
# 1523
void *reserved1; 
# 1524
size_t dstPitch; 
# 1525
size_t dstHeight; 
# 1527
size_t WidthInBytes; 
# 1528
size_t Height; 
# 1529
size_t Depth; 
# 1530
} CUDA_MEMCPY3D; 
# 1563
typedef 
# 1535
struct CUDA_MEMCPY3D_PEER_st { 
# 1536
size_t srcXInBytes; 
# 1537
size_t srcY; 
# 1538
size_t srcZ; 
# 1539
size_t srcLOD; 
# 1540
CUmemorytype srcMemoryType; 
# 1541
const void *srcHost; 
# 1542
CUdeviceptr srcDevice; 
# 1543
CUarray srcArray; 
# 1544
CUcontext srcContext; 
# 1545
size_t srcPitch; 
# 1546
size_t srcHeight; 
# 1548
size_t dstXInBytes; 
# 1549
size_t dstY; 
# 1550
size_t dstZ; 
# 1551
size_t dstLOD; 
# 1552
CUmemorytype dstMemoryType; 
# 1553
void *dstHost; 
# 1554
CUdeviceptr dstDevice; 
# 1555
CUarray dstArray; 
# 1556
CUcontext dstContext; 
# 1557
size_t dstPitch; 
# 1558
size_t dstHeight; 
# 1560
size_t WidthInBytes; 
# 1561
size_t Height; 
# 1562
size_t Depth; 
# 1563
} CUDA_MEMCPY3D_PEER; 
# 1575
typedef 
# 1568
struct CUDA_ARRAY_DESCRIPTOR_st { 
# 1570
size_t Width; 
# 1571
size_t Height; 
# 1573
CUarray_format Format; 
# 1574
unsigned NumChannels; 
# 1575
} CUDA_ARRAY_DESCRIPTOR; 
# 1589
typedef 
# 1580
struct CUDA_ARRAY3D_DESCRIPTOR_st { 
# 1582
size_t Width; 
# 1583
size_t Height; 
# 1584
size_t Depth; 
# 1586
CUarray_format Format; 
# 1587
unsigned NumChannels; 
# 1588
unsigned Flags; 
# 1589
} CUDA_ARRAY3D_DESCRIPTOR; 
# 1629
typedef 
# 1598
struct CUDA_RESOURCE_DESC_st { 
# 1600
CUresourcetype resType; 
# 1602
union { 
# 1603
struct { 
# 1604
CUarray hArray; 
# 1605
} array; 
# 1606
struct { 
# 1607
CUmipmappedArray hMipmappedArray; 
# 1608
} mipmap; 
# 1609
struct { 
# 1610
CUdeviceptr devPtr; 
# 1611
CUarray_format format; 
# 1612
unsigned numChannels; 
# 1613
size_t sizeInBytes; 
# 1614
} linear; 
# 1615
struct { 
# 1616
CUdeviceptr devPtr; 
# 1617
CUarray_format format; 
# 1618
unsigned numChannels; 
# 1619
size_t width; 
# 1620
size_t height; 
# 1621
size_t pitchInBytes; 
# 1622
} pitch2D; 
# 1623
struct { 
# 1624
int reserved[32]; 
# 1625
} reserved; 
# 1626
} res; 
# 1628
unsigned flags; 
# 1629
} CUDA_RESOURCE_DESC; 
# 1645
typedef 
# 1634
struct CUDA_TEXTURE_DESC_st { 
# 1635
CUaddress_mode addressMode[3]; 
# 1636
CUfilter_mode filterMode; 
# 1637
unsigned flags; 
# 1638
unsigned maxAnisotropy; 
# 1639
CUfilter_mode mipmapFilterMode; 
# 1640
float mipmapLevelBias; 
# 1641
float minMipmapLevelClamp; 
# 1642
float maxMipmapLevelClamp; 
# 1643
float borderColor[4]; 
# 1644
int reserved[12]; 
# 1645
} CUDA_TEXTURE_DESC; 
# 1687
typedef 
# 1650
enum CUresourceViewFormat_enum { 
# 1652
CU_RES_VIEW_FORMAT_NONE, 
# 1653
CU_RES_VIEW_FORMAT_UINT_1X8, 
# 1654
CU_RES_VIEW_FORMAT_UINT_2X8, 
# 1655
CU_RES_VIEW_FORMAT_UINT_4X8, 
# 1656
CU_RES_VIEW_FORMAT_SINT_1X8, 
# 1657
CU_RES_VIEW_FORMAT_SINT_2X8, 
# 1658
CU_RES_VIEW_FORMAT_SINT_4X8, 
# 1659
CU_RES_VIEW_FORMAT_UINT_1X16, 
# 1660
CU_RES_VIEW_FORMAT_UINT_2X16, 
# 1661
CU_RES_VIEW_FORMAT_UINT_4X16, 
# 1662
CU_RES_VIEW_FORMAT_SINT_1X16, 
# 1663
CU_RES_VIEW_FORMAT_SINT_2X16, 
# 1664
CU_RES_VIEW_FORMAT_SINT_4X16, 
# 1665
CU_RES_VIEW_FORMAT_UINT_1X32, 
# 1666
CU_RES_VIEW_FORMAT_UINT_2X32, 
# 1667
CU_RES_VIEW_FORMAT_UINT_4X32, 
# 1668
CU_RES_VIEW_FORMAT_SINT_1X32, 
# 1669
CU_RES_VIEW_FORMAT_SINT_2X32, 
# 1670
CU_RES_VIEW_FORMAT_SINT_4X32, 
# 1671
CU_RES_VIEW_FORMAT_FLOAT_1X16, 
# 1672
CU_RES_VIEW_FORMAT_FLOAT_2X16, 
# 1673
CU_RES_VIEW_FORMAT_FLOAT_4X16, 
# 1674
CU_RES_VIEW_FORMAT_FLOAT_1X32, 
# 1675
CU_RES_VIEW_FORMAT_FLOAT_2X32, 
# 1676
CU_RES_VIEW_FORMAT_FLOAT_4X32, 
# 1677
CU_RES_VIEW_FORMAT_UNSIGNED_BC1, 
# 1678
CU_RES_VIEW_FORMAT_UNSIGNED_BC2, 
# 1679
CU_RES_VIEW_FORMAT_UNSIGNED_BC3, 
# 1680
CU_RES_VIEW_FORMAT_UNSIGNED_BC4, 
# 1681
CU_RES_VIEW_FORMAT_SIGNED_BC4, 
# 1682
CU_RES_VIEW_FORMAT_UNSIGNED_BC5, 
# 1683
CU_RES_VIEW_FORMAT_SIGNED_BC5, 
# 1684
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H, 
# 1685
CU_RES_VIEW_FORMAT_SIGNED_BC6H, 
# 1686
CU_RES_VIEW_FORMAT_UNSIGNED_BC7
# 1687
} CUresourceViewFormat; 
# 1703
typedef 
# 1692
struct CUDA_RESOURCE_VIEW_DESC_st { 
# 1694
CUresourceViewFormat format; 
# 1695
size_t width; 
# 1696
size_t height; 
# 1697
size_t depth; 
# 1698
unsigned firstMipmapLevel; 
# 1699
unsigned lastMipmapLevel; 
# 1700
unsigned firstLayer; 
# 1701
unsigned lastLayer; 
# 1702
unsigned reserved[16]; 
# 1703
} CUDA_RESOURCE_VIEW_DESC; 
# 1711
typedef 
# 1708
struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st { 
# 1709
unsigned long long p2pToken; 
# 1710
unsigned vaSpaceToken; 
# 1711
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS; 
# 1858
CUresult cuGetErrorString(CUresult error, const char ** pStr); 
# 1877
CUresult cuGetErrorName(CUresult error, const char ** pStr); 
# 1909
CUresult cuInit(unsigned Flags); 
# 1939
CUresult cuDriverGetVersion(int * driverVersion); 
# 1979
CUresult cuDeviceGet(CUdevice * device, int ordinal); 
# 2004
CUresult cuDeviceGetCount(int * count); 
# 2032
CUresult cuDeviceGetName(char * name, int len, CUdevice dev); 
# 2059
CUresult cuDeviceTotalMem_v2(size_t * bytes, CUdevice dev); 
# 2254
CUresult cuDeviceGetAttribute(int * pi, CUdevice_attribute attrib, CUdevice dev); 
# 2331
CUresult cuDeviceGetProperties(CUdevprop * prop, CUdevice dev); 
# 2364
CUresult cuDeviceComputeCapability(int * major, int * minor, CUdevice dev); 
# 2432
CUresult cuDevicePrimaryCtxRetain(CUcontext * pctx, CUdevice dev); 
# 2466
CUresult cuDevicePrimaryCtxRelease(CUdevice dev); 
# 2529
CUresult cuDevicePrimaryCtxSetFlags(CUdevice dev, unsigned flags); 
# 2553
CUresult cuDevicePrimaryCtxGetState(CUdevice dev, unsigned * flags, int * active); 
# 2591
CUresult cuDevicePrimaryCtxReset(CUdevice dev); 
# 2697
CUresult cuCtxCreate_v2(CUcontext * pctx, unsigned flags, CUdevice dev); 
# 2737
CUresult cuCtxDestroy_v2(CUcontext ctx); 
# 2773
CUresult cuCtxPushCurrent_v2(CUcontext ctx); 
# 2807
CUresult cuCtxPopCurrent_v2(CUcontext * pctx); 
# 2833
CUresult cuCtxSetCurrent(CUcontext ctx); 
# 2852
CUresult cuCtxGetCurrent(CUcontext * pctx); 
# 2882
CUresult cuCtxGetDevice(CUdevice * device); 
# 2910
CUresult cuCtxGetFlags(unsigned * flags); 
# 2940
CUresult cuCtxSynchronize(); 
# 3035
CUresult cuCtxSetLimit(CUlimit limit, size_t value); 
# 3074
CUresult cuCtxGetLimit(size_t * pvalue, CUlimit limit); 
# 3117
CUresult cuCtxGetCacheConfig(CUfunc_cache * pconfig); 
# 3167
CUresult cuCtxSetCacheConfig(CUfunc_cache config); 
# 3209
CUresult cuCtxGetSharedMemConfig(CUsharedconfig * pConfig); 
# 3261
CUresult cuCtxSetSharedMemConfig(CUsharedconfig config); 
# 3299
CUresult cuCtxGetApiVersion(CUcontext ctx, unsigned * version); 
# 3338
CUresult cuCtxGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 3393
CUresult cuCtxAttach(CUcontext * pctx, unsigned flags); 
# 3429
CUresult cuCtxDetach(CUcontext ctx); 
# 3483
CUresult cuModuleLoad(CUmodule * module, const char * fname); 
# 3519
CUresult cuModuleLoadData(CUmodule * module, const void * image); 
# 3561
CUresult cuModuleLoadDataEx(CUmodule * module, const void * image, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 3602
CUresult cuModuleLoadFatBinary(CUmodule * module, const void * fatCubin); 
# 3627
CUresult cuModuleUnload(CUmodule hmod); 
# 3657
CUresult cuModuleGetFunction(CUfunction * hfunc, CUmodule hmod, const char * name); 
# 3691
CUresult cuModuleGetGlobal_v2(CUdeviceptr * dptr, size_t * bytes, CUmodule hmod, const char * name); 
# 3725
CUresult cuModuleGetTexRef(CUtexref * pTexRef, CUmodule hmod, const char * name); 
# 3756
CUresult cuModuleGetSurfRef(CUsurfref * pSurfRef, CUmodule hmod, const char * name); 
# 3798
CUresult cuLinkCreate_v2(unsigned numOptions, CUjit_option * options, void ** optionValues, CUlinkState * stateOut); 
# 3835
CUresult cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void * data, size_t size, const char * name, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 3874
CUresult cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char * path, unsigned numOptions, CUjit_option * options, void ** optionValues); 
# 3901
CUresult cuLinkComplete(CUlinkState state, void ** cubinOut, size_t * sizeOut); 
# 3915
CUresult cuLinkDestroy(CUlinkState state); 
# 3963
CUresult cuMemGetInfo_v2(size_t * free, size_t * total); 
# 3996
CUresult cuMemAlloc_v2(CUdeviceptr * dptr, size_t bytesize); 
# 4057
CUresult cuMemAllocPitch_v2(CUdeviceptr * dptr, size_t * pPitch, size_t WidthInBytes, size_t Height, unsigned ElementSizeBytes); 
# 4086
CUresult cuMemFree_v2(CUdeviceptr dptr); 
# 4119
CUresult cuMemGetAddressRange_v2(CUdeviceptr * pbase, size_t * psize, CUdeviceptr dptr); 
# 4165
CUresult cuMemAllocHost_v2(void ** pp, size_t bytesize); 
# 4195
CUresult cuMemFreeHost(void * p); 
# 4277
CUresult cuMemHostAlloc(void ** pp, size_t bytesize, unsigned Flags); 
# 4330
CUresult cuMemHostGetDevicePointer_v2(CUdeviceptr * pdptr, void * p, unsigned Flags); 
# 4355
CUresult cuMemHostGetFlags(unsigned * pFlags, void * p); 
# 4465
CUresult cuMemAllocManaged(CUdeviceptr * dptr, size_t bytesize, unsigned flags); 
# 4494
CUresult cuDeviceGetByPCIBusId(CUdevice * dev, const char * pciBusId); 
# 4522
CUresult cuDeviceGetPCIBusId(char * pciBusId, int len, CUdevice dev); 
# 4564
CUresult cuIpcGetEventHandle(CUipcEventHandle * pHandle, CUevent event); 
# 4601
CUresult cuIpcOpenEventHandle(CUevent * phEvent, CUipcEventHandle handle); 
# 4638
CUresult cuIpcGetMemHandle(CUipcMemHandle * pHandle, CUdeviceptr dptr); 
# 4689
CUresult cuIpcOpenMemHandle(CUdeviceptr * pdptr, CUipcMemHandle handle, unsigned Flags); 
# 4720
CUresult cuIpcCloseMemHandle(CUdeviceptr dptr); 
# 4803
CUresult cuMemHostRegister_v2(void * p, size_t bytesize, unsigned Flags); 
# 4827
CUresult cuMemHostUnregister(void * p); 
# 4863
CUresult cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount); 
# 4892
CUresult cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount); 
# 4928
CUresult cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount); 
# 4961
CUresult cuMemcpyDtoH_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount); 
# 4994
CUresult cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount); 
# 5029
CUresult cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount); 
# 5066
CUresult cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5101
CUresult cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount); 
# 5136
CUresult cuMemcpyAtoH_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5175
CUresult cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount); 
# 5336
CUresult cuMemcpy2D_v2(const CUDA_MEMCPY2D * pCopy); 
# 5495
CUresult cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D * pCopy); 
# 5663
CUresult cuMemcpy3D_v2(const CUDA_MEMCPY3D * pCopy); 
# 5688
CUresult cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER * pCopy); 
# 5728
CUresult cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream); 
# 5759
CUresult cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream); 
# 5798
CUresult cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void * srcHost, size_t ByteCount, CUstream hStream); 
# 5835
CUresult cuMemcpyDtoHAsync_v2(void * dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
# 5872
CUresult cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream); 
# 5911
CUresult cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void * srcHost, size_t ByteCount, CUstream hStream); 
# 5950
CUresult cuMemcpyAtoHAsync_v2(void * dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream); 
# 6115
CUresult cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D * pCopy, CUstream hStream); 
# 6287
CUresult cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D * pCopy, CUstream hStream); 
# 6314
CUresult cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER * pCopy, CUstream hStream); 
# 6350
CUresult cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N); 
# 6384
CUresult cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N); 
# 6418
CUresult cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned ui, size_t N); 
# 6457
CUresult cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height); 
# 6497
CUresult cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height); 
# 6537
CUresult cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height); 
# 6573
CUresult cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream); 
# 6609
CUresult cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream); 
# 6644
CUresult cuMemsetD32Async(CUdeviceptr dstDevice, unsigned ui, size_t N, CUstream hStream); 
# 6685
CUresult cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream); 
# 6727
CUresult cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream); 
# 6769
CUresult cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned ui, size_t Width, size_t Height, CUstream hStream); 
# 6872
CUresult cuArrayCreate_v2(CUarray * pHandle, const CUDA_ARRAY_DESCRIPTOR * pAllocateArray); 
# 6905
CUresult cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
# 6936
CUresult cuArrayDestroy(CUarray hArray); 
# 7116
CUresult cuArray3DCreate_v2(CUarray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pAllocateArray); 
# 7152
CUresult cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR * pArrayDescriptor, CUarray hArray); 
# 7279
CUresult cuMipmappedArrayCreate(CUmipmappedArray * pHandle, const CUDA_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc, unsigned numMipmapLevels); 
# 7305
CUresult cuMipmappedArrayGetLevel(CUarray * pLevelArray, CUmipmappedArray hMipmappedArray, unsigned level); 
# 7325
CUresult cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray); 
# 7571
CUresult cuPointerGetAttribute(void * data, CUpointer_attribute attribute, CUdeviceptr ptr); 
# 7640
CUresult cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream); 
# 7726
CUresult cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device); 
# 7783
CUresult cuMemRangeGetAttribute(void * data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count); 
# 7822
CUresult cuMemRangeGetAttributes(void ** data, size_t * dataSizes, CUmem_range_attribute * attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count); 
# 7866
CUresult cuPointerSetAttribute(const void * value, CUpointer_attribute attribute, CUdeviceptr ptr); 
# 7908
CUresult cuPointerGetAttributes(unsigned numAttributes, CUpointer_attribute * attributes, void ** data, CUdeviceptr ptr); 
# 7956
CUresult cuStreamCreate(CUstream * phStream, unsigned Flags); 
# 8004
CUresult cuStreamCreateWithPriority(CUstream * phStream, unsigned flags, int priority); 
# 8034
CUresult cuStreamGetPriority(CUstream hStream, int * priority); 
# 8061
CUresult cuStreamGetFlags(CUstream hStream, unsigned * flags); 
# 8102
CUresult cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned Flags); 
# 8173
CUresult cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void * userData, unsigned flags); 
# 8252
CUresult cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned flags); 
# 8283
CUresult cuStreamQuery(CUstream hStream); 
# 8310
CUresult cuStreamSynchronize(CUstream hStream); 
# 8339
CUresult cuStreamDestroy_v2(CUstream hStream); 
# 8394
CUresult cuEventCreate(CUevent * phEvent, unsigned Flags); 
# 8430
CUresult cuEventRecord(CUevent hEvent, CUstream hStream); 
# 8464
CUresult cuEventQuery(CUevent hEvent); 
# 8498
CUresult cuEventSynchronize(CUevent hEvent); 
# 8527
CUresult cuEventDestroy_v2(CUevent hEvent); 
# 8571
CUresult cuEventElapsedTime(float * pMilliseconds, CUevent hStart, CUevent hEnd); 
# 8606
CUresult cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
# 8639
CUresult cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned flags); 
# 8671
CUresult cuStreamBatchMemOp(CUstream stream, unsigned count, CUstreamBatchMemOpParams * paramArray, unsigned flags); 
# 8739
CUresult cuFuncGetAttribute(int * pi, CUfunction_attribute attrib, CUfunction hfunc); 
# 8782
CUresult cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config); 
# 8834
CUresult cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config); 
# 8948
CUresult cuLaunchKernel(CUfunction f, unsigned gridDimX, unsigned gridDimY, unsigned gridDimZ, unsigned blockDimX, unsigned blockDimY, unsigned blockDimZ, unsigned sharedMemBytes, CUstream hStream, void ** kernelParams, void ** extra); 
# 9009
CUresult cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z); 
# 9043
CUresult cuFuncSetSharedSize(CUfunction hfunc, unsigned bytes); 
# 9075
CUresult cuParamSetSize(CUfunction hfunc, unsigned numbytes); 
# 9108
CUresult cuParamSeti(CUfunction hfunc, int offset, unsigned value); 
# 9141
CUresult cuParamSetf(CUfunction hfunc, int offset, float value); 
# 9176
CUresult cuParamSetv(CUfunction hfunc, int offset, void * ptr, unsigned numbytes); 
# 9213
CUresult cuLaunch(CUfunction f); 
# 9252
CUresult cuLaunchGrid(CUfunction f, int grid_width, int grid_height); 
# 9299
CUresult cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream); 
# 9324
CUresult cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef); 
# 9362
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize); 
# 9402
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 9452
CUresult cuOccupancyMaxPotentialBlockSize(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit); 
# 9496
CUresult cuOccupancyMaxPotentialBlockSizeWithFlags(int * minGridSize, int * blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned flags); 
# 9539
CUresult cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned Flags); 
# 9566
CUresult cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned Flags); 
# 9610
CUresult cuTexRefSetAddress_v2(size_t * ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes); 
# 9662
CUresult cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR * desc, CUdeviceptr dptr, size_t Pitch); 
# 9691
CUresult cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents); 
# 9731
CUresult cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am); 
# 9764
CUresult cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
# 9797
CUresult cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm); 
# 9823
CUresult cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias); 
# 9851
CUresult cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp); 
# 9877
CUresult cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned maxAniso); 
# 9907
CUresult cuTexRefSetBorderColor(CUtexref hTexRef, float * pBorderColor); 
# 9942
CUresult cuTexRefSetFlags(CUtexref hTexRef, unsigned Flags); 
# 9968
CUresult cuTexRefGetAddress_v2(CUdeviceptr * pdptr, CUtexref hTexRef); 
# 9994
CUresult cuTexRefGetArray(CUarray * phArray, CUtexref hTexRef); 
# 10019
CUresult cuTexRefGetMipmappedArray(CUmipmappedArray * phMipmappedArray, CUtexref hTexRef); 
# 10045
CUresult cuTexRefGetAddressMode(CUaddress_mode * pam, CUtexref hTexRef, int dim); 
# 10069
CUresult cuTexRefGetFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
# 10095
CUresult cuTexRefGetFormat(CUarray_format * pFormat, int * pNumChannels, CUtexref hTexRef); 
# 10119
CUresult cuTexRefGetMipmapFilterMode(CUfilter_mode * pfm, CUtexref hTexRef); 
# 10143
CUresult cuTexRefGetMipmapLevelBias(float * pbias, CUtexref hTexRef); 
# 10168
CUresult cuTexRefGetMipmapLevelClamp(float * pminMipmapLevelClamp, float * pmaxMipmapLevelClamp, CUtexref hTexRef); 
# 10192
CUresult cuTexRefGetMaxAnisotropy(int * pmaxAniso, CUtexref hTexRef); 
# 10219
CUresult cuTexRefGetBorderColor(float * pBorderColor, CUtexref hTexRef); 
# 10242
CUresult cuTexRefGetFlags(unsigned * pFlags, CUtexref hTexRef); 
# 10281
CUresult cuTexRefCreate(CUtexref * pTexRef); 
# 10301
CUresult cuTexRefDestroy(CUtexref hTexRef); 
# 10340
CUresult cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned Flags); 
# 10361
CUresult cuSurfRefGetArray(CUarray * phArray, CUsurfref hSurfRef); 
# 10583
CUresult cuTexObjectCreate(CUtexObject * pTexObject, const CUDA_RESOURCE_DESC * pResDesc, const CUDA_TEXTURE_DESC * pTexDesc, const CUDA_RESOURCE_VIEW_DESC * pResViewDesc); 
# 10601
CUresult cuTexObjectDestroy(CUtexObject texObject); 
# 10620
CUresult cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUtexObject texObject); 
# 10639
CUresult cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC * pTexDesc, CUtexObject texObject); 
# 10659
CUresult cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC * pResViewDesc, CUtexObject texObject); 
# 10700
CUresult cuSurfObjectCreate(CUsurfObject * pSurfObject, const CUDA_RESOURCE_DESC * pResDesc); 
# 10718
CUresult cuSurfObjectDestroy(CUsurfObject surfObject); 
# 10737
CUresult cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC * pResDesc, CUsurfObject surfObject); 
# 10779
CUresult cuDeviceCanAccessPeer(int * canAccessPeer, CUdevice dev, CUdevice peerDev); 
# 10816
CUresult cuDeviceGetP2PAttribute(int * value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice); 
# 10865
CUresult cuCtxEnablePeerAccess(CUcontext peerContext, unsigned Flags); 
# 10890
CUresult cuCtxDisablePeerAccess(CUcontext peerContext); 
# 10934
CUresult cuGraphicsUnregisterResource(CUgraphicsResource resource); 
# 10972
CUresult cuGraphicsSubResourceGetMappedArray(CUarray * pArray, CUgraphicsResource resource, unsigned arrayIndex, unsigned mipLevel); 
# 11003
CUresult cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray * pMipmappedArray, CUgraphicsResource resource); 
# 11039
CUresult cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr * pDevPtr, size_t * pSize, CUgraphicsResource resource); 
# 11080
CUresult cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned flags); 
# 11119
CUresult cuGraphicsMapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
# 11155
CUresult cuGraphicsUnmapResources(unsigned count, CUgraphicsResource * resources, CUstream hStream); 
# 11159
CUresult cuGetExportTable(const void ** ppExportTable, const CUuuid * pExportTableId); 
# 11478
}
# 24 "/usr/local/cuda/include/thrust/detail/config/global_workarounds.h"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 45 "/usr/local/cuda/include/thrust/detail/type_traits.h"
namespace thrust { 
# 49
template< class T> class device_reference; 
# 51
namespace detail { 
# 54
template< class _Tp, _Tp __v> 
# 55
struct integral_constant { 
# 57
static const _Tp value = __v; 
# 58
typedef _Tp value_type; 
# 59
typedef integral_constant type; 
# 60
}; 
# 63
typedef integral_constant< bool, true>  true_type; 
# 66
typedef integral_constant< bool, false>  false_type; 
# 69
template< class T> struct is_integral : public false_type { }; 
# 70
template<> struct is_integral< bool>  : public true_type { }; 
# 71
template<> struct is_integral< char>  : public true_type { }; 
# 72
template<> struct is_integral< signed char>  : public true_type { }; 
# 73
template<> struct is_integral< unsigned char>  : public true_type { }; 
# 74
template<> struct is_integral< short>  : public true_type { }; 
# 75
template<> struct is_integral< unsigned short>  : public true_type { }; 
# 76
template<> struct is_integral< int>  : public true_type { }; 
# 77
template<> struct is_integral< unsigned>  : public true_type { }; 
# 78
template<> struct is_integral< long>  : public true_type { }; 
# 79
template<> struct is_integral< unsigned long>  : public true_type { }; 
# 80
template<> struct is_integral< long long>  : public true_type { }; 
# 81
template<> struct is_integral< unsigned long long>  : public true_type { }; 
# 82
template<> struct is_integral< const bool>  : public true_type { }; 
# 83
template<> struct is_integral< const char>  : public true_type { }; 
# 84
template<> struct is_integral< const unsigned char>  : public true_type { }; 
# 85
template<> struct is_integral< const short>  : public true_type { }; 
# 86
template<> struct is_integral< const unsigned short>  : public true_type { }; 
# 87
template<> struct is_integral< const int>  : public true_type { }; 
# 88
template<> struct is_integral< const unsigned>  : public true_type { }; 
# 89
template<> struct is_integral< const long>  : public true_type { }; 
# 90
template<> struct is_integral< const unsigned long>  : public true_type { }; 
# 91
template<> struct is_integral< const long long>  : public true_type { }; 
# 92
template<> struct is_integral< const unsigned long long>  : public true_type { }; 
# 94
template< class T> struct is_floating_point : public false_type { }; 
# 95
template<> struct is_floating_point< float>  : public true_type { }; 
# 96
template<> struct is_floating_point< double>  : public true_type { }; 
# 97
template<> struct is_floating_point< long double>  : public true_type { }; 
# 99
template< class T> struct is_arithmetic : public is_integral< T>  { }; 
# 100
template<> struct is_arithmetic< float>  : public true_type { }; 
# 101
template<> struct is_arithmetic< double>  : public true_type { }; 
# 102
template<> struct is_arithmetic< const float>  : public true_type { }; 
# 103
template<> struct is_arithmetic< const double>  : public true_type { }; 
# 105
template< class T> struct is_pointer : public false_type { }; 
# 106
template< class T> struct is_pointer< T *>  : public true_type { }; 
# 108
template< class T> struct is_device_ptr : public false_type { }; 
# 110
template< class T> struct is_void : public false_type { }; 
# 111
template<> struct is_void< void>  : public true_type { }; 
# 112
template<> struct is_void< const void>  : public true_type { }; 
# 115
namespace tt_detail { 
# 119
}
# 121
template< class T> struct is_pod : public integral_constant< bool, ((is_void< T> ::value || is_pointer< T> ::value) || is_arithmetic< T> ::value) || __is_pod(T)>  { 
# 135
}; 
# 138
template< class T> struct has_trivial_constructor : public integral_constant< bool, is_pod< T> ::value || __has_trivial_constructor(T)>  { 
# 151
}; 
# 153
template< class T> struct has_trivial_copy_constructor : public integral_constant< bool, is_pod< T> ::value || __has_trivial_copy(T)>  { 
# 166
}; 
# 168
template< class T> struct has_trivial_destructor : public is_pod< T>  { }; 
# 170
template< class T> struct is_const : public false_type { }; 
# 171
template< class T> struct is_const< const T>  : public true_type { }; 
# 173
template< class T> struct is_volatile : public false_type { }; 
# 174
template< class T> struct is_volatile< volatile T>  : public true_type { }; 
# 176
template< class T> 
# 177
struct add_const { 
# 179
typedef const T type; 
# 180
}; 
# 182
template< class T> 
# 183
struct remove_const { 
# 185
typedef T type; 
# 186
}; 
# 188
template< class T> 
# 189
struct remove_const< const T>  { 
# 191
typedef T type; 
# 192
}; 
# 194
template< class T> 
# 195
struct add_volatile { 
# 197
typedef volatile T type; 
# 198
}; 
# 200
template< class T> 
# 201
struct remove_volatile { 
# 203
typedef T type; 
# 204
}; 
# 206
template< class T> 
# 207
struct remove_volatile< volatile T>  { 
# 209
typedef T type; 
# 210
}; 
# 212
template< class T> 
# 213
struct add_cv { 
# 215
typedef const volatile T type; 
# 216
}; 
# 218
template< class T> 
# 219
struct remove_cv { 
# 221
typedef typename remove_const< typename remove_volatile< T> ::type> ::type type; 
# 222
}; 
# 225
template< class T> struct is_reference : public false_type { }; 
# 226
template< class T> struct is_reference< T &>  : public true_type { }; 
# 228
template< class T> struct is_device_reference : public false_type { }; 
# 229
template< class T> struct is_device_reference< device_reference< T> >  : public true_type { }; 
# 233
template< class _Tp, bool  = is_void< _Tp> ::value || is_reference< _Tp> ::value> 
# 234
struct __add_reference_helper { 
# 235
typedef _Tp &type; }; 
# 237
template< class _Tp> 
# 238
struct __add_reference_helper< _Tp, true>  { 
# 239
typedef _Tp type; }; 
# 241
template< class _Tp> 
# 242
struct add_reference : public __add_reference_helper< _Tp>  { 
# 243
}; 
# 245
template< class T> 
# 246
struct remove_reference { 
# 248
typedef T type; 
# 249
}; 
# 251
template< class T> 
# 252
struct remove_reference< T &>  { 
# 254
typedef T type; 
# 255
}; 
# 257
template< class T1, class T2> 
# 258
struct is_same : public false_type { 
# 261
}; 
# 263
template< class T> 
# 264
struct is_same< T, T>  : public true_type { 
# 267
}; 
# 269
template< class T1, class T2> 
# 270
struct lazy_is_same : public is_same< typename T1::type, typename T2::type>  { 
# 273
}; 
# 275
template< class T1, class T2> 
# 276
struct is_different : public true_type { 
# 279
}; 
# 281
template< class T> 
# 282
struct is_different< T, T>  : public false_type { 
# 285
}; 
# 287
template< class T1, class T2> 
# 288
struct lazy_is_different : public is_different< typename T1::type, typename T2::type>  { 
# 291
}; 
# 293
namespace tt_detail { 
# 296
template< class T> 
# 297
struct is_int_or_cref { 
# 299
typedef typename remove_reference< T> ::type type_sans_ref; 
# 300
static const bool value = (is_integral< T> ::value || (is_integral< typename remove_reference< T> ::type> ::value && is_const< typename remove_reference< T> ::type> ::value && (!is_volatile< typename remove_reference< T> ::type> ::value))); 
# 304
}; 
# 311
template< class From, class To> 
# 312
struct is_convertible_sfinae { 
# 315
private: typedef char yes; 
# 316
typedef struct { char two_chars[2]; } no; 
# 318
static yes test(To) { return yes(); } 
# 319
static no test(...) { return no(); } 
# 320
static typename remove_reference< From> ::type &from() { typename remove_reference< From> ::type *ptr = (0); return *ptr; } 
# 323
public: static const bool value = (sizeof(test((from)())) == sizeof(yes)); 
# 324
}; 
# 331
template< class From, class To> 
# 332
struct is_convertible_needs_simple_test { 
# 334
static const bool from_is_void = (is_void< From> ::value); 
# 335
static const bool to_is_void = (is_void< To> ::value); 
# 336
static const bool from_is_float = (is_floating_point< typename remove_reference< From> ::type> ::value); 
# 337
static const bool to_is_int_or_cref = (is_int_or_cref< To> ::value); 
# 339
static const bool value = ((from_is_void || to_is_void) || (from_is_float && to_is_int_or_cref)); 
# 340
}; 
# 343
template< class From, class To, bool 
# 344
 = is_convertible_needs_simple_test< From, To> ::value> 
# 345
struct is_convertible { 
# 347
static const bool value = (is_void< To> ::value || (is_int_or_cref< To> ::value && (!is_void< From> ::value))); 
# 350
}; 
# 353
template< class From, class To> 
# 354
struct is_convertible< From, To, false>  { 
# 356
static const bool value = (is_convertible_sfinae< typename add_reference< From> ::type, To> ::value); 
# 358
}; 
# 361
}
# 363
template< class From, class To> 
# 364
struct is_convertible : public integral_constant< bool, tt_detail::is_convertible< From, To> ::value>  { 
# 367
}; 
# 370
template< class T1, class T2> 
# 371
struct is_one_convertible_to_the_other : public integral_constant< bool, is_convertible< T1, T2> ::value || is_convertible< T2, T1> ::value>  { 
# 376
}; 
# 381
template< class Condition1, class Condition2, class Condition3 = false_type, class 
# 382
Condition4 = false_type, class Condition5 = false_type, class Condition6 = false_type, class 
# 383
Condition7 = false_type, class Condition8 = false_type, class Condition9 = false_type, class 
# 384
Condition10 = false_type> 
# 385
struct or_ : public integral_constant< bool, ((((((((Condition1::value || Condition2::value) || Condition3::value) || Condition4::value) || Condition5::value) || Condition6::value) || Condition7::value) || Condition8::value) || Condition9::value) || Condition10::value>  { 
# 391
}; 
# 393
template< class Condition1, class Condition2, class Condition3 = true_type> 
# 394
struct and_ : public integral_constant< bool, Condition1::value && Condition2::value && Condition3::value>  { 
# 397
}; 
# 399
template< class Boolean> 
# 400
struct not_ : public integral_constant< bool, !Boolean::value>  { 
# 403
}; 
# 405
template< bool , class Then, class Else> 
# 406
struct eval_if { 
# 408
}; 
# 410
template< class Then, class Else> 
# 411
struct eval_if< true, Then, Else>  { 
# 413
typedef typename Then::type type; 
# 414
}; 
# 416
template< class Then, class Else> 
# 417
struct eval_if< false, Then, Else>  { 
# 419
typedef typename Else::type type; 
# 420
}; 
# 422
template< class T> 
# 425
struct identity_ { 
# 427
typedef T type; 
# 428
}; 
# 430
template< bool , class T = void> struct enable_if { }; 
# 431
template< class T> struct enable_if< true, T>  { typedef T type; }; 
# 433
template< bool , class T> struct lazy_enable_if { }; 
# 434
template< class T> struct lazy_enable_if< true, T>  { typedef typename T::type type; }; 
# 436
template< bool condition, class T = void> struct disable_if : public enable_if< !condition, T>  { }; 
# 437
template< bool condition, class T> struct lazy_disable_if : public lazy_enable_if< !condition, T>  { }; 
# 440
template< class T1, class T2, class T = void> 
# 441
struct enable_if_convertible : public enable_if< is_convertible< T1, T2> ::value, T>  { 
# 443
}; 
# 446
template< class T1, class T2, class T = void> 
# 447
struct disable_if_convertible : public disable_if< is_convertible< T1, T2> ::value, T>  { 
# 449
}; 
# 452
template< class T1, class T2, class Result = void> 
# 453
struct enable_if_different : public enable_if< is_different< T1, T2> ::value, Result>  { 
# 455
}; 
# 458
template< class T> 
# 459
struct is_numeric : public and_< is_convertible< int, T> , is_convertible< T, int> >  { 
# 465
}; 
# 468
template< class > struct is_reference_to_const : public false_type { }; 
# 469
template< class T> struct is_reference_to_const< const T &>  : public true_type { }; 
# 474
namespace tt_detail { 
# 477
template< class T> struct make_unsigned_simple; 
# 479
template<> struct make_unsigned_simple< char>  { typedef unsigned char type; }; 
# 480
template<> struct make_unsigned_simple< signed char>  { typedef signed char type; }; 
# 481
template<> struct make_unsigned_simple< unsigned char>  { typedef unsigned char type; }; 
# 482
template<> struct make_unsigned_simple< short>  { typedef unsigned short type; }; 
# 483
template<> struct make_unsigned_simple< unsigned short>  { typedef unsigned short type; }; 
# 484
template<> struct make_unsigned_simple< int>  { typedef unsigned type; }; 
# 485
template<> struct make_unsigned_simple< unsigned>  { typedef unsigned type; }; 
# 486
template<> struct make_unsigned_simple< long>  { typedef unsigned long type; }; 
# 487
template<> struct make_unsigned_simple< unsigned long>  { typedef unsigned long type; }; 
# 488
template<> struct make_unsigned_simple< long long>  { typedef unsigned long long type; }; 
# 489
template<> struct make_unsigned_simple< unsigned long long>  { typedef unsigned long long type; }; 
# 491
template< class T> 
# 492
struct make_unsigned_base { 
# 495
typedef typename remove_cv< T> ::type remove_cv_t; 
# 498
typedef typename make_unsigned_simple< typename remove_cv< T> ::type> ::type unsigned_remove_cv_t; 
# 518
typedef typename eval_if< is_const< T> ::value && is_volatile< T> ::value, add_cv< typename make_unsigned_simple< typename remove_cv< T> ::type> ::type> , eval_if< is_const< T> ::value, add_const< typename make_unsigned_simple< typename remove_cv< T> ::type> ::type> , eval_if< is_volatile< T> ::value, add_volatile< typename make_unsigned_simple< typename remove_cv< T> ::type> ::type> , identity_< typename make_unsigned_simple< typename remove_cv< T> ::type> ::type> > > > ::type type; 
# 519
}; 
# 521
}
# 523
template< class T> 
# 524
struct make_unsigned : public tt_detail::make_unsigned_base< T>  { 
# 526
}; 
# 528
struct largest_available_float { 
# 537
typedef double type; 
# 539
}; 
# 542
template< class T1, class T2> 
# 543
struct larger_type : public eval_if< (sizeof(T2) > sizeof(T1)), identity_< T2> , identity_< T1> >  { 
# 549
}; 
# 552
namespace is_base_of_ns { 
# 555
typedef char yes; 
# 556
typedef struct { char two_chars[2]; } no; 
# 558
template< class Base, class Derived> 
# 559
struct host { 
# 561
operator Base *() const; 
# 562
operator Derived *(); 
# 563
}; 
# 565
template< class Base, class Derived> 
# 566
struct impl { 
# 568
template< class T> static yes check(Derived *, T); 
# 569
static no check(Base *, int); 
# 571
static const bool value = (sizeof(check(host< Base, Derived> (), ((int)0))) == sizeof(yes)); 
# 572
}; 
# 574
}
# 577
template< class Base, class Derived> 
# 578
struct is_base_of : public integral_constant< bool, is_base_of_ns::impl< Base, Derived> ::value>  { 
# 583
}; 
# 585
template< class Base, class Derived, class Result = void> 
# 586
struct enable_if_base_of : public enable_if< is_base_of< Base, Derived> ::value, Result>  { 
# 591
}; 
# 594
namespace is_assignable_ns { 
# 597
template< class T1, class T2> 
# 598
class is_assignable { 
# 600
typedef char yes_type; 
# 601
typedef struct { char array[2]; } no_type; 
# 603
template< class T> static typename add_reference< T> ::type declval(); 
# 605
template< unsigned > struct helper { typedef void *type; }; 
# 607
template< class U1, class U2> static yes_type test(typename helper< sizeof((declval< U1> () = declval< U2> ()))> ::type); 
# 609
template< class , class > static no_type test(...); 
# 612
public: static const bool value = (sizeof(test< T1, T2> (0)) == (1)); 
# 613
}; 
# 615
}
# 618
template< class T1, class T2> 
# 619
struct is_assignable : public integral_constant< bool, is_assignable_ns::is_assignable< T1, T2> ::value>  { 
# 624
}; 
# 627
template< class T> 
# 628
struct is_copy_assignable : public is_assignable< typename add_reference< T> ::type, typename add_reference< typename add_const< T> ::type> ::type>  { 
# 633
}; 
# 636
template< class T1, class T2, class Enable = void> struct promoted_numerical_type; 
# 638
template< class T1, class T2> 
# 639
struct promoted_numerical_type< T1, T2, typename enable_if< and_< typename is_floating_point< T1> ::type, typename is_floating_point< T2> ::type> ::value> ::type>  { 
# 643
typedef larger_type< T1, T2>  type; 
# 644
}; 
# 646
template< class T1, class T2> 
# 647
struct promoted_numerical_type< T1, T2, typename enable_if< and_< typename is_integral< T1> ::type, typename is_floating_point< T2> ::type> ::value> ::type>  { 
# 651
typedef T2 type; 
# 652
}; 
# 654
template< class T1, class T2> 
# 655
struct promoted_numerical_type< T1, T2, typename enable_if< and_< typename is_floating_point< T1> ::type, typename is_integral< T2> ::type> ::value> ::type>  { 
# 659
typedef T1 type; 
# 660
}; 
# 662
}
# 664
}
# 28 "/usr/local/cuda/include/thrust/detail/type_traits/has_trivial_assign.h"
namespace thrust { 
# 31
namespace detail { 
# 34
template< class T> struct has_trivial_assign : public integral_constant< bool, (is_pod< T> ::value && (!is_const< T> ::value)) || __has_trivial_assign(T)>  { 
# 47
}; 
# 49
}
# 51
}
# 22 "/usr/local/cuda/include/thrust/detail/type_traits/is_metafunction_defined.h"
namespace thrust { 
# 25
namespace detail { 
# 28
template< class T> struct is_metafunction_defined { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 30
template< class Metafunction> 
# 31
struct enable_if_defined : public lazy_enable_if< is_metafunction_defined< Metafunction> ::value, Metafunction>  { 
# 36
}; 
# 38
}
# 40
}
# 70 "/usr/include/c++/5/bits/stl_iterator_base_types.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 89
struct input_iterator_tag { }; 
# 92
struct output_iterator_tag { }; 
# 95
struct forward_iterator_tag : public input_iterator_tag { }; 
# 99
struct bidirectional_iterator_tag : public forward_iterator_tag { }; 
# 103
struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
# 116
template< class _Category, class _Tp, class _Distance = ptrdiff_t, class 
# 117
_Pointer = _Tp *, class _Reference = _Tp &> 
# 118
struct iterator { 
# 121
typedef _Category iterator_category; 
# 123
typedef _Tp value_type; 
# 125
typedef _Distance difference_type; 
# 127
typedef _Pointer pointer; 
# 129
typedef _Reference reference; 
# 130
}; 
# 165
template< class _Iterator> 
# 166
struct iterator_traits { 
# 168
typedef typename _Iterator::iterator_category iterator_category; 
# 169
typedef typename _Iterator::value_type value_type; 
# 170
typedef typename _Iterator::difference_type difference_type; 
# 171
typedef typename _Iterator::pointer pointer; 
# 172
typedef typename _Iterator::reference reference; 
# 173
}; 
# 177
template< class _Tp> 
# 178
struct iterator_traits< _Tp *>  { 
# 180
typedef random_access_iterator_tag iterator_category; 
# 181
typedef _Tp value_type; 
# 182
typedef ptrdiff_t difference_type; 
# 183
typedef _Tp *pointer; 
# 184
typedef _Tp &reference; 
# 185
}; 
# 188
template< class _Tp> 
# 189
struct iterator_traits< const _Tp *>  { 
# 191
typedef random_access_iterator_tag iterator_category; 
# 192
typedef _Tp value_type; 
# 193
typedef ptrdiff_t difference_type; 
# 194
typedef const _Tp *pointer; 
# 195
typedef const _Tp &reference; 
# 196
}; 
# 202
template< class _Iter> inline typename iterator_traits< _Iter> ::iterator_category 
# 204
__iterator_category(const _Iter &) 
# 205
{ return typename iterator_traits< _Iter> ::iterator_category(); } 
# 211
template< class _Iterator, bool _HasBase> 
# 212
struct _Iter_base { 
# 214
typedef _Iterator iterator_type; 
# 215
static iterator_type _S_base(_Iterator __it) 
# 216
{ return __it; } 
# 217
}; 
# 219
template< class _Iterator> 
# 220
struct _Iter_base< _Iterator, true>  { 
# 222
typedef typename _Iterator::iterator_type iterator_type; 
# 223
static iterator_type _S_base(_Iterator __it) 
# 224
{ return (__it.base()); } 
# 225
}; 
# 236
}
# 46 "/usr/include/c++/5/debug/debug.h" 3
namespace std { 
# 48
namespace __debug { }
# 49
}
# 54
namespace __gnu_debug { 
# 56
using namespace std::__debug;
# 57
}
# 67 "/usr/include/c++/5/bits/stl_iterator_base_funcs.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _InputIterator> inline typename iterator_traits< _InputIterator> ::difference_type 
# 73
__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag) 
# 75
{ 
# 79
typename iterator_traits< _InputIterator> ::difference_type __n = (0); 
# 80
while (__first != __last) 
# 81
{ 
# 82
++__first; 
# 83
++__n; 
# 84
}  
# 85
return __n; 
# 86
} 
# 88
template< class _RandomAccessIterator> inline typename iterator_traits< _RandomAccessIterator> ::difference_type 
# 90
__distance(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) 
# 92
{ 
# 96
return __last - __first; 
# 97
} 
# 112
template< class _InputIterator> inline typename iterator_traits< _InputIterator> ::difference_type 
# 114
distance(_InputIterator __first, _InputIterator __last) 
# 115
{ 
# 117
return std::__distance(__first, __last, std::__iterator_category(__first)); 
# 119
} 
# 121
template< class _InputIterator, class _Distance> inline void 
# 123
__advance(_InputIterator &__i, _Distance __n, input_iterator_tag) 
# 124
{ 
# 127
; 
# 128
while (__n--) { 
# 129
++__i; }  
# 130
} 
# 132
template< class _BidirectionalIterator, class _Distance> inline void 
# 134
__advance(_BidirectionalIterator &__i, _Distance __n, bidirectional_iterator_tag) 
# 136
{ 
# 140
if (__n > 0) { 
# 141
while (__n--) { 
# 142
++__i; }  } else { 
# 144
while (__n++) { 
# 145
--__i; }  }  
# 146
} 
# 148
template< class _RandomAccessIterator, class _Distance> inline void 
# 150
__advance(_RandomAccessIterator &__i, _Distance __n, random_access_iterator_tag) 
# 152
{ 
# 156
__i += __n; 
# 157
} 
# 171
template< class _InputIterator, class _Distance> inline void 
# 173
advance(_InputIterator &__i, _Distance __n) 
# 174
{ 
# 176
typename iterator_traits< _InputIterator> ::difference_type __d = __n; 
# 177
std::__advance(__i, __d, std::__iterator_category(__i)); 
# 178
} 
# 203
}
# 36 "/usr/include/c++/5/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Tp> inline _Tp *
# 47
__addressof(_Tp &__r) 
# 48
{ 
# 49
return reinterpret_cast< _Tp *>(&(const_cast< char &>(reinterpret_cast< const volatile char &>(__r)))); 
# 51
} 
# 54
}
# 159
namespace std __attribute((__visibility__("default"))) { 
# 174
template< class _Tp> inline void 
# 176
swap(_Tp &__a, _Tp &__b) 
# 181
{ 
# 185
_Tp __tmp = __a; 
# 186
__a = __b; 
# 187
__b = __tmp; 
# 188
} 
# 193
template< class _Tp, size_t _Nm> inline void 
# 195
swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) 
# 199
{ 
# 200
for (size_t __n = (0); __n < _Nm; ++__n) { 
# 201
swap((__a)[__n], (__b)[__n]); }  
# 202
} 
# 206
}
# 68 "/usr/include/c++/5/bits/stl_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 96
template< class _Iterator> 
# 97
class reverse_iterator : public iterator< typename iterator_traits< _Iterator> ::iterator_category, typename iterator_traits< _Iterator> ::value_type, typename iterator_traits< _Iterator> ::difference_type, typename iterator_traits< _Iterator> ::pointer, typename iterator_traits< _Iterator> ::reference>  { 
# 105
protected: _Iterator current; 
# 107
typedef iterator_traits< _Iterator>  __traits_type; 
# 110
public: typedef _Iterator iterator_type; 
# 111
typedef typename iterator_traits< _Iterator> ::difference_type difference_type; 
# 112
typedef typename iterator_traits< _Iterator> ::pointer pointer; 
# 113
typedef typename iterator_traits< _Iterator> ::reference reference; 
# 121
reverse_iterator() : current() { } 
# 127
explicit reverse_iterator(iterator_type __x) : current(__x) { } 
# 132
reverse_iterator(const reverse_iterator &__x) : current(__x.current) 
# 133
{ } 
# 139
template< class _Iter> 
# 140
reverse_iterator(const ::std::reverse_iterator< _Iter>  &__x) : current((__x.base())) 
# 141
{ } 
# 147
iterator_type base() const 
# 148
{ return current; } 
# 161
reference operator*() const 
# 162
{ 
# 163
_Iterator __tmp = current; 
# 164
return *(--__tmp); 
# 165
} 
# 173
pointer operator->() const 
# 174
{ return &operator*(); } 
# 182
reverse_iterator &operator++() 
# 183
{ 
# 184
--(current); 
# 185
return *this; 
# 186
} 
# 194
reverse_iterator operator++(int) 
# 195
{ 
# 196
reverse_iterator __tmp = *this; 
# 197
--(current); 
# 198
return __tmp; 
# 199
} 
# 207
reverse_iterator &operator--() 
# 208
{ 
# 209
++(current); 
# 210
return *this; 
# 211
} 
# 219
reverse_iterator operator--(int) 
# 220
{ 
# 221
reverse_iterator __tmp = *this; 
# 222
++(current); 
# 223
return __tmp; 
# 224
} 
# 232
reverse_iterator operator+(difference_type __n) const 
# 233
{ return ((reverse_iterator)((current) - __n)); } 
# 242
reverse_iterator &operator+=(difference_type __n) 
# 243
{ 
# 244
(current) -= __n; 
# 245
return *this; 
# 246
} 
# 254
reverse_iterator operator-(difference_type __n) const 
# 255
{ return ((reverse_iterator)((current) + __n)); } 
# 264
reverse_iterator &operator-=(difference_type __n) 
# 265
{ 
# 266
(current) += __n; 
# 267
return *this; 
# 268
} 
# 276
reference operator[](difference_type __n) const 
# 277
{ return *((*this) + __n); } 
# 278
}; 
# 290
template< class _Iterator> inline bool 
# 292
operator==(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 293
__y) 
# 294
{ return (__x.base()) == (__y.base()); } 
# 296
template< class _Iterator> inline bool 
# 298
operator<(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 299
__y) 
# 300
{ return (__y.base()) < (__x.base()); } 
# 302
template< class _Iterator> inline bool 
# 304
operator!=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 305
__y) 
# 306
{ return !(__x == __y); } 
# 308
template< class _Iterator> inline bool 
# 310
operator>(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 311
__y) 
# 312
{ return __y < __x; } 
# 314
template< class _Iterator> inline bool 
# 316
operator<=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 317
__y) 
# 318
{ return !(__y < __x); } 
# 320
template< class _Iterator> inline bool 
# 322
operator>=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 323
__y) 
# 324
{ return !(__x < __y); } 
# 326
template< class _Iterator> inline typename reverse_iterator< _Iterator> ::difference_type 
# 328
operator-(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 329
__y) 
# 330
{ return (__y.base()) - (__x.base()); } 
# 332
template< class _Iterator> inline reverse_iterator< _Iterator>  
# 334
operator+(typename reverse_iterator< _Iterator> ::difference_type __n, const reverse_iterator< _Iterator>  &
# 335
__x) 
# 336
{ return ((reverse_iterator< _Iterator> )((__x.base()) - __n)); } 
# 340
template< class _IteratorL, class _IteratorR> inline bool 
# 342
operator==(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 343
__y) 
# 344
{ return (__x.base()) == (__y.base()); } 
# 346
template< class _IteratorL, class _IteratorR> inline bool 
# 348
operator<(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 349
__y) 
# 350
{ return (__y.base()) < (__x.base()); } 
# 352
template< class _IteratorL, class _IteratorR> inline bool 
# 354
operator!=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 355
__y) 
# 356
{ return !(__x == __y); } 
# 358
template< class _IteratorL, class _IteratorR> inline bool 
# 360
operator>(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 361
__y) 
# 362
{ return __y < __x; } 
# 364
template< class _IteratorL, class _IteratorR> inline bool 
# 366
operator<=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 367
__y) 
# 368
{ return !(__y < __x); } 
# 370
template< class _IteratorL, class _IteratorR> inline bool 
# 372
operator>=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 373
__y) 
# 374
{ return !(__x < __y); } 
# 376
template< class _IteratorL, class _IteratorR> inline typename reverse_iterator< _IteratorL> ::difference_type 
# 385
operator-(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 386
__y) 
# 388
{ return (__y.base()) - (__x.base()); } 
# 414
template< class _Container> 
# 415
class back_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 419
protected: _Container *container; 
# 423
public: typedef _Container container_type; 
# 427
explicit back_insert_iterator(_Container &__x) : container((&__x)) { } 
# 442
back_insert_iterator &operator=(typename _Container::const_reference __value) 
# 443
{ 
# 444
((container)->push_back(__value)); 
# 445
return *this; 
# 446
} 
# 465
back_insert_iterator &operator*() 
# 466
{ return *this; } 
# 470
back_insert_iterator &operator++() 
# 471
{ return *this; } 
# 475
back_insert_iterator operator++(int) 
# 476
{ return *this; } 
# 477
}; 
# 490
template< class _Container> inline back_insert_iterator< _Container>  
# 492
back_inserter(_Container &__x) 
# 493
{ return ((back_insert_iterator< _Container> )(__x)); } 
# 505
template< class _Container> 
# 506
class front_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 510
protected: _Container *container; 
# 514
public: typedef _Container container_type; 
# 517
explicit front_insert_iterator(_Container &__x) : container((&__x)) { } 
# 532
front_insert_iterator &operator=(typename _Container::const_reference __value) 
# 533
{ 
# 534
((container)->push_front(__value)); 
# 535
return *this; 
# 536
} 
# 555
front_insert_iterator &operator*() 
# 556
{ return *this; } 
# 560
front_insert_iterator &operator++() 
# 561
{ return *this; } 
# 565
front_insert_iterator operator++(int) 
# 566
{ return *this; } 
# 567
}; 
# 580
template< class _Container> inline front_insert_iterator< _Container>  
# 582
front_inserter(_Container &__x) 
# 583
{ return ((front_insert_iterator< _Container> )(__x)); } 
# 599
template< class _Container> 
# 600
class insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 604
protected: _Container *container; 
# 605
typename _Container::iterator iter; 
# 609
public: typedef _Container container_type; 
# 615
insert_iterator(_Container &__x, typename _Container::iterator __i) : container((&__x)), iter(__i) 
# 616
{ } 
# 643
insert_iterator &operator=(typename _Container::const_reference __value) 
# 644
{ 
# 645
(iter) = ((container)->insert(iter, __value)); 
# 646
++(iter); 
# 647
return *this; 
# 648
} 
# 669
insert_iterator &operator*() 
# 670
{ return *this; } 
# 674
insert_iterator &operator++() 
# 675
{ return *this; } 
# 679
insert_iterator &operator++(int) 
# 680
{ return *this; } 
# 681
}; 
# 694
template< class _Container, class _Iterator> inline insert_iterator< _Container>  
# 696
inserter(_Container &__x, _Iterator __i) 
# 697
{ 
# 698
return insert_iterator< _Container> (__x, (typename _Container::iterator)__i); 
# 700
} 
# 705
}
# 707
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 718
using std::iterator_traits;
# 719
using std::iterator;
# 720
template< class _Iterator, class _Container> 
# 721
class __normal_iterator { 
# 724
protected: _Iterator _M_current; 
# 726
typedef std::iterator_traits< _Iterator>  __traits_type; 
# 729
public: typedef _Iterator iterator_type; 
# 730
typedef typename std::iterator_traits< _Iterator> ::iterator_category iterator_category; 
# 731
typedef typename std::iterator_traits< _Iterator> ::value_type value_type; 
# 732
typedef typename std::iterator_traits< _Iterator> ::difference_type difference_type; 
# 733
typedef typename std::iterator_traits< _Iterator> ::reference reference; 
# 734
typedef typename std::iterator_traits< _Iterator> ::pointer pointer; 
# 736
__normal_iterator() : _M_current(_Iterator()) 
# 737
{ } 
# 740
explicit __normal_iterator(const _Iterator &__i) : _M_current(__i) 
# 741
{ } 
# 744
template< class _Iter> 
# 745
__normal_iterator(const __gnu_cxx::__normal_iterator< _Iter, typename __enable_if< std::__are_same< _Iter, typename _Container::pointer> ::__value, _Container> ::__type>  &
# 748
__i) : _M_current((__i.base())) 
# 749
{ } 
# 753
reference operator*() const 
# 754
{ return *(_M_current); } 
# 757
pointer operator->() const 
# 758
{ return _M_current; } 
# 761
__normal_iterator &operator++() 
# 762
{ 
# 763
++(_M_current); 
# 764
return *this; 
# 765
} 
# 768
__normal_iterator operator++(int) 
# 769
{ return ((__normal_iterator)((_M_current)++)); } 
# 773
__normal_iterator &operator--() 
# 774
{ 
# 775
--(_M_current); 
# 776
return *this; 
# 777
} 
# 780
__normal_iterator operator--(int) 
# 781
{ return ((__normal_iterator)((_M_current)--)); } 
# 785
reference operator[](difference_type __n) const 
# 786
{ return (_M_current)[__n]; } 
# 789
__normal_iterator &operator+=(difference_type __n) 
# 790
{ (_M_current) += __n; return *this; } 
# 793
__normal_iterator operator+(difference_type __n) const 
# 794
{ return ((__normal_iterator)((_M_current) + __n)); } 
# 797
__normal_iterator &operator-=(difference_type __n) 
# 798
{ (_M_current) -= __n; return *this; } 
# 801
__normal_iterator operator-(difference_type __n) const 
# 802
{ return ((__normal_iterator)((_M_current) - __n)); } 
# 805
const _Iterator &base() const 
# 806
{ return _M_current; } 
# 807
}; 
# 818
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 820
operator==(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 821
__rhs) 
# 823
{ return (__lhs.base()) == (__rhs.base()); } 
# 825
template< class _Iterator, class _Container> inline bool 
# 827
operator==(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 828
__rhs) 
# 830
{ return (__lhs.base()) == (__rhs.base()); } 
# 832
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 834
operator!=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 835
__rhs) 
# 837
{ return (__lhs.base()) != (__rhs.base()); } 
# 839
template< class _Iterator, class _Container> inline bool 
# 841
operator!=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 842
__rhs) 
# 844
{ return (__lhs.base()) != (__rhs.base()); } 
# 847
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 849
operator<(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 850
__rhs) 
# 852
{ return (__lhs.base()) < (__rhs.base()); } 
# 854
template< class _Iterator, class _Container> inline bool 
# 856
operator<(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 857
__rhs) 
# 859
{ return (__lhs.base()) < (__rhs.base()); } 
# 861
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 863
operator>(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 864
__rhs) 
# 866
{ return (__lhs.base()) > (__rhs.base()); } 
# 868
template< class _Iterator, class _Container> inline bool 
# 870
operator>(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 871
__rhs) 
# 873
{ return (__lhs.base()) > (__rhs.base()); } 
# 875
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 877
operator<=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 878
__rhs) 
# 880
{ return (__lhs.base()) <= (__rhs.base()); } 
# 882
template< class _Iterator, class _Container> inline bool 
# 884
operator<=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 885
__rhs) 
# 887
{ return (__lhs.base()) <= (__rhs.base()); } 
# 889
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 891
operator>=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 892
__rhs) 
# 894
{ return (__lhs.base()) >= (__rhs.base()); } 
# 896
template< class _Iterator, class _Container> inline bool 
# 898
operator>=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 899
__rhs) 
# 901
{ return (__lhs.base()) >= (__rhs.base()); } 
# 907
template< class _IteratorL, class _IteratorR, class _Container> inline typename __normal_iterator< _IteratorL, _Container> ::difference_type 
# 916
operator-(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 917
__rhs) 
# 919
{ return (__lhs.base()) - (__rhs.base()); } 
# 921
template< class _Iterator, class _Container> inline typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 923
operator-(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 924
__rhs) 
# 926
{ return (__lhs.base()) - (__rhs.base()); } 
# 928
template< class _Iterator, class _Container> inline __normal_iterator< _Iterator, _Container>  
# 930
operator+(typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 931
__n, const __normal_iterator< _Iterator, _Container>  &__i) 
# 933
{ return ((__normal_iterator< _Iterator, _Container> )((__i.base()) + __n)); } 
# 936
}
# 50 "/usr/include/c++/5/bits/memoryfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< class > class allocator; 
# 67
template<> class allocator< void> ; 
# 70
template< class , class > struct uses_allocator; 
# 76
}
# 42 "/usr/include/c++/5/bits/stringfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT> struct char_traits; 
# 55
template<> struct char_traits< char> ; 
# 58
template<> struct char_traits< wchar_t> ; 
# 67
inline namespace __cxx11 { 
# 69
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 70
_Alloc = allocator< _CharT> > class basic_string; 
# 74
typedef basic_string< char>  string; 
# 78
typedef basic_string< wchar_t>  wstring; 
# 90
}
# 95
}
# 44 "/usr/include/stdio.h" 3
struct _IO_FILE; 
# 48
typedef _IO_FILE FILE; 
# 64
typedef _IO_FILE __FILE; 
# 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list; 
# 357 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3
typedef unsigned wint_t; 
# 94 "/usr/include/wchar.h" 3
typedef 
# 83
struct { 
# 84
int __count; 
# 86
union { 
# 88
unsigned __wch; 
# 92
char __wchb[4]; 
# 93
} __value; 
# 94
} __mbstate_t; 
# 106
typedef __mbstate_t mbstate_t; 
# 132
extern "C" {
# 137
struct tm; 
# 147
extern __attribute((gnu_inline)) inline wchar_t *wcscpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 149
 __attribute((__nonnull__(1, 2))); 
# 152
extern __attribute((gnu_inline)) inline wchar_t *wcsncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 154
 __attribute((__nonnull__(1, 2))); 
# 157
extern __attribute((gnu_inline)) inline wchar_t *wcscat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 159
 __attribute((__nonnull__(1, 2))); 
# 161
extern __attribute((gnu_inline)) inline wchar_t *wcsncat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 163
 __attribute((__nonnull__(1, 2))); 
# 166
extern int wcscmp(const wchar_t * __s1, const wchar_t * __s2) throw()
# 167
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 169
extern int wcsncmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 170
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 175
extern int wcscasecmp(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 178
extern int wcsncasecmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 185
extern int wcscasecmp_l(const wchar_t * __s1, const wchar_t * __s2, __locale_t __loc) throw(); 
# 188
extern int wcsncasecmp_l(const wchar_t * __s1, const wchar_t * __s2, size_t __n, __locale_t __loc) throw(); 
# 195
extern int wcscoll(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 199
extern size_t wcsxfrm(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 209
extern int wcscoll_l(const wchar_t * __s1, const wchar_t * __s2, __locale_t __loc) throw(); 
# 215
extern size_t wcsxfrm_l(wchar_t * __s1, const wchar_t * __s2, size_t __n, __locale_t __loc) throw(); 
# 219
extern wchar_t *wcsdup(const wchar_t * __s) throw() __attribute((__malloc__)); 
# 225
extern "C++" wchar_t *wcschr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 226
 __attribute((__pure__)); 
# 227
extern "C++" const wchar_t *wcschr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 228
 __attribute((__pure__)); 
# 235
extern "C++" wchar_t *wcsrchr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 236
 __attribute((__pure__)); 
# 237
extern "C++" const wchar_t *wcsrchr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 238
 __attribute((__pure__)); 
# 248
extern wchar_t *wcschrnul(const wchar_t * __s, wchar_t __wc) throw()
# 249
 __attribute((__pure__)); 
# 255
extern size_t wcscspn(const wchar_t * __wcs, const wchar_t * __reject) throw()
# 256
 __attribute((__pure__)); 
# 259
extern size_t wcsspn(const wchar_t * __wcs, const wchar_t * __accept) throw()
# 260
 __attribute((__pure__)); 
# 263
extern "C++" wchar_t *wcspbrk(wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 264
 __attribute((__pure__)); 
# 265
extern "C++" const wchar_t *wcspbrk(const wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 267
 __attribute((__pure__)); 
# 274
extern "C++" wchar_t *wcsstr(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 275
 __attribute((__pure__)); 
# 276
extern "C++" const wchar_t *wcsstr(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 278
 __attribute((__pure__)); 
# 285
extern wchar_t *wcstok(wchar_t *__restrict__ __s, const wchar_t *__restrict__ __delim, wchar_t **__restrict__ __ptr) throw(); 
# 290
extern size_t wcslen(const wchar_t * __s) throw() __attribute((__pure__)); 
# 296
extern "C++" wchar_t *wcswcs(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 297
 __attribute((__pure__)); 
# 298
extern "C++" const wchar_t *wcswcs(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 300
 __attribute((__pure__)); 
# 309
extern size_t wcsnlen(const wchar_t * __s, size_t __maxlen) throw()
# 310
 __attribute((__pure__)); 
# 317
extern "C++" wchar_t *wmemchr(wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 318
 __attribute((__pure__)); 
# 319
extern "C++" const wchar_t *wmemchr(const wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 321
 __attribute((__pure__)); 
# 328
extern int wmemcmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 329
 __attribute((__pure__)); 
# 332
extern __attribute((gnu_inline)) inline wchar_t *wmemcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 337
extern __attribute((gnu_inline)) inline wchar_t *wmemmove(wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 341
extern __attribute((gnu_inline)) inline wchar_t *wmemset(wchar_t * __s, wchar_t __c, size_t __n) throw(); 
# 347
extern __attribute((gnu_inline)) inline wchar_t *wmempcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 356
extern __attribute((gnu_inline)) inline wint_t btowc(int __c) throw(); 
# 360
extern __attribute((gnu_inline)) inline int wctob(wint_t __c) throw(); 
# 364
extern int mbsinit(const mbstate_t * __ps) throw() __attribute((__pure__)); 
# 368
extern size_t mbrtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __p) throw(); 
# 373
extern __attribute((gnu_inline)) inline size_t wcrtomb(char *__restrict__ __s, wchar_t __wc, mbstate_t *__restrict__ __ps) throw(); 
# 377
extern size_t __mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 379
extern __attribute((gnu_inline)) inline size_t mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 389
extern wint_t __btowc_alias(int __c) __asm__("btowc"); 
# 390
__attribute((__gnu_inline__)) extern inline wint_t
# 391
 __attribute((__leaf__)) btowc(int __c) throw() 
# 392
{ return ((0) && (__c >= ('\000')) && (__c <= ('\177'))) ? (wint_t)__c : __btowc_alias(__c); 
# 393
} 
# 395
extern int __wctob_alias(wint_t __c) __asm__("wctob"); 
# 396
__attribute((__gnu_inline__)) extern inline int
# 397
 __attribute((__leaf__)) wctob(wint_t __wc) throw() 
# 398
{ return ((0) && (__wc >= (L'\x0')) && (__wc <= (L'\x7f'))) ? (int)__wc : __wctob_alias(__wc); 
# 399
} 
# 401
__attribute((__gnu_inline__)) extern inline size_t
# 402
 __attribute((__leaf__)) mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw() 
# 404
{ return (__ps != (__null)) ? mbrtowc(__null, __s, __n, __ps) : __mbrlen(__s, __n, __null); 
# 405
} 
# 411
extern __attribute((gnu_inline)) inline size_t mbsrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 417
extern __attribute((gnu_inline)) inline size_t wcsrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 426
extern __attribute((gnu_inline)) inline size_t mbsnrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 432
extern __attribute((gnu_inline)) inline size_t wcsnrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 442
extern int wcwidth(wchar_t __c) throw(); 
# 446
extern int wcswidth(const wchar_t * __s, size_t __n) throw(); 
# 453
extern double wcstod(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 460
extern float wcstof(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 462
extern long double wcstold(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 471
extern long wcstol(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 476
extern unsigned long wcstoul(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 486
__extension__ extern long long wcstoll(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 493
__extension__ extern unsigned long long wcstoull(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 503
__extension__ extern long long wcstoq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 510
__extension__ extern unsigned long long wcstouq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 533
extern long wcstol_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 537
extern unsigned long wcstoul_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 542
__extension__ extern long long wcstoll_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 547
__extension__ extern unsigned long long wcstoull_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, __locale_t __loc) throw(); 
# 552
extern double wcstod_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 556
extern float wcstof_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 560
extern long double wcstold_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, __locale_t __loc) throw(); 
# 569
extern __attribute((gnu_inline)) inline wchar_t *wcpcpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw(); 
# 574
extern __attribute((gnu_inline)) inline wchar_t *wcpncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw(); 
# 583
extern __FILE *open_wmemstream(wchar_t ** __bufloc, size_t * __sizeloc) throw(); 
# 590
extern int fwide(__FILE * __fp, int __mode) throw(); 
# 597
extern __attribute((gnu_inline)) inline int fwprintf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...); 
# 604
extern __attribute((gnu_inline)) inline int wprintf(const wchar_t *__restrict__ __format, ...); 
# 607
extern __attribute((gnu_inline)) inline int swprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, ...) throw(); 
# 615
extern __attribute((gnu_inline)) inline int vfwprintf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 623
extern __attribute((gnu_inline)) inline int vwprintf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 628
extern __attribute((gnu_inline)) inline int vswprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 638
extern int fwscanf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...); 
# 645
extern int wscanf(const wchar_t *__restrict__ __format, ...); 
# 648
extern int swscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, ...) throw(); 
# 692
extern int vfwscanf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 700
extern int vwscanf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 704
extern int vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 748
extern wint_t fgetwc(__FILE * __stream); 
# 749
extern wint_t getwc(__FILE * __stream); 
# 755
extern wint_t getwchar(); 
# 762
extern wint_t fputwc(wchar_t __wc, __FILE * __stream); 
# 763
extern wint_t putwc(wchar_t __wc, __FILE * __stream); 
# 769
extern wint_t putwchar(wchar_t __wc); 
# 777
extern __attribute((gnu_inline)) inline wchar_t *fgetws(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 784
extern int fputws(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 792
extern wint_t ungetwc(wint_t __wc, __FILE * __stream); 
# 804
extern wint_t getwc_unlocked(__FILE * __stream); 
# 805
extern wint_t getwchar_unlocked(); 
# 813
extern wint_t fgetwc_unlocked(__FILE * __stream); 
# 821
extern wint_t fputwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 830
extern wint_t putwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 831
extern wint_t putwchar_unlocked(wchar_t __wc); 
# 840
extern __attribute((gnu_inline)) inline wchar_t *fgetws_unlocked(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 849
extern int fputws_unlocked(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 858
extern size_t wcsftime(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 868
extern size_t wcsftime_l(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp, __locale_t __loc) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3
extern wchar_t *__wmemcpy_chk(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n, size_t __ns1) throw(); 
# 27
extern wchar_t *__wmemcpy_alias(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw() __asm__("wmemcpy"); 
# 31
extern wchar_t *__wmemcpy_chk_warn(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n, size_t __ns1) throw() __asm__("__wmemcpy_chk")
# 35
 __attribute((__warning__("wmemcpy called with length bigger than size of destination buffer"))); 
# 38
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 39
__attribute((__leaf__)) extern inline wchar_t *wmemcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw() 
# 41
{ 
# 42
if (__builtin_object_size(__s1, 0) != ((size_t)(-1))) 
# 43
{ 
# 44
if (!(0)) { 
# 45
return __wmemcpy_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 48
if (__n > (__builtin_object_size(__s1, 0) / sizeof(wchar_t))) { 
# 49
return __wmemcpy_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 51
}  
# 52
return __wmemcpy_alias(__s1, __s2, __n); 
# 53
} 
# 56
extern wchar_t *__wmemmove_chk(wchar_t * __s1, const wchar_t * __s2, size_t __n, size_t __ns1) throw(); 
# 58
extern wchar_t *__wmemmove_alias(wchar_t * __s1, const wchar_t * __s2, size_t __n) throw() __asm__("wmemmove"); 
# 61
extern wchar_t *__wmemmove_chk_warn(wchar_t * __s1, const wchar_t * __s2, size_t __n, size_t __ns1) throw() __asm__("__wmemmove_chk")
# 64
 __attribute((__warning__("wmemmove called with length bigger than size of destination buffer"))); 
# 67
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 68
__attribute((__leaf__)) extern inline wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() 
# 69
{ 
# 70
if (__builtin_object_size(__s1, 0) != ((size_t)(-1))) 
# 71
{ 
# 72
if (!(0)) { 
# 73
return __wmemmove_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 76
if (__n > (__builtin_object_size(__s1, 0) / sizeof(wchar_t))) { 
# 77
return __wmemmove_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 79
}  
# 80
return __wmemmove_alias(__s1, __s2, __n); 
# 81
} 
# 85
extern wchar_t *__wmempcpy_chk(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n, size_t __ns1) throw(); 
# 88
extern wchar_t *__wmempcpy_alias(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw() __asm__("wmempcpy"); 
# 92
extern wchar_t *__wmempcpy_chk_warn(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n, size_t __ns1) throw() __asm__("__wmempcpy_chk")
# 96
 __attribute((__warning__("wmempcpy called with length bigger than size of destination buffer"))); 
# 99
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 100
__attribute((__leaf__)) extern inline wchar_t *wmempcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw() 
# 102
{ 
# 103
if (__builtin_object_size(__s1, 0) != ((size_t)(-1))) 
# 104
{ 
# 105
if (!(0)) { 
# 106
return __wmempcpy_chk(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 109
if (__n > (__builtin_object_size(__s1, 0) / sizeof(wchar_t))) { 
# 110
return __wmempcpy_chk_warn(__s1, __s2, __n, __builtin_object_size(__s1, 0) / sizeof(wchar_t)); }  
# 112
}  
# 113
return __wmempcpy_alias(__s1, __s2, __n); 
# 114
} 
# 118
extern wchar_t *__wmemset_chk(wchar_t * __s, wchar_t __c, size_t __n, size_t __ns) throw(); 
# 120
extern wchar_t *__wmemset_alias(wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemset"); 
# 122
extern wchar_t *__wmemset_chk_warn(wchar_t * __s, wchar_t __c, size_t __n, size_t __ns) throw() __asm__("__wmemset_chk")
# 125
 __attribute((__warning__("wmemset called with length bigger than size of destination buffer"))); 
# 128
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 129
__attribute((__leaf__)) extern inline wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) throw() 
# 130
{ 
# 131
if (__builtin_object_size(__s, 0) != ((size_t)(-1))) 
# 132
{ 
# 133
if (!(0)) { 
# 134
return __wmemset_chk(__s, __c, __n, __builtin_object_size(__s, 0) / sizeof(wchar_t)); }  
# 136
if (__n > (__builtin_object_size(__s, 0) / sizeof(wchar_t))) { 
# 137
return __wmemset_chk_warn(__s, __c, __n, __builtin_object_size(__s, 0) / sizeof(wchar_t)); }  
# 139
}  
# 140
return __wmemset_alias(__s, __c, __n); 
# 141
} 
# 144
extern wchar_t *__wcscpy_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw(); 
# 147
extern wchar_t *__wcscpy_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() __asm__("wcscpy"); 
# 151
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 152
__attribute((__leaf__)) extern inline wchar_t *wcscpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() 
# 153
{ 
# 154
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) { 
# 155
return __wcscpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 156
return __wcscpy_alias(__dest, __src); 
# 157
} 
# 160
extern wchar_t *__wcpcpy_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __destlen) throw(); 
# 163
extern wchar_t *__wcpcpy_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() __asm__("wcpcpy"); 
# 167
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 168
__attribute((__leaf__)) extern inline wchar_t *wcpcpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() 
# 169
{ 
# 170
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) { 
# 171
return __wcpcpy_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 172
return __wcpcpy_alias(__dest, __src); 
# 173
} 
# 176
extern wchar_t *__wcsncpy_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n, size_t __destlen) throw(); 
# 179
extern wchar_t *__wcsncpy_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() __asm__("wcsncpy"); 
# 183
extern wchar_t *__wcsncpy_chk_warn(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n, size_t __destlen) throw() __asm__("__wcsncpy_chk")
# 187
 __attribute((__warning__("wcsncpy called with length bigger than size of destination buffer"))); 
# 190
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 191
__attribute((__leaf__)) extern inline wchar_t *wcsncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() 
# 193
{ 
# 194
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) 
# 195
{ 
# 196
if (!(0)) { 
# 197
return __wcsncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 199
if (__n > (__builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t))) { 
# 200
return __wcsncpy_chk_warn(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 202
}  
# 203
return __wcsncpy_alias(__dest, __src, __n); 
# 204
} 
# 207
extern wchar_t *__wcpncpy_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n, size_t __destlen) throw(); 
# 210
extern wchar_t *__wcpncpy_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() __asm__("wcpncpy"); 
# 214
extern wchar_t *__wcpncpy_chk_warn(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n, size_t __destlen) throw() __asm__("__wcpncpy_chk")
# 218
 __attribute((__warning__("wcpncpy called with length bigger than size of destination buffer"))); 
# 221
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 222
__attribute((__leaf__)) extern inline wchar_t *wcpncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() 
# 224
{ 
# 225
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) 
# 226
{ 
# 227
if (!(0)) { 
# 228
return __wcpncpy_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 230
if (__n > (__builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t))) { 
# 231
return __wcpncpy_chk_warn(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 233
}  
# 234
return __wcpncpy_alias(__dest, __src, __n); 
# 235
} 
# 238
extern wchar_t *__wcscat_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __destlen) throw(); 
# 241
extern wchar_t *__wcscat_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() __asm__("wcscat"); 
# 245
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 246
__attribute((__leaf__)) extern inline wchar_t *wcscat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw() 
# 247
{ 
# 248
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) { 
# 249
return __wcscat_chk(__dest, __src, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 250
return __wcscat_alias(__dest, __src); 
# 251
} 
# 254
extern wchar_t *__wcsncat_chk(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n, size_t __destlen) throw(); 
# 257
extern wchar_t *__wcsncat_alias(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() __asm__("wcsncat"); 
# 262
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) 
# 263
__attribute((__leaf__)) extern inline wchar_t *wcsncat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw() 
# 265
{ 
# 266
if (__builtin_object_size(__dest, 2 > 1) != ((size_t)(-1))) { 
# 267
return __wcsncat_chk(__dest, __src, __n, __builtin_object_size(__dest, 2 > 1) / sizeof(wchar_t)); }  
# 269
return __wcsncat_alias(__dest, __src, __n); 
# 270
} 
# 273
extern int __swprintf_chk(wchar_t *__restrict__ __s, size_t __n, int __flag, size_t __s_len, const wchar_t *__restrict__ __format, ...) throw(); 
# 278
extern int __swprintf_alias(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __fmt, ...) throw() __asm__("swprintf"); 
# 284
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 285
 __attribute((__leaf__)) swprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __fmt, ...) throw() 
# 287
{ 
# 288
if ((__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) || (2 > 1)) { 
# 289
return __swprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __fmt, __builtin_va_arg_pack()); }  
# 292
return __swprintf_alias(__s, __n, __fmt, __builtin_va_arg_pack()); 
# 293
} 
# 303
extern int __vswprintf_chk(wchar_t *__restrict__ __s, size_t __n, int __flag, size_t __s_len, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 309
extern int __vswprintf_alias(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __fmt, __gnuc_va_list __ap) throw() __asm__("vswprintf"); 
# 314
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 315
 __attribute((__leaf__)) vswprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __fmt, __gnuc_va_list __ap) throw() 
# 317
{ 
# 318
if ((__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) || (2 > 1)) { 
# 319
return __vswprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __fmt, __ap); }  
# 321
return __vswprintf_alias(__s, __n, __fmt, __ap); 
# 322
} 
# 327
extern int __fwprintf_chk(__FILE *__restrict__ __stream, int __flag, const wchar_t *__restrict__ __format, ...); 
# 329
extern int __wprintf_chk(int __flag, const wchar_t *__restrict__ __format, ...); 
# 331
extern int __vfwprintf_chk(__FILE *__restrict__ __stream, int __flag, const wchar_t *__restrict__ __format, __gnuc_va_list __ap); 
# 334
extern int __vwprintf_chk(int __flag, const wchar_t *__restrict__ __format, __gnuc_va_list __ap); 
# 338
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 339
wprintf(const wchar_t *__restrict__ __fmt, ...) 
# 340
{ 
# 341
return __wprintf_chk(2 - 1, __fmt, __builtin_va_arg_pack()); 
# 342
} 
# 344
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 345
fwprintf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __fmt, ...) 
# 346
{ 
# 347
return __fwprintf_chk(__stream, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 349
} 
# 357
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 358
vwprintf(const wchar_t *__restrict__ __fmt, __gnuc_va_list __ap) 
# 359
{ 
# 360
return __vwprintf_chk(2 - 1, __fmt, __ap); 
# 361
} 
# 363
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 364
vfwprintf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ 
# 365
__fmt, __gnuc_va_list __ap) 
# 366
{ 
# 367
return __vfwprintf_chk(__stream, 2 - 1, __fmt, __ap); 
# 368
} 
# 372
extern wchar_t *__fgetws_chk(wchar_t *__restrict__ __s, size_t __size, int __n, __FILE *__restrict__ __stream)
# 373
 __attribute((__warn_unused_result__)); 
# 374
extern wchar_t *__fgetws_alias(wchar_t *__restrict__ __s, int __n, __FILE *__restrict__ __stream) __asm__("fgetws")
# 376
 __attribute((__warn_unused_result__)); 
# 377
extern wchar_t *__fgetws_chk_warn(wchar_t *__restrict__ __s, size_t __size, int __n, __FILE *__restrict__ __stream) __asm__("__fgetws_chk")
# 380
 __attribute((__warn_unused_result__)) __attribute((__warning__("fgetws called with bigger size than length of destination buffer"))); 
# 383
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline wchar_t *
# 384
fgetws(wchar_t *__restrict__ __s, int __n, __FILE *__restrict__ __stream) 
# 385
{ 
# 386
if (__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) 
# 387
{ 
# 388
if ((!(0)) || (__n <= 0)) { 
# 389
return __fgetws_chk(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream); }  
# 392
if (((size_t)__n) > (__builtin_object_size(__s, 2 > 1) / sizeof(wchar_t))) { 
# 393
return __fgetws_chk_warn(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream); }  
# 395
}  
# 396
return __fgetws_alias(__s, __n, __stream); 
# 397
} 
# 400
extern wchar_t *__fgetws_unlocked_chk(wchar_t *__restrict__ __s, size_t __size, int __n, __FILE *__restrict__ __stream)
# 402
 __attribute((__warn_unused_result__)); 
# 403
extern wchar_t *__fgetws_unlocked_alias(wchar_t *__restrict__ __s, int __n, __FILE *__restrict__ __stream) __asm__("fgetws_unlocked")
# 406
 __attribute((__warn_unused_result__)); 
# 407
extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t *__restrict__ __s, size_t __size, int __n, __FILE *__restrict__ __stream) __asm__("__fgetws_unlocked_chk")
# 411
 __attribute((__warn_unused_result__)) __attribute((__warning__("fgetws_unlocked called with bigger size than length of destination buffer"))); 
# 414
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline wchar_t *
# 415
fgetws_unlocked(wchar_t *__restrict__ __s, int __n, __FILE *__restrict__ __stream) 
# 416
{ 
# 417
if (__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) 
# 418
{ 
# 419
if ((!(0)) || (__n <= 0)) { 
# 420
return __fgetws_unlocked_chk(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream); }  
# 423
if (((size_t)__n) > (__builtin_object_size(__s, 2 > 1) / sizeof(wchar_t))) { 
# 424
return __fgetws_unlocked_chk_warn(__s, __builtin_object_size(__s, 2 > 1) / sizeof(wchar_t), __n, __stream); }  
# 426
}  
# 427
return __fgetws_unlocked_alias(__s, __n, __stream); 
# 428
} 
# 432
extern size_t __wcrtomb_chk(char *__restrict__ __s, wchar_t __wchar, mbstate_t *__restrict__ __p, size_t __buflen) throw()
# 434
 __attribute((__warn_unused_result__)); 
# 435
extern size_t __wcrtomb_alias(char *__restrict__ __s, wchar_t __wchar, mbstate_t *__restrict__ __ps) throw() __asm__("wcrtomb")
# 437
 __attribute((__warn_unused_result__)); 
# 439
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline size_t
# 440
 __attribute((__leaf__)) wcrtomb(char *__restrict__ __s, wchar_t __wchar, mbstate_t *__restrict__ __ps) throw() 
# 442
{ 
# 450
if ((__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) && ((16) > __builtin_object_size(__s, 2 > 1))) { 
# 451
return __wcrtomb_chk(__s, __wchar, __ps, __builtin_object_size(__s, 2 > 1)); }  
# 452
return __wcrtomb_alias(__s, __wchar, __ps); 
# 453
} 
# 456
extern size_t __mbsrtowcs_chk(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw(); 
# 460
extern size_t __mbsrtowcs_alias(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw() __asm__("mbsrtowcs"); 
# 465
extern size_t __mbsrtowcs_chk_warn(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw() __asm__("__mbsrtowcs_chk")
# 470
 __attribute((__warning__("mbsrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))); 
# 473
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 474
 __attribute((__leaf__)) mbsrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw() 
# 476
{ 
# 477
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 478
{ 
# 479
if (!(0)) { 
# 480
return __mbsrtowcs_chk(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 483
if (__len > (__builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))) { 
# 484
return __mbsrtowcs_chk_warn(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 486
}  
# 487
return __mbsrtowcs_alias(__dst, __src, __len, __ps); 
# 488
} 
# 491
extern size_t __wcsrtombs_chk(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw(); 
# 495
extern size_t __wcsrtombs_alias(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw() __asm__("wcsrtombs"); 
# 500
extern size_t __wcsrtombs_chk_warn(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw() __asm__("__wcsrtombs_chk")
# 505
 __attribute((__warning__("wcsrtombs called with dst buffer smaller than len"))); 
# 507
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 508
 __attribute((__leaf__)) wcsrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw() 
# 510
{ 
# 511
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 512
{ 
# 513
if (!(0)) { 
# 514
return __wcsrtombs_chk(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1)); }  
# 516
if (__len > __builtin_object_size(__dst, 2 > 1)) { 
# 517
return __wcsrtombs_chk_warn(__dst, __src, __len, __ps, __builtin_object_size(__dst, 2 > 1)); }  
# 518
}  
# 519
return __wcsrtombs_alias(__dst, __src, __len, __ps); 
# 520
} 
# 524
extern size_t __mbsnrtowcs_chk(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw(); 
# 528
extern size_t __mbsnrtowcs_alias(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps) throw() __asm__("mbsnrtowcs"); 
# 533
extern size_t __mbsnrtowcs_chk_warn(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw() __asm__("__mbsnrtowcs_chk")
# 538
 __attribute((__warning__("mbsnrtowcs called with dst buffer smaller than len * sizeof (wchar_t)"))); 
# 541
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 542
 __attribute((__leaf__)) mbsnrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps) throw() 
# 544
{ 
# 545
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 546
{ 
# 547
if (!(0)) { 
# 548
return __mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 551
if (__len > (__builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t))) { 
# 552
return __mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, __builtin_object_size(__dst, 2 > 1) / sizeof(wchar_t)); }  
# 554
}  
# 555
return __mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps); 
# 556
} 
# 559
extern size_t __wcsnrtombs_chk(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw(); 
# 564
extern size_t __wcsnrtombs_alias(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps) throw() __asm__("wcsnrtombs"); 
# 569
extern size_t __wcsnrtombs_chk_warn(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps, size_t __dstlen) throw() __asm__("__wcsnrtombs_chk")
# 575
 __attribute((__warning__("wcsnrtombs called with dst buffer smaller than len"))); 
# 577
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline size_t
# 578
 __attribute((__leaf__)) wcsnrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps) throw() 
# 580
{ 
# 581
if (__builtin_object_size(__dst, 2 > 1) != ((size_t)(-1))) 
# 582
{ 
# 583
if (!(0)) { 
# 584
return __wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, __builtin_object_size(__dst, 2 > 1)); }  
# 587
if (__len > __builtin_object_size(__dst, 2 > 1)) { 
# 588
return __wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, __builtin_object_size(__dst, 2 > 1)); }  
# 590
}  
# 591
return __wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps); 
# 592
} 
# 894 "/usr/include/wchar.h" 3
}
# 62 "/usr/include/c++/5/cwchar" 3
namespace std { 
# 64
using ::mbstate_t;
# 65
}
# 135
namespace std __attribute((__visibility__("default"))) { 
# 139
using ::wint_t;
# 141
using ::btowc;
# 142
using ::fgetwc;
# 143
using ::fgetws;
# 144
using ::fputwc;
# 145
using ::fputws;
# 146
using ::fwide;
# 147
using ::fwprintf;
# 148
using ::fwscanf;
# 149
using ::getwc;
# 150
using ::getwchar;
# 151
using ::mbrlen;
# 152
using ::mbrtowc;
# 153
using ::mbsinit;
# 154
using ::mbsrtowcs;
# 155
using ::putwc;
# 156
using ::putwchar;
# 158
using ::swprintf;
# 160
using ::swscanf;
# 161
using ::ungetwc;
# 162
using ::vfwprintf;
# 164
using ::vfwscanf;
# 167
using ::vswprintf;
# 170
using ::vswscanf;
# 172
using ::vwprintf;
# 174
using ::vwscanf;
# 176
using ::wcrtomb;
# 177
using ::wcscat;
# 178
using ::wcscmp;
# 179
using ::wcscoll;
# 180
using ::wcscpy;
# 181
using ::wcscspn;
# 182
using ::wcsftime;
# 183
using ::wcslen;
# 184
using ::wcsncat;
# 185
using ::wcsncmp;
# 186
using ::wcsncpy;
# 187
using ::wcsrtombs;
# 188
using ::wcsspn;
# 189
using ::wcstod;
# 191
using ::wcstof;
# 193
using ::wcstok;
# 194
using ::wcstol;
# 195
using ::wcstoul;
# 196
using ::wcsxfrm;
# 197
using ::wctob;
# 198
using ::wmemcmp;
# 199
using ::wmemcpy;
# 200
using ::wmemmove;
# 201
using ::wmemset;
# 202
using ::wprintf;
# 203
using ::wscanf;
# 204
using ::wcschr;
# 205
using ::wcspbrk;
# 206
using ::wcsrchr;
# 207
using ::wcsstr;
# 208
using ::wmemchr;
# 233
}
# 241
namespace __gnu_cxx { 
# 248
using ::wcstold;
# 257
using ::wcstoll;
# 258
using ::wcstoull;
# 260
}
# 262
namespace std { 
# 264
using __gnu_cxx::wcstold;
# 265
using __gnu_cxx::wcstoll;
# 266
using __gnu_cxx::wcstoull;
# 267
}
# 68 "/usr/include/c++/5/bits/postypes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 88
typedef long streamoff; 
# 98
typedef ptrdiff_t streamsize; 
# 111
template< class _StateT> 
# 112
class fpos { 
# 115
streamoff _M_off; 
# 116
_StateT _M_state; 
# 123
public: fpos() : _M_off((0)), _M_state() 
# 124
{ } 
# 133
fpos(streamoff __off) : _M_off(__off), _M_state() 
# 134
{ } 
# 137
operator streamoff() const { return _M_off; } 
# 141
void state(_StateT __st) 
# 142
{ (_M_state) = __st; } 
# 146
_StateT state() const 
# 147
{ return _M_state; } 
# 154
fpos &operator+=(streamoff __off) 
# 155
{ 
# 156
(_M_off) += __off; 
# 157
return *this; 
# 158
} 
# 165
fpos &operator-=(streamoff __off) 
# 166
{ 
# 167
(_M_off) -= __off; 
# 168
return *this; 
# 169
} 
# 178
fpos operator+(streamoff __off) const 
# 179
{ 
# 180
fpos __pos(*this); 
# 181
__pos += __off; 
# 182
return __pos; 
# 183
} 
# 192
fpos operator-(streamoff __off) const 
# 193
{ 
# 194
fpos __pos(*this); 
# 195
__pos -= __off; 
# 196
return __pos; 
# 197
} 
# 205
streamoff operator-(const fpos &__other) const 
# 206
{ return (_M_off) - (__other._M_off); } 
# 207
}; 
# 214
template< class _StateT> inline bool 
# 216
operator==(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 217
{ return ((streamoff)__lhs) == ((streamoff)__rhs); } 
# 219
template< class _StateT> inline bool 
# 221
operator!=(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 222
{ return ((streamoff)__lhs) != ((streamoff)__rhs); } 
# 228
typedef fpos< __mbstate_t>  streampos; 
# 230
typedef fpos< __mbstate_t>  wstreampos; 
# 240
}
# 42 "/usr/include/c++/5/iosfwd" 3
namespace std __attribute((__visibility__("default"))) { 
# 74
class ios_base; 
# 76
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ios; 
# 79
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_streambuf; 
# 82
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_istream; 
# 85
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ostream; 
# 88
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_iostream; 
# 92
inline namespace __cxx11 { 
# 94
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 95
_Alloc = allocator< _CharT> > class basic_stringbuf; 
# 98
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 99
_Alloc = allocator< _CharT> > class basic_istringstream; 
# 102
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 103
_Alloc = allocator< _CharT> > class basic_ostringstream; 
# 106
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 107
_Alloc = allocator< _CharT> > class basic_stringstream; 
# 110
}
# 112
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_filebuf; 
# 115
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ifstream; 
# 118
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ofstream; 
# 121
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_fstream; 
# 124
template< class _CharT, class _Traits = char_traits< _CharT> > class istreambuf_iterator; 
# 127
template< class _CharT, class _Traits = char_traits< _CharT> > class ostreambuf_iterator; 
# 132
typedef basic_ios< char>  ios; 
# 135
typedef basic_streambuf< char>  streambuf; 
# 138
typedef basic_istream< char>  istream; 
# 141
typedef basic_ostream< char>  ostream; 
# 144
typedef basic_iostream< char>  iostream; 
# 147
typedef __cxx11::basic_stringbuf< char>  stringbuf; 
# 150
typedef __cxx11::basic_istringstream< char>  istringstream; 
# 153
typedef __cxx11::basic_ostringstream< char>  ostringstream; 
# 156
typedef __cxx11::basic_stringstream< char>  stringstream; 
# 159
typedef basic_filebuf< char>  filebuf; 
# 162
typedef basic_ifstream< char>  ifstream; 
# 165
typedef basic_ofstream< char>  ofstream; 
# 168
typedef basic_fstream< char>  fstream; 
# 172
typedef basic_ios< wchar_t>  wios; 
# 175
typedef basic_streambuf< wchar_t>  wstreambuf; 
# 178
typedef basic_istream< wchar_t>  wistream; 
# 181
typedef basic_ostream< wchar_t>  wostream; 
# 184
typedef basic_iostream< wchar_t>  wiostream; 
# 187
typedef __cxx11::basic_stringbuf< wchar_t>  wstringbuf; 
# 190
typedef __cxx11::basic_istringstream< wchar_t>  wistringstream; 
# 193
typedef __cxx11::basic_ostringstream< wchar_t>  wostringstream; 
# 196
typedef __cxx11::basic_stringstream< wchar_t>  wstringstream; 
# 199
typedef basic_filebuf< wchar_t>  wfilebuf; 
# 202
typedef basic_ifstream< wchar_t>  wifstream; 
# 205
typedef basic_ofstream< wchar_t>  wofstream; 
# 208
typedef basic_fstream< wchar_t>  wfstream; 
# 213
}
# 35 "/usr/include/c++/5/exception" 3
#pragma GCC visibility push ( default )
# 40
extern "C++" {
# 42
namespace std { 
# 60
class exception { 
# 63
public: exception() throw() { } 
# 64
virtual ~exception() throw(); 
# 68
virtual const char *what() const throw(); 
# 69
}; 
# 73
class bad_exception : public exception { 
# 76
public: bad_exception() throw() { } 
# 80
virtual ~bad_exception() throw(); 
# 83
virtual const char *what() const throw(); 
# 84
}; 
# 87
typedef void (*terminate_handler)(void); 
# 90
typedef void (*unexpected_handler)(void); 
# 93
terminate_handler set_terminate(terminate_handler) throw(); 
# 102
void terminate() throw() __attribute((__noreturn__)); 
# 105
unexpected_handler set_unexpected(unexpected_handler) throw(); 
# 114
void unexpected() __attribute((__noreturn__)); 
# 127
bool uncaught_exception() throw() __attribute((__pure__)); 
# 130
}
# 132
namespace __gnu_cxx { 
# 152
void __verbose_terminate_handler(); 
# 155
}
# 157
}
# 159
#pragma GCC visibility pop
# 42 "/usr/include/c++/5/bits/functexcept.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
void __throw_bad_exception() __attribute((__noreturn__)); 
# 52
void __throw_bad_alloc() __attribute((__noreturn__)); 
# 56
void __throw_bad_cast() __attribute((__noreturn__)); 
# 59
void __throw_bad_typeid() __attribute((__noreturn__)); 
# 63
void __throw_logic_error(const char *) __attribute((__noreturn__)); 
# 66
void __throw_domain_error(const char *) __attribute((__noreturn__)); 
# 69
void __throw_invalid_argument(const char *) __attribute((__noreturn__)); 
# 72
void __throw_length_error(const char *) __attribute((__noreturn__)); 
# 75
void __throw_out_of_range(const char *) __attribute((__noreturn__)); 
# 78
void __throw_out_of_range_fmt(const char *, ...) __attribute((__noreturn__))
# 79
 __attribute((__format__(__gnu_printf__, 1, 2))); 
# 82
void __throw_runtime_error(const char *) __attribute((__noreturn__)); 
# 85
void __throw_range_error(const char *) __attribute((__noreturn__)); 
# 88
void __throw_overflow_error(const char *) __attribute((__noreturn__)); 
# 91
void __throw_underflow_error(const char *) __attribute((__noreturn__)); 
# 95
void __throw_ios_failure(const char *) __attribute((__noreturn__)); 
# 98
void __throw_system_error(int) __attribute((__noreturn__)); 
# 101
void __throw_future_error(int) __attribute((__noreturn__)); 
# 105
void __throw_bad_function_call() __attribute((__noreturn__)); 
# 108
}
# 37 "/usr/include/c++/5/ext/numeric_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 54
template< class _Value> 
# 55
struct __numeric_traits_integer { 
# 58
static const _Value __min = ((((_Value)(-1)) < 0) ? ((_Value)1) << ((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)) : ((_Value)0)); 
# 59
static const _Value __max = ((((_Value)(-1)) < 0) ? (((((_Value)1) << (((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((_Value)0))); 
# 63
static const bool __is_signed = (((_Value)(-1)) < 0); 
# 64
static const int __digits = ((sizeof(_Value) * (8)) - (((_Value)(-1)) < 0)); 
# 65
}; 
# 67
template< class _Value> const _Value 
# 68
__numeric_traits_integer< _Value> ::__min; 
# 70
template< class _Value> const _Value 
# 71
__numeric_traits_integer< _Value> ::__max; 
# 73
template< class _Value> const bool 
# 74
__numeric_traits_integer< _Value> ::__is_signed; 
# 76
template< class _Value> const int 
# 77
__numeric_traits_integer< _Value> ::__digits; 
# 99
template< class _Value> 
# 100
struct __numeric_traits_floating { 
# 103
static const int __max_digits10 = ((2) + ((((std::__are_same< _Value, float> ::__value) ? 24 : ((std::__are_same< _Value, double> ::__value) ? 53 : 64)) * 643L) / (2136))); 
# 106
static const bool __is_signed = true; 
# 107
static const int __digits10 = ((std::__are_same< _Value, float> ::__value) ? 6 : ((std::__are_same< _Value, double> ::__value) ? 15 : 18)); 
# 108
static const int __max_exponent10 = ((std::__are_same< _Value, float> ::__value) ? 38 : ((std::__are_same< _Value, double> ::__value) ? 308 : 4932)); 
# 109
}; 
# 111
template< class _Value> const int 
# 112
__numeric_traits_floating< _Value> ::__max_digits10; 
# 114
template< class _Value> const bool 
# 115
__numeric_traits_floating< _Value> ::__is_signed; 
# 117
template< class _Value> const int 
# 118
__numeric_traits_floating< _Value> ::__digits10; 
# 120
template< class _Value> const int 
# 121
__numeric_traits_floating< _Value> ::__max_exponent10; 
# 123
template< class _Value> 
# 124
struct __numeric_traits : public __conditional_type< std::__is_integer< _Value> ::__value, __numeric_traits_integer< _Value> , __numeric_traits_floating< _Value> > ::__type { 
# 128
}; 
# 131
}
# 65 "/usr/include/c++/5/bits/stl_pair.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 95
template< class _T1, class _T2> 
# 96
struct pair { 
# 98
typedef _T1 first_type; 
# 99
typedef _T2 second_type; 
# 101
_T1 first; 
# 102
_T2 second; 
# 108
pair() : first(), second() 
# 109
{ } 
# 112
pair(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) 
# 113
{ } 
# 117
template< class _U1, class _U2> 
# 118
pair(const std::pair< _U1, _U2>  &__p) : first((__p.first)), second((__p.second)) 
# 119
{ } 
# 209
}; 
# 212
template< class _T1, class _T2> inline bool 
# 214
operator==(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 215
{ return ((__x.first) == (__y.first)) && ((__x.second) == (__y.second)); } 
# 218
template< class _T1, class _T2> inline bool 
# 220
operator<(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 221
{ return ((__x.first) < (__y.first)) || ((!((__y.first) < (__x.first))) && ((__x.second) < (__y.second))); 
# 222
} 
# 225
template< class _T1, class _T2> inline bool 
# 227
operator!=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 228
{ return !(__x == __y); } 
# 231
template< class _T1, class _T2> inline bool 
# 233
operator>(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 234
{ return __y < __x; } 
# 237
template< class _T1, class _T2> inline bool 
# 239
operator<=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 240
{ return !(__y < __x); } 
# 243
template< class _T1, class _T2> inline bool 
# 245
operator>=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 246
{ return !(__x < __y); } 
# 284
template< class _T1, class _T2> inline pair< _T1, _T2>  
# 286
make_pair(_T1 __x, _T2 __y) 
# 287
{ return pair< _T1, _T2> (__x, __y); } 
# 293
}
# 33 "/usr/include/c++/5/bits/predefined_ops.h" 3
namespace __gnu_cxx { 
# 35
namespace __ops { 
# 37
struct _Iter_less_iter { 
# 39
template< class _Iterator1, class _Iterator2> bool 
# 42
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 43
{ return (*__it1) < (*__it2); } 
# 44
}; 
# 47
inline _Iter_less_iter __iter_less_iter() 
# 48
{ return _Iter_less_iter(); } 
# 50
struct _Iter_less_val { 
# 52
template< class _Iterator, class _Value> bool 
# 54
operator()(_Iterator __it, _Value &__val) const 
# 55
{ return (*__it) < __val; } 
# 56
}; 
# 59
inline _Iter_less_val __iter_less_val() 
# 60
{ return _Iter_less_val(); } 
# 63
inline _Iter_less_val __iter_comp_val(_Iter_less_iter) 
# 64
{ return _Iter_less_val(); } 
# 66
struct _Val_less_iter { 
# 68
template< class _Value, class _Iterator> bool 
# 70
operator()(_Value &__val, _Iterator __it) const 
# 71
{ return __val < (*__it); } 
# 72
}; 
# 75
inline _Val_less_iter __val_less_iter() 
# 76
{ return _Val_less_iter(); } 
# 79
inline _Val_less_iter __val_comp_iter(_Iter_less_iter) 
# 80
{ return _Val_less_iter(); } 
# 82
struct _Iter_equal_to_iter { 
# 84
template< class _Iterator1, class _Iterator2> bool 
# 86
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 87
{ return (*__it1) == (*__it2); } 
# 88
}; 
# 91
inline _Iter_equal_to_iter __iter_equal_to_iter() 
# 92
{ return _Iter_equal_to_iter(); } 
# 94
struct _Iter_equal_to_val { 
# 96
template< class _Iterator, class _Value> bool 
# 98
operator()(_Iterator __it, _Value &__val) const 
# 99
{ return (*__it) == __val; } 
# 100
}; 
# 103
inline _Iter_equal_to_val __iter_equal_to_val() 
# 104
{ return _Iter_equal_to_val(); } 
# 107
inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) 
# 108
{ return _Iter_equal_to_val(); } 
# 110
template< class _Compare> 
# 111
struct _Iter_comp_iter { 
# 113
_Compare _M_comp; 
# 115
_Iter_comp_iter(_Compare __comp) : _M_comp(__comp) 
# 117
{ } 
# 119
template< class _Iterator1, class _Iterator2> bool 
# 122
operator()(_Iterator1 __it1, _Iterator2 __it2) 
# 123
{ return (bool)(_M_comp)(*__it1, *__it2); } 
# 124
}; 
# 126
template< class _Compare> inline _Iter_comp_iter< _Compare>  
# 129
__iter_comp_iter(_Compare __comp) 
# 130
{ return ((_Iter_comp_iter< _Compare> )(__comp)); } 
# 132
template< class _Compare> 
# 133
struct _Iter_comp_val { 
# 135
_Compare _M_comp; 
# 137
_Iter_comp_val(_Compare __comp) : _M_comp(__comp) 
# 139
{ } 
# 141
template< class _Iterator, class _Value> bool 
# 143
operator()(_Iterator __it, _Value &__val) 
# 144
{ return (bool)(_M_comp)(*__it, __val); } 
# 145
}; 
# 147
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 149
__iter_comp_val(_Compare __comp) 
# 150
{ return ((_Iter_comp_val< _Compare> )(__comp)); } 
# 152
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 154
__iter_comp_val(_Iter_comp_iter< _Compare>  __comp) 
# 155
{ return ((_Iter_comp_val< _Compare> )((__comp._M_comp))); } 
# 157
template< class _Compare> 
# 158
struct _Val_comp_iter { 
# 160
_Compare _M_comp; 
# 162
_Val_comp_iter(_Compare __comp) : _M_comp(__comp) 
# 164
{ } 
# 166
template< class _Value, class _Iterator> bool 
# 168
operator()(_Value &__val, _Iterator __it) 
# 169
{ return (bool)(_M_comp)(__val, *__it); } 
# 170
}; 
# 172
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 174
__val_comp_iter(_Compare __comp) 
# 175
{ return ((_Val_comp_iter< _Compare> )(__comp)); } 
# 177
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 179
__val_comp_iter(_Iter_comp_iter< _Compare>  __comp) 
# 180
{ return ((_Val_comp_iter< _Compare> )((__comp._M_comp))); } 
# 182
template< class _Value> 
# 183
struct _Iter_equals_val { 
# 185
_Value &_M_value; 
# 187
_Iter_equals_val(_Value &__value) : _M_value(__value) 
# 189
{ } 
# 191
template< class _Iterator> bool 
# 193
operator()(_Iterator __it) 
# 194
{ return (*__it) == (_M_value); } 
# 195
}; 
# 197
template< class _Value> inline _Iter_equals_val< _Value>  
# 199
__iter_equals_val(_Value &__val) 
# 200
{ return ((_Iter_equals_val< _Value> )(__val)); } 
# 202
template< class _Iterator1> 
# 203
struct _Iter_equals_iter { 
# 205
typename std::iterator_traits< _Iterator1> ::reference _M_ref; 
# 207
_Iter_equals_iter(_Iterator1 __it1) : _M_ref(*__it1) 
# 209
{ } 
# 211
template< class _Iterator2> bool 
# 213
operator()(_Iterator2 __it2) 
# 214
{ return (*__it2) == (_M_ref); } 
# 215
}; 
# 217
template< class _Iterator> inline _Iter_equals_iter< _Iterator>  
# 219
__iter_comp_iter(_Iter_equal_to_iter, _Iterator __it) 
# 220
{ return ((_Iter_equals_iter< _Iterator> )(__it)); } 
# 222
template< class _Predicate> 
# 223
struct _Iter_pred { 
# 225
_Predicate _M_pred; 
# 227
_Iter_pred(_Predicate __pred) : _M_pred(__pred) 
# 229
{ } 
# 231
template< class _Iterator> bool 
# 233
operator()(_Iterator __it) 
# 234
{ return (bool)(_M_pred)(*__it); } 
# 235
}; 
# 237
template< class _Predicate> inline _Iter_pred< _Predicate>  
# 239
__pred_iter(_Predicate __pred) 
# 240
{ return ((_Iter_pred< _Predicate> )(__pred)); } 
# 242
template< class _Compare, class _Value> 
# 243
struct _Iter_comp_to_val { 
# 245
_Compare _M_comp; 
# 246
_Value &_M_value; 
# 248
_Iter_comp_to_val(_Compare __comp, _Value &__value) : _M_comp(__comp), _M_value(__value) 
# 250
{ } 
# 252
template< class _Iterator> bool 
# 254
operator()(_Iterator __it) 
# 255
{ return (bool)(_M_comp)(*__it, _M_value); } 
# 256
}; 
# 258
template< class _Compare, class _Value> _Iter_comp_to_val< _Compare, _Value>  
# 260
__iter_comp_val(_Compare __comp, _Value &__val) 
# 261
{ return _Iter_comp_to_val< _Compare, _Value> (__comp, __val); } 
# 263
template< class _Compare, class _Iterator1> 
# 264
struct _Iter_comp_to_iter { 
# 266
_Compare _M_comp; 
# 267
typename std::iterator_traits< _Iterator1> ::reference _M_ref; 
# 269
_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1) : _M_comp(__comp), _M_ref(*__it1) 
# 271
{ } 
# 273
template< class _Iterator2> bool 
# 275
operator()(_Iterator2 __it2) 
# 276
{ return (bool)(_M_comp)(*__it2, _M_ref); } 
# 277
}; 
# 279
template< class _Compare, class _Iterator> inline _Iter_comp_to_iter< _Compare, _Iterator>  
# 281
__iter_comp_iter(_Iter_comp_iter< _Compare>  __comp, _Iterator __it) 
# 282
{ return _Iter_comp_to_iter< _Compare, _Iterator> ((__comp._M_comp), __it); } 
# 284
template< class _Predicate> 
# 285
struct _Iter_negate { 
# 287
_Predicate _M_pred; 
# 289
_Iter_negate(_Predicate __pred) : _M_pred(__pred) 
# 291
{ } 
# 293
template< class _Iterator> bool 
# 295
operator()(_Iterator __it) 
# 296
{ return !((bool)(_M_pred)(*__it)); } 
# 297
}; 
# 299
template< class _Predicate> inline _Iter_negate< _Predicate>  
# 301
__negate(_Iter_pred< _Predicate>  __pred) 
# 302
{ return ((_Iter_negate< _Predicate> )((__pred._M_pred))); } 
# 304
}
# 305
}
# 73 "/usr/include/c++/5/bits/stl_algobase.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 81
template< bool _BoolType> 
# 82
struct __iter_swap { 
# 84
template< class _ForwardIterator1, class _ForwardIterator2> static void 
# 86
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) 
# 87
{ 
# 89
typedef typename iterator_traits< _ForwardIterator1> ::value_type _ValueType1; 
# 90
_ValueType1 __tmp = *__a; 
# 91
(*__a) = (*__b); 
# 92
(*__b) = __tmp; 
# 93
} 
# 94
}; 
# 97
template<> struct __iter_swap< true>  { 
# 99
template< class _ForwardIterator1, class _ForwardIterator2> static void 
# 101
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) 
# 102
{ 
# 103
swap(*__a, *__b); 
# 104
} 
# 105
}; 
# 118
template< class _ForwardIterator1, class _ForwardIterator2> inline void 
# 120
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) 
# 121
{ 
# 130
typedef typename iterator_traits< _ForwardIterator1> ::value_type _ValueType1; 
# 132
typedef typename iterator_traits< _ForwardIterator2> ::value_type _ValueType2; 
# 140
typedef typename iterator_traits< _ForwardIterator1> ::reference _ReferenceType1; 
# 142
typedef typename iterator_traits< _ForwardIterator2> ::reference _ReferenceType2; 
# 143
std::__iter_swap< __are_same< typename iterator_traits< _ForwardIterator1> ::value_type, typename iterator_traits< _ForwardIterator2> ::value_type> ::__value && __are_same< typename iterator_traits< _ForwardIterator1> ::value_type &, typename iterator_traits< _ForwardIterator1> ::reference> ::__value && __are_same< typename iterator_traits< _ForwardIterator2> ::value_type &, typename iterator_traits< _ForwardIterator2> ::reference> ::__value> ::iter_swap(__a, __b); 
# 150
} 
# 164
template< class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator2 
# 166
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 167
__first2) 
# 168
{ 
# 174
; 
# 176
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 177
std::iter_swap(__first1, __first2); }  
# 178
return __first2; 
# 179
} 
# 192
template< class _Tp> inline const _Tp &
# 195
min(const _Tp &__a, const _Tp &__b) 
# 196
{ 
# 200
if (__b < __a) { 
# 201
return __b; }  
# 202
return __a; 
# 203
} 
# 216
template< class _Tp> inline const _Tp &
# 219
max(const _Tp &__a, const _Tp &__b) 
# 220
{ 
# 224
if (__a < __b) { 
# 225
return __b; }  
# 226
return __a; 
# 227
} 
# 240
template< class _Tp, class _Compare> inline const _Tp &
# 243
min(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 244
{ 
# 246
if (__comp(__b, __a)) { 
# 247
return __b; }  
# 248
return __a; 
# 249
} 
# 262
template< class _Tp, class _Compare> inline const _Tp &
# 265
max(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 266
{ 
# 268
if (__comp(__a, __b)) { 
# 269
return __b; }  
# 270
return __a; 
# 271
} 
# 275
template< class _Iterator> 
# 276
struct _Niter_base : public _Iter_base< _Iterator, __is_normal_iterator< _Iterator> ::__value>  { 
# 278
}; 
# 280
template< class _Iterator> inline typename _Niter_base< _Iterator> ::iterator_type 
# 282
__niter_base(_Iterator __it) 
# 283
{ return std::_Niter_base< _Iterator> ::_S_base(__it); } 
# 286
template< class _Iterator> 
# 287
struct _Miter_base : public _Iter_base< _Iterator, __is_move_iterator< _Iterator> ::__value>  { 
# 289
}; 
# 291
template< class _Iterator> inline typename _Miter_base< _Iterator> ::iterator_type 
# 293
__miter_base(_Iterator __it) 
# 294
{ return std::_Miter_base< _Iterator> ::_S_base(__it); } 
# 302
template< bool , bool , class > 
# 303
struct __copy_move { 
# 305
template< class _II, class _OI> static _OI 
# 307
__copy_m(_II __first, _II __last, _OI __result) 
# 308
{ 
# 309
for (; __first != __last; (++__result), (++__first)) { 
# 310
(*__result) = (*__first); }  
# 311
return __result; 
# 312
} 
# 313
}; 
# 331
template<> struct __copy_move< false, false, random_access_iterator_tag>  { 
# 333
template< class _II, class _OI> static _OI 
# 335
__copy_m(_II __first, _II __last, _OI __result) 
# 336
{ 
# 337
typedef typename iterator_traits< _II> ::difference_type _Distance; 
# 338
for (_Distance __n = __last - __first; __n > 0; --__n) 
# 339
{ 
# 340
(*__result) = (*__first); 
# 341
++__first; 
# 342
++__result; 
# 343
}  
# 344
return __result; 
# 345
} 
# 346
}; 
# 368
template< bool _IsMove> 
# 369
struct __copy_move< _IsMove, true, random_access_iterator_tag>  { 
# 371
template< class _Tp> static _Tp *
# 373
__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 374
{ 
# 382
const ptrdiff_t _Num = __last - __first; 
# 383
if (_Num) { 
# 384
__builtin_memmove(__result, __first, sizeof(_Tp) * _Num); }  
# 385
return __result + _Num; 
# 386
} 
# 387
}; 
# 389
template< bool _IsMove, class _II, class _OI> inline _OI 
# 391
__copy_move_a(_II __first, _II __last, _OI __result) 
# 392
{ 
# 393
typedef typename iterator_traits< _II> ::value_type _ValueTypeI; 
# 394
typedef typename iterator_traits< _OI> ::value_type _ValueTypeO; 
# 395
typedef typename iterator_traits< _II> ::iterator_category _Category; 
# 396
const bool __simple = (__is_trivial(_ValueTypeI) && __is_pointer< _II> ::__value && __is_pointer< _OI> ::__value && __are_same< typename iterator_traits< _II> ::value_type, typename iterator_traits< _OI> ::value_type> ::__value); 
# 401
return std::__copy_move< _IsMove, __simple, typename iterator_traits< _II> ::iterator_category> ::__copy_m(__first, __last, __result); 
# 403
} 
# 407
template< class _CharT> struct char_traits; 
# 410
template< class _CharT, class _Traits> class istreambuf_iterator; 
# 413
template< class _CharT, class _Traits> class ostreambuf_iterator; 
# 416
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 422
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 428
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type __copy_move_a2(istreambuf_iterator< _CharT, char_traits< _CharT> > , istreambuf_iterator< _CharT, char_traits< _CharT> > , _CharT *); 
# 434
template< bool _IsMove, class _II, class _OI> inline _OI 
# 436
__copy_move_a2(_II __first, _II __last, _OI __result) 
# 437
{ 
# 438
return (_OI)std::__copy_move_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)); 
# 441
} 
# 460
template< class _II, class _OI> inline _OI 
# 462
copy(_II __first, _II __last, _OI __result) 
# 463
{ 
# 468
; 
# 470
return std::__copy_move_a2< __is_move_iterator< _II> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 473
} 
# 512
template< bool , bool , class > 
# 513
struct __copy_move_backward { 
# 515
template< class _BI1, class _BI2> static _BI2 
# 517
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 518
{ 
# 519
while (__first != __last) { 
# 520
(*(--__result)) = (*(--__last)); }  
# 521
return __result; 
# 522
} 
# 523
}; 
# 541
template<> struct __copy_move_backward< false, false, random_access_iterator_tag>  { 
# 543
template< class _BI1, class _BI2> static _BI2 
# 545
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 546
{ 
# 547
typename iterator_traits< _BI1> ::difference_type __n; 
# 548
for (__n = (__last - __first); __n > 0; --__n) { 
# 549
(*(--__result)) = (*(--__last)); }  
# 550
return __result; 
# 551
} 
# 552
}; 
# 570
template< bool _IsMove> 
# 571
struct __copy_move_backward< _IsMove, true, random_access_iterator_tag>  { 
# 573
template< class _Tp> static _Tp *
# 575
__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 576
{ 
# 584
const ptrdiff_t _Num = __last - __first; 
# 585
if (_Num) { 
# 586
__builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num); }  
# 587
return __result - _Num; 
# 588
} 
# 589
}; 
# 591
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 593
__copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result) 
# 594
{ 
# 595
typedef typename iterator_traits< _BI1> ::value_type _ValueType1; 
# 596
typedef typename iterator_traits< _BI2> ::value_type _ValueType2; 
# 597
typedef typename iterator_traits< _BI1> ::iterator_category _Category; 
# 598
const bool __simple = (__is_trivial(_ValueType1) && __is_pointer< _BI1> ::__value && __is_pointer< _BI2> ::__value && __are_same< typename iterator_traits< _BI1> ::value_type, typename iterator_traits< _BI2> ::value_type> ::__value); 
# 603
return std::__copy_move_backward< _IsMove, __simple, typename iterator_traits< _BI1> ::iterator_category> ::__copy_move_b(__first, __last, __result); 
# 607
} 
# 609
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 611
__copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result) 
# 612
{ 
# 613
return (_BI2)std::__copy_move_backward_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)); 
# 616
} 
# 636
template< class _BI1, class _BI2> inline _BI2 
# 638
copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) 
# 639
{ 
# 646
; 
# 648
return std::__copy_move_backward_a2< __is_move_iterator< _BI1> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 651
} 
# 694
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, void> ::__type 
# 697
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 698
__value) 
# 699
{ 
# 700
for (; __first != __last; ++__first) { 
# 701
(*__first) = __value; }  
# 702
} 
# 704
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, void> ::__type 
# 707
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 708
__value) 
# 709
{ 
# 710
const _Tp __tmp = __value; 
# 711
for (; __first != __last; ++__first) { 
# 712
(*__first) = __tmp; }  
# 713
} 
# 716
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, void> ::__type 
# 719
__fill_a(_Tp *__first, _Tp *__last, const _Tp &__c) 
# 720
{ 
# 721
const _Tp __tmp = __c; 
# 722
if (const size_t __len = __last - __first) { 
# 723
__builtin_memset(__first, static_cast< unsigned char>(__tmp), __len); }  
# 724
} 
# 738
template< class _ForwardIterator, class _Tp> inline void 
# 740
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) 
# 741
{ 
# 745
; 
# 747
std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value); 
# 749
} 
# 751
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 754
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 755
{ 
# 756
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), (++__first)) { 
# 758
(*__first) = __value; }  
# 759
return __first; 
# 760
} 
# 762
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 765
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 766
{ 
# 767
const _Tp __tmp = __value; 
# 768
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), (++__first)) { 
# 770
(*__first) = __tmp; }  
# 771
return __first; 
# 772
} 
# 774
template< class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, _Tp *> ::__type 
# 777
__fill_n_a(_Tp *__first, _Size __n, const _Tp &__c) 
# 778
{ 
# 779
std::__fill_a(__first, __first + __n, __c); 
# 780
return __first + __n; 
# 781
} 
# 798
template< class _OI, class _Size, class _Tp> inline _OI 
# 800
fill_n(_OI __first, _Size __n, const _Tp &__value) 
# 801
{ 
# 805
return (_OI)std::__fill_n_a(std::__niter_base(__first), __n, __value); 
# 806
} 
# 808
template< bool _BoolType> 
# 809
struct __equal { 
# 811
template< class _II1, class _II2> static bool 
# 813
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 814
{ 
# 815
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 816
if (!((*__first1) == (*__first2))) { 
# 817
return false; }  }  
# 818
return true; 
# 819
} 
# 820
}; 
# 823
template<> struct __equal< true>  { 
# 825
template< class _Tp> static bool 
# 827
equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2) 
# 828
{ 
# 829
if (const size_t __len = __last1 - __first1) { 
# 830
return !(__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len)); }  
# 831
return true; 
# 832
} 
# 833
}; 
# 835
template< class _II1, class _II2> inline bool 
# 837
__equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) 
# 838
{ 
# 839
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 840
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 841
const bool __simple = ((__is_integer< typename iterator_traits< _II1> ::value_type> ::__value || __is_pointer< typename iterator_traits< _II1> ::value_type> ::__value) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value && __are_same< typename iterator_traits< _II1> ::value_type, typename iterator_traits< _II2> ::value_type> ::__value); 
# 847
return std::__equal< __simple> ::equal(__first1, __last1, __first2); 
# 848
} 
# 850
template< class , class > 
# 851
struct __lc_rai { 
# 853
template< class _II1, class _II2> static _II1 
# 855
__newlast1(_II1, _II1 __last1, _II2, _II2) 
# 856
{ return __last1; } 
# 858
template< class _II> static bool 
# 860
__cnd2(_II __first, _II __last) 
# 861
{ return __first != __last; } 
# 862
}; 
# 865
template<> struct __lc_rai< random_access_iterator_tag, random_access_iterator_tag>  { 
# 867
template< class _RAI1, class _RAI2> static _RAI1 
# 869
__newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 
# 870
__first2, _RAI2 __last2) 
# 871
{ 
# 873
const typename iterator_traits< _RAI1> ::difference_type __diff1 = __last1 - __first1; 
# 875
const typename iterator_traits< _RAI2> ::difference_type __diff2 = __last2 - __first2; 
# 876
return (__diff2 < __diff1) ? __first1 + __diff2 : __last1; 
# 877
} 
# 879
template< class _RAI> static bool 
# 881
__cnd2(_RAI, _RAI) 
# 882
{ return true; } 
# 883
}; 
# 885
template< class _II1, class _II2, class _Compare> bool 
# 887
__lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 
# 888
__first2, _II2 __last2, _Compare 
# 889
__comp) 
# 890
{ 
# 891
typedef typename iterator_traits< _II1> ::iterator_category _Category1; 
# 892
typedef typename iterator_traits< _II2> ::iterator_category _Category2; 
# 893
typedef __lc_rai< typename iterator_traits< _II1> ::iterator_category, typename iterator_traits< _II2> ::iterator_category>  __rai_type; 
# 895
__last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2); 
# 896
for (; (__first1 != __last1) && __rai_type::__cnd2(__first2, __last2); (++__first1), (++__first2)) 
# 898
{ 
# 899
if (__comp(__first1, __first2)) { 
# 900
return true; }  
# 901
if (__comp(__first2, __first1)) { 
# 902
return false; }  
# 903
}  
# 904
return (__first1 == __last1) && (__first2 != __last2); 
# 905
} 
# 907
template< bool _BoolType> 
# 908
struct __lexicographical_compare { 
# 910
template< class _II1, class _II2> static bool __lc(_II1, _II1, _II2, _II2); 
# 912
}; 
# 914
template< bool _BoolType> 
# 915
template< class _II1, class _II2> bool 
# 918
__lexicographical_compare< _BoolType> ::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) 
# 919
{ 
# 920
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter()); 
# 923
} 
# 926
template<> struct __lexicographical_compare< true>  { 
# 928
template< class _Tp, class _Up> static bool 
# 930
__lc(const _Tp *__first1, const _Tp *__last1, const _Up *
# 931
__first2, const _Up *__last2) 
# 932
{ 
# 933
const size_t __len1 = __last1 - __first1; 
# 934
const size_t __len2 = __last2 - __first2; 
# 935
if (const size_t __len = std::min(__len1, __len2)) { 
# 936
if (int __result = __builtin_memcmp(__first1, __first2, __len)) { 
# 937
return __result < 0; }  }  
# 938
return __len1 < __len2; 
# 939
} 
# 940
}; 
# 942
template< class _II1, class _II2> inline bool 
# 944
__lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 
# 945
__first2, _II2 __last2) 
# 946
{ 
# 947
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 948
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 949
const bool __simple = (__is_byte< typename iterator_traits< _II1> ::value_type> ::__value && __is_byte< typename iterator_traits< _II2> ::value_type> ::__value && (!__gnu_cxx::__numeric_traits< typename iterator_traits< _II1> ::value_type> ::__is_signed) && (!__gnu_cxx::__numeric_traits< typename iterator_traits< _II2> ::value_type> ::__is_signed) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value); 
# 956
return std::__lexicographical_compare< __simple> ::__lc(__first1, __last1, __first2, __last2); 
# 958
} 
# 960
template< class _ForwardIterator, class _Tp, class _Compare> _ForwardIterator 
# 962
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 963
__val, _Compare __comp) 
# 964
{ 
# 966
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 968
_DistanceType __len = std::distance(__first, __last); 
# 970
while (__len > 0) 
# 971
{ 
# 972
_DistanceType __half = __len >> 1; 
# 973
_ForwardIterator __middle = __first; 
# 974
std::advance(__middle, __half); 
# 975
if (__comp(__middle, __val)) 
# 976
{ 
# 977
__first = __middle; 
# 978
++__first; 
# 979
__len = ((__len - __half) - 1); 
# 980
} else { 
# 982
__len = __half; }  
# 983
}  
# 984
return __first; 
# 985
} 
# 998
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 1000
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 1001
__val) 
# 1002
{ 
# 1007
; 
# 1009
return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val()); 
# 1011
} 
# 1016
inline int __lg(int __n) 
# 1017
{ return ((sizeof(int) * (8)) - (1)) - (__builtin_clz(__n)); } 
# 1020
inline unsigned __lg(unsigned __n) 
# 1021
{ return ((sizeof(int) * (8)) - (1)) - (__builtin_clz(__n)); } 
# 1024
inline long __lg(long __n) 
# 1025
{ return ((sizeof(long) * (8)) - (1)) - (__builtin_clzl(__n)); } 
# 1028
inline unsigned long __lg(unsigned long __n) 
# 1029
{ return ((sizeof(long) * (8)) - (1)) - (__builtin_clzl(__n)); } 
# 1032
inline long long __lg(long long __n) 
# 1033
{ return ((sizeof(long long) * (8)) - (1)) - (__builtin_clzll(__n)); } 
# 1036
inline unsigned long long __lg(unsigned long long __n) 
# 1037
{ return ((sizeof(long long) * (8)) - (1)) - (__builtin_clzll(__n)); } 
# 1055
template< class _II1, class _II2> inline bool 
# 1057
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 1058
{ 
# 1065
; 
# 1067
return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2)); 
# 1070
} 
# 1087
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool 
# 1089
equal(_IIter1 __first1, _IIter1 __last1, _IIter2 
# 1090
__first2, _BinaryPredicate __binary_pred) 
# 1091
{ 
# 1095
; 
# 1097
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 1098
if (!((bool)__binary_pred(*__first1, *__first2))) { 
# 1099
return false; }  }  
# 1100
return true; 
# 1101
} 
# 1215
template< class _II1, class _II2> inline bool 
# 1217
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1218
__first2, _II2 __last2) 
# 1219
{ 
# 1229
; 
# 1230
; 
# 1232
return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2)); 
# 1236
} 
# 1251
template< class _II1, class _II2, class _Compare> inline bool 
# 1253
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1254
__first2, _II2 __last2, _Compare __comp) 
# 1255
{ 
# 1259
; 
# 1260
; 
# 1262
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 1265
} 
# 1267
template< class _InputIterator1, class _InputIterator2, class 
# 1268
_BinaryPredicate> pair< _InputIterator1, _InputIterator2>  
# 1270
__mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1271
__first2, _BinaryPredicate __binary_pred) 
# 1272
{ 
# 1273
while ((__first1 != __last1) && __binary_pred(__first1, __first2)) 
# 1274
{ 
# 1275
++__first1; 
# 1276
++__first2; 
# 1277
}  
# 1278
return pair< _InputIterator1, _InputIterator2> (__first1, __first2); 
# 1279
} 
# 1294
template< class _InputIterator1, class _InputIterator2> inline pair< _InputIterator1, _InputIterator2>  
# 1296
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1297
__first2) 
# 1298
{ 
# 1305
; 
# 1307
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1309
} 
# 1327
template< class _InputIterator1, class _InputIterator2, class 
# 1328
_BinaryPredicate> inline pair< _InputIterator1, _InputIterator2>  
# 1330
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1331
__first2, _BinaryPredicate __binary_pred) 
# 1332
{ 
# 1336
; 
# 1338
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1340
} 
# 1428
}
# 43 "/usr/include/c++/5/bits/char_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 57
template< class _CharT> 
# 58
struct _Char_types { 
# 60
typedef unsigned long int_type; 
# 61
typedef std::streampos pos_type; 
# 62
typedef std::streamoff off_type; 
# 63
typedef mbstate_t state_type; 
# 64
}; 
# 82
template< class _CharT> 
# 83
struct char_traits { 
# 85
typedef _CharT char_type; 
# 86
typedef typename _Char_types< _CharT> ::int_type int_type; 
# 87
typedef typename _Char_types< _CharT> ::pos_type pos_type; 
# 88
typedef typename _Char_types< _CharT> ::off_type off_type; 
# 89
typedef typename _Char_types< _CharT> ::state_type state_type; 
# 92
static void assign(char_type &__c1, const char_type &__c2) 
# 93
{ __c1 = __c2; } 
# 96
static bool eq(const char_type &__c1, const char_type &__c2) 
# 97
{ return __c1 == __c2; } 
# 100
static bool lt(const char_type &__c1, const char_type &__c2) 
# 101
{ return __c1 < __c2; } 
# 104
static int compare(const char_type * __s1, const char_type * __s2, std::size_t __n); 
# 107
static std::size_t length(const char_type * __s); 
# 110
static const char_type *find(const char_type * __s, std::size_t __n, const char_type & __a); 
# 113
static char_type *move(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 116
static char_type *copy(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 119
static char_type *assign(char_type * __s, std::size_t __n, char_type __a); 
# 122
static char_type to_char_type(const int_type &__c) 
# 123
{ return static_cast< char_type>(__c); } 
# 126
static int_type to_int_type(const char_type &__c) 
# 127
{ return static_cast< int_type>(__c); } 
# 130
static bool eq_int_type(const int_type &__c1, const int_type &__c2) 
# 131
{ return __c1 == __c2; } 
# 134
static int_type eof() 
# 135
{ return static_cast< int_type>(-1); } 
# 138
static int_type not_eof(const int_type &__c) 
# 139
{ return (!(eq_int_type)(__c, (eof)())) ? __c : (to_int_type)(char_type()); } 
# 140
}; 
# 142
template< class _CharT> int 
# 145
char_traits< _CharT> ::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) 
# 146
{ 
# 147
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 148
if ((lt)(__s1[__i], __s2[__i])) { 
# 149
return -1; } else { 
# 150
if ((lt)(__s2[__i], __s1[__i])) { 
# 151
return 1; }  }  }  
# 152
return 0; 
# 153
} 
# 155
template< class _CharT> std::size_t 
# 158
char_traits< _CharT> ::length(const char_type *__p) 
# 159
{ 
# 160
std::size_t __i = (0); 
# 161
while (!(eq)(__p[__i], char_type())) { 
# 162
++__i; }  
# 163
return __i; 
# 164
} 
# 166
template< class _CharT> const typename char_traits< _CharT> ::char_type *
# 169
char_traits< _CharT> ::find(const char_type *__s, std::size_t __n, const char_type &__a) 
# 170
{ 
# 171
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 172
if ((eq)(__s[__i], __a)) { 
# 173
return __s + __i; }  }  
# 174
return 0; 
# 175
} 
# 177
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 180
char_traits< _CharT> ::move(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 181
{ 
# 182
return static_cast< _CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))); 
# 184
} 
# 186
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 189
char_traits< _CharT> ::copy(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 190
{ 
# 192
std::copy(__s2, __s2 + __n, __s1); 
# 193
return __s1; 
# 194
} 
# 196
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 199
char_traits< _CharT> ::assign(char_type *__s, std::size_t __n, char_type __a) 
# 200
{ 
# 202
std::fill_n(__s, __n, __a); 
# 203
return __s; 
# 204
} 
# 207
}
# 209
namespace std __attribute((__visibility__("default"))) { 
# 226
template< class _CharT> 
# 227
struct char_traits : public __gnu_cxx::char_traits< _CharT>  { 
# 228
}; 
# 233
template<> struct char_traits< char>  { 
# 235
typedef char char_type; 
# 236
typedef int int_type; 
# 237
typedef streampos pos_type; 
# 238
typedef streamoff off_type; 
# 239
typedef mbstate_t state_type; 
# 242
static void assign(char_type &__c1, const char_type &__c2) 
# 243
{ __c1 = __c2; } 
# 246
static bool eq(const char_type &__c1, const char_type &__c2) 
# 247
{ return __c1 == __c2; } 
# 250
static bool lt(const char_type &__c1, const char_type &__c2) 
# 251
{ 
# 253
return (static_cast< unsigned char>(__c1)) < (static_cast< unsigned char>(__c2)); 
# 255
} 
# 258
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 259
{ 
# 260
if (__n == (0)) { 
# 261
return 0; }  
# 262
return __builtin_memcmp(__s1, __s2, __n); 
# 263
} 
# 266
static size_t length(const char_type *__s) 
# 267
{ return __builtin_strlen(__s); } 
# 270
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 271
{ 
# 272
if (__n == (0)) { 
# 273
return 0; }  
# 274
return static_cast< const char_type *>(__builtin_memchr(__s, __a, __n)); 
# 275
} 
# 278
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 279
{ 
# 280
if (__n == (0)) { 
# 281
return __s1; }  
# 282
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n)); 
# 283
} 
# 286
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 287
{ 
# 288
if (__n == (0)) { 
# 289
return __s1; }  
# 290
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n)); 
# 291
} 
# 294
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 295
{ 
# 296
if (__n == (0)) { 
# 297
return __s; }  
# 298
return static_cast< char_type *>(__builtin_memset(__s, __a, __n)); 
# 299
} 
# 302
static char_type to_char_type(const int_type &__c) 
# 303
{ return static_cast< char_type>(__c); } 
# 308
static int_type to_int_type(const char_type &__c) 
# 309
{ return static_cast< int_type>(static_cast< unsigned char>(__c)); } 
# 312
static bool eq_int_type(const int_type &__c1, const int_type &__c2) 
# 313
{ return __c1 == __c2; } 
# 316
static int_type eof() 
# 317
{ return static_cast< int_type>(-1); } 
# 320
static int_type not_eof(const int_type &__c) 
# 321
{ return (__c == eof()) ? 0 : __c; } 
# 322
}; 
# 328
template<> struct char_traits< wchar_t>  { 
# 330
typedef wchar_t char_type; 
# 331
typedef wint_t int_type; 
# 332
typedef streamoff off_type; 
# 333
typedef wstreampos pos_type; 
# 334
typedef mbstate_t state_type; 
# 337
static void assign(char_type &__c1, const char_type &__c2) 
# 338
{ __c1 = __c2; } 
# 341
static bool eq(const char_type &__c1, const char_type &__c2) 
# 342
{ return __c1 == __c2; } 
# 345
static bool lt(const char_type &__c1, const char_type &__c2) 
# 346
{ return __c1 < __c2; } 
# 349
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 350
{ 
# 351
if (__n == (0)) { 
# 352
return 0; }  
# 353
return wmemcmp(__s1, __s2, __n); 
# 354
} 
# 357
static size_t length(const char_type *__s) 
# 358
{ return wcslen(__s); } 
# 361
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 362
{ 
# 363
if (__n == (0)) { 
# 364
return 0; }  
# 365
return wmemchr(__s, __a, __n); 
# 366
} 
# 369
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 370
{ 
# 371
if (__n == (0)) { 
# 372
return __s1; }  
# 373
return wmemmove(__s1, __s2, __n); 
# 374
} 
# 377
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 378
{ 
# 379
if (__n == (0)) { 
# 380
return __s1; }  
# 381
return wmemcpy(__s1, __s2, __n); 
# 382
} 
# 385
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 386
{ 
# 387
if (__n == (0)) { 
# 388
return __s; }  
# 389
return wmemset(__s, __a, __n); 
# 390
} 
# 393
static char_type to_char_type(const int_type &__c) 
# 394
{ return (char_type)__c; } 
# 397
static int_type to_int_type(const char_type &__c) 
# 398
{ return (int_type)__c; } 
# 401
static bool eq_int_type(const int_type &__c1, const int_type &__c2) 
# 402
{ return __c1 == __c2; } 
# 405
static int_type eof() 
# 406
{ return static_cast< int_type>(4294967295U); } 
# 409
static int_type not_eof(const int_type &__c) 
# 410
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 411
}; 
# 415
}
# 31 "/usr/include/locale.h" 3
extern "C" {
# 53
struct lconv { 
# 57
char *decimal_point; 
# 58
char *thousands_sep; 
# 64
char *grouping; 
# 70
char *int_curr_symbol; 
# 71
char *currency_symbol; 
# 72
char *mon_decimal_point; 
# 73
char *mon_thousands_sep; 
# 74
char *mon_grouping; 
# 75
char *positive_sign; 
# 76
char *negative_sign; 
# 77
char int_frac_digits; 
# 78
char frac_digits; 
# 80
char p_cs_precedes; 
# 82
char p_sep_by_space; 
# 84
char n_cs_precedes; 
# 86
char n_sep_by_space; 
# 93
char p_sign_posn; 
# 94
char n_sign_posn; 
# 97
char int_p_cs_precedes; 
# 99
char int_p_sep_by_space; 
# 101
char int_n_cs_precedes; 
# 103
char int_n_sep_by_space; 
# 110
char int_p_sign_posn; 
# 111
char int_n_sign_posn; 
# 120
}; 
# 124
extern char *setlocale(int __category, const char * __locale) throw(); 
# 127
extern lconv *localeconv() throw(); 
# 151
extern __locale_t newlocale(int __category_mask, const char * __locale, __locale_t __base) throw(); 
# 186
extern __locale_t duplocale(__locale_t __dataset) throw(); 
# 190
extern void freelocale(__locale_t __dataset) throw(); 
# 197
extern __locale_t uselocale(__locale_t __dataset) throw(); 
# 205
}
# 51 "/usr/include/c++/5/clocale" 3
namespace std { 
# 53
using ::lconv;
# 54
using ::setlocale;
# 55
using ::localeconv;
# 56
}
# 48 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++locale.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 52
extern "C" __typeof__(uselocale) __uselocale; 
# 55
}
# 58
namespace std __attribute((__visibility__("default"))) { 
# 62
typedef __locale_t __c_locale; 
# 69
inline int __convert_from_v(const __c_locale &__cloc __attribute((__unused__)), char *
# 70
__out, const int 
# 71
__size __attribute((__unused__)), const char *
# 72
__fmt, ...) 
# 73
{ 
# 75
__c_locale __old = __gnu_cxx::__uselocale(__cloc); 
# 88
__builtin_va_list __args; 
# 89
__builtin_va_start((__args),__fmt); 
# 92
const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args); 
# 97
__builtin_va_end(__args); 
# 100
__gnu_cxx::__uselocale(__old); 
# 108
return __ret; 
# 109
} 
# 112
}
# 28 "/usr/include/ctype.h" 3
extern "C" {
# 47
enum { 
# 48
_ISupper = 256, 
# 49
_ISlower = 512, 
# 50
_ISalpha = 1024, 
# 51
_ISdigit = 2048, 
# 52
_ISxdigit = 4096, 
# 53
_ISspace = 8192, 
# 54
_ISprint = 16384, 
# 55
_ISgraph = 32768, 
# 56
_ISblank = 1, 
# 57
_IScntrl, 
# 58
_ISpunct = 4, 
# 59
_ISalnum = 8
# 60
}; 
# 79
extern const unsigned short **__ctype_b_loc() throw()
# 80
 __attribute((const)); 
# 81
extern const __int32_t **__ctype_tolower_loc() throw()
# 82
 __attribute((const)); 
# 83
extern const __int32_t **__ctype_toupper_loc() throw()
# 84
 __attribute((const)); 
# 110
extern int isalnum(int) throw(); 
# 111
extern int isalpha(int) throw(); 
# 112
extern int iscntrl(int) throw(); 
# 113
extern int isdigit(int) throw(); 
# 114
extern int islower(int) throw(); 
# 115
extern int isgraph(int) throw(); 
# 116
extern int isprint(int) throw(); 
# 117
extern int ispunct(int) throw(); 
# 118
extern int isspace(int) throw(); 
# 119
extern int isupper(int) throw(); 
# 120
extern int isxdigit(int) throw(); 
# 124
extern int tolower(int __c) throw(); 
# 127
extern int toupper(int __c) throw(); 
# 136
extern int isblank(int) throw(); 
# 143
extern int isctype(int __c, int __mask) throw(); 
# 150
extern int isascii(int __c) throw(); 
# 154
extern int toascii(int __c) throw(); 
# 158
extern int _toupper(int) throw(); 
# 159
extern int _tolower(int) throw(); 
# 271
extern int isalnum_l(int, __locale_t) throw(); 
# 272
extern int isalpha_l(int, __locale_t) throw(); 
# 273
extern int iscntrl_l(int, __locale_t) throw(); 
# 274
extern int isdigit_l(int, __locale_t) throw(); 
# 275
extern int islower_l(int, __locale_t) throw(); 
# 276
extern int isgraph_l(int, __locale_t) throw(); 
# 277
extern int isprint_l(int, __locale_t) throw(); 
# 278
extern int ispunct_l(int, __locale_t) throw(); 
# 279
extern int isspace_l(int, __locale_t) throw(); 
# 280
extern int isupper_l(int, __locale_t) throw(); 
# 281
extern int isxdigit_l(int, __locale_t) throw(); 
# 283
extern int isblank_l(int, __locale_t) throw(); 
# 287
extern int __tolower_l(int __c, __locale_t __l) throw(); 
# 288
extern int tolower_l(int __c, __locale_t __l) throw(); 
# 291
extern int __toupper_l(int __c, __locale_t __l) throw(); 
# 292
extern int toupper_l(int __c, __locale_t __l) throw(); 
# 347
}
# 62 "/usr/include/c++/5/cctype" 3
namespace std { 
# 64
using ::isalnum;
# 65
using ::isalpha;
# 66
using ::iscntrl;
# 67
using ::isdigit;
# 68
using ::isgraph;
# 69
using ::islower;
# 70
using ::isprint;
# 71
using ::ispunct;
# 72
using ::isspace;
# 73
using ::isupper;
# 74
using ::isxdigit;
# 75
using ::tolower;
# 76
using ::toupper;
# 77
}
# 44 "/usr/include/c++/5/bits/localefwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 55
class locale; 
# 57
template< class _Facet> bool has_facet(const locale &) throw(); 
# 61
template< class _Facet> const _Facet &use_facet(const locale &); 
# 66
template< class _CharT> inline bool isspace(_CharT, const locale &); 
# 70
template< class _CharT> inline bool isprint(_CharT, const locale &); 
# 74
template< class _CharT> inline bool iscntrl(_CharT, const locale &); 
# 78
template< class _CharT> inline bool isupper(_CharT, const locale &); 
# 82
template< class _CharT> inline bool islower(_CharT, const locale &); 
# 86
template< class _CharT> inline bool isalpha(_CharT, const locale &); 
# 90
template< class _CharT> inline bool isdigit(_CharT, const locale &); 
# 94
template< class _CharT> inline bool ispunct(_CharT, const locale &); 
# 98
template< class _CharT> inline bool isxdigit(_CharT, const locale &); 
# 102
template< class _CharT> inline bool isalnum(_CharT, const locale &); 
# 106
template< class _CharT> inline bool isgraph(_CharT, const locale &); 
# 116
template< class _CharT> inline _CharT toupper(_CharT, const locale &); 
# 120
template< class _CharT> inline _CharT tolower(_CharT, const locale &); 
# 125
struct ctype_base; 
# 126
template< class _CharT> class ctype; 
# 128
template<> class ctype< char> ; 
# 130
template<> class ctype< wchar_t> ; 
# 132
template< class _CharT> class ctype_byname; 
# 136
class codecvt_base; 
# 137
template< class _InternT, class _ExternT, class _StateT> class codecvt; 
# 139
template<> class codecvt< char, char, __mbstate_t> ; 
# 141
template<> class codecvt< wchar_t, char, __mbstate_t> ; 
# 143
template< class _InternT, class _ExternT, class _StateT> class codecvt_byname; 
# 148
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class num_get; 
# 150
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class num_put; 
# 153
inline namespace __cxx11 { 
# 154
template< class _CharT> class numpunct; 
# 155
template< class _CharT> class numpunct_byname; 
# 156
}
# 158
inline namespace __cxx11 { 
# 160
template< class _CharT> class collate; 
# 162
template< class _CharT> class collate_byname; 
# 164
}
# 167
class time_base; 
# 168
inline namespace __cxx11 { 
# 169
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class time_get; 
# 171
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class time_get_byname; 
# 173
}
# 174
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class time_put; 
# 176
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class time_put_byname; 
# 180
class money_base; 
# 181
inline namespace __cxx11 { 
# 182
template< class _CharT, class _InIter = istreambuf_iterator< _CharT, char_traits< _CharT> > > class money_get; 
# 184
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT, char_traits< _CharT> > > class money_put; 
# 186
}
# 187
inline namespace __cxx11 { 
# 188
template< class _CharT, bool _Intl = false> class moneypunct; 
# 190
template< class _CharT, bool _Intl = false> class moneypunct_byname; 
# 192
}
# 195
class messages_base; 
# 196
inline namespace __cxx11 { 
# 197
template< class _CharT> class messages; 
# 199
template< class _CharT> class messages_byname; 
# 201
}
# 204
}
# 30 "/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h" 3
#pragma GCC visibility push ( default )
# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3
struct sched_param { 
# 74
int __sched_priority; 
# 75
}; 
# 77
extern "C" {
# 81
extern int clone(int (* __fn)(void * __arg), void * __child_stack, int __flags, void * __arg, ...) throw(); 
# 85
extern int unshare(int __flags) throw(); 
# 88
extern int sched_getcpu() throw(); 
# 91
extern int setns(int __fd, int __nstype) throw(); 
# 95
}
# 103
struct __sched_param { 
# 105
int __sched_priority; 
# 106
}; 
# 118
typedef unsigned long __cpu_mask; 
# 128
typedef 
# 126
struct { 
# 127
__cpu_mask __bits[(1024) / ((8) * sizeof(__cpu_mask))]; 
# 128
} cpu_set_t; 
# 201
extern "C" {
# 203
extern int __sched_cpucount(size_t __setsize, const cpu_set_t * __setp) throw(); 
# 205
extern cpu_set_t *__sched_cpualloc(size_t __count) throw() __attribute((__warn_unused_result__)); 
# 206
extern void __sched_cpufree(cpu_set_t * __set) throw(); 
# 208
}
# 48 "/usr/include/sched.h" 3
extern "C" {
# 51
extern int sched_setparam(__pid_t __pid, const sched_param * __param) throw(); 
# 55
extern int sched_getparam(__pid_t __pid, sched_param * __param) throw(); 
# 58
extern int sched_setscheduler(__pid_t __pid, int __policy, const sched_param * __param) throw(); 
# 62
extern int sched_getscheduler(__pid_t __pid) throw(); 
# 65
extern int sched_yield() throw(); 
# 68
extern int sched_get_priority_max(int __algorithm) throw(); 
# 71
extern int sched_get_priority_min(int __algorithm) throw(); 
# 74
extern int sched_rr_get_interval(__pid_t __pid, timespec * __t) throw(); 
# 118
extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t * __cpuset) throw(); 
# 122
extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t * __cpuset) throw(); 
# 126
}
# 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3
typedef long __jmp_buf[8]; 
# 33 "/usr/include/pthread.h" 3
enum { 
# 34
PTHREAD_CREATE_JOINABLE, 
# 36
PTHREAD_CREATE_DETACHED
# 38
}; 
# 43
enum { 
# 44
PTHREAD_MUTEX_TIMED_NP, 
# 45
PTHREAD_MUTEX_RECURSIVE_NP, 
# 46
PTHREAD_MUTEX_ERRORCHECK_NP, 
# 47
PTHREAD_MUTEX_ADAPTIVE_NP, 
# 50
PTHREAD_MUTEX_NORMAL = 0, 
# 51
PTHREAD_MUTEX_RECURSIVE, 
# 52
PTHREAD_MUTEX_ERRORCHECK, 
# 53
PTHREAD_MUTEX_DEFAULT = 0, 
# 57
PTHREAD_MUTEX_FAST_NP = 0
# 59
}; 
# 65
enum { 
# 66
PTHREAD_MUTEX_STALLED, 
# 67
PTHREAD_MUTEX_STALLED_NP = 0, 
# 68
PTHREAD_MUTEX_ROBUST, 
# 69
PTHREAD_MUTEX_ROBUST_NP = 1
# 70
}; 
# 77
enum { 
# 78
PTHREAD_PRIO_NONE, 
# 79
PTHREAD_PRIO_INHERIT, 
# 80
PTHREAD_PRIO_PROTECT
# 81
}; 
# 115
enum { 
# 116
PTHREAD_RWLOCK_PREFER_READER_NP, 
# 117
PTHREAD_RWLOCK_PREFER_WRITER_NP, 
# 118
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 
# 119
PTHREAD_RWLOCK_DEFAULT_NP = 0
# 120
}; 
# 156
enum { 
# 157
PTHREAD_INHERIT_SCHED, 
# 159
PTHREAD_EXPLICIT_SCHED
# 161
}; 
# 166
enum { 
# 167
PTHREAD_SCOPE_SYSTEM, 
# 169
PTHREAD_SCOPE_PROCESS
# 171
}; 
# 176
enum { 
# 177
PTHREAD_PROCESS_PRIVATE, 
# 179
PTHREAD_PROCESS_SHARED
# 181
}; 
# 190
struct _pthread_cleanup_buffer { 
# 192
void (*__routine)(void *); 
# 193
void *__arg; 
# 194
int __canceltype; 
# 195
_pthread_cleanup_buffer *__prev; 
# 196
}; 
# 200
enum { 
# 201
PTHREAD_CANCEL_ENABLE, 
# 203
PTHREAD_CANCEL_DISABLE
# 205
}; 
# 207
enum { 
# 208
PTHREAD_CANCEL_DEFERRED, 
# 210
PTHREAD_CANCEL_ASYNCHRONOUS
# 212
}; 
# 228
extern "C" {
# 233
extern int pthread_create(pthread_t *__restrict__ __newthread, const pthread_attr_t *__restrict__ __attr, void *(* __start_routine)(void *), void *__restrict__ __arg) throw()
# 236
 __attribute((__nonnull__(1, 3))); 
# 242
extern void pthread_exit(void * __retval) __attribute((__noreturn__)); 
# 250
extern int pthread_join(pthread_t __th, void ** __thread_return); 
# 255
extern int pthread_tryjoin_np(pthread_t __th, void ** __thread_return) throw(); 
# 263
extern int pthread_timedjoin_np(pthread_t __th, void ** __thread_return, const timespec * __abstime); 
# 271
extern int pthread_detach(pthread_t __th) throw(); 
# 275
extern pthread_t pthread_self() throw() __attribute((const)); 
# 278
extern __attribute((gnu_inline)) inline int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw()
# 279
 __attribute((const)); 
# 287
extern int pthread_attr_init(pthread_attr_t * __attr) throw() __attribute((__nonnull__(1))); 
# 290
extern int pthread_attr_destroy(pthread_attr_t * __attr) throw()
# 291
 __attribute((__nonnull__(1))); 
# 294
extern int pthread_attr_getdetachstate(const pthread_attr_t * __attr, int * __detachstate) throw()
# 296
 __attribute((__nonnull__(1, 2))); 
# 299
extern int pthread_attr_setdetachstate(pthread_attr_t * __attr, int __detachstate) throw()
# 301
 __attribute((__nonnull__(1))); 
# 305
extern int pthread_attr_getguardsize(const pthread_attr_t * __attr, size_t * __guardsize) throw()
# 307
 __attribute((__nonnull__(1, 2))); 
# 310
extern int pthread_attr_setguardsize(pthread_attr_t * __attr, size_t __guardsize) throw()
# 312
 __attribute((__nonnull__(1))); 
# 316
extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict__ __attr, sched_param *__restrict__ __param) throw()
# 318
 __attribute((__nonnull__(1, 2))); 
# 321
extern int pthread_attr_setschedparam(pthread_attr_t *__restrict__ __attr, const sched_param *__restrict__ __param) throw()
# 323
 __attribute((__nonnull__(1, 2))); 
# 326
extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __policy) throw()
# 328
 __attribute((__nonnull__(1, 2))); 
# 331
extern int pthread_attr_setschedpolicy(pthread_attr_t * __attr, int __policy) throw()
# 332
 __attribute((__nonnull__(1))); 
# 335
extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __inherit) throw()
# 337
 __attribute((__nonnull__(1, 2))); 
# 340
extern int pthread_attr_setinheritsched(pthread_attr_t * __attr, int __inherit) throw()
# 342
 __attribute((__nonnull__(1))); 
# 346
extern int pthread_attr_getscope(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __scope) throw()
# 348
 __attribute((__nonnull__(1, 2))); 
# 351
extern int pthread_attr_setscope(pthread_attr_t * __attr, int __scope) throw()
# 352
 __attribute((__nonnull__(1))); 
# 355
extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr) throw()
# 357
 __attribute((__nonnull__(1, 2))) __attribute((__deprecated__)); 
# 363
extern int pthread_attr_setstackaddr(pthread_attr_t * __attr, void * __stackaddr) throw()
# 365
 __attribute((__nonnull__(1))) __attribute((__deprecated__)); 
# 368
extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict__ __attr, size_t *__restrict__ __stacksize) throw()
# 370
 __attribute((__nonnull__(1, 2))); 
# 375
extern int pthread_attr_setstacksize(pthread_attr_t * __attr, size_t __stacksize) throw()
# 377
 __attribute((__nonnull__(1))); 
# 381
extern int pthread_attr_getstack(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr, size_t *__restrict__ __stacksize) throw()
# 384
 __attribute((__nonnull__(1, 2, 3))); 
# 389
extern int pthread_attr_setstack(pthread_attr_t * __attr, void * __stackaddr, size_t __stacksize) throw()
# 390
 __attribute((__nonnull__(1))); 
# 396
extern int pthread_attr_setaffinity_np(pthread_attr_t * __attr, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 399
 __attribute((__nonnull__(1, 3))); 
# 403
extern int pthread_attr_getaffinity_np(const pthread_attr_t * __attr, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 406
 __attribute((__nonnull__(1, 3))); 
# 409
extern int pthread_getattr_default_np(pthread_attr_t * __attr) throw()
# 410
 __attribute((__nonnull__(1))); 
# 414
extern int pthread_setattr_default_np(const pthread_attr_t * __attr) throw()
# 415
 __attribute((__nonnull__(1))); 
# 420
extern int pthread_getattr_np(pthread_t __th, pthread_attr_t * __attr) throw()
# 421
 __attribute((__nonnull__(2))); 
# 429
extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const sched_param * __param) throw()
# 431
 __attribute((__nonnull__(3))); 
# 434
extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict__ __policy, sched_param *__restrict__ __param) throw()
# 437
 __attribute((__nonnull__(2, 3))); 
# 440
extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw(); 
# 446
extern int pthread_getname_np(pthread_t __target_thread, char * __buf, size_t __buflen) throw()
# 448
 __attribute((__nonnull__(2))); 
# 451
extern int pthread_setname_np(pthread_t __target_thread, const char * __name) throw()
# 452
 __attribute((__nonnull__(2))); 
# 458
extern int pthread_getconcurrency() throw(); 
# 461
extern int pthread_setconcurrency(int __level) throw(); 
# 469
extern int pthread_yield() throw(); 
# 474
extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 476
 __attribute((__nonnull__(3))); 
# 479
extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 481
 __attribute((__nonnull__(3))); 
# 494
extern int pthread_once(pthread_once_t * __once_control, void (* __init_routine)(void))
# 495
 __attribute((__nonnull__(1, 2))); 
# 506
extern int pthread_setcancelstate(int __state, int * __oldstate); 
# 510
extern int pthread_setcanceltype(int __type, int * __oldtype); 
# 513
extern int pthread_cancel(pthread_t __th); 
# 518
extern void pthread_testcancel(); 
# 531
typedef 
# 524
struct { 
# 526
struct { 
# 527
__jmp_buf __cancel_jmp_buf; 
# 528
int __mask_was_saved; 
# 529
} __cancel_jmp_buf[1]; 
# 530
void *__pad[4]; 
# 531
} __pthread_unwind_buf_t __attribute((__aligned__)); 
# 540
struct __pthread_cleanup_frame { 
# 542
void (*__cancel_routine)(void *); 
# 543
void *__cancel_arg; 
# 544
int __do_it; 
# 545
int __cancel_type; 
# 546
}; 
# 551
class __pthread_cleanup_class { 
# 553
void (*__cancel_routine)(void *); 
# 554
void *__cancel_arg; 
# 555
int __do_it; 
# 556
int __cancel_type; 
# 559
public: __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) 
# 560
{ } 
# 561
~__pthread_cleanup_class() { if (__do_it) { (__cancel_routine)(__cancel_arg); }  } 
# 562
void __setdoit(int __newval) { (__do_it) = __newval; } 
# 563
void __defer() { pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &(__cancel_type)); 
# 564
} 
# 565
void __restore() const { pthread_setcanceltype(__cancel_type, 0); } 
# 566
}; 
# 742
struct __jmp_buf_tag; 
# 743
extern int __sigsetjmp(__jmp_buf_tag * __env, int __savemask) throw(); 
# 749
extern int pthread_mutex_init(pthread_mutex_t * __mutex, const pthread_mutexattr_t * __mutexattr) throw()
# 751
 __attribute((__nonnull__(1))); 
# 754
extern int pthread_mutex_destroy(pthread_mutex_t * __mutex) throw()
# 755
 __attribute((__nonnull__(1))); 
# 758
extern int pthread_mutex_trylock(pthread_mutex_t * __mutex) throw()
# 759
 __attribute((__nonnull__(1))); 
# 762
extern int pthread_mutex_lock(pthread_mutex_t * __mutex) throw()
# 763
 __attribute((__nonnull__(1))); 
# 767
extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime) throw()
# 769
 __attribute((__nonnull__(1, 2))); 
# 773
extern int pthread_mutex_unlock(pthread_mutex_t * __mutex) throw()
# 774
 __attribute((__nonnull__(1))); 
# 778
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict__ __mutex, int *__restrict__ __prioceiling) throw()
# 781
 __attribute((__nonnull__(1, 2))); 
# 785
extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict__ __mutex, int __prioceiling, int *__restrict__ __old_ceiling) throw()
# 788
 __attribute((__nonnull__(1, 3))); 
# 793
extern int pthread_mutex_consistent(pthread_mutex_t * __mutex) throw()
# 794
 __attribute((__nonnull__(1))); 
# 796
extern int pthread_mutex_consistent_np(pthread_mutex_t * __mutex) throw()
# 797
 __attribute((__nonnull__(1))); 
# 806
extern int pthread_mutexattr_init(pthread_mutexattr_t * __attr) throw()
# 807
 __attribute((__nonnull__(1))); 
# 810
extern int pthread_mutexattr_destroy(pthread_mutexattr_t * __attr) throw()
# 811
 __attribute((__nonnull__(1))); 
# 814
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 817
 __attribute((__nonnull__(1, 2))); 
# 820
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t * __attr, int __pshared) throw()
# 822
 __attribute((__nonnull__(1))); 
# 826
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __kind) throw()
# 828
 __attribute((__nonnull__(1, 2))); 
# 833
extern int pthread_mutexattr_settype(pthread_mutexattr_t * __attr, int __kind) throw()
# 834
 __attribute((__nonnull__(1))); 
# 838
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __protocol) throw()
# 841
 __attribute((__nonnull__(1, 2))); 
# 845
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t * __attr, int __protocol) throw()
# 847
 __attribute((__nonnull__(1))); 
# 850
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __prioceiling) throw()
# 853
 __attribute((__nonnull__(1, 2))); 
# 856
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * __attr, int __prioceiling) throw()
# 858
 __attribute((__nonnull__(1))); 
# 862
extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 864
 __attribute((__nonnull__(1, 2))); 
# 866
extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 868
 __attribute((__nonnull__(1, 2))); 
# 872
extern int pthread_mutexattr_setrobust(pthread_mutexattr_t * __attr, int __robustness) throw()
# 874
 __attribute((__nonnull__(1))); 
# 876
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * __attr, int __robustness) throw()
# 878
 __attribute((__nonnull__(1))); 
# 888
extern int pthread_rwlock_init(pthread_rwlock_t *__restrict__ __rwlock, const pthread_rwlockattr_t *__restrict__ __attr) throw()
# 890
 __attribute((__nonnull__(1))); 
# 893
extern int pthread_rwlock_destroy(pthread_rwlock_t * __rwlock) throw()
# 894
 __attribute((__nonnull__(1))); 
# 897
extern int pthread_rwlock_rdlock(pthread_rwlock_t * __rwlock) throw()
# 898
 __attribute((__nonnull__(1))); 
# 901
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t * __rwlock) throw()
# 902
 __attribute((__nonnull__(1))); 
# 906
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 908
 __attribute((__nonnull__(1, 2))); 
# 912
extern int pthread_rwlock_wrlock(pthread_rwlock_t * __rwlock) throw()
# 913
 __attribute((__nonnull__(1))); 
# 916
extern int pthread_rwlock_trywrlock(pthread_rwlock_t * __rwlock) throw()
# 917
 __attribute((__nonnull__(1))); 
# 921
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 923
 __attribute((__nonnull__(1, 2))); 
# 927
extern int pthread_rwlock_unlock(pthread_rwlock_t * __rwlock) throw()
# 928
 __attribute((__nonnull__(1))); 
# 934
extern int pthread_rwlockattr_init(pthread_rwlockattr_t * __attr) throw()
# 935
 __attribute((__nonnull__(1))); 
# 938
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t * __attr) throw()
# 939
 __attribute((__nonnull__(1))); 
# 942
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 945
 __attribute((__nonnull__(1, 2))); 
# 948
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * __attr, int __pshared) throw()
# 950
 __attribute((__nonnull__(1))); 
# 953
extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pref) throw()
# 956
 __attribute((__nonnull__(1, 2))); 
# 959
extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * __attr, int __pref) throw()
# 960
 __attribute((__nonnull__(1))); 
# 968
extern int pthread_cond_init(pthread_cond_t *__restrict__ __cond, const pthread_condattr_t *__restrict__ __cond_attr) throw()
# 970
 __attribute((__nonnull__(1))); 
# 973
extern int pthread_cond_destroy(pthread_cond_t * __cond) throw()
# 974
 __attribute((__nonnull__(1))); 
# 977
extern int pthread_cond_signal(pthread_cond_t * __cond) throw()
# 978
 __attribute((__nonnull__(1))); 
# 981
extern int pthread_cond_broadcast(pthread_cond_t * __cond) throw()
# 982
 __attribute((__nonnull__(1))); 
# 989
extern int pthread_cond_wait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex)
# 991
 __attribute((__nonnull__(1, 2))); 
# 1000
extern int pthread_cond_timedwait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime)
# 1003
 __attribute((__nonnull__(1, 2, 3))); 
# 1008
extern int pthread_condattr_init(pthread_condattr_t * __attr) throw()
# 1009
 __attribute((__nonnull__(1))); 
# 1012
extern int pthread_condattr_destroy(pthread_condattr_t * __attr) throw()
# 1013
 __attribute((__nonnull__(1))); 
# 1016
extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1019
 __attribute((__nonnull__(1, 2))); 
# 1022
extern int pthread_condattr_setpshared(pthread_condattr_t * __attr, int __pshared) throw()
# 1023
 __attribute((__nonnull__(1))); 
# 1027
extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict__ __attr, __clockid_t *__restrict__ __clock_id) throw()
# 1030
 __attribute((__nonnull__(1, 2))); 
# 1033
extern int pthread_condattr_setclock(pthread_condattr_t * __attr, __clockid_t __clock_id) throw()
# 1035
 __attribute((__nonnull__(1))); 
# 1044
extern int pthread_spin_init(pthread_spinlock_t * __lock, int __pshared) throw()
# 1045
 __attribute((__nonnull__(1))); 
# 1048
extern int pthread_spin_destroy(pthread_spinlock_t * __lock) throw()
# 1049
 __attribute((__nonnull__(1))); 
# 1052
extern int pthread_spin_lock(pthread_spinlock_t * __lock) throw()
# 1053
 __attribute((__nonnull__(1))); 
# 1056
extern int pthread_spin_trylock(pthread_spinlock_t * __lock) throw()
# 1057
 __attribute((__nonnull__(1))); 
# 1060
extern int pthread_spin_unlock(pthread_spinlock_t * __lock) throw()
# 1061
 __attribute((__nonnull__(1))); 
# 1068
extern int pthread_barrier_init(pthread_barrier_t *__restrict__ __barrier, const pthread_barrierattr_t *__restrict__ __attr, unsigned __count) throw()
# 1071
 __attribute((__nonnull__(1))); 
# 1074
extern int pthread_barrier_destroy(pthread_barrier_t * __barrier) throw()
# 1075
 __attribute((__nonnull__(1))); 
# 1078
extern int pthread_barrier_wait(pthread_barrier_t * __barrier) throw()
# 1079
 __attribute((__nonnull__(1))); 
# 1083
extern int pthread_barrierattr_init(pthread_barrierattr_t * __attr) throw()
# 1084
 __attribute((__nonnull__(1))); 
# 1087
extern int pthread_barrierattr_destroy(pthread_barrierattr_t * __attr) throw()
# 1088
 __attribute((__nonnull__(1))); 
# 1091
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1094
 __attribute((__nonnull__(1, 2))); 
# 1097
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t * __attr, int __pshared) throw()
# 1099
 __attribute((__nonnull__(1))); 
# 1111
extern int pthread_key_create(pthread_key_t * __key, void (* __destr_function)(void *)) throw()
# 1113
 __attribute((__nonnull__(1))); 
# 1116
extern int pthread_key_delete(pthread_key_t __key) throw(); 
# 1119
extern void *pthread_getspecific(pthread_key_t __key) throw(); 
# 1122
extern int pthread_setspecific(pthread_key_t __key, const void * __pointer) throw(); 
# 1128
extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t * __clock_id) throw()
# 1130
 __attribute((__nonnull__(2))); 
# 1145
extern int pthread_atfork(void (* __prepare)(void), void (* __parent)(void), void (* __child)(void)) throw(); 
# 1152
__attribute((__gnu_inline__)) extern inline int
# 1153
 __attribute((__leaf__)) pthread_equal(pthread_t __thread1, pthread_t __thread2) throw() 
# 1154
{ 
# 1155
return __thread1 == __thread2; 
# 1156
} 
# 1159
}
# 47 "/usr/include/x86_64-linux-gnu/c++/5/bits/gthr-default.h" 3
typedef pthread_t __gthread_t; 
# 48
typedef pthread_key_t __gthread_key_t; 
# 49
typedef pthread_once_t __gthread_once_t; 
# 50
typedef pthread_mutex_t __gthread_mutex_t; 
# 51
typedef pthread_mutex_t __gthread_recursive_mutex_t; 
# 52
typedef pthread_cond_t __gthread_cond_t; 
# 53
typedef timespec __gthread_time_t; 
# 101
static __typeof__(pthread_once) __gthrw_pthread_once __attribute((__weakref__("pthread_once"))); 
# 102
static __typeof__(pthread_getspecific) __gthrw_pthread_getspecific __attribute((__weakref__("pthread_getspecific"))); 
# 103
static __typeof__(pthread_setspecific) __gthrw_pthread_setspecific __attribute((__weakref__("pthread_setspecific"))); 
# 105
static __typeof__(pthread_create) __gthrw_pthread_create __attribute((__weakref__("pthread_create"))); 
# 106
static __typeof__(pthread_join) __gthrw_pthread_join __attribute((__weakref__("pthread_join"))); 
# 107
static __typeof__(pthread_equal) __gthrw_pthread_equal __attribute((__weakref__("pthread_equal"))); 
# 108
static __typeof__(pthread_self) __gthrw_pthread_self __attribute((__weakref__("pthread_self"))); 
# 109
static __typeof__(pthread_detach) __gthrw_pthread_detach __attribute((__weakref__("pthread_detach"))); 
# 111
static __typeof__(pthread_cancel) __gthrw_pthread_cancel __attribute((__weakref__("pthread_cancel"))); 
# 113
static __typeof__(sched_yield) __gthrw_sched_yield __attribute((__weakref__("sched_yield"))); 
# 115
static __typeof__(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute((__weakref__("pthread_mutex_lock"))); 
# 116
static __typeof__(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute((__weakref__("pthread_mutex_trylock"))); 
# 118
static __typeof__(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute((__weakref__("pthread_mutex_timedlock"))); 
# 120
static __typeof__(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute((__weakref__("pthread_mutex_unlock"))); 
# 121
static __typeof__(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute((__weakref__("pthread_mutex_init"))); 
# 122
static __typeof__(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute((__weakref__("pthread_mutex_destroy"))); 
# 124
static __typeof__(pthread_cond_init) __gthrw_pthread_cond_init __attribute((__weakref__("pthread_cond_init"))); 
# 125
static __typeof__(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute((__weakref__("pthread_cond_broadcast"))); 
# 126
static __typeof__(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute((__weakref__("pthread_cond_signal"))); 
# 127
static __typeof__(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute((__weakref__("pthread_cond_wait"))); 
# 128
static __typeof__(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute((__weakref__("pthread_cond_timedwait"))); 
# 129
static __typeof__(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute((__weakref__("pthread_cond_destroy"))); 
# 131
static __typeof__(pthread_key_create) __gthrw_pthread_key_create __attribute((__weakref__("pthread_key_create"))); 
# 132
static __typeof__(pthread_key_delete) __gthrw_pthread_key_delete __attribute((__weakref__("pthread_key_delete"))); 
# 133
static __typeof__(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute((__weakref__("pthread_mutexattr_init"))); 
# 134
static __typeof__(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute((__weakref__("pthread_mutexattr_settype"))); 
# 135
static __typeof__(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute((__weakref__("pthread_mutexattr_destroy"))); 
# 236
static __typeof__(pthread_key_create) __gthrw___pthread_key_create __attribute((__weakref__("__pthread_key_create"))); 
# 247
static inline int __gthread_active_p() 
# 248
{ 
# 249
static void *const __gthread_active_ptr = __extension__ ((void *)(&__gthrw___pthread_key_create)); 
# 251
return __gthread_active_ptr != (0); 
# 252
} 
# 659
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *
# 660
__args) 
# 661
{ 
# 662
return __gthrw_pthread_create(__threadid, __null, __func, __args); 
# 663
} 
# 666
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) 
# 667
{ 
# 668
return __gthrw_pthread_join(__threadid, __value_ptr); 
# 669
} 
# 672
static inline int __gthread_detach(__gthread_t __threadid) 
# 673
{ 
# 674
return __gthrw_pthread_detach(__threadid); 
# 675
} 
# 678
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) 
# 679
{ 
# 680
return __gthrw_pthread_equal(__t1, __t2); 
# 681
} 
# 684
static inline __gthread_t __gthread_self() 
# 685
{ 
# 686
return __gthrw_pthread_self(); 
# 687
} 
# 690
static inline int __gthread_yield() 
# 691
{ 
# 692
return __gthrw_sched_yield(); 
# 693
} 
# 696
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)(void)) 
# 697
{ 
# 698
if (__gthread_active_p()) { 
# 699
return __gthrw_pthread_once(__once, __func); } else { 
# 701
return -1; }  
# 702
} 
# 705
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) 
# 706
{ 
# 707
return __gthrw_pthread_key_create(__key, __dtor); 
# 708
} 
# 711
static inline int __gthread_key_delete(__gthread_key_t __key) 
# 712
{ 
# 713
return __gthrw_pthread_key_delete(__key); 
# 714
} 
# 717
static inline void *__gthread_getspecific(__gthread_key_t __key) 
# 718
{ 
# 719
return __gthrw_pthread_getspecific(__key); 
# 720
} 
# 723
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) 
# 724
{ 
# 725
return __gthrw_pthread_setspecific(__key, __ptr); 
# 726
} 
# 729
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) 
# 730
{ 
# 731
if (__gthread_active_p()) { 
# 732
__gthrw_pthread_mutex_init(__mutex, __null); }  
# 733
} 
# 736
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) 
# 737
{ 
# 738
if (__gthread_active_p()) { 
# 739
return __gthrw_pthread_mutex_destroy(__mutex); } else { 
# 741
return 0; }  
# 742
} 
# 745
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) 
# 746
{ 
# 747
if (__gthread_active_p()) { 
# 748
return __gthrw_pthread_mutex_lock(__mutex); } else { 
# 750
return 0; }  
# 751
} 
# 754
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) 
# 755
{ 
# 756
if (__gthread_active_p()) { 
# 757
return __gthrw_pthread_mutex_trylock(__mutex); } else { 
# 759
return 0; }  
# 760
} 
# 764
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *
# 765
__abs_timeout) 
# 766
{ 
# 767
if (__gthread_active_p()) { 
# 768
return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout); } else { 
# 770
return 0; }  
# 771
} 
# 775
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) 
# 776
{ 
# 777
if (__gthread_active_p()) { 
# 778
return __gthrw_pthread_mutex_unlock(__mutex); } else { 
# 780
return 0; }  
# 781
} 
# 808
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) 
# 809
{ 
# 810
return __gthread_mutex_lock(__mutex); 
# 811
} 
# 814
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) 
# 815
{ 
# 816
return __gthread_mutex_trylock(__mutex); 
# 817
} 
# 821
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *
# 822
__abs_timeout) 
# 823
{ 
# 824
return __gthread_mutex_timedlock(__mutex, __abs_timeout); 
# 825
} 
# 829
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) 
# 830
{ 
# 831
return __gthread_mutex_unlock(__mutex); 
# 832
} 
# 835
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) 
# 836
{ 
# 837
return __gthread_mutex_destroy(__mutex); 
# 838
} 
# 850
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) 
# 851
{ 
# 852
return __gthrw_pthread_cond_broadcast(__cond); 
# 853
} 
# 856
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) 
# 857
{ 
# 858
return __gthrw_pthread_cond_signal(__cond); 
# 859
} 
# 862
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) 
# 863
{ 
# 864
return __gthrw_pthread_cond_wait(__cond, __mutex); 
# 865
} 
# 868
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *
# 869
__abs_timeout) 
# 870
{ 
# 871
return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout); 
# 872
} 
# 875
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *
# 876
__mutex) 
# 877
{ 
# 878
return __gthread_cond_wait(__cond, __mutex); 
# 879
} 
# 882
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) 
# 883
{ 
# 884
return __gthrw_pthread_cond_destroy(__cond); 
# 885
} 
# 151 "/usr/include/x86_64-linux-gnu/c++/5/bits/gthr.h" 3
#pragma GCC visibility pop
# 32 "/usr/include/x86_64-linux-gnu/c++/5/bits/atomic_word.h" 3
typedef int _Atomic_word; 
# 38 "/usr/include/c++/5/ext/atomicity.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 48
static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) 
# 49
{ return __atomic_fetch_add(__mem, __val, 4); } 
# 52
static inline void __atomic_add(volatile _Atomic_word *__mem, int __val) 
# 53
{ __atomic_fetch_add(__mem, __val, 4); } 
# 65
static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) 
# 66
{ 
# 67
_Atomic_word __result = *__mem; 
# 68
(*__mem) += __val; 
# 69
return __result; 
# 70
} 
# 73
static inline void __atomic_add_single(_Atomic_word *__mem, int __val) 
# 74
{ (*__mem) += __val; } 
# 77
__attribute((__unused__)) static inline _Atomic_word 
# 78
__exchange_and_add_dispatch(_Atomic_word *__mem, int __val) 
# 79
{ 
# 81
if (__gthread_active_p()) { 
# 82
return __exchange_and_add(__mem, __val); } else { 
# 84
return __exchange_and_add_single(__mem, __val); }  
# 88
} 
# 91
__attribute((__unused__)) static inline void 
# 92
__atomic_add_dispatch(_Atomic_word *__mem, int __val) 
# 93
{ 
# 95
if (__gthread_active_p()) { 
# 96
__atomic_add(__mem, __val); } else { 
# 98
__atomic_add_single(__mem, __val); }  
# 102
} 
# 105
}
# 42 "/usr/include/c++/5/new" 3
#pragma GCC visibility push ( default )
# 44
extern "C++" {
# 46
namespace std { 
# 54
class bad_alloc : public exception { 
# 57
public: bad_alloc() throw() { } 
# 61
virtual ~bad_alloc() throw(); 
# 64
virtual const char *what() const throw(); 
# 65
}; 
# 82
struct nothrow_t { }; 
# 84
extern const nothrow_t nothrow; 
# 88
typedef void (*new_handler)(void); 
# 92
new_handler set_new_handler(new_handler) throw(); 
# 98
}
# 111
void *operator new(std::size_t) throw(std::bad_alloc)
# 112
 __attribute((__externally_visible__)); 
# 113
void *operator new[](std::size_t) throw(std::bad_alloc)
# 114
 __attribute((__externally_visible__)); 
# 115
void operator delete(void *) throw()
# 116
 __attribute((__externally_visible__)); 
# 117
void operator delete[](void *) throw()
# 118
 __attribute((__externally_visible__)); 
# 119
void *operator new(std::size_t, const std::nothrow_t &) throw()
# 120
 __attribute((__externally_visible__)); 
# 121
void *operator new[](std::size_t, const std::nothrow_t &) throw()
# 122
 __attribute((__externally_visible__)); 
# 123
void operator delete(void *, const std::nothrow_t &) throw()
# 124
 __attribute((__externally_visible__)); 
# 125
void operator delete[](void *, const std::nothrow_t &) throw()
# 126
 __attribute((__externally_visible__)); 
# 129
inline void *operator new(std::size_t, void *__p) throw() 
# 130
{ return __p; } 
# 131
inline void *operator new[](std::size_t, void *__p) throw() 
# 132
{ return __p; } 
# 135
inline void operator delete(void *, void *) throw() { } 
# 136
inline void operator delete[](void *, void *) throw() { } 
# 138
}
# 140
#pragma GCC visibility pop
# 40 "/usr/include/c++/5/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 44
using std::size_t;
# 45
using std::ptrdiff_t;
# 57
template< class _Tp> 
# 58
class new_allocator { 
# 61
public: typedef std::size_t size_type; 
# 62
typedef std::ptrdiff_t difference_type; 
# 63
typedef _Tp *pointer; 
# 64
typedef const _Tp *const_pointer; 
# 65
typedef _Tp &reference; 
# 66
typedef const _Tp &const_reference; 
# 67
typedef _Tp value_type; 
# 69
template< class _Tp1> 
# 70
struct rebind { 
# 71
typedef __gnu_cxx::new_allocator< _Tp1>  other; }; 
# 79
new_allocator() throw() { } 
# 81
new_allocator(const new_allocator &) throw() { } 
# 83
template< class _Tp1> 
# 84
new_allocator(const __gnu_cxx::new_allocator< _Tp1>  &) throw() { } 
# 86
~new_allocator() throw() { } 
# 89
pointer address(reference __x) const 
# 90
{ return std::__addressof(__x); } 
# 93
const_pointer address(const_reference __x) const 
# 94
{ return std::__addressof(__x); } 
# 99
pointer allocate(size_type __n, const void * = 0) 
# 100
{ 
# 101
if (__n > this->max_size()) { 
# 102
std::__throw_bad_alloc(); }  
# 104
return static_cast< _Tp *>(::operator new(__n * sizeof(_Tp))); 
# 105
} 
# 109
void deallocate(pointer __p, size_type) 
# 110
{ ::operator delete(__p); } 
# 113
size_type max_size() const throw() 
# 114
{ return ((std::size_t)(-1)) / sizeof(_Tp); } 
# 129
void construct(pointer __p, const _Tp &__val) 
# 130
{ ::new ((void *)__p) (_Tp)(__val); } 
# 133
void destroy(pointer __p) { (__p->~_Tp()); } 
# 135
}; 
# 137
template< class _Tp> inline bool 
# 139
operator==(const new_allocator< _Tp>  &, const new_allocator< _Tp>  &) 
# 140
{ return true; } 
# 142
template< class _Tp> inline bool 
# 144
operator!=(const new_allocator< _Tp>  &, const new_allocator< _Tp>  &) 
# 145
{ return false; } 
# 148
}
# 52 "/usr/include/c++/5/bits/allocator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template<> class allocator< void>  { 
# 66
public: typedef size_t size_type; 
# 67
typedef ptrdiff_t difference_type; 
# 68
typedef void *pointer; 
# 69
typedef const void *const_pointer; 
# 70
typedef void value_type; 
# 72
template< class _Tp1> 
# 73
struct rebind { 
# 74
typedef std::allocator< _Tp1>  other; }; 
# 81
}; 
# 91
template< class _Tp> 
# 92
class allocator : public __gnu_cxx::new_allocator< _Tp>  { 
# 95
public: typedef ::std::size_t size_type; 
# 96
typedef ::std::ptrdiff_t difference_type; 
# 97
typedef _Tp *pointer; 
# 98
typedef const _Tp *const_pointer; 
# 99
typedef _Tp &reference; 
# 100
typedef const _Tp &const_reference; 
# 101
typedef _Tp value_type; 
# 103
template< class _Tp1> 
# 104
struct rebind { 
# 105
typedef ::std::allocator< _Tp1>  other; }; 
# 113
allocator() throw() { } 
# 115
allocator(const allocator &__a) throw() : ::__gnu_cxx::new_allocator< _Tp> (__a) 
# 116
{ } 
# 118
template< class _Tp1> 
# 119
allocator(const ::std::allocator< _Tp1>  &) throw() { } 
# 121
~allocator() throw() { } 
# 124
}; 
# 126
template< class _T1, class _T2> inline bool 
# 128
operator==(const allocator< _T1>  &, const allocator< _T2>  &) throw() 
# 130
{ return true; } 
# 132
template< class _Tp> inline bool 
# 134
operator==(const allocator< _Tp>  &, const allocator< _Tp>  &) throw() 
# 136
{ return true; } 
# 138
template< class _T1, class _T2> inline bool 
# 140
operator!=(const allocator< _T1>  &, const allocator< _T2>  &) throw() 
# 142
{ return false; } 
# 144
template< class _Tp> inline bool 
# 146
operator!=(const allocator< _Tp>  &, const allocator< _Tp>  &) throw() 
# 148
{ return false; } 
# 155
extern template class allocator< char> ;
# 156
extern template class allocator< wchar_t> ;
# 163
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 164
struct __alloc_swap { 
# 165
static void _S_do_it(_Alloc &, _Alloc &) { } }; 
# 167
template< class _Alloc> 
# 168
struct __alloc_swap< _Alloc, false>  { 
# 171
static void _S_do_it(_Alloc &__one, _Alloc &__two) 
# 172
{ 
# 174
if (__one != __two) { 
# 175
swap(__one, __two); }  
# 176
} 
# 177
}; 
# 180
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 181
struct __alloc_neq { 
# 184
static bool _S_do_it(const _Alloc &, const _Alloc &) 
# 185
{ return false; } 
# 186
}; 
# 188
template< class _Alloc> 
# 189
struct __alloc_neq< _Alloc, false>  { 
# 192
static bool _S_do_it(const _Alloc &__one, const _Alloc &__two) 
# 193
{ return __one != __two; } 
# 194
}; 
# 227
}
# 36 "/usr/include/c++/5/bits/cxxabi_forced.h" 3
#pragma GCC visibility push ( default )
# 39
namespace __cxxabiv1 { 
# 48
class __forced_unwind { 
# 50
virtual ~__forced_unwind() throw(); 
# 53
virtual void __pure_dummy() = 0; 
# 54
}; 
# 55
}
# 58
#pragma GCC visibility pop
# 38 "/usr/include/c++/5/bits/ostream_insert.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
template< class _CharT, class _Traits> inline void 
# 44
__ostream_write(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 45
__s, streamsize __n) 
# 46
{ 
# 47
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 48
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 50
const streamsize __put = ((__out.rdbuf())->sputn(__s, __n)); 
# 51
if (__put != __n) { 
# 52
(__out.setstate(__ios_base::badbit)); }  
# 53
} 
# 55
template< class _CharT, class _Traits> inline void 
# 57
__ostream_fill(basic_ostream< _CharT, _Traits>  &__out, streamsize __n) 
# 58
{ 
# 59
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 60
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 62
const _CharT __c = (__out.fill()); 
# 63
for (; __n > (0); --__n) 
# 64
{ 
# 65
const typename _Traits::int_type __put = ((__out.rdbuf())->sputc(__c)); 
# 66
if (_Traits::eq_int_type(__put, _Traits::eof())) 
# 67
{ 
# 68
(__out.setstate(__ios_base::badbit)); 
# 69
break; 
# 70
}  
# 71
}  
# 72
} 
# 74
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 76
__ostream_insert(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 77
__s, streamsize __n) 
# 78
{ 
# 79
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 80
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 82
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__out); 
# 83
if (__cerb) 
# 84
{ 
# 85
try 
# 86
{ 
# 87
const streamsize __w = (__out.width()); 
# 88
if (__w > __n) 
# 89
{ 
# 90
const bool __left = ((__out.flags()) & __ios_base::adjustfield) == __ios_base::left; 
# 93
if (!__left) { 
# 94
__ostream_fill(__out, __w - __n); }  
# 95
if ((__out.good())) { 
# 96
__ostream_write(__out, __s, __n); }  
# 97
if (__left && (__out.good())) { 
# 98
__ostream_fill(__out, __w - __n); }  
# 99
} else { 
# 101
__ostream_write(__out, __s, __n); }  
# 102
(__out.width(0)); 
# 103
} 
# 104
catch (__cxxabiv1::__forced_unwind &) 
# 105
{ 
# 106
(__out._M_setstate(__ios_base::badbit)); 
# 107
throw; 
# 108
} 
# 109
catch (...) 
# 110
{ (__out._M_setstate(__ios_base::badbit)); }  
# 111
}  
# 112
return __out; 
# 113
} 
# 118
extern template basic_ostream< char>  &__ostream_insert(basic_ostream< char>  & __out, const char * __s, streamsize __n);
# 121
extern template basic_ostream< wchar_t>  &__ostream_insert(basic_ostream< wchar_t>  & __out, const wchar_t * __s, streamsize __n);
# 127
}
# 63 "/usr/include/c++/5/bits/stl_function.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 104
template< class _Arg, class _Result> 
# 105
struct unary_function { 
# 108
typedef _Arg argument_type; 
# 111
typedef _Result result_type; 
# 112
}; 
# 117
template< class _Arg1, class _Arg2, class _Result> 
# 118
struct binary_function { 
# 121
typedef _Arg1 first_argument_type; 
# 124
typedef _Arg2 second_argument_type; 
# 127
typedef _Result result_type; 
# 128
}; 
# 166
template< class _Tp> 
# 167
struct plus : public binary_function< _Tp, _Tp, _Tp>  { 
# 171
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 172
{ return __x + __y; } 
# 173
}; 
# 176
template< class _Tp> 
# 177
struct minus : public binary_function< _Tp, _Tp, _Tp>  { 
# 181
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 182
{ return __x - __y; } 
# 183
}; 
# 186
template< class _Tp> 
# 187
struct multiplies : public binary_function< _Tp, _Tp, _Tp>  { 
# 191
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 192
{ return __x * __y; } 
# 193
}; 
# 196
template< class _Tp> 
# 197
struct divides : public binary_function< _Tp, _Tp, _Tp>  { 
# 201
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 202
{ return __x / __y; } 
# 203
}; 
# 206
template< class _Tp> 
# 207
struct modulus : public binary_function< _Tp, _Tp, _Tp>  { 
# 211
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 212
{ return __x % __y; } 
# 213
}; 
# 216
template< class _Tp> 
# 217
struct negate : public unary_function< _Tp, _Tp>  { 
# 221
_Tp operator()(const _Tp &__x) const 
# 222
{ return -__x; } 
# 223
}; 
# 351
template< class _Tp> 
# 352
struct equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 356
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 357
{ return __x == __y; } 
# 358
}; 
# 361
template< class _Tp> 
# 362
struct not_equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 366
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 367
{ return __x != __y; } 
# 368
}; 
# 371
template< class _Tp> 
# 372
struct greater : public binary_function< _Tp, _Tp, bool>  { 
# 376
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 377
{ return __x > __y; } 
# 378
}; 
# 381
template< class _Tp> 
# 382
struct less : public binary_function< _Tp, _Tp, bool>  { 
# 386
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 387
{ return __x < __y; } 
# 388
}; 
# 391
template< class _Tp> 
# 392
struct greater_equal : public binary_function< _Tp, _Tp, bool>  { 
# 396
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 397
{ return __x >= __y; } 
# 398
}; 
# 401
template< class _Tp> 
# 402
struct less_equal : public binary_function< _Tp, _Tp, bool>  { 
# 406
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 407
{ return __x <= __y; } 
# 408
}; 
# 524
template< class _Tp> 
# 525
struct logical_and : public binary_function< _Tp, _Tp, bool>  { 
# 529
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 530
{ return __x && __y; } 
# 531
}; 
# 534
template< class _Tp> 
# 535
struct logical_or : public binary_function< _Tp, _Tp, bool>  { 
# 539
bool operator()(const _Tp &__x, const _Tp &__y) const 
# 540
{ return __x || __y; } 
# 541
}; 
# 544
template< class _Tp> 
# 545
struct logical_not : public unary_function< _Tp, bool>  { 
# 549
bool operator()(const _Tp &__x) const 
# 550
{ return !__x; } 
# 551
}; 
# 617
template< class _Tp> 
# 618
struct bit_and : public binary_function< _Tp, _Tp, _Tp>  { 
# 622
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 623
{ return __x & __y; } 
# 624
}; 
# 626
template< class _Tp> 
# 627
struct bit_or : public binary_function< _Tp, _Tp, _Tp>  { 
# 631
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 632
{ return __x | __y; } 
# 633
}; 
# 635
template< class _Tp> 
# 636
struct bit_xor : public binary_function< _Tp, _Tp, _Tp>  { 
# 640
_Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 641
{ return __x ^ __y; } 
# 642
}; 
# 644
template< class _Tp> 
# 645
struct bit_not : public unary_function< _Tp, _Tp>  { 
# 649
_Tp operator()(const _Tp &__x) const 
# 650
{ return ~__x; } 
# 651
}; 
# 741
template< class _Predicate> 
# 742
class unary_negate : public unary_function< typename _Predicate::argument_type, bool>  { 
# 746
protected: _Predicate _M_pred; 
# 751
public: explicit unary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 755
bool operator()(const typename _Predicate::argument_type &__x) const 
# 756
{ return !(_M_pred)(__x); } 
# 757
}; 
# 760
template< class _Predicate> inline unary_negate< _Predicate>  
# 763
not1(const _Predicate &__pred) 
# 764
{ return ((unary_negate< _Predicate> )(__pred)); } 
# 767
template< class _Predicate> 
# 768
class binary_negate : public binary_function< typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>  { 
# 773
protected: _Predicate _M_pred; 
# 778
public: explicit binary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 782
bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &
# 783
__y) const 
# 784
{ return !(_M_pred)(__x, __y); } 
# 785
}; 
# 788
template< class _Predicate> inline binary_negate< _Predicate>  
# 791
not2(const _Predicate &__pred) 
# 792
{ return ((binary_negate< _Predicate> )(__pred)); } 
# 818
template< class _Arg, class _Result> 
# 819
class pointer_to_unary_function : public unary_function< _Arg, _Result>  { 
# 822
protected: _Result (*_M_ptr)(_Arg); 
# 825
public: pointer_to_unary_function() { } 
# 828
explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) 
# 829
{ } 
# 832
_Result operator()(_Arg __x) const 
# 833
{ return (_M_ptr)(__x); } 
# 834
}; 
# 837
template< class _Arg, class _Result> inline pointer_to_unary_function< _Arg, _Result>  
# 839
ptr_fun(_Result (*__x)(_Arg)) 
# 840
{ return ((pointer_to_unary_function< _Arg, _Result> )(__x)); } 
# 843
template< class _Arg1, class _Arg2, class _Result> 
# 844
class pointer_to_binary_function : public binary_function< _Arg1, _Arg2, _Result>  { 
# 848
protected: _Result (*_M_ptr)(_Arg1, _Arg2); 
# 851
public: pointer_to_binary_function() { } 
# 854
explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x) 
# 855
{ } 
# 858
_Result operator()(_Arg1 __x, _Arg2 __y) const 
# 859
{ return (_M_ptr)(__x, __y); } 
# 860
}; 
# 863
template< class _Arg1, class _Arg2, class _Result> inline pointer_to_binary_function< _Arg1, _Arg2, _Result>  
# 865
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) 
# 866
{ return ((pointer_to_binary_function< _Arg1, _Arg2, _Result> )(__x)); } 
# 869
template< class _Tp> 
# 870
struct _Identity : public unary_function< _Tp, _Tp>  { 
# 874
_Tp &operator()(_Tp &__x) const 
# 875
{ return __x; } 
# 878
const _Tp &operator()(const _Tp &__x) const 
# 879
{ return __x; } 
# 880
}; 
# 882
template< class _Pair> 
# 883
struct _Select1st : public unary_function< _Pair, typename _Pair::first_type>  { 
# 887
typename _Pair::first_type &operator()(_Pair &__x) const 
# 888
{ return __x.first; } 
# 891
const typename _Pair::first_type &operator()(const _Pair &__x) const 
# 892
{ return __x.first; } 
# 905
}; 
# 907
template< class _Pair> 
# 908
struct _Select2nd : public unary_function< _Pair, typename _Pair::second_type>  { 
# 912
typename _Pair::second_type &operator()(_Pair &__x) const 
# 913
{ return __x.second; } 
# 916
const typename _Pair::second_type &operator()(const _Pair &__x) const 
# 917
{ return __x.second; } 
# 918
}; 
# 938
template< class _Ret, class _Tp> 
# 939
class mem_fun_t : public unary_function< _Tp *, _Ret>  { 
# 943
public: explicit mem_fun_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 944
{ } 
# 947
_Ret operator()(_Tp *__p) const 
# 948
{ return (__p->*(_M_f))(); } 
# 951
private: _Ret (_Tp::*_M_f)(void); 
# 952
}; 
# 956
template< class _Ret, class _Tp> 
# 957
class const_mem_fun_t : public unary_function< const _Tp *, _Ret>  { 
# 961
public: explicit const_mem_fun_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 962
{ } 
# 965
_Ret operator()(const _Tp *__p) const 
# 966
{ return (__p->*(_M_f))(); } 
# 969
private: _Ret (_Tp::*_M_f)(void) const; 
# 970
}; 
# 974
template< class _Ret, class _Tp> 
# 975
class mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 979
public: explicit mem_fun_ref_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 980
{ } 
# 983
_Ret operator()(_Tp &__r) const 
# 984
{ return (__r.*(_M_f))(); } 
# 987
private: _Ret (_Tp::*_M_f)(void); 
# 988
}; 
# 992
template< class _Ret, class _Tp> 
# 993
class const_mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 997
public: explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 998
{ } 
# 1001
_Ret operator()(const _Tp &__r) const 
# 1002
{ return (__r.*(_M_f))(); } 
# 1005
private: _Ret (_Tp::*_M_f)(void) const; 
# 1006
}; 
# 1010
template< class _Ret, class _Tp, class _Arg> 
# 1011
class mem_fun1_t : public binary_function< _Tp *, _Arg, _Ret>  { 
# 1015
public: explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1016
{ } 
# 1019
_Ret operator()(_Tp *__p, _Arg __x) const 
# 1020
{ return (__p->*(_M_f))(__x); } 
# 1023
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1024
}; 
# 1028
template< class _Ret, class _Tp, class _Arg> 
# 1029
class const_mem_fun1_t : public binary_function< const _Tp *, _Arg, _Ret>  { 
# 1033
public: explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1034
{ } 
# 1037
_Ret operator()(const _Tp *__p, _Arg __x) const 
# 1038
{ return (__p->*(_M_f))(__x); } 
# 1041
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1042
}; 
# 1046
template< class _Ret, class _Tp, class _Arg> 
# 1047
class mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1051
public: explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1052
{ } 
# 1055
_Ret operator()(_Tp &__r, _Arg __x) const 
# 1056
{ return (__r.*(_M_f))(__x); } 
# 1059
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1060
}; 
# 1064
template< class _Ret, class _Tp, class _Arg> 
# 1065
class const_mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1069
public: explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1070
{ } 
# 1073
_Ret operator()(const _Tp &__r, _Arg __x) const 
# 1074
{ return (__r.*(_M_f))(__x); } 
# 1077
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1078
}; 
# 1082
template< class _Ret, class _Tp> inline mem_fun_t< _Ret, _Tp>  
# 1084
mem_fun(_Ret (_Tp::*__f)(void)) 
# 1085
{ return ((mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1087
template< class _Ret, class _Tp> inline const_mem_fun_t< _Ret, _Tp>  
# 1089
mem_fun(_Ret (_Tp::*__f)(void) const) 
# 1090
{ return ((const_mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1092
template< class _Ret, class _Tp> inline mem_fun_ref_t< _Ret, _Tp>  
# 1094
mem_fun_ref(_Ret (_Tp::*__f)(void)) 
# 1095
{ return ((mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1097
template< class _Ret, class _Tp> inline const_mem_fun_ref_t< _Ret, _Tp>  
# 1099
mem_fun_ref(_Ret (_Tp::*__f)(void) const) 
# 1100
{ return ((const_mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1102
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_t< _Ret, _Tp, _Arg>  
# 1104
mem_fun(_Ret (_Tp::*__f)(_Arg)) 
# 1105
{ return ((mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1107
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_t< _Ret, _Tp, _Arg>  
# 1109
mem_fun(_Ret (_Tp::*__f)(_Arg) const) 
# 1110
{ return ((const_mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1112
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1114
mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) 
# 1115
{ return ((mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1117
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1119
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) 
# 1120
{ return ((const_mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1125
}
# 60 "/usr/include/c++/5/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 63
namespace std __attribute((__visibility__("default"))) { 
# 107
template< class _Operation> 
# 108
class binder1st : public unary_function< typename _Operation::second_argument_type, typename _Operation::result_type>  { 
# 113
protected: _Operation op; 
# 114
typename _Operation::first_argument_type value; 
# 117
public: binder1st(const _Operation &__x, const typename _Operation::first_argument_type &
# 118
__y) : op(__x), value(__y) 
# 119
{ } 
# 122
typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const 
# 123
{ return (op)(value, __x); } 
# 128
typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const 
# 129
{ return (op)(value, __x); } 
# 130
}; 
# 133
template< class _Operation, class _Tp> inline binder1st< _Operation>  
# 135
bind1st(const _Operation &__fn, const _Tp &__x) 
# 136
{ 
# 137
typedef typename _Operation::first_argument_type _Arg1_type; 
# 138
return binder1st< _Operation> (__fn, (_Arg1_type)__x); 
# 139
} 
# 142
template< class _Operation> 
# 143
class binder2nd : public unary_function< typename _Operation::first_argument_type, typename _Operation::result_type>  { 
# 148
protected: _Operation op; 
# 149
typename _Operation::second_argument_type value; 
# 152
public: binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &
# 153
__y) : op(__x), value(__y) 
# 154
{ } 
# 157
typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const 
# 158
{ return (op)(__x, value); } 
# 163
typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const 
# 164
{ return (op)(__x, value); } 
# 165
}; 
# 168
template< class _Operation, class _Tp> inline binder2nd< _Operation>  
# 170
bind2nd(const _Operation &__fn, const _Tp &__x) 
# 171
{ 
# 172
typedef typename _Operation::second_argument_type _Arg2_type; 
# 173
return binder2nd< _Operation> (__fn, (_Arg2_type)__x); 
# 174
} 
# 178
}
# 180
#pragma GCC diagnostic pop
# 41 "/usr/include/c++/5/ext/alloc_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 94
template< class _Alloc> 
# 95
struct __alloc_traits { 
# 100
typedef _Alloc allocator_type; 
# 172
typedef typename _Alloc::pointer pointer; 
# 173
typedef typename _Alloc::const_pointer const_pointer; 
# 174
typedef typename _Alloc::value_type value_type; 
# 175
typedef typename _Alloc::reference reference; 
# 176
typedef typename _Alloc::const_reference const_reference; 
# 177
typedef typename _Alloc::size_type size_type; 
# 178
typedef typename _Alloc::difference_type difference_type; 
# 181
static pointer allocate(_Alloc &__a, size_type __n) 
# 182
{ return (__a.allocate(__n)); } 
# 184
static void deallocate(_Alloc &__a, pointer __p, size_type __n) 
# 185
{ (__a.deallocate(__p, __n)); } 
# 187
template< class _Tp> static void 
# 188
construct(_Alloc &__a, pointer __p, const _Tp &__arg) 
# 189
{ (__a.construct(__p, __arg)); } 
# 191
static void destroy(_Alloc &__a, pointer __p) 
# 192
{ (__a.destroy(__p)); } 
# 194
static size_type max_size(const _Alloc &__a) 
# 195
{ return (__a.max_size()); } 
# 197
static const _Alloc &_S_select_on_copy(const _Alloc &__a) { return __a; } 
# 199
static void _S_on_swap(_Alloc &__a, _Alloc &__b) 
# 200
{ 
# 203
std::__alloc_swap< _Alloc> ::_S_do_it(__a, __b); 
# 204
} 
# 206
template< class _Tp> 
# 207
struct rebind { 
# 208
typedef typename _Alloc::template rebind< _Tp> ::other other; }; 
# 210
}; 
# 213
}
# 46 "/usr/include/c++/5/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
inline namespace __cxx11 { 
# 70
template< class _CharT, class _Traits, class _Alloc> 
# 71
class basic_string { 
# 74
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other _Char_alloc_type; 
# 75
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other>  _Alloc_traits; 
# 79
public: typedef _Traits traits_type; 
# 80
typedef typename _Traits::char_type value_type; 
# 81
typedef _Char_alloc_type allocator_type; 
# 82
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::size_type size_type; 
# 83
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::difference_type difference_type; 
# 84
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::reference reference; 
# 85
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_reference const_reference; 
# 86
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer pointer; 
# 87
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer const_pointer; 
# 88
typedef __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer, basic_string>  iterator; 
# 90
typedef __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer, basic_string>  const_iterator; 
# 91
typedef std::reverse_iterator< __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::const_pointer, basic_string> >  const_reverse_iterator; 
# 92
typedef std::reverse_iterator< __gnu_cxx::__normal_iterator< typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::pointer, basic_string> >  reverse_iterator; 
# 95
static const size_type npos = (static_cast< size_type>(-1)); 
# 100
private: typedef iterator __const_iterator; 
# 106
struct _Alloc_hider : public allocator_type { 
# 108
_Alloc_hider(typename ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer __dat, const _Alloc &__a = _Alloc()) : ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::allocator_type(__a), _M_p(__dat) 
# 109
{ } 
# 111
typename ::std::__cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer _M_p; 
# 112
}; 
# 114
_Alloc_hider _M_dataplus; 
# 115
size_type _M_string_length; 
# 117
enum { _S_local_capacity = (15) / sizeof(_CharT)}; 
# 120
union { 
# 121
_CharT _M_local_buf[(_S_local_capacity) + 1]; 
# 122
size_type _M_allocated_capacity; 
# 123
}; 
# 126
void _M_data(pointer __p) 
# 127
{ ((_M_dataplus)._M_p) = __p; } 
# 130
void _M_length(size_type __length) 
# 131
{ (_M_string_length) = __length; } 
# 134
pointer _M_data() const 
# 135
{ return (_M_dataplus)._M_p; } 
# 138
pointer _M_local_data() 
# 139
{ 
# 143
return (pointer)(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf); 
# 145
} 
# 148
const_pointer _M_local_data() const 
# 149
{ 
# 153
return (const_pointer)(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf); 
# 155
} 
# 158
void _M_capacity(size_type __capacity) 
# 159
{ (__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity) = __capacity; } 
# 162
void _M_set_length(size_type __n) 
# 163
{ 
# 164
_M_length(__n); 
# 165
traits_type::assign(_M_data()[__n], _CharT()); 
# 166
} 
# 169
bool _M_is_local() const 
# 170
{ return _M_data() == this->_M_local_data(); } 
# 174
pointer _M_create(size_type &, size_type); 
# 177
void _M_dispose() 
# 178
{ 
# 179
if (!_M_is_local()) { 
# 180
_M_destroy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity); }  
# 181
} 
# 184
void _M_destroy(size_type __size) throw() 
# 185
{ _Alloc_traits::deallocate(this->_M_get_allocator(), _M_data(), __size + 1); } 
# 189
template< class _InIterator> void 
# 191
_M_construct_aux(_InIterator __beg, _InIterator __end, __false_type) 
# 193
{ 
# 194
typedef typename iterator_traits< _InIterator> ::iterator_category _Tag; 
# 195
_M_construct(__beg, __end, _Tag()); 
# 196
} 
# 200
template< class _Integer> void 
# 202
_M_construct_aux(_Integer __beg, _Integer __end, __true_type) 
# 203
{ _M_construct_aux_2(static_cast< size_type>(__beg), __end); } 
# 206
void _M_construct_aux_2(size_type __req, _CharT __c) 
# 207
{ _M_construct(__req, __c); } 
# 209
template< class _InIterator> void 
# 211
_M_construct(_InIterator __beg, _InIterator __end) 
# 212
{ 
# 213
typedef typename __is_integer< _InIterator> ::__type _Integral; 
# 214
_M_construct_aux(__beg, __end, _Integral()); 
# 215
} 
# 218
template< class _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag); 
# 225
template< class _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, forward_iterator_tag); 
# 231
void _M_construct(size_type __req, _CharT __c); 
# 234
allocator_type &_M_get_allocator() 
# 235
{ return _M_dataplus; } 
# 238
const allocator_type &_M_get_allocator() const 
# 239
{ return _M_dataplus; } 
# 258
size_type _M_check(size_type __pos, const char *__s) const 
# 259
{ 
# 260
if (__pos > this->size()) { 
# 261
__throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, this->size()); }  
# 264
return __pos; 
# 265
} 
# 268
void _M_check_length(size_type __n1, size_type __n2, const char *__s) const 
# 269
{ 
# 270
if ((this->max_size() - (this->size() - __n1)) < __n2) { 
# 271
__throw_length_error(__s); }  
# 272
} 
# 277
size_type _M_limit(size_type __pos, size_type __off) const 
# 278
{ 
# 279
const bool __testoff = __off < (this->size() - __pos); 
# 280
return __testoff ? __off : (this->size() - __pos); 
# 281
} 
# 285
bool _M_disjunct(const _CharT *__s) const 
# 286
{ 
# 287
return less< const _CharT *> ()(__s, _M_data()) || less< const _CharT *> ()(_M_data() + this->size(), __s); 
# 289
} 
# 294
static void _S_copy(_CharT *__d, const _CharT *__s, size_type __n) 
# 295
{ 
# 296
if (__n == 1) { 
# 297
traits_type::assign(*__d, *__s); } else { 
# 299
traits_type::copy(__d, __s, __n); }  
# 300
} 
# 303
static void _S_move(_CharT *__d, const _CharT *__s, size_type __n) 
# 304
{ 
# 305
if (__n == 1) { 
# 306
traits_type::assign(*__d, *__s); } else { 
# 308
traits_type::move(__d, __s, __n); }  
# 309
} 
# 312
static void _S_assign(_CharT *__d, size_type __n, _CharT __c) 
# 313
{ 
# 314
if (__n == 1) { 
# 315
traits_type::assign(*__d, __c); } else { 
# 317
traits_type::assign(__d, __n, __c); }  
# 318
} 
# 322
template< class _Iterator> static void 
# 324
_S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) 
# 325
{ 
# 326
for (; __k1 != __k2; (++__k1), (++__p)) { 
# 327
traits_type::assign(*__p, *__k1); }  
# 328
} 
# 331
static void _S_copy_chars(_CharT *__p, iterator __k1, iterator __k2) 
# 332
{ _S_copy_chars(__p, (__k1.base()), (__k2.base())); } 
# 335
static void _S_copy_chars(_CharT *__p, const_iterator __k1, const_iterator __k2) 
# 337
{ _S_copy_chars(__p, (__k1.base()), (__k2.base())); } 
# 340
static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) 
# 341
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 344
static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) 
# 346
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 349
static int _S_compare(size_type __n1, size_type __n2) 
# 350
{ 
# 351
const difference_type __d = (difference_type)(__n1 - __n2); 
# 353
if (__d > __gnu_cxx::__numeric_traits< int> ::__max) { 
# 354
return __gnu_cxx::__numeric_traits_integer< int> ::__max; } else { 
# 355
if (__d < __gnu_cxx::__numeric_traits< int> ::__min) { 
# 356
return __gnu_cxx::__numeric_traits_integer< int> ::__min; } else { 
# 358
return (int)__d; }  }  
# 359
} 
# 362
void _M_assign(const basic_string & __rcs); 
# 365
void _M_mutate(size_type __pos, size_type __len1, const _CharT * __s, size_type __len2); 
# 369
void _M_erase(size_type __pos, size_type __n); 
# 379
public: basic_string() : _M_dataplus(this->_M_local_data()) 
# 384
{ _M_set_length(0); } 
# 390
explicit basic_string(const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 392
{ _M_set_length(0); } 
# 398
basic_string(const basic_string &__str) : _M_dataplus(this->_M_local_data(), __str._M_get_allocator()) 
# 400
{ _M_construct((__str._M_data()), (__str._M_data()) + __str.length()); } 
# 410
basic_string(const basic_string &__str, size_type __pos, size_type 
# 411
__n = npos) : _M_dataplus(this->_M_local_data()) 
# 413
{ 
# 414
const _CharT *__start = (__str._M_data()) + __str._M_check(__pos, "basic_string::basic_string"); 
# 416
_M_construct(__start, __start + __str._M_limit(__pos, __n)); 
# 417
} 
# 426
basic_string(const basic_string &__str, size_type __pos, size_type 
# 427
__n, const _Alloc &__a) : _M_dataplus(this->_M_local_data(), __a) 
# 429
{ 
# 430
const _CharT *__start = (__str._M_data()) + __str._M_check(__pos, "string::string"); 
# 432
_M_construct(__start, __start + __str._M_limit(__pos, __n)); 
# 433
} 
# 444
basic_string(const _CharT *__s, size_type __n, const _Alloc &
# 445
__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 447
{ _M_construct(__s, __s + __n); } 
# 454
basic_string(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 456
{ _M_construct(__s, (__s) ? __s + traits_type::length(__s) : (__s + npos)); } 
# 464
basic_string(size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 466
{ _M_construct(__n, __c); } 
# 532
template< class _InputIterator> 
# 534
basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &
# 535
__a = _Alloc()) : _M_dataplus(this->_M_local_data(), __a) 
# 537
{ _M_construct(__beg, __end); } 
# 542
~basic_string() 
# 543
{ _M_dispose(); } 
# 550
basic_string &operator=(const basic_string &__str) 
# 551
{ return (this->assign(__str)); } 
# 558
basic_string &operator=(const _CharT *__s) 
# 559
{ return (this->assign(__s)); } 
# 569
basic_string &operator=(_CharT __c) 
# 570
{ 
# 571
(this->assign(1, __c)); 
# 572
return *this; 
# 573
} 
# 611
iterator begin() 
# 612
{ return ((iterator)(_M_data())); } 
# 619
const_iterator begin() const 
# 620
{ return ((const_iterator)(_M_data())); } 
# 627
iterator end() 
# 628
{ return ((iterator)(_M_data() + this->size())); } 
# 635
const_iterator end() const 
# 636
{ return ((const_iterator)(_M_data() + this->size())); } 
# 644
reverse_iterator rbegin() 
# 645
{ return ((reverse_iterator)(this->end())); } 
# 653
const_reverse_iterator rbegin() const 
# 654
{ return ((const_reverse_iterator)(this->end())); } 
# 662
reverse_iterator rend() 
# 663
{ return ((reverse_iterator)(this->begin())); } 
# 671
const_reverse_iterator rend() const 
# 672
{ return ((const_reverse_iterator)(this->begin())); } 
# 715
size_type size() const 
# 716
{ return _M_string_length; } 
# 721
size_type length() const 
# 722
{ return _M_string_length; } 
# 726
size_type max_size() const 
# 727
{ return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2; } 
# 740
void resize(size_type __n, _CharT __c); 
# 753
void resize(size_type __n) 
# 754
{ (this->resize(__n, _CharT())); } 
# 778
size_type capacity() const 
# 779
{ 
# 780
return (_M_is_local()) ? (size_type)(_S_local_capacity) : (__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity); 
# 782
} 
# 802
void reserve(size_type __res_arg = 0); 
# 808
void clear() 
# 809
{ _M_set_length(0); } 
# 816
bool empty() const 
# 817
{ return this->size() == 0; } 
# 831
const_reference operator[](size_type __pos) const 
# 832
{ 
# 833
; 
# 834
return _M_data()[__pos]; 
# 835
} 
# 848
reference operator[](size_type __pos) 
# 849
{ 
# 852
; 
# 854
; 
# 855
return _M_data()[__pos]; 
# 856
} 
# 869
const_reference at(size_type __n) const 
# 870
{ 
# 871
if (__n >= this->size()) { 
# 872
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 876
return _M_data()[__n]; 
# 877
} 
# 890
reference at(size_type __n) 
# 891
{ 
# 892
if (__n >= size()) { 
# 893
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 897
return _M_data()[__n]; 
# 898
} 
# 941
basic_string &operator+=(const basic_string &__str) 
# 942
{ return (this->append(__str)); } 
# 950
basic_string &operator+=(const _CharT *__s) 
# 951
{ return (this->append(__s)); } 
# 959
basic_string &operator+=(_CharT __c) 
# 960
{ 
# 961
this->push_back(__c); 
# 962
return *this; 
# 963
} 
# 982
basic_string &append(const basic_string &__str) 
# 983
{ return _M_append((__str._M_data()), __str.size()); } 
# 999
basic_string &append(const basic_string &__str, size_type __pos, size_type __n) 
# 1000
{ return _M_append((__str._M_data()) + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n)); 
# 1002
} 
# 1011
basic_string &append(const _CharT *__s, size_type __n) 
# 1012
{ 
# 1013
; 
# 1014
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1015
return _M_append(__s, __n); 
# 1016
} 
# 1024
basic_string &append(const _CharT *__s) 
# 1025
{ 
# 1026
; 
# 1027
const size_type __n = traits_type::length(__s); 
# 1028
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1029
return _M_append(__s, __n); 
# 1030
} 
# 1041
basic_string &append(size_type __n, _CharT __c) 
# 1042
{ return _M_replace_aux(this->size(), (size_type)0, __n, __c); } 
# 1067
template< class _InputIterator> basic_string &
# 1070
append(_InputIterator __first, _InputIterator __last) 
# 1071
{ return (this->replace(this->end(), this->end(), __first, __last)); } 
# 1078
void push_back(_CharT __c) 
# 1079
{ 
# 1080
const size_type __size = this->size(); 
# 1081
if ((__size + 1) > this->capacity()) { 
# 1082
this->_M_mutate(__size, (size_type)0, 0, (size_type)1); }  
# 1083
traits_type::assign((this->_M_data())[__size], __c); 
# 1084
this->_M_set_length(__size + 1); 
# 1085
} 
# 1093
basic_string &assign(const basic_string &__str) 
# 1094
{ 
# 1095
this->_M_assign(__str); 
# 1096
return *this; 
# 1097
} 
# 1131
basic_string &assign(const basic_string &__str, size_type __pos, size_type __n) 
# 1132
{ return _M_replace((size_type)0, this->size(), (__str._M_data()) + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n)); 
# 1134
} 
# 1147
basic_string &assign(const _CharT *__s, size_type __n) 
# 1148
{ 
# 1149
; 
# 1150
return _M_replace((size_type)0, this->size(), __s, __n); 
# 1151
} 
# 1163
basic_string &assign(const _CharT *__s) 
# 1164
{ 
# 1165
; 
# 1166
return _M_replace((size_type)0, this->size(), __s, traits_type::length(__s)); 
# 1168
} 
# 1180
basic_string &assign(size_type __n, _CharT __c) 
# 1181
{ return _M_replace_aux((size_type)0, this->size(), __n, __c); } 
# 1195
template< class _InputIterator> basic_string &
# 1198
assign(_InputIterator __first, _InputIterator __last) 
# 1199
{ return (this->replace(this->begin(), this->end(), __first, __last)); } 
# 1251
void insert(iterator __p, size_type __n, _CharT __c) 
# 1252
{ (this->replace(__p, __p, __n, __c)); } 
# 1293
template< class _InputIterator> void 
# 1295
insert(iterator __p, _InputIterator __beg, _InputIterator __end) 
# 1296
{ (this->replace(__p, __p, __beg, __end)); } 
# 1327
basic_string &insert(size_type __pos1, const basic_string &__str) 
# 1328
{ return (this->replace(__pos1, (size_type)0, (__str._M_data()), __str.size())); 
# 1329
} 
# 1350
basic_string &insert(size_type __pos1, const basic_string &__str, size_type 
# 1351
__pos2, size_type __n) 
# 1352
{ return (this->replace(__pos1, (size_type)0, (__str._M_data()) + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n))); 
# 1354
} 
# 1373
basic_string &insert(size_type __pos, const _CharT *__s, size_type __n) 
# 1374
{ return (this->replace(__pos, (size_type)0, __s, __n)); } 
# 1392
basic_string &insert(size_type __pos, const _CharT *__s) 
# 1393
{ 
# 1394
; 
# 1395
return (this->replace(__pos, (size_type)0, __s, traits_type::length(__s))); 
# 1397
} 
# 1416
basic_string &insert(size_type __pos, size_type __n, _CharT __c) 
# 1417
{ return _M_replace_aux(_M_check(__pos, "basic_string::insert"), (size_type)0, __n, __c); 
# 1418
} 
# 1434
iterator insert(__const_iterator __p, _CharT __c) 
# 1435
{ 
# 1436
; 
# 1437
const size_type __pos = __p - this->begin(); 
# 1438
_M_replace_aux(__pos, (size_type)0, (size_type)1, __c); 
# 1439
return ((iterator)(_M_data() + __pos)); 
# 1440
} 
# 1458
basic_string &erase(size_type __pos = 0, size_type __n = npos) 
# 1459
{ 
# 1460
this->_M_erase(_M_check(__pos, "basic_string::erase"), _M_limit(__pos, __n)); 
# 1462
return *this; 
# 1463
} 
# 1474
iterator erase(__const_iterator __position) 
# 1475
{ 
# 1477
; 
# 1478
const size_type __pos = __position - this->begin(); 
# 1479
this->_M_erase(__pos, (size_type)1); 
# 1480
return ((iterator)(_M_data() + __pos)); 
# 1481
} 
# 1493
iterator erase(__const_iterator __first, __const_iterator __last) 
# 1494
{ 
# 1496
; 
# 1497
const size_type __pos = __first - this->begin(); 
# 1498
this->_M_erase(__pos, __last - __first); 
# 1499
return ((iterator)((this->_M_data()) + __pos)); 
# 1500
} 
# 1531
basic_string &replace(size_type __pos, size_type __n, const basic_string &__str) 
# 1532
{ return (this->replace(__pos, __n, (__str._M_data()), __str.size())); } 
# 1553
basic_string &replace(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1554
__pos2, size_type __n2) 
# 1555
{ return (this->replace(__pos1, __n1, (__str._M_data()) + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2))); 
# 1557
} 
# 1578
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1579
__n2) 
# 1580
{ 
# 1581
; 
# 1582
return _M_replace(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __s, __n2); 
# 1584
} 
# 1603
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s) 
# 1604
{ 
# 1605
; 
# 1606
return (this->replace(__pos, __n1, __s, traits_type::length(__s))); 
# 1607
} 
# 1627
basic_string &replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c) 
# 1628
{ return _M_replace_aux(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __n2, __c); 
# 1629
} 
# 1645
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const basic_string &
# 1646
__str) 
# 1647
{ return (this->replace(__i1, __i2, (__str._M_data()), __str.size())); } 
# 1665
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 1666
__s, size_type __n) 
# 1667
{ 
# 1669
; 
# 1670
return (this->replace(__i1 - this->begin(), __i2 - __i1, __s, __n)); 
# 1671
} 
# 1687
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s) 
# 1688
{ 
# 1689
; 
# 1690
return (this->replace(__i1, __i2, __s, traits_type::length(__s))); 
# 1691
} 
# 1708
basic_string &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, _CharT 
# 1709
__c) 
# 1710
{ 
# 1712
; 
# 1713
return _M_replace_aux(__i1 - this->begin(), __i2 - __i1, __n, __c); 
# 1714
} 
# 1745
template< class _InputIterator> basic_string &
# 1751
replace(iterator __i1, iterator __i2, _InputIterator 
# 1752
__k1, _InputIterator __k2) 
# 1753
{ 
# 1755
; 
# 1756
; 
# 1757
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 1758
return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral()); 
# 1759
} 
# 1765
basic_string &replace(__const_iterator __i1, __const_iterator __i2, _CharT *
# 1766
__k1, _CharT *__k2) 
# 1767
{ 
# 1769
; 
# 1770
; 
# 1771
return (this->replace(__i1 - this->begin(), __i2 - __i1, __k1, __k2 - __k1)); 
# 1773
} 
# 1776
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 1777
__k1, const _CharT *__k2) 
# 1778
{ 
# 1780
; 
# 1781
; 
# 1782
return (this->replace(__i1 - this->begin(), __i2 - __i1, __k1, __k2 - __k1)); 
# 1784
} 
# 1787
basic_string &replace(__const_iterator __i1, __const_iterator __i2, iterator 
# 1788
__k1, iterator __k2) 
# 1789
{ 
# 1791
; 
# 1792
; 
# 1793
return (this->replace(__i1 - this->begin(), __i2 - __i1, (__k1.base()), __k2 - __k1)); 
# 1795
} 
# 1798
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const_iterator 
# 1799
__k1, const_iterator __k2) 
# 1800
{ 
# 1802
; 
# 1803
; 
# 1804
return (this->replace(__i1 - this->begin(), __i2 - __i1, (__k1.base()), __k2 - __k1)); 
# 1806
} 
# 1831
private: 
# 1829
template< class _Integer> basic_string &
# 1831
_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer 
# 1832
__n, _Integer __val, __true_type) 
# 1833
{ return _M_replace_aux(__i1 - this->begin(), __i2 - __i1, __n, __val); } 
# 1835
template< class _InputIterator> basic_string &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type); 
# 1842
basic_string &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c); 
# 1846
basic_string &_M_replace(size_type __pos, size_type __len1, const _CharT * __s, const size_type __len2); 
# 1850
basic_string &_M_append(const _CharT * __s, size_type __n); 
# 1867
public: size_type copy(_CharT * __s, size_type __n, size_type __pos = 0) const; 
# 1877
void swap(basic_string & __s); 
# 1887
const _CharT *c_str() const 
# 1888
{ return _M_data(); } 
# 1897
const _CharT *data() const 
# 1898
{ return _M_data(); } 
# 1904
allocator_type get_allocator() const 
# 1905
{ return this->_M_get_allocator(); } 
# 1920
size_type find(const _CharT * __s, size_type __pos, size_type __n) const; 
# 1933
size_type find(const basic_string &__str, size_type __pos = 0) const 
# 1935
{ return (this->find(__str.data(), __pos, __str.size())); } 
# 1948
size_type find(const _CharT *__s, size_type __pos = 0) const 
# 1949
{ 
# 1950
; 
# 1951
return (this->find(__s, __pos, traits_type::length(__s))); 
# 1952
} 
# 1965
size_type find(_CharT __c, size_type __pos = 0) const; 
# 1978
size_type rfind(const basic_string &__str, size_type __pos = npos) const 
# 1980
{ return (this->rfind(__str.data(), __pos, __str.size())); } 
# 1995
size_type rfind(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2008
size_type rfind(const _CharT *__s, size_type __pos = npos) const 
# 2009
{ 
# 2010
; 
# 2011
return (this->rfind(__s, __pos, traits_type::length(__s))); 
# 2012
} 
# 2025
size_type rfind(_CharT __c, size_type __pos = npos) const; 
# 2039
size_type find_first_of(const basic_string &__str, size_type __pos = 0) const 
# 2041
{ return (this->find_first_of(__str.data(), __pos, __str.size())); } 
# 2056
size_type find_first_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2069
size_type find_first_of(const _CharT *__s, size_type __pos = 0) const 
# 2070
{ 
# 2071
; 
# 2072
return (this->find_first_of(__s, __pos, traits_type::length(__s))); 
# 2073
} 
# 2088
size_type find_first_of(_CharT __c, size_type __pos = 0) const 
# 2089
{ return (this->find(__c, __pos)); } 
# 2103
size_type find_last_of(const basic_string &__str, size_type __pos = npos) const 
# 2105
{ return (this->find_last_of(__str.data(), __pos, __str.size())); } 
# 2120
size_type find_last_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2133
size_type find_last_of(const _CharT *__s, size_type __pos = npos) const 
# 2134
{ 
# 2135
; 
# 2136
return (this->find_last_of(__s, __pos, traits_type::length(__s))); 
# 2137
} 
# 2152
size_type find_last_of(_CharT __c, size_type __pos = npos) const 
# 2153
{ return (this->rfind(__c, __pos)); } 
# 2166
size_type find_first_not_of(const basic_string &__str, size_type __pos = 0) const 
# 2168
{ return (this->find_first_not_of(__str.data(), __pos, __str.size())); } 
# 2183
size_type find_first_not_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2197
size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const 
# 2198
{ 
# 2199
; 
# 2200
return (this->find_first_not_of(__s, __pos, traits_type::length(__s))); 
# 2201
} 
# 2214
size_type find_first_not_of(_CharT __c, size_type __pos = 0) const; 
# 2229
size_type find_last_not_of(const basic_string &__str, size_type __pos = npos) const 
# 2231
{ return (this->find_last_not_of(__str.data(), __pos, __str.size())); } 
# 2246
size_type find_last_not_of(const _CharT * __s, size_type __pos, size_type __n) const; 
# 2260
size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const 
# 2261
{ 
# 2262
; 
# 2263
return (this->find_last_not_of(__s, __pos, traits_type::length(__s))); 
# 2264
} 
# 2277
size_type find_last_not_of(_CharT __c, size_type __pos = npos) const; 
# 2293
basic_string substr(size_type __pos = 0, size_type __n = npos) const 
# 2294
{ return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n); 
# 2295
} 
# 2312
int compare(const basic_string &__str) const 
# 2313
{ 
# 2314
const size_type __size = this->size(); 
# 2315
const size_type __osize = __str.size(); 
# 2316
const size_type __len = std::min(__size, __osize); 
# 2318
int __r = traits_type::compare(_M_data(), __str.data(), __len); 
# 2319
if (!__r) { 
# 2320
__r = (_S_compare)(__size, __osize); }  
# 2321
return __r; 
# 2322
} 
# 2344
int compare(size_type __pos, size_type __n, const basic_string & __str) const; 
# 2370
int compare(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2) const; 
# 2388
int compare(const _CharT * __s) const; 
# 2412
int compare(size_type __pos, size_type __n1, const _CharT * __s) const; 
# 2439
int compare(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2) const; 
# 2441
}; 
# 2442
}
# 4781
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4783
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4784
__rhs) 
# 4785
{ 
# 4786
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 4787
(__str.append(__rhs)); 
# 4788
return __str; 
# 4789
} 
# 4797
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(const _CharT * __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 4808
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 4818
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4820
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4821
__rhs) 
# 4822
{ 
# 4823
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 4824
(__str.append(__rhs)); 
# 4825
return __str; 
# 4826
} 
# 4834
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 4836
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, _CharT __rhs) 
# 4837
{ 
# 4838
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 4839
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 4840
__string_type __str(__lhs); 
# 4841
(__str.append((__size_type)1, __rhs)); 
# 4842
return __str; 
# 4843
} 
# 4902
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4904
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4905
__rhs) 
# 4906
{ return (__lhs.compare(__rhs)) == 0; } 
# 4908
template< class _CharT> inline typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, bool> ::__type 
# 4911
operator==(const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__lhs, const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &
# 4912
__rhs) 
# 4913
{ return ((__lhs.size()) == (__rhs.size())) && (!std::char_traits< _CharT> ::compare((__lhs.data()), (__rhs.data()), (__lhs.size()))); 
# 4915
} 
# 4923
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4925
operator==(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4926
__rhs) 
# 4927
{ return (__rhs.compare(__lhs)) == 0; } 
# 4935
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4937
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4938
__rhs) 
# 4939
{ return (__lhs.compare(__rhs)) == 0; } 
# 4948
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4950
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4951
__rhs) 
# 4952
{ return !(__lhs == __rhs); } 
# 4960
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4962
operator!=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4963
__rhs) 
# 4964
{ return !(__lhs == __rhs); } 
# 4972
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4974
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 4975
__rhs) 
# 4976
{ return !(__lhs == __rhs); } 
# 4985
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4987
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 4988
__rhs) 
# 4989
{ return (__lhs.compare(__rhs)) < 0; } 
# 4997
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 4999
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5000
__rhs) 
# 5001
{ return (__lhs.compare(__rhs)) < 0; } 
# 5009
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5011
operator<(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5012
__rhs) 
# 5013
{ return (__rhs.compare(__lhs)) > 0; } 
# 5022
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5024
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5025
__rhs) 
# 5026
{ return (__lhs.compare(__rhs)) > 0; } 
# 5034
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5036
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5037
__rhs) 
# 5038
{ return (__lhs.compare(__rhs)) > 0; } 
# 5046
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5048
operator>(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5049
__rhs) 
# 5050
{ return (__rhs.compare(__lhs)) < 0; } 
# 5059
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5061
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5062
__rhs) 
# 5063
{ return (__lhs.compare(__rhs)) <= 0; } 
# 5071
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5073
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5074
__rhs) 
# 5075
{ return (__lhs.compare(__rhs)) <= 0; } 
# 5083
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5085
operator<=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5086
__rhs) 
# 5087
{ return (__rhs.compare(__lhs)) >= 0; } 
# 5096
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5098
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5099
__rhs) 
# 5100
{ return (__lhs.compare(__rhs)) >= 0; } 
# 5108
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5110
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 5111
__rhs) 
# 5112
{ return (__lhs.compare(__rhs)) >= 0; } 
# 5120
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 5122
operator>=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5123
__rhs) 
# 5124
{ return (__rhs.compare(__lhs)) <= 0; } 
# 5133
template< class _CharT, class _Traits, class _Alloc> inline void 
# 5135
swap(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5136
__rhs) 
# 5137
{ (__lhs.swap(__rhs)); } 
# 5152
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str); 
# 5159
template<> basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str); 
# 5170
template< class _CharT, class _Traits, class _Alloc> inline basic_ostream< _CharT, _Traits>  &
# 5172
operator<<(basic_ostream< _CharT, _Traits>  &__os, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5173
__str) 
# 5174
{ 
# 5177
return __ostream_insert(__os, (__str.data()), (__str.size())); 
# 5178
} 
# 5193
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &getline(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str, _CharT __delim); 
# 5210
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 5212
getline(basic_istream< _CharT, _Traits>  &__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 5213
__str) 
# 5214
{ return std::getline(__is, __str, (__is.widen('\n'))); } 
# 5234
template<> basic_istream< char>  &getline(basic_istream< char>  & __in, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str, char __delim); 
# 5240
template<> basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __in, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str, wchar_t __delim); 
# 5245
}
# 46 "/usr/include/c++/5/bits/basic_string.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT, class _Traits, class _Alloc> const typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 54
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::npos; 
# 56
template< class _CharT, class _Traits, class _Alloc> void 
# 59
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::swap(basic_string &__s) 
# 60
{ 
# 61
if (this == (&__s)) { 
# 62
return; }  
# 67
std::__alloc_swap< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::_S_do_it(this->_M_get_allocator(), __s._M_get_allocator()); 
# 70
if (_M_is_local()) { 
# 71
if (__s._M_is_local()) 
# 72
{ 
# 73
if (length() && __s.length()) 
# 74
{ 
# 75
_CharT __tmp_data[(_S_local_capacity) + 1]; 
# 76
traits_type::copy(__tmp_data, __s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 78
traits_type::copy(__s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 80
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __tmp_data, (_S_local_capacity) + 1); 
# 82
} else { 
# 83
if (__s.length()) 
# 84
{ 
# 85
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 87
_M_length(__s.length()); 
# 88
__s._M_set_length(0); 
# 89
return; 
# 90
} else { 
# 91
if (length()) 
# 92
{ 
# 93
traits_type::copy(__s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 95
__s._M_length(length()); 
# 96
_M_set_length(0); 
# 97
return; 
# 98
}  }  }  
# 99
} else 
# 101
{ 
# 102
const size_type __tmp_capacity = __s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity; 
# 103
traits_type::copy(__s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 105
_M_data((__s._M_data())); 
# 106
(__s._M_data(__s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf)); 
# 107
_M_capacity(__tmp_capacity); 
# 108
}  } else 
# 110
{ 
# 111
const size_type __tmp_capacity = __cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity; 
# 112
if (__s._M_is_local()) 
# 113
{ 
# 114
traits_type::copy(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, __s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf, (_S_local_capacity) + 1); 
# 116
(__s._M_data(_M_data())); 
# 117
_M_data(__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_local_buf); 
# 118
} else 
# 120
{ 
# 121
pointer __tmp_ptr = _M_data(); 
# 122
_M_data((__s._M_data())); 
# 123
(__s._M_data(__tmp_ptr)); 
# 124
_M_capacity(__s.__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_allocated_capacity); 
# 125
}  
# 126
__s._M_capacity(__tmp_capacity); 
# 127
}  
# 129
const size_type __tmp_length = length(); 
# 130
_M_length(__s.length()); 
# 131
__s._M_length(__tmp_length); 
# 132
} 
# 134
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer 
# 137
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_create(size_type &__capacity, size_type __old_capacity) 
# 138
{ 
# 141
if (__capacity > max_size()) { 
# 142
std::__throw_length_error("basic_string::_M_create"); }  
# 147
if ((__capacity > __old_capacity) && (__capacity < (2 * __old_capacity))) 
# 148
{ 
# 149
__capacity = (2 * __old_capacity); 
# 151
if (__capacity > max_size()) { 
# 152
__capacity = max_size(); }  
# 153
}  
# 157
return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1); 
# 158
} 
# 164
template< class _CharT, class _Traits, class _Alloc> 
# 165
template< class _InIterator> void 
# 168
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag) 
# 170
{ 
# 171
size_type __len = (0); 
# 172
size_type __capacity = ((size_type)(_S_local_capacity)); 
# 174
while ((__beg != __end) && (__len < __capacity)) 
# 175
{ 
# 176
(_M_data()[__len++]) = (*__beg); 
# 177
++__beg; 
# 178
}  
# 180
try 
# 181
{ 
# 182
while (__beg != __end) 
# 183
{ 
# 184
if (__len == __capacity) 
# 185
{ 
# 187
__capacity = (__len + 1); 
# 188
pointer __another = _M_create(__capacity, __len); 
# 189
(this->_S_copy(__another, _M_data(), __len)); 
# 190
_M_dispose(); 
# 191
_M_data(__another); 
# 192
_M_capacity(__capacity); 
# 193
}  
# 194
(_M_data()[__len++]) = (*__beg); 
# 195
++__beg; 
# 196
}  
# 197
} 
# 198
catch (...) 
# 199
{ 
# 200
_M_dispose(); 
# 201
throw; 
# 202
}  
# 204
_M_set_length(__len); 
# 205
} 
# 207
template< class _CharT, class _Traits, class _Alloc> 
# 208
template< class _InIterator> void 
# 211
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, forward_iterator_tag) 
# 213
{ 
# 215
if (__gnu_cxx::__is_null_pointer(__beg) && (__beg != __end)) { 
# 216
std::__throw_logic_error("basic_string::_M_construct null not valid"); }  
# 219
size_type __dnew = static_cast< size_type>(std::distance(__beg, __end)); 
# 221
if (__dnew > ((size_type)(_S_local_capacity))) 
# 222
{ 
# 223
_M_data(_M_create(__dnew, (size_type)0)); 
# 224
_M_capacity(__dnew); 
# 225
}  
# 228
try 
# 229
{ (this->_S_copy_chars(_M_data(), __beg, __end)); } 
# 230
catch (...) 
# 231
{ 
# 232
_M_dispose(); 
# 233
throw; 
# 234
}  
# 236
_M_set_length(__dnew); 
# 237
} 
# 239
template< class _CharT, class _Traits, class _Alloc> void 
# 242
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(size_type __n, _CharT __c) 
# 243
{ 
# 244
if (__n > ((size_type)(_S_local_capacity))) 
# 245
{ 
# 246
_M_data(_M_create(__n, (size_type)0)); 
# 247
_M_capacity(__n); 
# 248
}  
# 250
if (__n) { 
# 251
(this->_S_assign(_M_data(), __n, __c)); }  
# 253
_M_set_length(__n); 
# 254
} 
# 256
template< class _CharT, class _Traits, class _Alloc> void 
# 259
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_assign(const basic_string &__str) 
# 260
{ 
# 261
if (this != (&__str)) 
# 262
{ 
# 263
const size_type __rsize = __str.length(); 
# 264
const size_type __capacity = capacity(); 
# 266
if (__rsize > __capacity) 
# 267
{ 
# 268
size_type __new_capacity = __rsize; 
# 269
pointer __tmp = _M_create(__new_capacity, __capacity); 
# 270
_M_dispose(); 
# 271
_M_data(__tmp); 
# 272
_M_capacity(__new_capacity); 
# 273
}  
# 275
if (__rsize) { 
# 276
(this->_S_copy(_M_data(), (__str._M_data()), __rsize)); }  
# 278
_M_set_length(__rsize); 
# 279
}  
# 280
} 
# 282
template< class _CharT, class _Traits, class _Alloc> void 
# 285
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::reserve(size_type __res) 
# 286
{ 
# 288
if (__res < length()) { 
# 289
__res = length(); }  
# 291
const size_type __capacity = capacity(); 
# 292
if (__res != __capacity) 
# 293
{ 
# 294
if ((__res > __capacity) || (__res > ((size_type)(_S_local_capacity)))) 
# 296
{ 
# 297
pointer __tmp = _M_create(__res, __capacity); 
# 298
(this->_S_copy(__tmp, _M_data(), length() + 1)); 
# 299
_M_dispose(); 
# 300
_M_data(__tmp); 
# 301
_M_capacity(__res); 
# 302
} else { 
# 303
if (!_M_is_local()) 
# 304
{ 
# 305
(this->_S_copy(this->_M_local_data(), _M_data(), length() + 1)); 
# 306
_M_destroy(__capacity); 
# 307
_M_data(this->_M_local_data()); 
# 308
}  }  
# 309
}  
# 310
} 
# 312
template< class _CharT, class _Traits, class _Alloc> void 
# 315
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type 
# 316
__len2) 
# 317
{ 
# 318
const size_type __how_much = (length() - __pos) - __len1; 
# 320
size_type __new_capacity = (length() + __len2) - __len1; 
# 321
pointer __r = _M_create(__new_capacity, capacity()); 
# 323
if (__pos) { 
# 324
(this->_S_copy(__r, _M_data(), __pos)); }  
# 325
if (__s && __len2) { 
# 326
(this->_S_copy(__r + __pos, __s, __len2)); }  
# 327
if (__how_much) { 
# 328
(this->_S_copy((__r + __pos) + __len2, (_M_data() + __pos) + __len1, __how_much)); }  
# 331
_M_dispose(); 
# 332
_M_data(__r); 
# 333
_M_capacity(__new_capacity); 
# 334
} 
# 336
template< class _CharT, class _Traits, class _Alloc> void 
# 339
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_erase(size_type __pos, size_type __n) 
# 340
{ 
# 341
const size_type __how_much = (length() - __pos) - __n; 
# 343
if (__how_much && __n) { 
# 344
(this->_S_move(_M_data() + __pos, (_M_data() + __pos) + __n, __how_much)); }  
# 346
_M_set_length(length() - __n); 
# 347
} 
# 349
template< class _CharT, class _Traits, class _Alloc> void 
# 352
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::resize(size_type __n, _CharT __c) 
# 353
{ 
# 354
const size_type __size = this->size(); 
# 355
if (__size < __n) { 
# 356
(this->append(__n - __size, __c)); } else { 
# 357
if (__n < __size) { 
# 358
this->_M_erase(__n, __size - __n); }  }  
# 359
} 
# 361
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 364
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_append(const _CharT *__s, size_type __n) 
# 365
{ 
# 366
const size_type __len = __n + this->size(); 
# 368
if (__len <= this->capacity()) 
# 369
{ 
# 370
if (__n) { 
# 371
(this->_S_copy((this->_M_data()) + this->size(), __s, __n)); }  
# 372
} else { 
# 374
this->_M_mutate(this->size(), (size_type)0, __s, __n); }  
# 376
this->_M_set_length(__len); 
# 377
return *this; 
# 378
} 
# 380
template< class _CharT, class _Traits, class _Alloc> 
# 381
template< class _InputIterator> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 384
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator 
# 385
__k1, _InputIterator __k2, __false_type) 
# 387
{ 
# 388
const basic_string __s(__k1, __k2); 
# 389
const size_type __n1 = __i2 - __i1; 
# 390
return _M_replace(__i1 - this->begin(), __n1, (__s._M_data()), __s.size()); 
# 392
} 
# 394
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 397
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT 
# 398
__c) 
# 399
{ 
# 400
_M_check_length(__n1, __n2, "basic_string::_M_replace_aux"); 
# 402
const size_type __old_size = this->size(); 
# 403
const size_type __new_size = (__old_size + __n2) - __n1; 
# 405
if (__new_size <= this->capacity()) 
# 406
{ 
# 407
_CharT *__p = (this->_M_data()) + __pos1; 
# 409
const size_type __how_much = (__old_size - __pos1) - __n1; 
# 410
if (__how_much && (__n1 != __n2)) { 
# 411
(this->_S_move(__p + __n2, __p + __n1, __how_much)); }  
# 412
} else { 
# 414
this->_M_mutate(__pos1, __n1, 0, __n2); }  
# 416
if (__n2) { 
# 417
(this->_S_assign((this->_M_data()) + __pos1, __n2, __c)); }  
# 419
this->_M_set_length(__new_size); 
# 420
return *this; 
# 421
} 
# 423
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 426
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other> ::size_type 
# 427
__len2) 
# 428
{ 
# 429
_M_check_length(__len1, __len2, "basic_string::_M_replace"); 
# 431
const size_type __old_size = this->size(); 
# 432
const size_type __new_size = (__old_size + __len2) - __len1; 
# 434
if (__new_size <= this->capacity()) 
# 435
{ 
# 436
_CharT *__p = (this->_M_data()) + __pos; 
# 438
const size_type __how_much = (__old_size - __pos) - __len1; 
# 439
if (_M_disjunct(__s)) 
# 440
{ 
# 441
if (__how_much && (__len1 != __len2)) { 
# 442
(this->_S_move(__p + __len2, __p + __len1, __how_much)); }  
# 443
if (__len2) { 
# 444
(this->_S_copy(__p, __s, __len2)); }  
# 445
} else 
# 447
{ 
# 449
if (__len2 && (__len2 <= __len1)) { 
# 450
(this->_S_move(__p, __s, __len2)); }  
# 451
if (__how_much && (__len1 != __len2)) { 
# 452
(this->_S_move(__p + __len2, __p + __len1, __how_much)); }  
# 453
if (__len2 > __len1) 
# 454
{ 
# 455
if ((__s + __len2) <= (__p + __len1)) { 
# 456
(this->_S_move(__p, __s, __len2)); } else { 
# 457
if (__s >= (__p + __len1)) { 
# 458
(this->_S_copy(__p, (__s + __len2) - __len1, __len2)); } else 
# 460
{ 
# 461
const size_type __nleft = (__p + __len1) - __s; 
# 462
(this->_S_move(__p, __s, __nleft)); 
# 463
(this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft)); 
# 465
}  }  
# 466
}  
# 467
}  
# 468
} else { 
# 470
this->_M_mutate(__pos, __len1, __s, __len2); }  
# 472
this->_M_set_length(__new_size); 
# 473
return *this; 
# 474
} 
# 476
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 479
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::copy(_CharT *__s, size_type __n, size_type __pos) const 
# 480
{ 
# 481
_M_check(__pos, "basic_string::copy"); 
# 482
__n = _M_limit(__pos, __n); 
# 483
; 
# 484
if (__n) { 
# 485
(_S_copy)(__s, _M_data() + __pos, __n); }  
# 487
return __n; 
# 488
} 
# 1149
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1151
operator+(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1152
__rhs) 
# 1153
{ 
# 1154
; 
# 1155
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1156
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1157
const __size_type __len = _Traits::length(__lhs); 
# 1158
__string_type __str; 
# 1159
(__str.reserve(__len + (__rhs.size()))); 
# 1160
(__str.append(__lhs, __len)); 
# 1161
(__str.append(__rhs)); 
# 1162
return __str; 
# 1163
} 
# 1165
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1167
operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__rhs) 
# 1168
{ 
# 1169
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1170
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1171
__string_type __str; 
# 1172
const __size_type __len = (__rhs.size()); 
# 1173
(__str.reserve(__len + 1)); 
# 1174
(__str.append((__size_type)1, __lhs)); 
# 1175
(__str.append(__rhs)); 
# 1176
return __str; 
# 1177
} 
# 1179
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1182
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(const _CharT *__s, size_type __pos, size_type __n) const 
# 1183
{ 
# 1184
; 
# 1185
const size_type __size = this->size(); 
# 1186
const _CharT *__data = _M_data(); 
# 1188
if (__n == 0) { 
# 1189
return (__pos <= __size) ? __pos : npos; }  
# 1191
if (__n <= __size) 
# 1192
{ 
# 1193
for (; __pos <= (__size - __n); ++__pos) { 
# 1194
if (traits_type::eq(__data[__pos], __s[0]) && (traits_type::compare((__data + __pos) + 1, __s + 1, __n - 1) == 0)) { 
# 1197
return __pos; }  }  
# 1198
}  
# 1199
return npos; 
# 1200
} 
# 1202
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1205
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(_CharT __c, size_type __pos) const 
# 1206
{ 
# 1207
size_type __ret = npos; 
# 1208
const size_type __size = this->size(); 
# 1209
if (__pos < __size) 
# 1210
{ 
# 1211
const _CharT *__data = _M_data(); 
# 1212
const size_type __n = __size - __pos; 
# 1213
const _CharT *__p = traits_type::find(__data + __pos, __n, __c); 
# 1214
if (__p) { 
# 1215
__ret = (__p - __data); }  
# 1216
}  
# 1217
return __ret; 
# 1218
} 
# 1220
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1223
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(const _CharT *__s, size_type __pos, size_type __n) const 
# 1224
{ 
# 1225
; 
# 1226
const size_type __size = this->size(); 
# 1227
if (__n <= __size) 
# 1228
{ 
# 1229
__pos = std::min((size_type)(__size - __n), __pos); 
# 1230
const _CharT *__data = _M_data(); 
# 1231
do 
# 1232
{ 
# 1233
if (traits_type::compare(__data + __pos, __s, __n) == 0) { 
# 1234
return __pos; }  
# 1235
} 
# 1236
while ((__pos--) > 0); 
# 1237
}  
# 1238
return npos; 
# 1239
} 
# 1241
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1244
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(_CharT __c, size_type __pos) const 
# 1245
{ 
# 1246
size_type __size = this->size(); 
# 1247
if (__size) 
# 1248
{ 
# 1249
if ((--__size) > __pos) { 
# 1250
__size = __pos; }  
# 1251
for (++__size; (__size--) > 0;) { 
# 1252
if (traits_type::eq(_M_data()[__size], __c)) { 
# 1253
return __size; }  }  
# 1254
}  
# 1255
return npos; 
# 1256
} 
# 1258
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1261
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1262
{ 
# 1263
; 
# 1264
for (; __n && (__pos < this->size()); ++__pos) 
# 1265
{ 
# 1266
const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]); 
# 1267
if (__p) { 
# 1268
return __pos; }  
# 1269
}  
# 1270
return npos; 
# 1271
} 
# 1273
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1276
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1277
{ 
# 1278
; 
# 1279
size_type __size = this->size(); 
# 1280
if (__size && __n) 
# 1281
{ 
# 1282
if ((--__size) > __pos) { 
# 1283
__size = __pos; }  
# 1284
do 
# 1285
{ 
# 1286
if (traits_type::find(__s, __n, _M_data()[__size])) { 
# 1287
return __size; }  
# 1288
} 
# 1289
while ((__size--) != 0); 
# 1290
}  
# 1291
return npos; 
# 1292
} 
# 1294
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1297
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1298
{ 
# 1299
; 
# 1300
for (; __pos < this->size(); ++__pos) { 
# 1301
if (!traits_type::find(__s, __n, _M_data()[__pos])) { 
# 1302
return __pos; }  }  
# 1303
return npos; 
# 1304
} 
# 1306
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1309
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const 
# 1310
{ 
# 1311
for (; __pos < this->size(); ++__pos) { 
# 1312
if (!traits_type::eq(_M_data()[__pos], __c)) { 
# 1313
return __pos; }  }  
# 1314
return npos; 
# 1315
} 
# 1317
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1320
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const 
# 1321
{ 
# 1322
; 
# 1323
size_type __size = this->size(); 
# 1324
if (__size) 
# 1325
{ 
# 1326
if ((--__size) > __pos) { 
# 1327
__size = __pos; }  
# 1328
do 
# 1329
{ 
# 1330
if (!traits_type::find(__s, __n, _M_data()[__size])) { 
# 1331
return __size; }  
# 1332
} 
# 1333
while (__size--); 
# 1334
}  
# 1335
return npos; 
# 1336
} 
# 1338
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1341
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const 
# 1342
{ 
# 1343
size_type __size = this->size(); 
# 1344
if (__size) 
# 1345
{ 
# 1346
if ((--__size) > __pos) { 
# 1347
__size = __pos; }  
# 1348
do 
# 1349
{ 
# 1350
if (!traits_type::eq(_M_data()[__size], __c)) { 
# 1351
return __size; }  
# 1352
} 
# 1353
while (__size--); 
# 1354
}  
# 1355
return npos; 
# 1356
} 
# 1358
template< class _CharT, class _Traits, class _Alloc> int 
# 1361
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n, const basic_string &__str) const 
# 1362
{ 
# 1363
_M_check(__pos, "basic_string::compare"); 
# 1364
__n = _M_limit(__pos, __n); 
# 1365
const size_type __osize = __str.size(); 
# 1366
const size_type __len = std::min(__n, __osize); 
# 1367
int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len); 
# 1368
if (!__r) { 
# 1369
__r = (_S_compare)(__n, __osize); }  
# 1370
return __r; 
# 1371
} 
# 1373
template< class _CharT, class _Traits, class _Alloc> int 
# 1376
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1377
__pos2, size_type __n2) const 
# 1378
{ 
# 1379
_M_check(__pos1, "basic_string::compare"); 
# 1380
__str._M_check(__pos2, "basic_string::compare"); 
# 1381
__n1 = _M_limit(__pos1, __n1); 
# 1382
__n2 = __str._M_limit(__pos2, __n2); 
# 1383
const size_type __len = std::min(__n1, __n2); 
# 1384
int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len); 
# 1386
if (!__r) { 
# 1387
__r = (_S_compare)(__n1, __n2); }  
# 1388
return __r; 
# 1389
} 
# 1391
template< class _CharT, class _Traits, class _Alloc> int 
# 1394
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(const _CharT *__s) const 
# 1395
{ 
# 1396
; 
# 1397
const size_type __size = this->size(); 
# 1398
const size_type __osize = traits_type::length(__s); 
# 1399
const size_type __len = std::min(__size, __osize); 
# 1400
int __r = traits_type::compare(_M_data(), __s, __len); 
# 1401
if (!__r) { 
# 1402
__r = (_S_compare)(__size, __osize); }  
# 1403
return __r; 
# 1404
} 
# 1406
template< class _CharT, class _Traits, class _Alloc> int 
# 1409
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s) const 
# 1410
{ 
# 1411
; 
# 1412
_M_check(__pos, "basic_string::compare"); 
# 1413
__n1 = _M_limit(__pos, __n1); 
# 1414
const size_type __osize = traits_type::length(__s); 
# 1415
const size_type __len = std::min(__n1, __osize); 
# 1416
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1417
if (!__r) { 
# 1418
__r = (_S_compare)(__n1, __osize); }  
# 1419
return __r; 
# 1420
} 
# 1422
template< class _CharT, class _Traits, class _Alloc> int 
# 1425
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1426
__n2) const 
# 1427
{ 
# 1428
; 
# 1429
_M_check(__pos, "basic_string::compare"); 
# 1430
__n1 = _M_limit(__pos, __n1); 
# 1431
const size_type __len = std::min(__n1, __n2); 
# 1432
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1433
if (!__r) { 
# 1434
__r = (_S_compare)(__n1, __n2); }  
# 1435
return __r; 
# 1436
} 
# 1439
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1441
operator>>(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1442
__str) 
# 1443
{ 
# 1444
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1445
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1446
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1447
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1448
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1449
typedef ctype< _CharT>  __ctype_type; 
# 1450
typedef typename ctype< _CharT> ::ctype_base __ctype_base; 
# 1452
__size_type __extracted = (0); 
# 1453
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1454
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 1455
if (__cerb) 
# 1456
{ 
# 1457
try 
# 1458
{ 
# 1460
(__str.erase()); 
# 1461
_CharT __buf[128]; 
# 1462
__size_type __len = (0); 
# 1463
const streamsize __w = (__in.width()); 
# 1464
const __size_type __n = (__w > (0)) ? static_cast< __size_type>(__w) : (__str.max_size()); 
# 1466
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 1467
const __int_type __eof = _Traits::eof(); 
# 1468
__int_type __c = ((__in.rdbuf())->sgetc()); 
# 1470
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!(__ct.is(__ctype_base::space, _Traits::to_char_type(__c))))) 
# 1474
{ 
# 1475
if (__len == (sizeof(__buf) / sizeof(_CharT))) 
# 1476
{ 
# 1477
(__str.append(__buf, sizeof(__buf) / sizeof(_CharT))); 
# 1478
__len = 0; 
# 1479
}  
# 1480
(__buf[__len++]) = _Traits::to_char_type(__c); 
# 1481
++__extracted; 
# 1482
__c = ((__in.rdbuf())->snextc()); 
# 1483
}  
# 1484
(__str.append(__buf, __len)); 
# 1486
if (_Traits::eq_int_type(__c, __eof)) { 
# 1487
__err |= __ios_base::eofbit; }  
# 1488
(__in.width(0)); 
# 1489
} 
# 1490
catch (__cxxabiv1::__forced_unwind &) 
# 1491
{ 
# 1492
(__in._M_setstate(__ios_base::badbit)); 
# 1493
throw; 
# 1494
} 
# 1495
catch (...) 
# 1496
{ 
# 1500
(__in._M_setstate(__ios_base::badbit)); 
# 1501
}  
# 1502
}  
# 1504
if (!__extracted) { 
# 1505
__err |= __ios_base::failbit; }  
# 1506
if (__err) { 
# 1507
(__in.setstate(__err)); }  
# 1508
return __in; 
# 1509
} 
# 1511
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1513
getline(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1514
__str, _CharT __delim) 
# 1515
{ 
# 1516
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1517
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1518
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1519
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1520
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1522
__size_type __extracted = (0); 
# 1523
const __size_type __n = (__str.max_size()); 
# 1524
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1525
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, true); 
# 1526
if (__cerb) 
# 1527
{ 
# 1528
try 
# 1529
{ 
# 1530
(__str.erase()); 
# 1531
const __int_type __idelim = _Traits::to_int_type(__delim); 
# 1532
const __int_type __eof = _Traits::eof(); 
# 1533
__int_type __c = ((__in.rdbuf())->sgetc()); 
# 1535
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!_Traits::eq_int_type(__c, __idelim))) 
# 1538
{ 
# 1539
__str += _Traits::to_char_type(__c); 
# 1540
++__extracted; 
# 1541
__c = ((__in.rdbuf())->snextc()); 
# 1542
}  
# 1544
if (_Traits::eq_int_type(__c, __eof)) { 
# 1545
__err |= __ios_base::eofbit; } else { 
# 1546
if (_Traits::eq_int_type(__c, __idelim)) 
# 1547
{ 
# 1548
++__extracted; 
# 1549
((__in.rdbuf())->sbumpc()); 
# 1550
} else { 
# 1552
__err |= __ios_base::failbit; }  }  
# 1553
} 
# 1554
catch (__cxxabiv1::__forced_unwind &) 
# 1555
{ 
# 1556
(__in._M_setstate(__ios_base::badbit)); 
# 1557
throw; 
# 1558
} 
# 1559
catch (...) 
# 1560
{ 
# 1564
(__in._M_setstate(__ios_base::badbit)); 
# 1565
}  
# 1566
}  
# 1567
if (!__extracted) { 
# 1568
__err |= __ios_base::failbit; }  
# 1569
if (__err) { 
# 1570
(__in.setstate(__err)); }  
# 1571
return __in; 
# 1572
} 
# 1577
extern template class __cxx11::basic_string< char, char_traits< char> , allocator< char> > ;
# 1578
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1581
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1584
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str, char __delim);
# 1587
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char, char_traits< char> , allocator< char> >  & __str);
# 1592
extern template class __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> > ;
# 1593
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1596
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1599
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str, wchar_t __delim);
# 1602
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t, char_traits< wchar_t> , allocator< wchar_t> >  & __str);
# 1609
}
# 43 "/usr/include/c++/5/bits/locale_classes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 62
class locale { 
# 67
public: typedef int category; 
# 70
class facet; 
# 71
class id; 
# 72
class _Impl; 
# 74
friend class facet; 
# 75
friend class _Impl; 
# 77
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 81
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 85
template< class _Cache> friend struct __use_cache; 
# 98
static const category none = 0; 
# 99
static const category ctype = (1L << 0); 
# 100
static const category numeric = (1L << 1); 
# 101
static const category collate = (1L << 2); 
# 102
static const category time = (1L << 3); 
# 103
static const category monetary = (1L << 4); 
# 104
static const category messages = (1L << 5); 
# 105
static const category all = (((((ctype | numeric) | collate) | time) | monetary) | messages); 
# 117
locale() throw(); 
# 126
locale(const locale & __other) throw(); 
# 137
explicit locale(const char * __s); 
# 151
locale(const locale & __base, const char * __s, category __cat); 
# 192
locale(const locale & __base, const locale & __add, category __cat); 
# 205
template< class _Facet> locale(const locale & __other, _Facet * __f); 
# 209
~locale() throw(); 
# 220
const locale &operator=(const locale & __other) throw(); 
# 234
template< class _Facet> locale combine(const locale & __other) const; 
# 243
__attribute((__abi_tag__("cxx11" ))) __cxx11::string 
# 245
name() const; 
# 255
bool operator==(const locale & __other) const throw(); 
# 264
bool operator!=(const locale &__other) const throw() 
# 265
{ return !this->operator==(__other); } 
# 282
template< class _Char, class _Traits, class _Alloc> bool operator()(const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s1, const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s2) const; 
# 299
static locale global(const locale & __loc); 
# 305
static const locale &classic(); 
# 309
private: _Impl *_M_impl; 
# 312
static _Impl *_S_classic; 
# 315
static _Impl *_S_global; 
# 321
static const char *const *const _S_categories; 
# 333
enum { _S_categories_size = 12}; 
# 336
static __gthread_once_t _S_once; 
# 340
explicit locale(_Impl *) throw(); 
# 343
static void _S_initialize(); 
# 346
static void _S_initialize_once() throw(); 
# 349
static category _S_normalize_category(category); 
# 352
void _M_coalesce(const locale & __base, const locale & __add, category __cat); 
# 355
static const id *const _S_twinned_facets[]; 
# 357
}; 
# 371
class locale::facet { 
# 374
friend class locale; 
# 375
friend class _Impl; 
# 377
mutable _Atomic_word _M_refcount; 
# 380
static __c_locale _S_c_locale; 
# 383
static const char _S_c_name[2]; 
# 386
static __gthread_once_t _S_once; 
# 390
static void _S_initialize_once(); 
# 403
protected: explicit facet(size_t __refs = 0) throw() : _M_refcount((__refs) ? 1 : 0) 
# 404
{ } 
# 408
virtual ~facet(); 
# 411
static void _S_create_c_locale(__c_locale & __cloc, const char * __s, __c_locale __old = 0); 
# 415
static __c_locale _S_clone_c_locale(__c_locale & __cloc) throw(); 
# 418
static void _S_destroy_c_locale(__c_locale & __cloc); 
# 421
static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char * __s); 
# 426
static __c_locale _S_get_c_locale(); 
# 428
__attribute((const)) static const char *
# 429
_S_get_c_name() throw(); 
# 433
private: void _M_add_reference() const throw() 
# 434
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 437
void _M_remove_reference() const throw() 
# 438
{ 
# 440
; 
# 441
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 442
{ 
# 443
; 
# 444
try 
# 445
{ delete this; } 
# 446
catch (...) 
# 447
{ }  
# 448
}  
# 449
} 
# 451
facet(const facet &); 
# 454
facet &operator=(const facet &); 
# 456
class __shim; 
# 458
const facet *_M_sso_shim(const id *) const; 
# 459
const facet *_M_cow_shim(const id *) const; 
# 460
}; 
# 474
class locale::id { 
# 477
friend class locale; 
# 478
friend class _Impl; 
# 480
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 484
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 491
mutable size_t _M_index; 
# 494
static _Atomic_word _S_refcount; 
# 497
void operator=(const id &); 
# 499
id(const id &); 
# 505
public: id() { } 
# 508
size_t _M_id() const throw(); 
# 509
}; 
# 513
class locale::_Impl { 
# 517
friend class locale; 
# 518
friend class facet; 
# 520
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 524
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 528
template< class _Cache> friend struct __use_cache; 
# 533
_Atomic_word _M_refcount; 
# 534
const facet **_M_facets; 
# 535
size_t _M_facets_size; 
# 536
const facet **_M_caches; 
# 537
char **_M_names; 
# 538
static const id *const _S_id_ctype[]; 
# 539
static const id *const _S_id_numeric[]; 
# 540
static const id *const _S_id_collate[]; 
# 541
static const id *const _S_id_time[]; 
# 542
static const id *const _S_id_monetary[]; 
# 543
static const id *const _S_id_messages[]; 
# 544
static const id *const *const _S_facet_categories[]; 
# 547
void _M_add_reference() throw() 
# 548
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 551
void _M_remove_reference() throw() 
# 552
{ 
# 554
; 
# 555
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 556
{ 
# 557
; 
# 558
try 
# 559
{ delete this; } 
# 560
catch (...) 
# 561
{ }  
# 562
}  
# 563
} 
# 565
_Impl(const _Impl &, size_t); 
# 566
_Impl(const char *, size_t); 
# 567
_Impl(size_t) throw(); 
# 569
~_Impl() throw(); 
# 571
_Impl(const _Impl &); 
# 574
void operator=(const _Impl &); 
# 577
bool _M_check_same_name() 
# 578
{ 
# 579
bool __ret = true; 
# 580
if ((_M_names)[1]) { 
# 582
for (size_t __i = (0); __ret && (__i < ((_S_categories_size) - 1)); ++__i) { 
# 583
__ret = (__builtin_strcmp((_M_names)[__i], (_M_names)[__i + (1)]) == 0); }  }  
# 584
return __ret; 
# 585
} 
# 588
void _M_replace_categories(const _Impl *, category); 
# 591
void _M_replace_category(const _Impl *, const id *const *); 
# 594
void _M_replace_facet(const _Impl *, const id *); 
# 597
void _M_install_facet(const id *, const facet *); 
# 599
template< class _Facet> void 
# 601
_M_init_facet(_Facet *__facet) 
# 602
{ this->_M_install_facet(&_Facet::id, __facet); } 
# 604
template< class _Facet> void 
# 606
_M_init_facet_unchecked(_Facet *__facet) 
# 607
{ 
# 608
(__facet->_M_add_reference()); 
# 609
((_M_facets)[(_Facet::id._M_id)()]) = __facet; 
# 610
} 
# 613
void _M_install_cache(const facet *, size_t); 
# 615
void _M_init_extra(facet **); 
# 616
void _M_init_extra(void *, void *, const char *, const char *); 
# 617
}; 
# 632
template< class _CharT> 
# 633
class __cxx11::collate : public locale::facet { 
# 639
public: typedef _CharT char_type; 
# 640
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 646
protected: __c_locale _M_c_locale_collate; 
# 650
public: static locale::id id; 
# 660
explicit collate(size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale()) 
# 662
{ } 
# 674
explicit collate(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) 
# 676
{ } 
# 691
int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 692
__lo2, const _CharT *__hi2) const 
# 693
{ return this->do_compare(__lo1, __hi1, __lo2, __hi2); } 
# 710
string_type transform(const _CharT *__lo, const _CharT *__hi) const 
# 711
{ return this->do_transform(__lo, __hi); } 
# 724
long hash(const _CharT *__lo, const _CharT *__hi) const 
# 725
{ return this->do_hash(__lo, __hi); } 
# 729
int _M_compare(const _CharT *, const _CharT *) const throw(); 
# 732
size_t _M_transform(_CharT *, const _CharT *, size_t) const throw(); 
# 737
protected: virtual ~collate() 
# 738
{ _S_destroy_c_locale(_M_c_locale_collate); } 
# 753
virtual int do_compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const; 
# 767
virtual string_type do_transform(const _CharT * __lo, const _CharT * __hi) const; 
# 780
virtual long do_hash(const _CharT * __lo, const _CharT * __hi) const; 
# 781
}; 
# 783
template< class _CharT> locale::id 
# 784
__cxx11::collate< _CharT> ::id; 
# 789
template<> int collate< char> ::_M_compare(const char *, const char *) const throw(); 
# 793
template<> size_t collate< char> ::_M_transform(char *, const char *, size_t) const throw(); 
# 798
template<> int collate< wchar_t> ::_M_compare(const wchar_t *, const wchar_t *) const throw(); 
# 802
template<> size_t collate< wchar_t> ::_M_transform(wchar_t *, const wchar_t *, size_t) const throw(); 
# 806
template< class _CharT> 
# 807
class __cxx11::collate_byname : public collate< _CharT>  { 
# 812
public: typedef _CharT char_type; 
# 813
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 817
explicit collate_byname(const char *__s, ::std::size_t __refs = 0) : ::std::__cxx11::collate< _CharT> (__refs) 
# 819
{ 
# 820
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 822
{ 
# 823
(this->_S_destroy_c_locale((this->_M_c_locale_collate))); 
# 824
(this->_S_create_c_locale((this->_M_c_locale_collate), __s)); 
# 825
}  
# 826
} 
# 836
protected: virtual ~collate_byname() { } 
# 837
}; 
# 840
}
# 39 "/usr/include/c++/5/bits/locale_classes.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _Facet> 
# 45
locale::locale(const locale &__other, _Facet *__f) 
# 46
{ 
# 47
(_M_impl) = (new _Impl(*(__other._M_impl), 1)); 
# 49
try 
# 50
{ (_M_impl)->_M_install_facet(&_Facet::id, __f); } 
# 51
catch (...) 
# 52
{ 
# 53
(_M_impl)->_M_remove_reference(); 
# 54
throw; 
# 55
}  
# 56
delete [] (((_M_impl)->_M_names)[0]); 
# 57
(((_M_impl)->_M_names)[0]) = (0); 
# 58
} 
# 60
template< class _Facet> locale 
# 63
locale::combine(const locale &__other) const 
# 64
{ 
# 65
_Impl *__tmp = new _Impl(*(_M_impl), 1); 
# 66
try 
# 67
{ 
# 68
__tmp->_M_replace_facet(__other._M_impl, &_Facet::id); 
# 69
} 
# 70
catch (...) 
# 71
{ 
# 72
__tmp->_M_remove_reference(); 
# 73
throw; 
# 74
}  
# 75
return ((locale)(__tmp)); 
# 76
} 
# 78
template< class _CharT, class _Traits, class _Alloc> bool 
# 81
locale::operator()(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__s1, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 82
__s2) const 
# 83
{ 
# 84
typedef __cxx11::collate< _CharT>  __collate_type; 
# 85
const __collate_type &__collate = use_facet< __cxx11::collate< _CharT> > (*this); 
# 86
return (__collate.compare((__s1.data()), (__s1.data()) + (__s1.length()), (__s2.data()), (__s2.data()) + (__s2.length()))) < 0; 
# 88
} 
# 102
template< class _Facet> bool 
# 104
has_facet(const locale &__loc) throw() 
# 105
{ 
# 106
const size_t __i = (_Facet::id._M_id)(); 
# 107
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 108
return (__i < ((__loc._M_impl)->_M_facets_size)) && (dynamic_cast< const _Facet *>(__facets[__i])); 
# 114
} 
# 130
template< class _Facet> const _Facet &
# 132
use_facet(const locale &__loc) 
# 133
{ 
# 134
const size_t __i = (_Facet::id._M_id)(); 
# 135
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 136
if ((__i >= ((__loc._M_impl)->_M_facets_size)) || (!(__facets[__i]))) { 
# 137
__throw_bad_cast(); }  
# 139
return dynamic_cast< const _Facet &>(*(__facets[__i])); 
# 143
} 
# 147
template< class _CharT> int 
# 149
__cxx11::collate< _CharT> ::_M_compare(const _CharT *, const _CharT *) const throw() 
# 150
{ return 0; } 
# 153
template< class _CharT> size_t 
# 155
__cxx11::collate< _CharT> ::_M_transform(_CharT *, const _CharT *, size_t) const throw() 
# 156
{ return 0; } 
# 158
template< class _CharT> int 
# 161
__cxx11::collate< _CharT> ::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 162
__lo2, const _CharT *__hi2) const 
# 163
{ 
# 166
const string_type __one(__lo1, __hi1); 
# 167
const string_type __two(__lo2, __hi2); 
# 169
const _CharT *__p = (__one.c_str()); 
# 170
const _CharT *__pend = (__one.data()) + (__one.length()); 
# 171
const _CharT *__q = (__two.c_str()); 
# 172
const _CharT *__qend = (__two.data()) + (__two.length()); 
# 177
for (; ;) 
# 178
{ 
# 179
const int __res = _M_compare(__p, __q); 
# 180
if (__res) { 
# 181
return __res; }  
# 183
__p += char_traits< _CharT> ::length(__p); 
# 184
__q += char_traits< _CharT> ::length(__q); 
# 185
if ((__p == __pend) && (__q == __qend)) { 
# 186
return 0; } else { 
# 187
if (__p == __pend) { 
# 188
return -1; } else { 
# 189
if (__q == __qend) { 
# 190
return 1; }  }  }  
# 192
__p++; 
# 193
__q++; 
# 194
}  
# 195
} 
# 197
template< class _CharT> typename __cxx11::collate< _CharT> ::string_type 
# 200
__cxx11::collate< _CharT> ::do_transform(const _CharT *__lo, const _CharT *__hi) const 
# 201
{ 
# 202
string_type __ret; 
# 205
const string_type __str(__lo, __hi); 
# 207
const _CharT *__p = (__str.c_str()); 
# 208
const _CharT *__pend = (__str.data()) + (__str.length()); 
# 210
size_t __len = (__hi - __lo) * 2; 
# 212
_CharT *__c = new _CharT [__len]; 
# 214
try 
# 215
{ 
# 219
for (; ;) 
# 220
{ 
# 222
size_t __res = _M_transform(__c, __p, __len); 
# 225
if (__res >= __len) 
# 226
{ 
# 227
__len = (__res + (1)); 
# 228
(delete [] __c), (__c = 0); 
# 229
__c = (new _CharT [__len]); 
# 230
__res = _M_transform(__c, __p, __len); 
# 231
}  
# 233
(__ret.append(__c, __res)); 
# 234
__p += char_traits< _CharT> ::length(__p); 
# 235
if (__p == __pend) { 
# 236
break; }  
# 238
__p++; 
# 239
(__ret.push_back(_CharT())); 
# 240
}  
# 241
} 
# 242
catch (...) 
# 243
{ 
# 244
delete [] __c; 
# 245
throw; 
# 246
}  
# 248
delete [] __c; 
# 250
return __ret; 
# 251
} 
# 253
template< class _CharT> long 
# 256
__cxx11::collate< _CharT> ::do_hash(const _CharT *__lo, const _CharT *__hi) const 
# 257
{ 
# 258
unsigned long __val = (0); 
# 259
for (; __lo < __hi; ++__lo) { 
# 260
__val = ((*__lo) + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits_integer< unsigned long> ::__digits - 7)))); }  
# 264
return static_cast< long>(__val); 
# 265
} 
# 270
extern template class __cxx11::collate< char> ;
# 271
extern template class __cxx11::collate_byname< char> ;
# 273
extern template const __cxx11::collate< char>  &use_facet< __cxx11::collate< char> > (const locale &);
# 277
extern template bool has_facet< __cxx11::collate< char> > (const locale &) throw();
# 282
extern template class __cxx11::collate< wchar_t> ;
# 283
extern template class __cxx11::collate_byname< wchar_t> ;
# 285
extern template const __cxx11::collate< wchar_t>  &use_facet< __cxx11::collate< wchar_t> > (const locale &);
# 289
extern template bool has_facet< __cxx11::collate< wchar_t> > (const locale &) throw();
# 296
}
# 41 "/usr/include/c++/5/stdexcept" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
struct __cow_string { 
# 50
union { 
# 51
const char *_M_p; 
# 52
char _M_bytes[sizeof(const char *)]; 
# 53
}; 
# 55
__cow_string(); 
# 56
__cow_string(const __cxx11::string &); 
# 57
__cow_string(const char *, size_t); 
# 58
__cow_string(const __cow_string &) throw(); 
# 59
__cow_string &operator=(const __cow_string &) throw(); 
# 60
~__cow_string(); 
# 65
}; 
# 67
typedef __cxx11::basic_string< char, char_traits< char> , allocator< char> >  __sso_string; 
# 113
class logic_error : public exception { 
# 115
__cow_string _M_msg; 
# 120
public: explicit logic_error(const __cxx11::string & __arg); 
# 128
logic_error(const logic_error &) throw(); 
# 129
logic_error &operator=(const logic_error &) throw(); 
# 132
virtual ~logic_error() throw(); 
# 137
virtual const char *what() const throw(); 
# 138
}; 
# 142
class domain_error : public logic_error { 
# 145
public: explicit domain_error(const __cxx11::string & __arg); 
# 149
virtual ~domain_error() throw(); 
# 150
}; 
# 153
class invalid_argument : public logic_error { 
# 156
public: explicit invalid_argument(const __cxx11::string & __arg); 
# 160
virtual ~invalid_argument() throw(); 
# 161
}; 
# 165
class length_error : public logic_error { 
# 168
public: explicit length_error(const __cxx11::string & __arg); 
# 172
virtual ~length_error() throw(); 
# 173
}; 
# 177
class out_of_range : public logic_error { 
# 180
public: explicit out_of_range(const __cxx11::string & __arg); 
# 184
virtual ~out_of_range() throw(); 
# 185
}; 
# 192
class runtime_error : public exception { 
# 194
__cow_string _M_msg; 
# 199
public: explicit runtime_error(const __cxx11::string & __arg); 
# 207
runtime_error(const runtime_error &) throw(); 
# 208
runtime_error &operator=(const runtime_error &) throw(); 
# 211
virtual ~runtime_error() throw(); 
# 216
virtual const char *what() const throw(); 
# 217
}; 
# 220
class range_error : public runtime_error { 
# 223
public: explicit range_error(const __cxx11::string & __arg); 
# 227
virtual ~range_error() throw(); 
# 228
}; 
# 231
class overflow_error : public runtime_error { 
# 234
public: explicit overflow_error(const __cxx11::string & __arg); 
# 238
virtual ~overflow_error() throw(); 
# 239
}; 
# 242
class underflow_error : public runtime_error { 
# 245
public: explicit underflow_error(const __cxx11::string & __arg); 
# 249
virtual ~underflow_error() throw(); 
# 250
}; 
# 255
}
# 49 "/usr/include/c++/5/bits/ios_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 57
enum _Ios_Fmtflags { 
# 59
_S_boolalpha = 1, 
# 60
_S_dec, 
# 61
_S_fixed = 4, 
# 62
_S_hex = 8, 
# 63
_S_internal = 16, 
# 64
_S_left = 32, 
# 65
_S_oct = 64, 
# 66
_S_right = 128, 
# 67
_S_scientific = 256, 
# 68
_S_showbase = 512, 
# 69
_S_showpoint = 1024, 
# 70
_S_showpos = 2048, 
# 71
_S_skipws = 4096, 
# 72
_S_unitbuf = 8192, 
# 73
_S_uppercase = 16384, 
# 74
_S_adjustfield = 176, 
# 75
_S_basefield = 74, 
# 76
_S_floatfield = 260, 
# 77
_S_ios_fmtflags_end = 65536, 
# 78
_S_ios_fmtflags_max = 2147483647, 
# 79
_S_ios_fmtflags_min = (-2147483647-1)
# 80
}; 
# 83
inline _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 84
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 87
inline _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 88
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 91
inline _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 92
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 95
inline _Ios_Fmtflags operator~(_Ios_Fmtflags __a) 
# 96
{ return (_Ios_Fmtflags)(~(static_cast< int>(__a))); } 
# 99
inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 100
{ return __a = ((__a | __b)); } 
# 103
inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 104
{ return __a = ((__a & __b)); } 
# 107
inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 108
{ return __a = ((__a ^ __b)); } 
# 111
enum _Ios_Openmode { 
# 113
_S_app = 1, 
# 114
_S_ate, 
# 115
_S_bin = 4, 
# 116
_S_in = 8, 
# 117
_S_out = 16, 
# 118
_S_trunc = 32, 
# 119
_S_ios_openmode_end = 65536, 
# 120
_S_ios_openmode_max = 2147483647, 
# 121
_S_ios_openmode_min = (-2147483647-1)
# 122
}; 
# 125
inline _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b) 
# 126
{ return (_Ios_Openmode)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 129
inline _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b) 
# 130
{ return (_Ios_Openmode)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 133
inline _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b) 
# 134
{ return (_Ios_Openmode)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 137
inline _Ios_Openmode operator~(_Ios_Openmode __a) 
# 138
{ return (_Ios_Openmode)(~(static_cast< int>(__a))); } 
# 141
inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 142
{ return __a = ((__a | __b)); } 
# 145
inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 146
{ return __a = ((__a & __b)); } 
# 149
inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 150
{ return __a = ((__a ^ __b)); } 
# 153
enum _Ios_Iostate { 
# 155
_S_goodbit, 
# 156
_S_badbit, 
# 157
_S_eofbit, 
# 158
_S_failbit = 4, 
# 159
_S_ios_iostate_end = 65536, 
# 160
_S_ios_iostate_max = 2147483647, 
# 161
_S_ios_iostate_min = (-2147483647-1)
# 162
}; 
# 165
inline _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) 
# 166
{ return (_Ios_Iostate)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 169
inline _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) 
# 170
{ return (_Ios_Iostate)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 173
inline _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) 
# 174
{ return (_Ios_Iostate)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 177
inline _Ios_Iostate operator~(_Ios_Iostate __a) 
# 178
{ return (_Ios_Iostate)(~(static_cast< int>(__a))); } 
# 181
inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 182
{ return __a = ((__a | __b)); } 
# 185
inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 186
{ return __a = ((__a & __b)); } 
# 189
inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 190
{ return __a = ((__a ^ __b)); } 
# 193
enum _Ios_Seekdir { 
# 195
_S_beg, 
# 196
_S_cur, 
# 197
_S_end, 
# 198
_S_ios_seekdir_end = 65536
# 199
}; 
# 228
class ios_base { 
# 233
struct system_error : public runtime_error { 
# 236
struct error_code { 
# 238
error_code() { } 
# 240
private: int _M_value; 
# 241
const void *_M_cat; 
# 242
} _M_code; 
# 243
}; 
# 255
public: class __attribute((__abi_tag__("cxx11" ))) failure : public system_error { 
# 259
public: explicit failure(const __cxx11::string & __str); 
# 270
virtual ~failure() throw(); 
# 273
virtual const char *what() const throw(); 
# 274
}; 
# 323
typedef _Ios_Fmtflags fmtflags; 
# 326
static const fmtflags boolalpha = _S_boolalpha; 
# 329
static const fmtflags dec = _S_dec; 
# 332
static const fmtflags fixed = _S_fixed; 
# 335
static const fmtflags hex = _S_hex; 
# 340
static const fmtflags internal = _S_internal; 
# 344
static const fmtflags left = _S_left; 
# 347
static const fmtflags oct = _S_oct; 
# 351
static const fmtflags right = _S_right; 
# 354
static const fmtflags scientific = _S_scientific; 
# 358
static const fmtflags showbase = _S_showbase; 
# 362
static const fmtflags showpoint = _S_showpoint; 
# 365
static const fmtflags showpos = _S_showpos; 
# 368
static const fmtflags skipws = _S_skipws; 
# 371
static const fmtflags unitbuf = _S_unitbuf; 
# 375
static const fmtflags uppercase = _S_uppercase; 
# 378
static const fmtflags adjustfield = _S_adjustfield; 
# 381
static const fmtflags basefield = _S_basefield; 
# 384
static const fmtflags floatfield = _S_floatfield; 
# 398
typedef _Ios_Iostate iostate; 
# 402
static const iostate badbit = _S_badbit; 
# 405
static const iostate eofbit = _S_eofbit; 
# 410
static const iostate failbit = _S_failbit; 
# 413
static const iostate goodbit = _S_goodbit; 
# 429
typedef _Ios_Openmode openmode; 
# 432
static const openmode app = _S_app; 
# 435
static const openmode ate = _S_ate; 
# 440
static const openmode binary = _S_bin; 
# 443
static const openmode in = _S_in; 
# 446
static const openmode out = _S_out; 
# 449
static const openmode trunc = _S_trunc; 
# 461
typedef _Ios_Seekdir seekdir; 
# 464
static const seekdir beg = _S_beg; 
# 467
static const seekdir cur = _S_cur; 
# 470
static const seekdir end = _S_end; 
# 473
typedef int io_state; 
# 474
typedef int open_mode; 
# 475
typedef int seek_dir; 
# 477
typedef std::streampos streampos; 
# 478
typedef std::streamoff streamoff; 
# 487
enum event { 
# 489
erase_event, 
# 490
imbue_event, 
# 491
copyfmt_event
# 492
}; 
# 504
typedef void (*event_callback)(event __e, ios_base & __b, int __i); 
# 517
void register_callback(event_callback __fn, int __index); 
# 520
protected: streamsize _M_precision; 
# 521
streamsize _M_width; 
# 522
fmtflags _M_flags; 
# 523
iostate _M_exception; 
# 524
iostate _M_streambuf_state; 
# 528
struct _Callback_list { 
# 531
_Callback_list *_M_next; 
# 532
event_callback _M_fn; 
# 533
int _M_index; 
# 534
_Atomic_word _M_refcount; 
# 536
_Callback_list(event_callback __fn, int __index, _Callback_list *
# 537
__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) 
# 538
{ } 
# 541
void _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 545
int _M_remove_reference() 
# 546
{ 
# 548
; 
# 549
int __res = __gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1); 
# 550
if (__res == 0) 
# 551
{ 
# 552
; 
# 553
}  
# 554
return __res; 
# 555
} 
# 556
}; 
# 558
_Callback_list *_M_callbacks; 
# 561
void _M_call_callbacks(event __ev) throw(); 
# 564
void _M_dispose_callbacks() throw(); 
# 567
struct _Words { 
# 569
void *_M_pword; 
# 570
long _M_iword; 
# 571
_Words() : _M_pword((0)), _M_iword((0)) { } 
# 572
}; 
# 575
_Words _M_word_zero; 
# 579
enum { _S_local_word_size = 8}; 
# 580
_Words _M_local_word[_S_local_word_size]; 
# 583
int _M_word_size; 
# 584
_Words *_M_word; 
# 587
_Words &_M_grow_words(int __index, bool __iword); 
# 590
locale _M_ios_locale; 
# 593
void _M_init() throw(); 
# 601
public: class Init { 
# 603
friend class ios_base; 
# 605
public: Init(); 
# 606
~Init(); 
# 609
private: static _Atomic_word _S_refcount; 
# 610
static bool _S_synced_with_stdio; 
# 611
}; 
# 619
fmtflags flags() const 
# 620
{ return _M_flags; } 
# 630
fmtflags flags(fmtflags __fmtfl) 
# 631
{ 
# 632
fmtflags __old = _M_flags; 
# 633
(_M_flags) = __fmtfl; 
# 634
return __old; 
# 635
} 
# 646
fmtflags setf(fmtflags __fmtfl) 
# 647
{ 
# 648
fmtflags __old = _M_flags; 
# 649
((_M_flags) |= __fmtfl); 
# 650
return __old; 
# 651
} 
# 663
fmtflags setf(fmtflags __fmtfl, fmtflags __mask) 
# 664
{ 
# 665
fmtflags __old = _M_flags; 
# 666
((_M_flags) &= ((~__mask))); 
# 667
((_M_flags) |= ((__fmtfl & __mask))); 
# 668
return __old; 
# 669
} 
# 678
void unsetf(fmtflags __mask) 
# 679
{ ((_M_flags) &= ((~__mask))); } 
# 689
streamsize precision() const 
# 690
{ return _M_precision; } 
# 698
streamsize precision(streamsize __prec) 
# 699
{ 
# 700
streamsize __old = _M_precision; 
# 701
(_M_precision) = __prec; 
# 702
return __old; 
# 703
} 
# 712
streamsize width() const 
# 713
{ return _M_width; } 
# 721
streamsize width(streamsize __wide) 
# 722
{ 
# 723
streamsize __old = _M_width; 
# 724
(_M_width) = __wide; 
# 725
return __old; 
# 726
} 
# 740
static bool sync_with_stdio(bool __sync = true); 
# 752
locale imbue(const locale & __loc) throw(); 
# 763
locale getloc() const 
# 764
{ return _M_ios_locale; } 
# 774
const locale &_M_getloc() const 
# 775
{ return _M_ios_locale; } 
# 793
static int xalloc() throw(); 
# 809
long &iword(int __ix) 
# 810
{ 
# 811
_Words &__word = (__ix < (_M_word_size)) ? (_M_word)[__ix] : this->_M_grow_words(__ix, true); 
# 813
return __word._M_iword; 
# 814
} 
# 830
void *&pword(int __ix) 
# 831
{ 
# 832
_Words &__word = (__ix < (_M_word_size)) ? (_M_word)[__ix] : this->_M_grow_words(__ix, false); 
# 834
return __word._M_pword; 
# 835
} 
# 846
virtual ~ios_base(); 
# 849
protected: ios_base() throw(); 
# 855
private: ios_base(const ios_base &); 
# 858
ios_base &operator=(const ios_base &); 
# 873
}; 
# 878
inline ios_base &boolalpha(ios_base &__base) 
# 879
{ 
# 880
__base.setf(ios_base::boolalpha); 
# 881
return __base; 
# 882
} 
# 886
inline ios_base &noboolalpha(ios_base &__base) 
# 887
{ 
# 888
__base.unsetf(ios_base::boolalpha); 
# 889
return __base; 
# 890
} 
# 894
inline ios_base &showbase(ios_base &__base) 
# 895
{ 
# 896
__base.setf(ios_base::showbase); 
# 897
return __base; 
# 898
} 
# 902
inline ios_base &noshowbase(ios_base &__base) 
# 903
{ 
# 904
__base.unsetf(ios_base::showbase); 
# 905
return __base; 
# 906
} 
# 910
inline ios_base &showpoint(ios_base &__base) 
# 911
{ 
# 912
__base.setf(ios_base::showpoint); 
# 913
return __base; 
# 914
} 
# 918
inline ios_base &noshowpoint(ios_base &__base) 
# 919
{ 
# 920
__base.unsetf(ios_base::showpoint); 
# 921
return __base; 
# 922
} 
# 926
inline ios_base &showpos(ios_base &__base) 
# 927
{ 
# 928
__base.setf(ios_base::showpos); 
# 929
return __base; 
# 930
} 
# 934
inline ios_base &noshowpos(ios_base &__base) 
# 935
{ 
# 936
__base.unsetf(ios_base::showpos); 
# 937
return __base; 
# 938
} 
# 942
inline ios_base &skipws(ios_base &__base) 
# 943
{ 
# 944
__base.setf(ios_base::skipws); 
# 945
return __base; 
# 946
} 
# 950
inline ios_base &noskipws(ios_base &__base) 
# 951
{ 
# 952
__base.unsetf(ios_base::skipws); 
# 953
return __base; 
# 954
} 
# 958
inline ios_base &uppercase(ios_base &__base) 
# 959
{ 
# 960
__base.setf(ios_base::uppercase); 
# 961
return __base; 
# 962
} 
# 966
inline ios_base &nouppercase(ios_base &__base) 
# 967
{ 
# 968
__base.unsetf(ios_base::uppercase); 
# 969
return __base; 
# 970
} 
# 974
inline ios_base &unitbuf(ios_base &__base) 
# 975
{ 
# 976
__base.setf(ios_base::unitbuf); 
# 977
return __base; 
# 978
} 
# 982
inline ios_base &nounitbuf(ios_base &__base) 
# 983
{ 
# 984
__base.unsetf(ios_base::unitbuf); 
# 985
return __base; 
# 986
} 
# 991
inline ios_base &internal(ios_base &__base) 
# 992
{ 
# 993
__base.setf(ios_base::internal, ios_base::adjustfield); 
# 994
return __base; 
# 995
} 
# 999
inline ios_base &left(ios_base &__base) 
# 1000
{ 
# 1001
__base.setf(ios_base::left, ios_base::adjustfield); 
# 1002
return __base; 
# 1003
} 
# 1007
inline ios_base &right(ios_base &__base) 
# 1008
{ 
# 1009
__base.setf(ios_base::right, ios_base::adjustfield); 
# 1010
return __base; 
# 1011
} 
# 1016
inline ios_base &dec(ios_base &__base) 
# 1017
{ 
# 1018
__base.setf(ios_base::dec, ios_base::basefield); 
# 1019
return __base; 
# 1020
} 
# 1024
inline ios_base &hex(ios_base &__base) 
# 1025
{ 
# 1026
__base.setf(ios_base::hex, ios_base::basefield); 
# 1027
return __base; 
# 1028
} 
# 1032
inline ios_base &oct(ios_base &__base) 
# 1033
{ 
# 1034
__base.setf(ios_base::oct, ios_base::basefield); 
# 1035
return __base; 
# 1036
} 
# 1041
inline ios_base &fixed(ios_base &__base) 
# 1042
{ 
# 1043
__base.setf(ios_base::fixed, ios_base::floatfield); 
# 1044
return __base; 
# 1045
} 
# 1049
inline ios_base &scientific(ios_base &__base) 
# 1050
{ 
# 1051
__base.setf(ios_base::scientific, ios_base::floatfield); 
# 1052
return __base; 
# 1053
} 
# 1077
}
# 45 "/usr/include/c++/5/streambuf" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class _CharT, class _Traits> streamsize __copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *, basic_streambuf< _CharT, _Traits>  *, bool &); 
# 119
template< class _CharT, class _Traits> 
# 120
class basic_streambuf { 
# 129
public: typedef _CharT char_type; 
# 130
typedef _Traits traits_type; 
# 131
typedef typename _Traits::int_type int_type; 
# 132
typedef typename _Traits::pos_type pos_type; 
# 133
typedef typename _Traits::off_type off_type; 
# 138
typedef basic_streambuf __streambuf_type; 
# 141
friend class basic_ios< _CharT, _Traits> ; 
# 142
friend class basic_istream< _CharT, _Traits> ; 
# 143
friend class basic_ostream< _CharT, _Traits> ; 
# 144
friend class istreambuf_iterator< _CharT, _Traits> ; 
# 145
friend class ostreambuf_iterator< _CharT, _Traits> ; 
# 148
friend streamsize __copy_streambufs_eof<> (basic_streambuf *, basic_streambuf *, bool &); 
# 150
template< bool _IsMove, class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , _CharT2 *); 
# 156
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, istreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type find(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , const _CharT2 &); 
# 162
template< class _CharT2, class _Traits2> friend basic_istream< _CharT2, _Traits2>  &operator>>(basic_istream< _CharT2, _Traits2>  &, _CharT2 *); 
# 166
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &operator>>(basic_istream< _CharT2, _Traits2>  &, __cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &); 
# 171
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &getline(basic_istream< _CharT2, _Traits2>  &, __cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &, _CharT2); 
# 184
protected: char_type *_M_in_beg; 
# 185
char_type *_M_in_cur; 
# 186
char_type *_M_in_end; 
# 187
char_type *_M_out_beg; 
# 188
char_type *_M_out_cur; 
# 189
char_type *_M_out_end; 
# 192
locale _M_buf_locale; 
# 197
public: virtual ~basic_streambuf() 
# 198
{ } 
# 209
locale pubimbue(const locale &__loc) 
# 210
{ 
# 211
locale __tmp(this->getloc()); 
# 212
this->imbue(__loc); 
# 213
((_M_buf_locale) = __loc); 
# 214
return __tmp; 
# 215
} 
# 226
locale getloc() const 
# 227
{ return _M_buf_locale; } 
# 239
basic_streambuf *pubsetbuf(char_type *__s, streamsize __n) 
# 240
{ return this->setbuf(__s, __n); } 
# 251
pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode 
# 252
__mode = (ios_base::in | ios_base::out)) 
# 253
{ return this->seekoff(__off, __way, __mode); } 
# 263
pos_type pubseekpos(pos_type __sp, ios_base::openmode 
# 264
__mode = (ios_base::in | ios_base::out)) 
# 265
{ return this->seekpos(__sp, __mode); } 
# 271
int pubsync() { return this->sync(); } 
# 284
streamsize in_avail() 
# 285
{ 
# 286
const streamsize __ret = this->egptr() - this->gptr(); 
# 287
return (__ret) ? __ret : this->showmanyc(); 
# 288
} 
# 298
int_type snextc() 
# 299
{ 
# 300
int_type __ret = traits_type::eof(); 
# 301
if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true)) { 
# 303
__ret = this->sgetc(); }  
# 304
return __ret; 
# 305
} 
# 316
int_type sbumpc() 
# 317
{ 
# 318
int_type __ret; 
# 319
if (__builtin_expect(this->gptr() < this->egptr(), true)) 
# 320
{ 
# 321
__ret = traits_type::to_int_type(*this->gptr()); 
# 322
this->gbump(1); 
# 323
} else { 
# 325
__ret = this->uflow(); }  
# 326
return __ret; 
# 327
} 
# 338
int_type sgetc() 
# 339
{ 
# 340
int_type __ret; 
# 341
if (__builtin_expect(this->gptr() < this->egptr(), true)) { 
# 342
__ret = traits_type::to_int_type(*this->gptr()); } else { 
# 344
__ret = this->underflow(); }  
# 345
return __ret; 
# 346
} 
# 357
streamsize sgetn(char_type *__s, streamsize __n) 
# 358
{ return this->xsgetn(__s, __n); } 
# 372
int_type sputbackc(char_type __c) 
# 373
{ 
# 374
int_type __ret; 
# 375
const bool __testpos = this->eback() < this->gptr(); 
# 376
if (__builtin_expect((!__testpos) || (!traits_type::eq(__c, this->gptr()[-1])), false)) { 
# 378
__ret = this->pbackfail(traits_type::to_int_type(__c)); } else 
# 380
{ 
# 381
this->gbump(-1); 
# 382
__ret = traits_type::to_int_type(*this->gptr()); 
# 383
}  
# 384
return __ret; 
# 385
} 
# 397
int_type sungetc() 
# 398
{ 
# 399
int_type __ret; 
# 400
if (__builtin_expect(this->eback() < this->gptr(), true)) 
# 401
{ 
# 402
this->gbump(-1); 
# 403
__ret = traits_type::to_int_type(*this->gptr()); 
# 404
} else { 
# 406
__ret = this->pbackfail(); }  
# 407
return __ret; 
# 408
} 
# 424
int_type sputc(char_type __c) 
# 425
{ 
# 426
int_type __ret; 
# 427
if (__builtin_expect(this->pptr() < this->epptr(), true)) 
# 428
{ 
# 429
(*this->pptr()) = __c; 
# 430
this->pbump(1); 
# 431
__ret = traits_type::to_int_type(__c); 
# 432
} else { 
# 434
__ret = this->overflow(traits_type::to_int_type(__c)); }  
# 435
return __ret; 
# 436
} 
# 450
streamsize sputn(const char_type *__s, streamsize __n) 
# 451
{ return this->xsputn(__s, __n); } 
# 463
protected: basic_streambuf() : _M_in_beg((0)), _M_in_cur((0)), _M_in_end((0)), _M_out_beg((0)), _M_out_cur((0)), _M_out_end((0)), _M_buf_locale(locale()) 
# 467
{ } 
# 482
char_type *eback() const { return _M_in_beg; } 
# 485
char_type *gptr() const { return _M_in_cur; } 
# 488
char_type *egptr() const { return _M_in_end; } 
# 498
void gbump(int __n) { (_M_in_cur) += __n; } 
# 509
void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) 
# 510
{ 
# 511
(_M_in_beg) = __gbeg; 
# 512
(_M_in_cur) = __gnext; 
# 513
(_M_in_end) = __gend; 
# 514
} 
# 529
char_type *pbase() const { return _M_out_beg; } 
# 532
char_type *pptr() const { return _M_out_cur; } 
# 535
char_type *epptr() const { return _M_out_end; } 
# 545
void pbump(int __n) { (_M_out_cur) += __n; } 
# 555
void setp(char_type *__pbeg, char_type *__pend) 
# 556
{ 
# 557
(_M_out_beg) = ((_M_out_cur) = __pbeg); 
# 558
(_M_out_end) = __pend; 
# 559
} 
# 576
virtual void imbue(const locale &__loc) 
# 577
{ } 
# 591
virtual basic_streambuf *setbuf(char_type *, streamsize) 
# 592
{ return this; } 
# 602
virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 604
{ return (pos_type)((off_type)(-1)); } 
# 614
virtual pos_type seekpos(pos_type, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 616
{ return (pos_type)((off_type)(-1)); } 
# 627
virtual int sync() { return 0; } 
# 649
virtual streamsize showmanyc() { return 0; } 
# 665
virtual streamsize xsgetn(char_type * __s, streamsize __n); 
# 687
virtual int_type underflow() 
# 688
{ return traits_type::eof(); } 
# 700
virtual int_type uflow() 
# 701
{ 
# 702
int_type __ret = traits_type::eof(); 
# 703
const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret); 
# 705
if (!__testeof) 
# 706
{ 
# 707
__ret = traits_type::to_int_type(*this->gptr()); 
# 708
this->gbump(1); 
# 709
}  
# 710
return __ret; 
# 711
} 
# 724
virtual int_type pbackfail(int_type __c = traits_type::eof()) 
# 725
{ return traits_type::eof(); } 
# 742
virtual streamsize xsputn(const char_type * __s, streamsize __n); 
# 768
virtual int_type overflow(int_type __c = traits_type::eof()) 
# 769
{ return traits_type::eof(); } 
# 783
public: void stossc() 
# 784
{ 
# 785
if (this->gptr() < this->egptr()) { 
# 786
this->gbump(1); } else { 
# 788
this->uflow(); }  
# 789
} 
# 794
void __safe_gbump(streamsize __n) { (_M_in_cur) += __n; } 
# 797
void __safe_pbump(streamsize __n) { (_M_out_cur) += __n; } 
# 804
private: basic_streambuf(const basic_streambuf &); 
# 807
basic_streambuf &operator=(const basic_streambuf &); 
# 822
}; 
# 838
template<> streamsize __copy_streambufs_eof(basic_streambuf< char, char_traits< char> >  * __sbin, basic_streambuf< char, char_traits< char> >  * __sbout, bool & __ineof); 
# 843
template<> streamsize __copy_streambufs_eof(basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbin, basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbout, bool & __ineof); 
# 848
}
# 39 "/usr/include/c++/5/bits/streambuf.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT, class _Traits> streamsize 
# 46
basic_streambuf< _CharT, _Traits> ::xsgetn(char_type *__s, streamsize __n) 
# 47
{ 
# 48
streamsize __ret = (0); 
# 49
while (__ret < __n) 
# 50
{ 
# 51
const streamsize __buf_len = this->egptr() - this->gptr(); 
# 52
if (__buf_len) 
# 53
{ 
# 54
const streamsize __remaining = __n - __ret; 
# 55
const streamsize __len = std::min(__buf_len, __remaining); 
# 56
traits_type::copy(__s, this->gptr(), __len); 
# 57
__ret += __len; 
# 58
__s += __len; 
# 59
this->__safe_gbump(__len); 
# 60
}  
# 62
if (__ret < __n) 
# 63
{ 
# 64
const int_type __c = this->uflow(); 
# 65
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 66
{ 
# 67
traits_type::assign(*(__s++), traits_type::to_char_type(__c)); 
# 68
++__ret; 
# 69
} else { 
# 71
break; }  
# 72
}  
# 73
}  
# 74
return __ret; 
# 75
} 
# 77
template< class _CharT, class _Traits> streamsize 
# 80
basic_streambuf< _CharT, _Traits> ::xsputn(const char_type *__s, streamsize __n) 
# 81
{ 
# 82
streamsize __ret = (0); 
# 83
while (__ret < __n) 
# 84
{ 
# 85
const streamsize __buf_len = this->epptr() - this->pptr(); 
# 86
if (__buf_len) 
# 87
{ 
# 88
const streamsize __remaining = __n - __ret; 
# 89
const streamsize __len = std::min(__buf_len, __remaining); 
# 90
traits_type::copy(this->pptr(), __s, __len); 
# 91
__ret += __len; 
# 92
__s += __len; 
# 93
this->__safe_pbump(__len); 
# 94
}  
# 96
if (__ret < __n) 
# 97
{ 
# 98
int_type __c = this->overflow(traits_type::to_int_type(*__s)); 
# 99
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 100
{ 
# 101
++__ret; 
# 102
++__s; 
# 103
} else { 
# 105
break; }  
# 106
}  
# 107
}  
# 108
return __ret; 
# 109
} 
# 114
template< class _CharT, class _Traits> streamsize 
# 116
__copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 117
__sbout, bool &
# 118
__ineof) 
# 119
{ 
# 120
streamsize __ret = (0); 
# 121
__ineof = true; 
# 122
typename _Traits::int_type __c = (__sbin->sgetc()); 
# 123
while (!_Traits::eq_int_type(__c, _Traits::eof())) 
# 124
{ 
# 125
__c = (__sbout->sputc(_Traits::to_char_type(__c))); 
# 126
if (_Traits::eq_int_type(__c, _Traits::eof())) 
# 127
{ 
# 128
__ineof = false; 
# 129
break; 
# 130
}  
# 131
++__ret; 
# 132
__c = (__sbin->snextc()); 
# 133
}  
# 134
return __ret; 
# 135
} 
# 137
template< class _CharT, class _Traits> inline streamsize 
# 139
__copy_streambufs(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 140
__sbout) 
# 141
{ 
# 142
bool __ineof; 
# 143
return __copy_streambufs_eof(__sbin, __sbout, __ineof); 
# 144
} 
# 149
extern template class basic_streambuf< char, char_traits< char> > ;
# 150
extern template streamsize __copy_streambufs(basic_streambuf< char, char_traits< char> >  * __sbin, basic_streambuf< char, char_traits< char> >  * __sbout);
# 154
extern template streamsize __copy_streambufs_eof< char, char_traits< char> > (basic_streambuf< char, char_traits< char> >  *, basic_streambuf< char, char_traits< char> >  *, bool &);
# 160
extern template class basic_streambuf< wchar_t, char_traits< wchar_t> > ;
# 161
extern template streamsize __copy_streambufs(basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbin, basic_streambuf< wchar_t, char_traits< wchar_t> >  * __sbout);
# 165
extern template streamsize __copy_streambufs_eof< wchar_t, char_traits< wchar_t> > (basic_streambuf< wchar_t, char_traits< wchar_t> >  *, basic_streambuf< wchar_t, char_traits< wchar_t> >  *, bool &);
# 173
}
# 52 "/usr/include/wctype.h" 3
typedef unsigned long wctype_t; 
# 72
enum { 
# 73
__ISwupper, 
# 74
__ISwlower, 
# 75
__ISwalpha, 
# 76
__ISwdigit, 
# 77
__ISwxdigit, 
# 78
__ISwspace, 
# 79
__ISwprint, 
# 80
__ISwgraph, 
# 81
__ISwblank, 
# 82
__ISwcntrl, 
# 83
__ISwpunct, 
# 84
__ISwalnum, 
# 86
_ISwupper = 16777216, 
# 87
_ISwlower = 33554432, 
# 88
_ISwalpha = 67108864, 
# 89
_ISwdigit = 134217728, 
# 90
_ISwxdigit = 268435456, 
# 91
_ISwspace = 536870912, 
# 92
_ISwprint = 1073741824, 
# 93
_ISwgraph = (-2147483647-1), 
# 94
_ISwblank = 65536, 
# 95
_ISwcntrl = 131072, 
# 96
_ISwpunct = 262144, 
# 97
_ISwalnum = 524288
# 98
}; 
# 102
extern "C" {
# 111
extern int iswalnum(wint_t __wc) throw(); 
# 117
extern int iswalpha(wint_t __wc) throw(); 
# 120
extern int iswcntrl(wint_t __wc) throw(); 
# 124
extern int iswdigit(wint_t __wc) throw(); 
# 128
extern int iswgraph(wint_t __wc) throw(); 
# 133
extern int iswlower(wint_t __wc) throw(); 
# 136
extern int iswprint(wint_t __wc) throw(); 
# 141
extern int iswpunct(wint_t __wc) throw(); 
# 146
extern int iswspace(wint_t __wc) throw(); 
# 151
extern int iswupper(wint_t __wc) throw(); 
# 156
extern int iswxdigit(wint_t __wc) throw(); 
# 162
extern int iswblank(wint_t __wc) throw(); 
# 171
extern wctype_t wctype(const char * __property) throw(); 
# 175
extern int iswctype(wint_t __wc, wctype_t __desc) throw(); 
# 186
typedef const __int32_t *wctrans_t; 
# 194
extern wint_t towlower(wint_t __wc) throw(); 
# 197
extern wint_t towupper(wint_t __wc) throw(); 
# 200
}
# 213
extern "C" {
# 218
extern wctrans_t wctrans(const char * __property) throw(); 
# 221
extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw(); 
# 230
extern int iswalnum_l(wint_t __wc, __locale_t __locale) throw(); 
# 236
extern int iswalpha_l(wint_t __wc, __locale_t __locale) throw(); 
# 239
extern int iswcntrl_l(wint_t __wc, __locale_t __locale) throw(); 
# 243
extern int iswdigit_l(wint_t __wc, __locale_t __locale) throw(); 
# 247
extern int iswgraph_l(wint_t __wc, __locale_t __locale) throw(); 
# 252
extern int iswlower_l(wint_t __wc, __locale_t __locale) throw(); 
# 255
extern int iswprint_l(wint_t __wc, __locale_t __locale) throw(); 
# 260
extern int iswpunct_l(wint_t __wc, __locale_t __locale) throw(); 
# 265
extern int iswspace_l(wint_t __wc, __locale_t __locale) throw(); 
# 270
extern int iswupper_l(wint_t __wc, __locale_t __locale) throw(); 
# 275
extern int iswxdigit_l(wint_t __wc, __locale_t __locale) throw(); 
# 280
extern int iswblank_l(wint_t __wc, __locale_t __locale) throw(); 
# 284
extern wctype_t wctype_l(const char * __property, __locale_t __locale) throw(); 
# 289
extern int iswctype_l(wint_t __wc, wctype_t __desc, __locale_t __locale) throw(); 
# 298
extern wint_t towlower_l(wint_t __wc, __locale_t __locale) throw(); 
# 301
extern wint_t towupper_l(wint_t __wc, __locale_t __locale) throw(); 
# 305
extern wctrans_t wctrans_l(const char * __property, __locale_t __locale) throw(); 
# 309
extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, __locale_t __locale) throw(); 
# 314
}
# 80 "/usr/include/c++/5/cwctype" 3
namespace std { 
# 82
using ::wctrans_t;
# 83
using ::wctype_t;
# 86
using ::iswalnum;
# 87
using ::iswalpha;
# 89
using ::iswblank;
# 91
using ::iswcntrl;
# 92
using ::iswctype;
# 93
using ::iswdigit;
# 94
using ::iswgraph;
# 95
using ::iswlower;
# 96
using ::iswprint;
# 97
using ::iswpunct;
# 98
using ::iswspace;
# 99
using ::iswupper;
# 100
using ::iswxdigit;
# 101
using ::towctrans;
# 102
using ::towlower;
# 103
using ::towupper;
# 104
using ::wctrans;
# 105
using ::wctype;
# 106
}
# 36 "/usr/include/x86_64-linux-gnu/c++/5/bits/ctype_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
struct ctype_base { 
# 44
typedef const int *__to_type; 
# 48
typedef unsigned short mask; 
# 49
static const mask upper = (_ISupper); 
# 50
static const mask lower = (_ISlower); 
# 51
static const mask alpha = (_ISalpha); 
# 52
static const mask digit = (_ISdigit); 
# 53
static const mask xdigit = (_ISxdigit); 
# 54
static const mask space = (_ISspace); 
# 55
static const mask print = (_ISprint); 
# 56
static const mask graph = (((_ISalpha) | (_ISdigit)) | (_ISpunct)); 
# 57
static const mask cntrl = (_IScntrl); 
# 58
static const mask punct = (_ISpunct); 
# 59
static const mask alnum = ((_ISalpha) | (_ISdigit)); 
# 63
}; 
# 66
}
# 38 "/usr/include/c++/5/bits/streambuf_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class _CharT, class _Traits> 
# 50
class istreambuf_iterator : public iterator< input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT &>  { 
# 64
public: typedef _CharT char_type; 
# 65
typedef _Traits traits_type; 
# 66
typedef typename _Traits::int_type int_type; 
# 67
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 68
typedef basic_istream< _CharT, _Traits>  istream_type; 
# 71
template< class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ostreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type copy(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ostreambuf_iterator< _CharT2, char_traits< _CharT2> > ); 
# 77
template< bool _IsMove, class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , _CharT2 *); 
# 83
template< class _CharT2> friend typename ::__gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type find(::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , ::std::istreambuf_iterator< _CharT2, char_traits< _CharT2> > , const _CharT2 &); 
# 97
private: mutable streambuf_type *_M_sbuf; 
# 98
mutable int_type _M_c; 
# 102
public: istreambuf_iterator() throw() : _M_sbuf((0)), _M_c(traits_type::eof()) 
# 103
{ } 
# 112
istreambuf_iterator(istream_type &__s) throw() : _M_sbuf((__s.rdbuf())), _M_c(traits_type::eof()) 
# 113
{ } 
# 116
istreambuf_iterator(streambuf_type *__s) throw() : _M_sbuf(__s), _M_c(traits_type::eof()) 
# 117
{ } 
# 123
char_type operator*() const 
# 124
{ 
# 132
return traits_type::to_char_type(_M_get()); 
# 133
} 
# 137
istreambuf_iterator &operator++() 
# 138
{ 
# 141
; 
# 142
if (_M_sbuf) 
# 143
{ 
# 144
((_M_sbuf)->sbumpc()); 
# 145
(_M_c) = traits_type::eof(); 
# 146
}  
# 147
return *this; 
# 148
} 
# 152
istreambuf_iterator operator++(int) 
# 153
{ 
# 156
; 
# 158
istreambuf_iterator __old = *this; 
# 159
if (_M_sbuf) 
# 160
{ 
# 161
(__old._M_c) = ((_M_sbuf)->sbumpc()); 
# 162
(_M_c) = traits_type::eof(); 
# 163
}  
# 164
return __old; 
# 165
} 
# 172
bool equal(const istreambuf_iterator &__b) const 
# 173
{ return _M_at_eof() == __b._M_at_eof(); } 
# 177
private: int_type _M_get() const 
# 178
{ 
# 179
const int_type __eof = traits_type::eof(); 
# 180
int_type __ret = __eof; 
# 181
if (_M_sbuf) 
# 182
{ 
# 183
if (!traits_type::eq_int_type(_M_c, __eof)) { 
# 184
__ret = (_M_c); } else { 
# 185
if (!traits_type::eq_int_type(__ret = ((_M_sbuf)->sgetc()), __eof)) { 
# 187
(_M_c) = __ret; } else { 
# 189
(_M_sbuf) = 0; }  }  
# 190
}  
# 191
return __ret; 
# 192
} 
# 195
bool _M_at_eof() const 
# 196
{ 
# 197
const int_type __eof = traits_type::eof(); 
# 198
return traits_type::eq_int_type(_M_get(), __eof); 
# 199
} 
# 200
}; 
# 202
template< class _CharT, class _Traits> inline bool 
# 204
operator==(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 205
__b) 
# 206
{ return (__a.equal(__b)); } 
# 208
template< class _CharT, class _Traits> inline bool 
# 210
operator!=(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 211
__b) 
# 212
{ return !(__a.equal(__b)); } 
# 215
template< class _CharT, class _Traits> 
# 216
class ostreambuf_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 223
public: typedef _CharT char_type; 
# 224
typedef _Traits traits_type; 
# 225
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 226
typedef basic_ostream< _CharT, _Traits>  ostream_type; 
# 229
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, std::ostreambuf_iterator< _CharT2, char_traits< _CharT2> > > ::__type copy(istreambuf_iterator< _CharT2, char_traits< _CharT2> > , istreambuf_iterator< _CharT2, char_traits< _CharT2> > , std::ostreambuf_iterator< _CharT2, char_traits< _CharT2> > ); 
# 236
private: streambuf_type *_M_sbuf; 
# 237
bool _M_failed; 
# 241
public: ostreambuf_iterator(ostream_type &__s) throw() : _M_sbuf((__s.rdbuf())), _M_failed(!(_M_sbuf)) 
# 242
{ } 
# 245
ostreambuf_iterator(streambuf_type *__s) throw() : _M_sbuf(__s), _M_failed(!(_M_sbuf)) 
# 246
{ } 
# 250
ostreambuf_iterator &operator=(_CharT __c) 
# 251
{ 
# 252
if ((!(_M_failed)) && _Traits::eq_int_type(((_M_sbuf)->sputc(__c)), _Traits::eof())) { 
# 254
(_M_failed) = true; }  
# 255
return *this; 
# 256
} 
# 260
ostreambuf_iterator &operator*() 
# 261
{ return *this; } 
# 265
ostreambuf_iterator &operator++(int) 
# 266
{ return *this; } 
# 270
ostreambuf_iterator &operator++() 
# 271
{ return *this; } 
# 275
bool failed() const throw() 
# 276
{ return _M_failed; } 
# 279
ostreambuf_iterator &_M_put(const _CharT *__ws, streamsize __len) 
# 280
{ 
# 281
if ((__builtin_expect(!(_M_failed), true)) && (__builtin_expect(((this->_M_sbuf)->sputn(__ws, __len)) != __len, false))) { 
# 284
(_M_failed) = true; }  
# 285
return *this; 
# 286
} 
# 287
}; 
# 290
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 293
copy(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 294
__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 295
__result) 
# 296
{ 
# 297
if ((__first._M_sbuf) && (!(__last._M_sbuf)) && (!(__result._M_failed))) 
# 298
{ 
# 299
bool __ineof; 
# 300
__copy_streambufs_eof((__first._M_sbuf), (__result._M_sbuf), __ineof); 
# 301
if (!__ineof) { 
# 302
(__result._M_failed) = true; }  
# 303
}  
# 304
return __result; 
# 305
} 
# 307
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 310
__copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 311
__result) 
# 312
{ 
# 313
const streamsize __num = __last - __first; 
# 314
if (__num > (0)) { 
# 315
(__result._M_put(__first, __num)); }  
# 316
return __result; 
# 317
} 
# 319
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 322
__copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 323
__result) 
# 324
{ 
# 325
const streamsize __num = __last - __first; 
# 326
if (__num > (0)) { 
# 327
(__result._M_put(__first, __num)); }  
# 328
return __result; 
# 329
} 
# 331
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type 
# 334
__copy_move_a2(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 335
__last, _CharT *__result) 
# 336
{ 
# 337
typedef istreambuf_iterator< _CharT, char_traits< _CharT> >  __is_iterator_type; 
# 338
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type traits_type; 
# 339
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::streambuf_type streambuf_type; 
# 340
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type::int_type int_type; 
# 342
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 343
{ 
# 344
streambuf_type *__sb = ((__first._M_sbuf)); 
# 345
int_type __c = (__sb->sgetc()); 
# 346
while (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 347
{ 
# 348
const streamsize __n = (__sb->egptr()) - (__sb->gptr()); 
# 349
if (__n > (1)) 
# 350
{ 
# 351
traits_type::copy(__result, (__sb->gptr()), __n); 
# 352
(__sb->__safe_gbump(__n)); 
# 353
__result += __n; 
# 354
__c = (__sb->underflow()); 
# 355
} else 
# 357
{ 
# 358
(*(__result++)) = traits_type::to_char_type(__c); 
# 359
__c = (__sb->snextc()); 
# 360
}  
# 361
}  
# 362
}  
# 363
return __result; 
# 364
} 
# 366
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, istreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type 
# 369
find(istreambuf_iterator< _CharT, char_traits< _CharT> >  __first, istreambuf_iterator< _CharT, char_traits< _CharT> >  
# 370
__last, const _CharT &__val) 
# 371
{ 
# 372
typedef istreambuf_iterator< _CharT, char_traits< _CharT> >  __is_iterator_type; 
# 373
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type traits_type; 
# 374
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::streambuf_type streambuf_type; 
# 375
typedef typename istreambuf_iterator< _CharT, char_traits< _CharT> > ::traits_type::int_type int_type; 
# 377
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 378
{ 
# 379
const int_type __ival = traits_type::to_int_type(__val); 
# 380
streambuf_type *__sb = ((__first._M_sbuf)); 
# 381
int_type __c = (__sb->sgetc()); 
# 382
while ((!traits_type::eq_int_type(__c, traits_type::eof())) && (!traits_type::eq_int_type(__c, __ival))) 
# 384
{ 
# 385
streamsize __n = (__sb->egptr()) - (__sb->gptr()); 
# 386
if (__n > (1)) 
# 387
{ 
# 388
const _CharT *__p = traits_type::find((__sb->gptr()), __n, __val); 
# 390
if (__p) { 
# 391
__n = (__p - (__sb->gptr())); }  
# 392
(__sb->__safe_gbump(__n)); 
# 393
__c = (__sb->sgetc()); 
# 394
} else { 
# 396
__c = (__sb->snextc()); }  
# 397
}  
# 399
if (!traits_type::eq_int_type(__c, traits_type::eof())) { 
# 400
(__first._M_c) = __c; } else { 
# 402
(__first._M_sbuf) = 0; }  
# 403
}  
# 404
return __first; 
# 405
} 
# 410
}
# 50 "/usr/include/c++/5/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const __c_locale &) throw(); 
# 79
template<> void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw(); 
# 84
template<> void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw(); 
# 89
template<> void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw(); 
# 94
template< class _CharT, class _Traits> 
# 95
struct __pad { 
# 98
static void _S_pad(ios_base & __io, _CharT __fill, _CharT * __news, const _CharT * __olds, streamsize __newlen, streamsize __oldlen); 
# 100
}; 
# 107
template< class _CharT> _CharT *__add_grouping(_CharT * __s, _CharT __sep, const char * __gbeg, size_t __gsize, const _CharT * __first, const _CharT * __last); 
# 116
template< class _CharT> inline ostreambuf_iterator< _CharT, char_traits< _CharT> >  
# 119
__write(ostreambuf_iterator< _CharT, char_traits< _CharT> >  __s, const _CharT *__ws, int __len) 
# 120
{ 
# 121
(__s._M_put(__ws, __len)); 
# 122
return __s; 
# 123
} 
# 126
template< class _CharT, class _OutIter> inline _OutIter 
# 129
__write(_OutIter __s, const _CharT *__ws, int __len) 
# 130
{ 
# 131
for (int __j = 0; __j < __len; (__j++), (++__s)) { 
# 132
(*__s) = (__ws[__j]); }  
# 133
return __s; 
# 134
} 
# 149
template< class _CharT> 
# 150
class __ctype_abstract_base : public locale::facet, public ctype_base { 
# 155
public: typedef _CharT char_type; 
# 169
bool is(mask __m, char_type __c) const 
# 170
{ return (this->do_is(__m, __c)); } 
# 186
const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const 
# 187
{ return (this->do_is(__lo, __hi, __vec)); } 
# 202
const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const 
# 203
{ return this->do_scan_is(__m, __lo, __hi); } 
# 218
const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const 
# 219
{ return this->do_scan_not(__m, __lo, __hi); } 
# 232
char_type toupper(char_type __c) const 
# 233
{ return (this->do_toupper(__c)); } 
# 247
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 248
{ return (this->do_toupper(__lo, __hi)); } 
# 261
char_type tolower(char_type __c) const 
# 262
{ return (this->do_tolower(__c)); } 
# 276
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 277
{ return (this->do_tolower(__lo, __hi)); } 
# 293
char_type widen(char __c) const 
# 294
{ return (this->do_widen(__c)); } 
# 312
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 313
{ return (this->do_widen(__lo, __hi, __to)); } 
# 331
char narrow(char_type __c, char __dfault) const 
# 332
{ return (this->do_narrow(__c, __dfault)); } 
# 353
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 354
__dfault, char *__to) const 
# 355
{ return (this->do_narrow(__lo, __hi, __dfault, __to)); } 
# 359
protected: explicit __ctype_abstract_base(size_t __refs = 0) : locale::facet(__refs) { } 
# 362
virtual ~__ctype_abstract_base() { } 
# 378
virtual bool do_is(mask __m, char_type __c) const = 0; 
# 397
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const = 0; 
# 416
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 435
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 453
virtual char_type do_toupper(char_type __c) const = 0; 
# 470
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const = 0; 
# 486
virtual char_type do_tolower(char_type __c) const = 0; 
# 503
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const = 0; 
# 522
virtual char_type do_widen(char __c) const = 0; 
# 543
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const = 0; 
# 564
virtual char do_narrow(char_type __c, char __dfault) const = 0; 
# 589
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const = 0; 
# 591
}; 
# 611
template< class _CharT> 
# 612
class ctype : public __ctype_abstract_base< _CharT>  { 
# 616
public: typedef _CharT char_type; 
# 617
typedef typename ::std::__ctype_abstract_base< _CharT> ::mask mask; 
# 620
static ::std::locale::id id; 
# 623
explicit ctype(::std::size_t __refs = 0) : ::std::__ctype_abstract_base< _CharT> (__refs) { } 
# 627
protected: virtual ~ctype(); 
# 630
virtual bool do_is(mask __m, char_type __c) const; 
# 633
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 636
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 639
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 643
virtual char_type do_toupper(char_type __c) const; 
# 646
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 649
virtual char_type do_tolower(char_type __c) const; 
# 652
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 655
virtual char_type do_widen(char __c) const; 
# 658
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __dest) const; 
# 661
virtual char do_narrow(char_type, char __dfault) const; 
# 664
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 666
}; 
# 668
template< class _CharT> locale::id 
# 669
ctype< _CharT> ::id; 
# 681
template<> class ctype< char>  : public locale::facet, public ctype_base { 
# 686
public: typedef char char_type; 
# 690
protected: __c_locale _M_c_locale_ctype; 
# 691
bool _M_del; 
# 692
__to_type _M_toupper; 
# 693
__to_type _M_tolower; 
# 694
const mask *_M_table; 
# 695
mutable char _M_widen_ok; 
# 696
mutable char _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 697
mutable char _M_narrow[1 + (static_cast< unsigned char>(-1))]; 
# 698
mutable char _M_narrow_ok; 
# 703
public: static locale::id id; 
# 705
static const size_t table_size = (1 + (static_cast< unsigned char>(-1))); 
# 718
explicit ctype(const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 731
explicit ctype(__c_locale __cloc, const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 744
inline bool is(mask __m, char __c) const; 
# 759
inline const char *is(const char * __lo, const char * __hi, mask * __vec) const; 
# 773
inline const char *scan_is(mask __m, const char * __lo, const char * __hi) const; 
# 787
inline const char *scan_not(mask __m, const char * __lo, const char * __hi) const; 
# 802
char_type toupper(char_type __c) const 
# 803
{ return this->do_toupper(__c); } 
# 819
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 820
{ return this->do_toupper(__lo, __hi); } 
# 835
char_type tolower(char_type __c) const 
# 836
{ return this->do_tolower(__c); } 
# 852
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 853
{ return this->do_tolower(__lo, __hi); } 
# 872
char_type widen(char __c) const 
# 873
{ 
# 874
if (_M_widen_ok) { 
# 875
return (_M_widen)[static_cast< unsigned char>(__c)]; }  
# 876
this->_M_widen_init(); 
# 877
return this->do_widen(__c); 
# 878
} 
# 899
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 900
{ 
# 901
if ((_M_widen_ok) == 1) 
# 902
{ 
# 903
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 904
return __hi; 
# 905
}  
# 906
if (!(_M_widen_ok)) { 
# 907
this->_M_widen_init(); }  
# 908
return this->do_widen(__lo, __hi, __to); 
# 909
} 
# 930
char narrow(char_type __c, char __dfault) const 
# 931
{ 
# 932
if ((_M_narrow)[static_cast< unsigned char>(__c)]) { 
# 933
return (_M_narrow)[static_cast< unsigned char>(__c)]; }  
# 934
const char __t = this->do_narrow(__c, __dfault); 
# 935
if (__t != __dfault) { 
# 936
((_M_narrow)[static_cast< unsigned char>(__c)]) = __t; }  
# 937
return __t; 
# 938
} 
# 963
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 964
__dfault, char *__to) const 
# 965
{ 
# 966
if (__builtin_expect((_M_narrow_ok) == 1, true)) 
# 967
{ 
# 968
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 969
return __hi; 
# 970
}  
# 971
if (!(_M_narrow_ok)) { 
# 972
this->_M_narrow_init(); }  
# 973
return this->do_narrow(__lo, __hi, __dfault, __to); 
# 974
} 
# 981
const mask *table() const throw() 
# 982
{ return _M_table; } 
# 986
static const mask *classic_table() throw(); 
# 996
protected: virtual ~ctype(); 
# 1012
virtual char_type do_toupper(char_type __c) const; 
# 1029
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1045
virtual char_type do_tolower(char_type __c) const; 
# 1062
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1082
virtual char_type do_widen(char __c) const 
# 1083
{ return __c; } 
# 1105
virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const 
# 1106
{ 
# 1107
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 1108
return __hi; 
# 1109
} 
# 1131
virtual char do_narrow(char_type __c, char __dfault) const 
# 1132
{ return __c; } 
# 1157
virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char 
# 1158
__dfault, char *__to) const 
# 1159
{ 
# 1160
__builtin_memcpy(__to, __lo, __hi - __lo); 
# 1161
return __hi; 
# 1162
} 
# 1165
private: void _M_narrow_init() const; 
# 1166
void _M_widen_init() const; 
# 1167
}; 
# 1182
template<> class ctype< wchar_t>  : public __ctype_abstract_base< wchar_t>  { 
# 1187
public: typedef wchar_t char_type; 
# 1188
typedef wctype_t __wmask_type; 
# 1191
protected: __c_locale _M_c_locale_ctype; 
# 1194
bool _M_narrow_ok; 
# 1195
char _M_narrow[128]; 
# 1196
wint_t _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 1199
mask _M_bit[16]; 
# 1200
__wmask_type _M_wmask[16]; 
# 1205
public: static locale::id id; 
# 1215
explicit ctype(size_t __refs = 0); 
# 1226
explicit ctype(__c_locale __cloc, size_t __refs = 0); 
# 1230
protected: __wmask_type _M_convert_to_wmask(const mask __m) const throw(); 
# 1234
virtual ~ctype(); 
# 1250
virtual bool do_is(mask __m, char_type __c) const; 
# 1269
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 1287
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1305
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1322
virtual char_type do_toupper(char_type __c) const; 
# 1339
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1355
virtual char_type do_tolower(char_type __c) const; 
# 1372
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1392
virtual char_type do_widen(char __c) const; 
# 1414
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const; 
# 1437
virtual char do_narrow(char_type __c, char __dfault) const; 
# 1463
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 1468
void _M_initialize_ctype() throw(); 
# 1469
}; 
# 1473
template< class _CharT> 
# 1474
class ctype_byname : public ctype< _CharT>  { 
# 1477
public: typedef typename ::std::ctype< _CharT> ::mask mask; 
# 1480
explicit ctype_byname(const char * __s, ::std::size_t __refs = 0); 
# 1490
protected: virtual ~ctype_byname() { } 
# 1491
}; 
# 1495
template<> class ctype_byname< char>  : public ctype< char>  { 
# 1499
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1508
protected: virtual ~ctype_byname(); 
# 1509
}; 
# 1513
template<> class ctype_byname< wchar_t>  : public ctype< wchar_t>  { 
# 1517
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1526
protected: virtual ~ctype_byname(); 
# 1527
}; 
# 1531
}
# 37 "/usr/include/x86_64-linux-gnu/c++/5/bits/ctype_inline.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
inline bool ctype< char> ::is(mask __m, char __c) const 
# 44
{ return ((_M_table)[static_cast< unsigned char>(__c)]) & __m; } 
# 48
inline const char *ctype< char> ::is(const char *__low, const char *__high, mask *__vec) const 
# 49
{ 
# 50
while (__low < __high) { 
# 51
(*(__vec++)) = ((_M_table)[static_cast< unsigned char>(*(__low++))]); }  
# 52
return __high; 
# 53
} 
# 57
inline const char *ctype< char> ::scan_is(mask __m, const char *__low, const char *__high) const 
# 58
{ 
# 59
while ((__low < __high) && (!(((_M_table)[static_cast< unsigned char>(*__low)]) & __m))) { 
# 61
++__low; }  
# 62
return __low; 
# 63
} 
# 67
inline const char *ctype< char> ::scan_not(mask __m, const char *__low, const char *__high) const 
# 68
{ 
# 69
while ((__low < __high) && ((((_M_table)[static_cast< unsigned char>(*__low)]) & __m) != 0)) { 
# 71
++__low; }  
# 72
return __low; 
# 73
} 
# 76
}
# 1536 "/usr/include/c++/5/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 1541
class __num_base { 
# 1547
public: enum { 
# 1548
_S_ominus, 
# 1549
_S_oplus, 
# 1550
_S_ox, 
# 1551
_S_oX, 
# 1552
_S_odigits, 
# 1553
_S_odigits_end = 20, 
# 1554
_S_oudigits = 20, 
# 1555
_S_oudigits_end = 36, 
# 1556
_S_oe = 18, 
# 1557
_S_oE = 34, 
# 1558
_S_oend = 36
# 1559
}; 
# 1566
static const char *_S_atoms_out; 
# 1570
static const char *_S_atoms_in; 
# 1573
enum { 
# 1574
_S_iminus, 
# 1575
_S_iplus, 
# 1576
_S_ix, 
# 1577
_S_iX, 
# 1578
_S_izero, 
# 1579
_S_ie = 18, 
# 1580
_S_iE = 24, 
# 1581
_S_iend = 26
# 1582
}; 
# 1587
static void _S_format_float(const ios_base & __io, char * __fptr, char __mod) throw(); 
# 1588
}; 
# 1590
template< class _CharT> 
# 1591
struct __numpunct_cache : public locale::facet { 
# 1593
const char *_M_grouping; 
# 1594
size_t _M_grouping_size; 
# 1595
bool _M_use_grouping; 
# 1596
const _CharT *_M_truename; 
# 1597
size_t _M_truename_size; 
# 1598
const _CharT *_M_falsename; 
# 1599
size_t _M_falsename_size; 
# 1600
_CharT _M_decimal_point; 
# 1601
_CharT _M_thousands_sep; 
# 1607
_CharT _M_atoms_out[__num_base::_S_oend]; 
# 1613
_CharT _M_atoms_in[__num_base::_S_iend]; 
# 1615
bool _M_allocated; 
# 1617
__numpunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_grouping((0)), _M_grouping_size((0)), _M_use_grouping(false), _M_truename((0)), _M_truename_size((0)), _M_falsename((0)), _M_falsename_size((0)), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) 
# 1623
{ } 
# 1625
virtual ~__numpunct_cache(); 
# 1628
void _M_cache(const locale & __loc); 
# 1632
private: __numpunct_cache &operator=(const __numpunct_cache &); 
# 1635
explicit __numpunct_cache(const __numpunct_cache &); 
# 1636
}; 
# 1638
template< class _CharT> 
# 1639
__numpunct_cache< _CharT> ::~__numpunct_cache() 
# 1640
{ 
# 1641
if (_M_allocated) 
# 1642
{ 
# 1643
delete [] (_M_grouping); 
# 1644
delete [] (_M_truename); 
# 1645
delete [] (_M_falsename); 
# 1646
}  
# 1647
} 
# 1649
inline namespace __cxx11 { 
# 1665
template< class _CharT> 
# 1666
class numpunct : public locale::facet { 
# 1672
public: typedef _CharT char_type; 
# 1673
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1675
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1678
protected: __cache_type *_M_data; 
# 1682
public: static locale::id id; 
# 1690
explicit numpunct(size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1692
{ _M_initialize_numpunct(); } 
# 1704
explicit numpunct(__cache_type *__cache, size_t __refs = 0) : locale::facet(__refs), _M_data(__cache) 
# 1706
{ _M_initialize_numpunct(); } 
# 1718
explicit numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1720
{ _M_initialize_numpunct(__cloc); } 
# 1732
char_type decimal_point() const 
# 1733
{ return this->do_decimal_point(); } 
# 1745
char_type thousands_sep() const 
# 1746
{ return this->do_thousands_sep(); } 
# 1776
string grouping() const 
# 1777
{ return this->do_grouping(); } 
# 1789
string_type truename() const 
# 1790
{ return this->do_truename(); } 
# 1802
string_type falsename() const 
# 1803
{ return this->do_falsename(); } 
# 1808
protected: virtual ~numpunct(); 
# 1819
virtual char_type do_decimal_point() const 
# 1820
{ return (_M_data)->_M_decimal_point; } 
# 1831
virtual char_type do_thousands_sep() const 
# 1832
{ return (_M_data)->_M_thousands_sep; } 
# 1844
virtual string do_grouping() const 
# 1845
{ return ((_M_data)->_M_grouping); } 
# 1857
virtual string_type do_truename() const 
# 1858
{ return ((_M_data)->_M_truename); } 
# 1870
virtual string_type do_falsename() const 
# 1871
{ return ((_M_data)->_M_falsename); } 
# 1875
void _M_initialize_numpunct(__c_locale __cloc = 0); 
# 1876
}; 
# 1878
template< class _CharT> locale::id 
# 1879
numpunct< _CharT> ::id; 
# 1882
template<> numpunct< char> ::~numpunct(); 
# 1886
template<> void numpunct< char> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1890
template<> numpunct< wchar_t> ::~numpunct(); 
# 1894
template<> void numpunct< wchar_t> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1898
template< class _CharT> 
# 1899
class numpunct_byname : public numpunct< _CharT>  { 
# 1902
public: typedef _CharT char_type; 
# 1903
typedef basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  string_type; 
# 1906
explicit numpunct_byname(const char *__s, ::std::size_t __refs = 0) : ::std::__cxx11::numpunct< _CharT> (__refs) 
# 1908
{ 
# 1909
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 1911
{ 
# 1912
::std::__c_locale __tmp; 
# 1913
(this->_S_create_c_locale(__tmp, __s)); 
# 1914
(this->_M_initialize_numpunct(__tmp)); 
# 1915
(this->_S_destroy_c_locale(__tmp)); 
# 1916
}  
# 1917
} 
# 1927
protected: virtual ~numpunct_byname() { } 
# 1928
}; 
# 1930
}
# 1947
template< class _CharT, class _InIter> 
# 1948
class num_get : public locale::facet { 
# 1954
public: typedef _CharT char_type; 
# 1955
typedef _InIter iter_type; 
# 1959
static locale::id id; 
# 1969
explicit num_get(size_t __refs = 0) : locale::facet(__refs) { } 
# 1995
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 1996
__err, bool &__v) const 
# 1997
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2032
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2033
__err, long &__v) const 
# 2034
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2037
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2038
__err, unsigned short &__v) const 
# 2039
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2042
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2043
__err, unsigned &__v) const 
# 2044
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2047
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2048
__err, unsigned long &__v) const 
# 2049
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2053
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2054
__err, long long &__v) const 
# 2055
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2058
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2059
__err, unsigned long long &__v) const 
# 2060
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2092
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2093
__err, float &__v) const 
# 2094
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2097
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2098
__err, double &__v) const 
# 2099
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2102
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2103
__err, long double &__v) const 
# 2104
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2135
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2136
__err, void *&__v) const 
# 2137
{ return (this->do_get(__in, __end, __io, __err, __v)); } 
# 2141
protected: virtual ~num_get() { } 
# 2143
__attribute((__abi_tag__("cxx11" ))) iter_type 
# 2145
_M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, __cxx11::string &) const; 
# 2148
template< class _ValueT> 
# 2149
__attribute((__abi_tag__("cxx11" ))) iter_type 
# 2148
_M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const; 
# 2154
template< class _CharT2> typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, int> ::__type 
# 2156
_M_find(const _CharT2 *, size_t __len, _CharT2 __c) const 
# 2157
{ 
# 2158
int __ret = (-1); 
# 2159
if (__len <= (10)) 
# 2160
{ 
# 2161
if ((__c >= ((_CharT2)'0')) && (__c < ((_CharT2)(((_CharT2)'0') + __len)))) { 
# 2162
__ret = (__c - ((_CharT2)'0')); }  
# 2163
} else 
# 2165
{ 
# 2166
if ((__c >= ((_CharT2)'0')) && (__c <= ((_CharT2)'9'))) { 
# 2167
__ret = (__c - ((_CharT2)'0')); } else { 
# 2168
if ((__c >= ((_CharT2)'a')) && (__c <= ((_CharT2)'f'))) { 
# 2169
__ret = (10 + (__c - ((_CharT2)'a'))); } else { 
# 2170
if ((__c >= ((_CharT2)'A')) && (__c <= ((_CharT2)'F'))) { 
# 2171
__ret = (10 + (__c - ((_CharT2)'A'))); }  }  }  
# 2172
}  
# 2173
return __ret; 
# 2174
} 
# 2176
template< class _CharT2> typename __gnu_cxx::__enable_if< !__is_char< _CharT2> ::__value, int> ::__type 
# 2179
_M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const 
# 2180
{ 
# 2181
int __ret = (-1); 
# 2182
const char_type *__q = char_traits< _CharT2> ::find(__zero, __len, __c); 
# 2183
if (__q) 
# 2184
{ 
# 2185
__ret = (__q - __zero); 
# 2186
if (__ret > 15) { 
# 2187
__ret -= 6; }  
# 2188
}  
# 2189
return __ret; 
# 2190
} 
# 2208
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const; 
# 2211
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2212
__err, long &__v) const 
# 2213
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2216
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2217
__err, unsigned short &__v) const 
# 2218
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2221
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2222
__err, unsigned &__v) const 
# 2223
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2226
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2227
__err, unsigned long &__v) const 
# 2228
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2232
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2233
__err, long long &__v) const 
# 2234
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2237
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2238
__err, unsigned long long &__v) const 
# 2239
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2243
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const; 
# 2246
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const; 
# 2256
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const; 
# 2261
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const; 
# 2270
}; 
# 2272
template< class _CharT, class _InIter> locale::id 
# 2273
num_get< _CharT, _InIter> ::id; 
# 2288
template< class _CharT, class _OutIter> 
# 2289
class num_put : public locale::facet { 
# 2295
public: typedef _CharT char_type; 
# 2296
typedef _OutIter iter_type; 
# 2300
static locale::id id; 
# 2310
explicit num_put(size_t __refs = 0) : locale::facet(__refs) { } 
# 2328
iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 2329
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2370
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2371
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2374
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2375
__v) const 
# 2376
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2380
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const 
# 2381
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2384
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2385
__v) const 
# 2386
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2433
iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 2434
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2437
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 2438
__v) const 
# 2439
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2458
iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 2459
__v) const 
# 2460
{ return (this->do_put(__s, __io, __fill, __v)); } 
# 2463
protected: template< class _ValueT> iter_type _M_insert_float(iter_type, ios_base & __io, char_type __fill, char __mod, _ValueT __v) const; 
# 2469
void _M_group_float(const char * __grouping, size_t __grouping_size, char_type __sep, const char_type * __p, char_type * __new, char_type * __cs, int & __len) const; 
# 2473
template< class _ValueT> iter_type _M_insert_int(iter_type, ios_base & __io, char_type __fill, _ValueT __v) const; 
# 2479
void _M_group_int(const char * __grouping, size_t __grouping_size, char_type __sep, ios_base & __io, char_type * __new, char_type * __cs, int & __len) const; 
# 2484
void _M_pad(char_type __fill, streamsize __w, ios_base & __io, char_type * __new, const char_type * __cs, int & __len) const; 
# 2489
virtual ~num_put() { } 
# 2506
virtual iter_type do_put(iter_type __s, ios_base & __io, char_type __fill, bool __v) const; 
# 2509
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2510
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2513
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2514
__v) const 
# 2515
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2519
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long 
# 2520
__v) const 
# 2521
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2524
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2525
__v) const 
# 2526
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2530
virtual iter_type do_put(iter_type, ios_base &, char_type, double) const; 
# 2538
virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const; 
# 2542
virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const; 
# 2550
}; 
# 2552
template< class _CharT, class _OutIter> locale::id 
# 2553
num_put< _CharT, _OutIter> ::id; 
# 2563
template< class _CharT> inline bool 
# 2565
isspace(_CharT __c, const locale &__loc) 
# 2566
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::space, __c)); } 
# 2569
template< class _CharT> inline bool 
# 2571
isprint(_CharT __c, const locale &__loc) 
# 2572
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::print, __c)); } 
# 2575
template< class _CharT> inline bool 
# 2577
iscntrl(_CharT __c, const locale &__loc) 
# 2578
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::cntrl, __c)); } 
# 2581
template< class _CharT> inline bool 
# 2583
isupper(_CharT __c, const locale &__loc) 
# 2584
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::upper, __c)); } 
# 2587
template< class _CharT> inline bool 
# 2589
islower(_CharT __c, const locale &__loc) 
# 2590
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::lower, __c)); } 
# 2593
template< class _CharT> inline bool 
# 2595
isalpha(_CharT __c, const locale &__loc) 
# 2596
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::alpha, __c)); } 
# 2599
template< class _CharT> inline bool 
# 2601
isdigit(_CharT __c, const locale &__loc) 
# 2602
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::digit, __c)); } 
# 2605
template< class _CharT> inline bool 
# 2607
ispunct(_CharT __c, const locale &__loc) 
# 2608
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::punct, __c)); } 
# 2611
template< class _CharT> inline bool 
# 2613
isxdigit(_CharT __c, const locale &__loc) 
# 2614
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::xdigit, __c)); } 
# 2617
template< class _CharT> inline bool 
# 2619
isalnum(_CharT __c, const locale &__loc) 
# 2620
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::alnum, __c)); } 
# 2623
template< class _CharT> inline bool 
# 2625
isgraph(_CharT __c, const locale &__loc) 
# 2626
{ return (use_facet< ctype< _CharT> > (__loc).is(ctype_base::graph, __c)); } 
# 2637
template< class _CharT> inline _CharT 
# 2639
toupper(_CharT __c, const locale &__loc) 
# 2640
{ return (use_facet< ctype< _CharT> > (__loc).toupper(__c)); } 
# 2643
template< class _CharT> inline _CharT 
# 2645
tolower(_CharT __c, const locale &__loc) 
# 2646
{ return (use_facet< ctype< _CharT> > (__loc).tolower(__c)); } 
# 2649
}
# 35 "/usr/include/c++/5/bits/locale_facets.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _Facet> 
# 42
struct __use_cache { 
# 45
const _Facet *operator()(const locale & __loc) const; 
# 46
}; 
# 49
template< class _CharT> 
# 50
struct __use_cache< __numpunct_cache< _CharT> >  { 
# 53
const __numpunct_cache< _CharT>  *operator()(const locale &__loc) const 
# 54
{ 
# 55
const size_t __i = (numpunct< _CharT> ::id._M_id)(); 
# 56
const locale::facet **__caches = (__loc._M_impl)->_M_caches; 
# 57
if (!(__caches[__i])) 
# 58
{ 
# 59
__numpunct_cache< _CharT>  *__tmp = (0); 
# 60
try 
# 61
{ 
# 62
__tmp = (new __numpunct_cache< _CharT> ); 
# 63
(__tmp->_M_cache(__loc)); 
# 64
} 
# 65
catch (...) 
# 66
{ 
# 67
delete __tmp; 
# 68
throw; 
# 69
}  
# 70
(__loc._M_impl)->_M_install_cache(__tmp, __i); 
# 71
}  
# 72
return static_cast< const __numpunct_cache< _CharT>  *>(__caches[__i]); 
# 73
} 
# 74
}; 
# 76
template< class _CharT> void 
# 78
__numpunct_cache< _CharT> ::_M_cache(const locale &__loc) 
# 79
{ 
# 80
const __cxx11::numpunct< _CharT>  &__np = use_facet< __cxx11::numpunct< _CharT> > (__loc); 
# 82
char *__grouping = (0); 
# 83
_CharT *__truename = (0); 
# 84
_CharT *__falsename = (0); 
# 85
try 
# 86
{ 
# 87
const __cxx11::string &__g = (__np.grouping()); 
# 88
(_M_grouping_size) = __g.size(); 
# 89
__grouping = (new char [_M_grouping_size]); 
# 90
__g.copy(__grouping, _M_grouping_size); 
# 91
(_M_use_grouping) = ((_M_grouping_size) && ((static_cast< signed char>(__grouping[0])) > 0) && ((__grouping[0]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)); 
# 96
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__tn = (__np.truename()); 
# 97
(_M_truename_size) = (__tn.size()); 
# 98
__truename = (new _CharT [_M_truename_size]); 
# 99
(__tn.copy(__truename, _M_truename_size)); 
# 101
const __cxx11::basic_string< _CharT, char_traits< _CharT> , allocator< _CharT> >  &__fn = (__np.falsename()); 
# 102
(_M_falsename_size) = (__fn.size()); 
# 103
__falsename = (new _CharT [_M_falsename_size]); 
# 104
(__fn.copy(__falsename, _M_falsename_size)); 
# 106
(_M_decimal_point) = (__np.decimal_point()); 
# 107
(_M_thousands_sep) = (__np.thousands_sep()); 
# 109
const ctype< _CharT>  &__ct = use_facet< ctype< _CharT> > (__loc); 
# 110
(__ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out)); 
# 113
(__ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in)); 
# 117
(_M_grouping) = __grouping; 
# 118
(_M_truename) = __truename; 
# 119
(_M_falsename) = __falsename; 
# 120
(_M_allocated) = true; 
# 121
} 
# 122
catch (...) 
# 123
{ 
# 124
delete [] __grouping; 
# 125
delete [] __truename; 
# 126
delete [] __falsename; 
# 127
throw; 
# 128
}  
# 129
} 
# 139
__attribute((__pure__)) bool 
# 140
__verify_grouping(const char * __grouping, size_t __grouping_size, const __cxx11::string & __grouping_tmp) throw(); 
# 145
template< class _CharT, class _InIter> 
# 146
__attribute((__abi_tag__("cxx11" ))) _InIter 
# 149
num_get< _CharT, _InIter> ::_M_extract_float(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 150
__err, __cxx11::string &__xtrc) const 
# 151
{ 
# 152
typedef char_traits< _CharT>  __traits_type; 
# 153
typedef __numpunct_cache< _CharT>  __cache_type; 
# 154
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 155
const locale &__loc = __io._M_getloc(); 
# 156
const __cache_type *__lc = __uc(__loc); 
# 157
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 158
char_type __c = (char_type()); 
# 161
bool __testeof = __beg == __end; 
# 164
if (!__testeof) 
# 165
{ 
# 166
__c = (*__beg); 
# 167
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 168
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 171
{ 
# 172
(__xtrc += (__plus ? '+' : '-')); 
# 173
if ((++__beg) != __end) { 
# 174
__c = (*__beg); } else { 
# 176
__testeof = true; }  
# 177
}  
# 178
}  
# 181
bool __found_mantissa = false; 
# 182
int __sep_pos = 0; 
# 183
while (!__testeof) 
# 184
{ 
# 185
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 187
break; } else { 
# 188
if (__c == (__lit[__num_base::_S_izero])) 
# 189
{ 
# 190
if (!__found_mantissa) 
# 191
{ 
# 192
(__xtrc += ('0')); 
# 193
__found_mantissa = true; 
# 194
}  
# 195
++__sep_pos; 
# 197
if ((++__beg) != __end) { 
# 198
__c = (*__beg); } else { 
# 200
__testeof = true; }  
# 201
} else { 
# 203
break; }  }  
# 204
}  
# 207
bool __found_dec = false; 
# 208
bool __found_sci = false; 
# 209
__cxx11::string __found_grouping; 
# 210
if (__lc->_M_use_grouping) { 
# 211
__found_grouping.reserve(32); }  
# 212
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 214
if (!(__lc->_M_allocated)) { 
# 216
while (!__testeof) { 
# 217
{ 
# 218
const int __digit = _M_find(__lit_zero, 10, __c); 
# 219
if (__digit != (-1)) 
# 220
{ 
# 221
(__xtrc += (('0') + __digit)); 
# 222
__found_mantissa = true; 
# 223
} else { 
# 224
if ((__c == (__lc->_M_decimal_point)) && (!__found_dec) && (!__found_sci)) 
# 226
{ 
# 227
(__xtrc += ('.')); 
# 228
__found_dec = true; 
# 229
} else { 
# 230
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 233
{ 
# 235
(__xtrc += ('e')); 
# 236
__found_sci = true; 
# 239
if ((++__beg) != __end) 
# 240
{ 
# 241
__c = (*__beg); 
# 242
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 243
if (__plus || (__c == (__lit[__num_base::_S_iminus]))) { 
# 244
(__xtrc += (__plus ? '+' : '-')); } else { 
# 246
continue; }  
# 247
} else 
# 249
{ 
# 250
__testeof = true; 
# 251
break; 
# 252
}  
# 253
} else { 
# 255
break; }  }  }  
# 257
if ((++__beg) != __end) { 
# 258
__c = (*__beg); } else { 
# 260
__testeof = true; }  
# 261
} }  } else { 
# 263
while (!__testeof) { 
# 264
{ 
# 267
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 268
{ 
# 269
if ((!__found_dec) && (!__found_sci)) 
# 270
{ 
# 273
if (__sep_pos) 
# 274
{ 
# 275
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 276
__sep_pos = 0; 
# 277
} else 
# 279
{ 
# 282
__xtrc.clear(); 
# 283
break; 
# 284
}  
# 285
} else { 
# 287
break; }  
# 288
} else { 
# 289
if (__c == (__lc->_M_decimal_point)) 
# 290
{ 
# 291
if ((!__found_dec) && (!__found_sci)) 
# 292
{ 
# 296
if (__found_grouping.size()) { 
# 297
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 298
(__xtrc += ('.')); 
# 299
__found_dec = true; 
# 300
} else { 
# 302
break; }  
# 303
} else 
# 305
{ 
# 306
const char_type *__q = __traits_type::find(__lit_zero, 10, __c); 
# 308
if (__q) 
# 309
{ 
# 310
__xtrc += ('0' + (__q - __lit_zero)); 
# 311
__found_mantissa = true; 
# 312
++__sep_pos; 
# 313
} else { 
# 314
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 317
{ 
# 319
if ((__found_grouping.size()) && (!__found_dec)) { 
# 320
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 321
(__xtrc += ('e')); 
# 322
__found_sci = true; 
# 325
if ((++__beg) != __end) 
# 326
{ 
# 327
__c = (*__beg); 
# 328
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 329
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) { 
# 333
(__xtrc += (__plus ? '+' : '-')); } else { 
# 335
continue; }  
# 336
} else 
# 338
{ 
# 339
__testeof = true; 
# 340
break; 
# 341
}  
# 342
} else { 
# 344
break; }  }  
# 345
}  }  
# 347
if ((++__beg) != __end) { 
# 348
__c = (*__beg); } else { 
# 350
__testeof = true; }  
# 351
} }  }  
# 355
if (__found_grouping.size()) 
# 356
{ 
# 358
if ((!__found_dec) && (!__found_sci)) { 
# 359
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 361
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 364
__err = ios_base::failbit; }  
# 365
}  
# 367
return __beg; 
# 368
} 
# 370
template< class _CharT, class _InIter> 
# 371
template< class _ValueT> 
# 372
__attribute((__abi_tag__("cxx11" ))) _InIter 
# 375
num_get< _CharT, _InIter> ::_M_extract_int(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 376
__err, _ValueT &__v) const 
# 377
{ 
# 378
typedef char_traits< _CharT>  __traits_type; 
# 379
using __gnu_cxx::__add_unsigned;
# 380
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 381
typedef __numpunct_cache< _CharT>  __cache_type; 
# 382
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 383
const locale &__loc = __io._M_getloc(); 
# 384
const __cache_type *__lc = __uc(__loc); 
# 385
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 386
char_type __c = (char_type()); 
# 389
const ios_base::fmtflags __basefield = ((__io.flags()) & ios_base::basefield); 
# 391
const bool __oct = __basefield == ios_base::oct; 
# 392
int __base = __oct ? 8 : ((__basefield == ios_base::hex) ? 16 : 10); 
# 395
bool __testeof = __beg == __end; 
# 398
bool __negative = false; 
# 399
if (!__testeof) 
# 400
{ 
# 401
__c = (*__beg); 
# 402
__negative = (__c == (__lit[__num_base::_S_iminus])); 
# 403
if ((__negative || (__c == (__lit[__num_base::_S_iplus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 406
{ 
# 407
if ((++__beg) != __end) { 
# 408
__c = (*__beg); } else { 
# 410
__testeof = true; }  
# 411
}  
# 412
}  
# 416
bool __found_zero = false; 
# 417
int __sep_pos = 0; 
# 418
while (!__testeof) 
# 419
{ 
# 420
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 422
break; } else { 
# 423
if ((__c == (__lit[__num_base::_S_izero])) && ((!__found_zero) || (__base == 10))) 
# 425
{ 
# 426
__found_zero = true; 
# 427
++__sep_pos; 
# 428
if (__basefield == 0) { 
# 429
__base = 8; }  
# 430
if (__base == 8) { 
# 431
__sep_pos = 0; }  
# 432
} else { 
# 433
if (__found_zero && ((__c == (__lit[__num_base::_S_ix])) || (__c == (__lit[__num_base::_S_iX])))) 
# 436
{ 
# 437
if (__basefield == 0) { 
# 438
__base = 16; }  
# 439
if (__base == 16) 
# 440
{ 
# 441
__found_zero = false; 
# 442
__sep_pos = 0; 
# 443
} else { 
# 445
break; }  
# 446
} else { 
# 448
break; }  }  }  
# 450
if ((++__beg) != __end) 
# 451
{ 
# 452
__c = (*__beg); 
# 453
if (!__found_zero) { 
# 454
break; }  
# 455
} else { 
# 457
__testeof = true; }  
# 458
}  
# 462
const size_t __len = (__base == 16) ? (__num_base::_S_iend) - (__num_base::_S_izero) : __base; 
# 466
__cxx11::string __found_grouping; 
# 467
if (__lc->_M_use_grouping) { 
# 468
__found_grouping.reserve(32); }  
# 469
bool __testfail = false; 
# 470
bool __testoverflow = false; 
# 471
const __unsigned_type __max = (__negative && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) ? -__gnu_cxx::__numeric_traits< _ValueT> ::__min : __gnu_cxx::__numeric_traits< _ValueT> ::__max; 
# 475
const __unsigned_type __smax = __max / __base; 
# 476
__unsigned_type __result = (0); 
# 477
int __digit = 0; 
# 478
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 480
if (!(__lc->_M_allocated)) { 
# 482
while (!__testeof) 
# 483
{ 
# 484
__digit = _M_find(__lit_zero, __len, __c); 
# 485
if (__digit == (-1)) { 
# 486
break; }  
# 488
if (__result > __smax) { 
# 489
__testoverflow = true; } else 
# 491
{ 
# 492
__result *= __base; 
# 493
__testoverflow |= (__result > (__max - __digit)); 
# 494
__result += __digit; 
# 495
++__sep_pos; 
# 496
}  
# 498
if ((++__beg) != __end) { 
# 499
__c = (*__beg); } else { 
# 501
__testeof = true; }  
# 502
}  } else { 
# 504
while (!__testeof) 
# 505
{ 
# 508
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 509
{ 
# 512
if (__sep_pos) 
# 513
{ 
# 514
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 515
__sep_pos = 0; 
# 516
} else 
# 518
{ 
# 519
__testfail = true; 
# 520
break; 
# 521
}  
# 522
} else { 
# 523
if (__c == (__lc->_M_decimal_point)) { 
# 524
break; } else 
# 526
{ 
# 527
const char_type *__q = __traits_type::find(__lit_zero, __len, __c); 
# 529
if (!__q) { 
# 530
break; }  
# 532
__digit = (__q - __lit_zero); 
# 533
if (__digit > 15) { 
# 534
__digit -= 6; }  
# 535
if (__result > __smax) { 
# 536
__testoverflow = true; } else 
# 538
{ 
# 539
__result *= __base; 
# 540
__testoverflow |= (__result > (__max - __digit)); 
# 541
__result += __digit; 
# 542
++__sep_pos; 
# 543
}  
# 544
}  }  
# 546
if ((++__beg) != __end) { 
# 547
__c = (*__beg); } else { 
# 549
__testeof = true; }  
# 550
}  }  
# 554
if (__found_grouping.size()) 
# 555
{ 
# 557
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 559
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 562
__err = ios_base::failbit; }  
# 563
}  
# 567
if (((!__sep_pos) && (!__found_zero) && (!(__found_grouping.size()))) || __testfail) 
# 569
{ 
# 570
__v = 0; 
# 571
__err = ios_base::failbit; 
# 572
} else { 
# 573
if (__testoverflow) 
# 574
{ 
# 575
if (__negative && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) { 
# 577
__v = __gnu_cxx::__numeric_traits< _ValueT> ::__min; } else { 
# 579
__v = __gnu_cxx::__numeric_traits< _ValueT> ::__max; }  
# 580
__err = ios_base::failbit; 
# 581
} else { 
# 583
__v = (__negative ? -__result : __result); }  }  
# 585
if (__testeof) { 
# 586
(__err |= ios_base::eofbit); }  
# 587
return __beg; 
# 588
} 
# 592
template< class _CharT, class _InIter> _InIter 
# 595
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 596
__err, bool &__v) const 
# 597
{ 
# 598
if (!(((__io.flags()) & ios_base::boolalpha))) 
# 599
{ 
# 603
long __l = (-1); 
# 604
__beg = _M_extract_int(__beg, __end, __io, __err, __l); 
# 605
if ((__l == (0)) || (__l == (1))) { 
# 606
__v = ((bool)__l); } else 
# 608
{ 
# 611
__v = true; 
# 612
__err = ios_base::failbit; 
# 613
if (__beg == __end) { 
# 614
(__err |= ios_base::eofbit); }  
# 615
}  
# 616
} else 
# 618
{ 
# 620
typedef __numpunct_cache< _CharT>  __cache_type; 
# 621
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 622
const locale &__loc = __io._M_getloc(); 
# 623
const __cache_type *__lc = __uc(__loc); 
# 625
bool __testf = true; 
# 626
bool __testt = true; 
# 627
bool __donef = (__lc->_M_falsename_size) == 0; 
# 628
bool __donet = (__lc->_M_truename_size) == 0; 
# 629
bool __testeof = false; 
# 630
size_t __n = (0); 
# 631
while ((!__donef) || (!__donet)) 
# 632
{ 
# 633
if (__beg == __end) 
# 634
{ 
# 635
__testeof = true; 
# 636
break; 
# 637
}  
# 639
const char_type __c = *__beg; 
# 641
if (!__donef) { 
# 642
__testf = (__c == ((__lc->_M_falsename)[__n])); }  
# 644
if ((!__testf) && __donet) { 
# 645
break; }  
# 647
if (!__donet) { 
# 648
__testt = (__c == ((__lc->_M_truename)[__n])); }  
# 650
if ((!__testt) && __donef) { 
# 651
break; }  
# 653
if ((!__testt) && (!__testf)) { 
# 654
break; }  
# 656
++__n; 
# 657
++__beg; 
# 659
__donef = ((!__testf) || (__n >= (__lc->_M_falsename_size))); 
# 660
__donet = ((!__testt) || (__n >= (__lc->_M_truename_size))); 
# 661
}  
# 662
if (__testf && (__n == (__lc->_M_falsename_size)) && __n) 
# 663
{ 
# 664
__v = false; 
# 665
if (__testt && (__n == (__lc->_M_truename_size))) { 
# 666
__err = ios_base::failbit; } else { 
# 668
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); }  
# 669
} else { 
# 670
if (__testt && (__n == (__lc->_M_truename_size)) && __n) 
# 671
{ 
# 672
__v = true; 
# 673
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); 
# 674
} else 
# 676
{ 
# 679
__v = false; 
# 680
__err = ios_base::failbit; 
# 681
if (__testeof) { 
# 682
(__err |= ios_base::eofbit); }  
# 683
}  }  
# 684
}  
# 685
return __beg; 
# 686
} 
# 688
template< class _CharT, class _InIter> _InIter 
# 691
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 692
__err, float &__v) const 
# 693
{ 
# 694
__cxx11::string __xtrc; 
# 695
__xtrc.reserve(32); 
# 696
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 697
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 698
if (__beg == __end) { 
# 699
(__err |= ios_base::eofbit); }  
# 700
return __beg; 
# 701
} 
# 703
template< class _CharT, class _InIter> _InIter 
# 706
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 707
__err, double &__v) const 
# 708
{ 
# 709
__cxx11::string __xtrc; 
# 710
__xtrc.reserve(32); 
# 711
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 712
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 713
if (__beg == __end) { 
# 714
(__err |= ios_base::eofbit); }  
# 715
return __beg; 
# 716
} 
# 735
template< class _CharT, class _InIter> _InIter 
# 738
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 739
__err, long double &__v) const 
# 740
{ 
# 741
__cxx11::string __xtrc; 
# 742
__xtrc.reserve(32); 
# 743
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 744
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 745
if (__beg == __end) { 
# 746
(__err |= ios_base::eofbit); }  
# 747
return __beg; 
# 748
} 
# 750
template< class _CharT, class _InIter> _InIter 
# 753
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 754
__err, void *&__v) const 
# 755
{ 
# 757
typedef ios_base::fmtflags fmtflags; 
# 758
const fmtflags __fmt = __io.flags(); 
# 759
__io.flags((((__fmt & ((~ios_base::basefield)))) | ios_base::hex)); 
# 763
typedef __gnu_cxx::__conditional_type< true, unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 765
_UIntPtrType __ul; 
# 766
__beg = _M_extract_int(__beg, __end, __io, __err, __ul); 
# 769
__io.flags(__fmt); 
# 771
__v = (reinterpret_cast< void *>(__ul)); 
# 772
return __beg; 
# 773
} 
# 777
template< class _CharT, class _OutIter> void 
# 780
num_put< _CharT, _OutIter> ::_M_pad(_CharT __fill, streamsize __w, ios_base &__io, _CharT *
# 781
__new, const _CharT *__cs, int &__len) const 
# 782
{ 
# 785
__pad< _CharT, char_traits< _CharT> > ::_S_pad(__io, __fill, __new, __cs, __w, __len); 
# 787
__len = (static_cast< int>(__w)); 
# 788
} 
# 792
template< class _CharT, class _ValueT> int 
# 794
__int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags 
# 795
__flags, bool __dec) 
# 796
{ 
# 797
_CharT *__buf = __bufend; 
# 798
if (__builtin_expect(__dec, true)) 
# 799
{ 
# 801
do 
# 802
{ 
# 803
(*(--__buf)) = (__lit[(__v % 10) + __num_base::_S_odigits]); 
# 804
__v /= 10; 
# 805
} 
# 806
while (__v != 0); 
# 807
} else { 
# 808
if (((__flags & ios_base::basefield)) == ios_base::oct) 
# 809
{ 
# 811
do 
# 812
{ 
# 813
(*(--__buf)) = (__lit[(__v & 7) + __num_base::_S_odigits]); 
# 814
__v >>= 3; 
# 815
} 
# 816
while (__v != 0); 
# 817
} else 
# 819
{ 
# 821
const bool __uppercase = (__flags & ios_base::uppercase); 
# 822
const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits; 
# 824
do 
# 825
{ 
# 826
(*(--__buf)) = (__lit[(__v & 15) + __case_offset]); 
# 827
__v >>= 4; 
# 828
} 
# 829
while (__v != 0); 
# 830
}  }  
# 831
return __bufend - __buf; 
# 832
} 
# 836
template< class _CharT, class _OutIter> void 
# 839
num_put< _CharT, _OutIter> ::_M_group_int(const char *__grouping, size_t __grouping_size, _CharT __sep, ios_base &, _CharT *
# 840
__new, _CharT *__cs, int &__len) const 
# 841
{ 
# 842
_CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len); 
# 844
__len = (__p - __new); 
# 845
} 
# 847
template< class _CharT, class _OutIter> 
# 848
template< class _ValueT> _OutIter 
# 851
num_put< _CharT, _OutIter> ::_M_insert_int(_OutIter __s, ios_base &__io, _CharT __fill, _ValueT 
# 852
__v) const 
# 853
{ 
# 854
using __gnu_cxx::__add_unsigned;
# 855
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 856
typedef __numpunct_cache< _CharT>  __cache_type; 
# 857
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 858
const locale &__loc = __io._M_getloc(); 
# 859
const __cache_type *__lc = __uc(__loc); 
# 860
const _CharT *__lit = ((__lc->_M_atoms_out)); 
# 861
const ios_base::fmtflags __flags = __io.flags(); 
# 864
const int __ilen = ((5) * sizeof(_ValueT)); 
# 865
_CharT *__cs = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen)); 
# 870
const ios_base::fmtflags __basefield = (__flags & ios_base::basefield); 
# 871
const bool __dec = (__basefield != ios_base::oct) && (__basefield != ios_base::hex); 
# 873
const __unsigned_type __u = ((__v > 0) || (!__dec)) ? (__unsigned_type)__v : (-((__unsigned_type)__v)); 
# 876
int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec); 
# 877
__cs += (__ilen - __len); 
# 880
if (__lc->_M_use_grouping) 
# 881
{ 
# 884
_CharT *__cs2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * (__len + 1)) * (2))); 
# 887
_M_group_int((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __io, __cs2 + 2, __cs, __len); 
# 889
__cs = (__cs2 + 2); 
# 890
}  
# 893
if (__builtin_expect(__dec, true)) 
# 894
{ 
# 896
if (__v >= 0) 
# 897
{ 
# 898
if (((bool)((__flags & ios_base::showpos))) && __gnu_cxx::__numeric_traits< _ValueT> ::__is_signed) { 
# 900
((*(--__cs)) = (__lit[__num_base::_S_oplus])), (++__len); }  
# 901
} else { 
# 903
((*(--__cs)) = (__lit[__num_base::_S_ominus])), (++__len); }  
# 904
} else { 
# 905
if (((bool)((__flags & ios_base::showbase))) && __v) 
# 906
{ 
# 907
if (__basefield == ios_base::oct) { 
# 908
((*(--__cs)) = (__lit[__num_base::_S_odigits])), (++__len); } else 
# 910
{ 
# 912
const bool __uppercase = (__flags & ios_base::uppercase); 
# 913
(*(--__cs)) = (__lit[(__num_base::_S_ox) + __uppercase]); 
# 915
(*(--__cs)) = (__lit[__num_base::_S_odigits]); 
# 916
__len += 2; 
# 917
}  
# 918
}  }  
# 921
const streamsize __w = __io.width(); 
# 922
if (__w > (static_cast< streamsize>(__len))) 
# 923
{ 
# 924
_CharT *__cs3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 926
_M_pad(__fill, __w, __io, __cs3, __cs, __len); 
# 927
__cs = __cs3; 
# 928
}  
# 929
__io.width(0); 
# 933
return std::__write(__s, __cs, __len); 
# 934
} 
# 936
template< class _CharT, class _OutIter> void 
# 939
num_put< _CharT, _OutIter> ::_M_group_float(const char *__grouping, size_t __grouping_size, _CharT 
# 940
__sep, const _CharT *__p, _CharT *__new, _CharT *
# 941
__cs, int &__len) const 
# 942
{ 
# 946
const int __declen = (__p) ? __p - __cs : __len; 
# 947
_CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen); 
# 952
int __newlen = __p2 - __new; 
# 953
if (__p) 
# 954
{ 
# 955
char_traits< _CharT> ::copy(__p2, __p, __len - __declen); 
# 956
__newlen += (__len - __declen); 
# 957
}  
# 958
__len = __newlen; 
# 959
} 
# 971
template< class _CharT, class _OutIter> 
# 972
template< class _ValueT> _OutIter 
# 975
num_put< _CharT, _OutIter> ::_M_insert_float(_OutIter __s, ios_base &__io, _CharT __fill, char __mod, _ValueT 
# 976
__v) const 
# 977
{ 
# 978
typedef __numpunct_cache< _CharT>  __cache_type; 
# 979
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 980
const locale &__loc = __io._M_getloc(); 
# 981
const __cache_type *__lc = __uc(__loc); 
# 984
const streamsize __prec = (__io.precision() < (0)) ? 6 : __io.precision(); 
# 986
const int __max_digits = (__gnu_cxx::__numeric_traits< _ValueT> ::__digits10); 
# 990
int __len; 
# 992
char __fbuf[16]; 
# 993
__num_base::_S_format_float(__io, __fbuf, __mod); 
# 997
const bool __use_prec = (((__io.flags()) & ios_base::floatfield)) != ios_base::floatfield; 
# 1002
int __cs_size = (__max_digits * 3); 
# 1003
char *__cs = static_cast< char *>(__builtin_alloca(__cs_size)); 
# 1004
if (__use_prec) { 
# 1005
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1008
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1012
if (__len >= __cs_size) 
# 1013
{ 
# 1014
__cs_size = (__len + 1); 
# 1015
__cs = (static_cast< char *>(__builtin_alloca(__cs_size))); 
# 1016
if (__use_prec) { 
# 1017
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1020
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1022
}  
# 1044
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1046
_CharT *__ws = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __len)); 
# 1048
(__ctype.widen(__cs, __cs + __len, __ws)); 
# 1051
_CharT *__wp = (0); 
# 1052
const char *__p = char_traits< char> ::find(__cs, __len, '.'); 
# 1053
if (__p) 
# 1054
{ 
# 1055
__wp = (__ws + (__p - __cs)); 
# 1056
(*__wp) = (__lc->_M_decimal_point); 
# 1057
}  
# 1062
if ((__lc->_M_use_grouping) && ((__wp || (__len < 3)) || (((__cs[1]) <= ('9')) && ((__cs[2]) <= ('9')) && ((__cs[1]) >= ('0')) && ((__cs[2]) >= ('0'))))) 
# 1065
{ 
# 1068
_CharT *__ws2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * __len) * (2))); 
# 1071
streamsize __off = (0); 
# 1072
if (((__cs[0]) == ('-')) || ((__cs[0]) == ('+'))) 
# 1073
{ 
# 1074
__off = (1); 
# 1075
(__ws2[0]) = (__ws[0]); 
# 1076
__len -= 1; 
# 1077
}  
# 1079
_M_group_float((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __wp, __ws2 + __off, __ws + __off, __len); 
# 1082
__len += __off; 
# 1084
__ws = __ws2; 
# 1085
}  
# 1088
const streamsize __w = __io.width(); 
# 1089
if (__w > (static_cast< streamsize>(__len))) 
# 1090
{ 
# 1091
_CharT *__ws3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 1093
_M_pad(__fill, __w, __io, __ws3, __ws, __len); 
# 1094
__ws = __ws3; 
# 1095
}  
# 1096
__io.width(0); 
# 1100
return std::__write(__s, __ws, __len); 
# 1101
} 
# 1103
template< class _CharT, class _OutIter> _OutIter 
# 1106
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 1107
{ 
# 1108
const ios_base::fmtflags __flags = __io.flags(); 
# 1109
if (((__flags & ios_base::boolalpha)) == 0) 
# 1110
{ 
# 1111
const long __l = __v; 
# 1112
__s = _M_insert_int(__s, __io, __fill, __l); 
# 1113
} else 
# 1115
{ 
# 1116
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1117
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 1118
const locale &__loc = __io._M_getloc(); 
# 1119
const __cache_type *__lc = __uc(__loc); 
# 1121
const _CharT *__name = __v ? __lc->_M_truename : (__lc->_M_falsename); 
# 1123
int __len = __v ? __lc->_M_truename_size : (__lc->_M_falsename_size); 
# 1126
const streamsize __w = __io.width(); 
# 1127
if (__w > (static_cast< streamsize>(__len))) 
# 1128
{ 
# 1129
const streamsize __plen = __w - __len; 
# 1130
_CharT *__ps = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __plen)); 
# 1134
char_traits< _CharT> ::assign(__ps, __plen, __fill); 
# 1135
__io.width(0); 
# 1137
if (((__flags & ios_base::adjustfield)) == ios_base::left) 
# 1138
{ 
# 1139
__s = std::__write(__s, __name, __len); 
# 1140
__s = std::__write(__s, __ps, __plen); 
# 1141
} else 
# 1143
{ 
# 1144
__s = std::__write(__s, __ps, __plen); 
# 1145
__s = std::__write(__s, __name, __len); 
# 1146
}  
# 1147
return __s; 
# 1148
}  
# 1149
__io.width(0); 
# 1150
__s = std::__write(__s, __name, __len); 
# 1151
}  
# 1152
return __s; 
# 1153
} 
# 1155
template< class _CharT, class _OutIter> _OutIter 
# 1158
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 1159
{ return _M_insert_float(__s, __io, __fill, ((char)0), __v); } 
# 1169
template< class _CharT, class _OutIter> _OutIter 
# 1172
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 1173
__v) const 
# 1174
{ return _M_insert_float(__s, __io, __fill, 'L', __v); } 
# 1176
template< class _CharT, class _OutIter> _OutIter 
# 1179
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 1180
__v) const 
# 1181
{ 
# 1182
const ios_base::fmtflags __flags = __io.flags(); 
# 1183
const ios_base::fmtflags __fmt = (~((ios_base::basefield | ios_base::uppercase))); 
# 1185
__io.flags((((__flags & __fmt)) | ((ios_base::hex | ios_base::showbase)))); 
# 1189
typedef __gnu_cxx::__conditional_type< true, unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 1191
__s = _M_insert_int(__s, __io, __fill, reinterpret_cast< _UIntPtrType>(__v)); 
# 1193
__io.flags(__flags); 
# 1194
return __s; 
# 1195
} 
# 1206
template< class _CharT, class _Traits> void 
# 1208
__pad< _CharT, _Traits> ::_S_pad(ios_base &__io, _CharT __fill, _CharT *
# 1209
__news, const _CharT *__olds, streamsize 
# 1210
__newlen, streamsize __oldlen) 
# 1211
{ 
# 1212
const size_t __plen = static_cast< size_t>(__newlen - __oldlen); 
# 1213
const ios_base::fmtflags __adjust = ((__io.flags()) & ios_base::adjustfield); 
# 1216
if (__adjust == ios_base::left) 
# 1217
{ 
# 1218
_Traits::copy(__news, __olds, __oldlen); 
# 1219
_Traits::assign(__news + __oldlen, __plen, __fill); 
# 1220
return; 
# 1221
}  
# 1223
size_t __mod = (0); 
# 1224
if (__adjust == ios_base::internal) 
# 1225
{ 
# 1229
const locale &__loc = __io._M_getloc(); 
# 1230
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1232
if (((__ctype.widen('-')) == (__olds[0])) || ((__ctype.widen('+')) == (__olds[0]))) 
# 1234
{ 
# 1235
(__news[0]) = (__olds[0]); 
# 1236
__mod = (1); 
# 1237
++__news; 
# 1238
} else { 
# 1239
if (((__ctype.widen('0')) == (__olds[0])) && (__oldlen > (1)) && (((__ctype.widen('x')) == (__olds[1])) || ((__ctype.widen('X')) == (__olds[1])))) 
# 1243
{ 
# 1244
(__news[0]) = (__olds[0]); 
# 1245
(__news[1]) = (__olds[1]); 
# 1246
__mod = (2); 
# 1247
__news += 2; 
# 1248
}  }  
# 1250
}  
# 1251
_Traits::assign(__news, __plen, __fill); 
# 1252
_Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod); 
# 1253
} 
# 1255
template< class _CharT> _CharT *
# 1257
__add_grouping(_CharT *__s, _CharT __sep, const char *
# 1258
__gbeg, size_t __gsize, const _CharT *
# 1259
__first, const _CharT *__last) 
# 1260
{ 
# 1261
size_t __idx = (0); 
# 1262
size_t __ctr = (0); 
# 1264
while (((__last - __first) > (__gbeg[__idx])) && ((static_cast< signed char>(__gbeg[__idx])) > 0) && ((__gbeg[__idx]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)) 
# 1267
{ 
# 1268
__last -= (__gbeg[__idx]); 
# 1269
(__idx < (__gsize - (1))) ? ++__idx : (++__ctr); 
# 1270
}  
# 1272
while (__first != __last) { 
# 1273
(*(__s++)) = (*(__first++)); }  
# 1275
while (__ctr--) 
# 1276
{ 
# 1277
(*(__s++)) = __sep; 
# 1278
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1279
(*(__s++)) = (*(__first++)); }  
# 1280
}  
# 1282
while (__idx--) 
# 1283
{ 
# 1284
(*(__s++)) = __sep; 
# 1285
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1286
(*(__s++)) = (*(__first++)); }  
# 1287
}  
# 1289
return __s; 
# 1290
} 
# 1295
extern template class __cxx11::numpunct< char> ;
# 1296
extern template class __cxx11::numpunct_byname< char> ;
# 1297
extern template class num_get< char, istreambuf_iterator< char, char_traits< char> > > ;
# 1298
extern template class num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
# 1301
extern template const ctype< char>  &use_facet< ctype< char> > (const locale &);
# 1305
extern template const __cxx11::numpunct< char>  &use_facet< __cxx11::numpunct< char> > (const locale &);
# 1309
extern template const num_put< char, ostreambuf_iterator< char, char_traits< char> > >  &use_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1313
extern template const num_get< char, istreambuf_iterator< char, char_traits< char> > >  &use_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &);
# 1317
extern template bool has_facet< ctype< char> > (const locale &) throw();
# 1321
extern template bool has_facet< __cxx11::numpunct< char> > (const locale &) throw();
# 1325
extern template bool has_facet< num_put< char, ostreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1329
extern template bool has_facet< num_get< char, istreambuf_iterator< char, char_traits< char> > > > (const locale &) throw();
# 1334
extern template class __cxx11::numpunct< wchar_t> ;
# 1335
extern template class __cxx11::numpunct_byname< wchar_t> ;
# 1336
extern template class num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1337
extern template class num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > ;
# 1340
extern template const ctype< wchar_t>  &use_facet< ctype< wchar_t> > (const locale &);
# 1344
extern template const __cxx11::numpunct< wchar_t>  &use_facet< __cxx11::numpunct< wchar_t> > (const locale &);
# 1348
extern template const num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1352
extern template const num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > >  &use_facet< num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &);
# 1356
extern template bool has_facet< ctype< wchar_t> > (const locale &) throw();
# 1360
extern template bool has_facet< __cxx11::numpunct< wchar_t> > (const locale &) throw();
# 1364
extern template bool has_facet< num_put< wchar_t, ostreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1368
extern template bool has_facet< num_get< wchar_t, istreambuf_iterator< wchar_t, char_traits< wchar_t> > > > (const locale &) throw();
# 1375
}
# 41 "/usr/include/c++/5/bits/basic_ios.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Facet> inline const _Facet &
# 47
__check_facet(const _Facet *__f) 
# 48
{ 
# 49
if (!__f) { 
# 50
__throw_bad_cast(); }  
# 51
return *__f; 
# 52
} 
# 66
template< class _CharT, class _Traits> 
# 67
class basic_ios : public ios_base { 
# 76
public: typedef _CharT char_type; 
# 77
typedef typename _Traits::int_type int_type; 
# 78
typedef typename _Traits::pos_type pos_type; 
# 79
typedef typename _Traits::off_type off_type; 
# 80
typedef _Traits traits_type; 
# 87
typedef ctype< _CharT>  __ctype_type; 
# 89
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 91
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 96
protected: basic_ostream< _CharT, _Traits>  *_M_tie; 
# 97
mutable char_type _M_fill; 
# 98
mutable bool _M_fill_init; 
# 99
basic_streambuf< _CharT, _Traits>  *_M_streambuf; 
# 102
const __ctype_type *_M_ctype; 
# 104
const __num_put_type *_M_num_put; 
# 106
const __num_get_type *_M_num_get; 
# 120
public: operator void *() const 
# 121
{ return this->fail() ? 0 : (const_cast< basic_ios *>(this)); } 
# 125
bool operator!() const 
# 126
{ return this->fail(); } 
# 137
iostate rdstate() const 
# 138
{ return ios_base::_M_streambuf_state; } 
# 148
void clear(iostate __state = goodbit); 
# 157
void setstate(iostate __state) 
# 158
{ this->clear(((this->rdstate()) | __state)); } 
# 164
void _M_setstate(iostate __state) 
# 165
{ 
# 168
((ios_base::_M_streambuf_state) |= __state); 
# 169
if (((this->exceptions()) & __state)) { 
# 170
throw; }  
# 171
} 
# 180
bool good() const 
# 181
{ return (this->rdstate()) == 0; } 
# 190
bool eof() const 
# 191
{ return (((this->rdstate()) & eofbit)) != 0; } 
# 201
bool fail() const 
# 202
{ return (((this->rdstate()) & ((badbit | failbit)))) != 0; } 
# 211
bool bad() const 
# 212
{ return (((this->rdstate()) & badbit)) != 0; } 
# 222
iostate exceptions() const 
# 223
{ return ios_base::_M_exception; } 
# 257
void exceptions(iostate __except) 
# 258
{ 
# 259
(ios_base::_M_exception) = __except; 
# 260
this->clear(ios_base::_M_streambuf_state); 
# 261
} 
# 270
explicit basic_ios(basic_streambuf< _CharT, _Traits>  *__sb) : ios_base(), _M_tie((0)), _M_fill(), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 273
{ this->init(__sb); } 
# 282
virtual ~basic_ios() { } 
# 295
basic_ostream< _CharT, _Traits>  *tie() const 
# 296
{ return _M_tie; } 
# 307
basic_ostream< _CharT, _Traits>  *tie(basic_ostream< _CharT, _Traits>  *__tiestr) 
# 308
{ 
# 309
basic_ostream< _CharT, _Traits>  *__old = _M_tie; 
# 310
(_M_tie) = __tiestr; 
# 311
return __old; 
# 312
} 
# 321
basic_streambuf< _CharT, _Traits>  *rdbuf() const 
# 322
{ return _M_streambuf; } 
# 347
basic_streambuf< _CharT, _Traits>  *rdbuf(basic_streambuf< _CharT, _Traits>  * __sb); 
# 361
basic_ios &copyfmt(const basic_ios & __rhs); 
# 370
char_type fill() const 
# 371
{ 
# 372
if (!(_M_fill_init)) 
# 373
{ 
# 374
(_M_fill) = this->widen(' '); 
# 375
(_M_fill_init) = true; 
# 376
}  
# 377
return _M_fill; 
# 378
} 
# 390
char_type fill(char_type __ch) 
# 391
{ 
# 392
char_type __old = (this->fill()); 
# 393
(_M_fill) = __ch; 
# 394
return __old; 
# 395
} 
# 410
locale imbue(const locale & __loc); 
# 430
char narrow(char_type __c, char __dfault) const 
# 431
{ return (__check_facet(_M_ctype).narrow(__c, __dfault)); } 
# 449
char_type widen(char __c) const 
# 450
{ return (__check_facet(_M_ctype).widen(__c)); } 
# 460
protected: basic_ios() : ios_base(), _M_tie((0)), _M_fill(char_type()), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 463
{ } 
# 472
void init(basic_streambuf< _CharT, _Traits>  * __sb); 
# 510
void _M_cache_locale(const locale & __loc); 
# 511
}; 
# 514
}
# 35 "/usr/include/c++/5/bits/basic_ios.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< class _CharT, class _Traits> void 
# 41
basic_ios< _CharT, _Traits> ::clear(iostate __state) 
# 42
{ 
# 43
if ((this->rdbuf())) { 
# 44
(ios_base::_M_streambuf_state) = __state; } else { 
# 46
(ios_base::_M_streambuf_state) = ((__state | badbit)); }  
# 47
if (((this->exceptions()) & (this->rdstate()))) { 
# 48
__throw_ios_failure("basic_ios::clear"); }  
# 49
} 
# 51
template< class _CharT, class _Traits> basic_streambuf< _CharT, _Traits>  *
# 53
basic_ios< _CharT, _Traits> ::rdbuf(basic_streambuf< _CharT, _Traits>  *__sb) 
# 54
{ 
# 55
basic_streambuf< _CharT, _Traits>  *__old = _M_streambuf; 
# 56
(_M_streambuf) = __sb; 
# 57
this->clear(); 
# 58
return __old; 
# 59
} 
# 61
template< class _CharT, class _Traits> basic_ios< _CharT, _Traits>  &
# 63
basic_ios< _CharT, _Traits> ::copyfmt(const basic_ios &__rhs) 
# 64
{ 
# 67
if (this != (&__rhs)) 
# 68
{ 
# 73
_Words *__words = ((__rhs.ios_base::_M_word_size) <= (_S_local_word_size)) ? ios_base::_M_local_word : (new _Words [__rhs.ios_base::_M_word_size]); 
# 77
_Callback_list *__cb = __rhs.ios_base::_M_callbacks; 
# 78
if (__cb) { 
# 79
__cb->_M_add_reference(); }  
# 80
this->ios_base::_M_call_callbacks(erase_event); 
# 81
if ((ios_base::_M_word) != (ios_base::_M_local_word)) 
# 82
{ 
# 83
delete [] (ios_base::_M_word); 
# 84
(ios_base::_M_word) = (0); 
# 85
}  
# 86
this->ios_base::_M_dispose_callbacks(); 
# 89
(ios_base::_M_callbacks) = __cb; 
# 90
for (int __i = 0; __i < (__rhs.ios_base::_M_word_size); ++__i) { 
# 91
(__words[__i]) = ((__rhs.ios_base::_M_word)[__i]); }  
# 92
(ios_base::_M_word) = __words; 
# 93
(ios_base::_M_word_size) = (__rhs.ios_base::_M_word_size); 
# 95
this->flags(__rhs.flags()); 
# 96
this->width(__rhs.width()); 
# 97
this->precision(__rhs.precision()); 
# 98
(this->tie((__rhs.tie()))); 
# 99
(this->fill((__rhs.fill()))); 
# 100
((ios_base::_M_ios_locale) = (__rhs.getloc())); 
# 101
_M_cache_locale(ios_base::_M_ios_locale); 
# 103
this->ios_base::_M_call_callbacks(copyfmt_event); 
# 106
this->exceptions(__rhs.exceptions()); 
# 107
}  
# 108
return *this; 
# 109
} 
# 112
template< class _CharT, class _Traits> locale 
# 114
basic_ios< _CharT, _Traits> ::imbue(const locale &__loc) 
# 115
{ 
# 116
locale __old(this->getloc()); 
# 117
this->ios_base::imbue(__loc); 
# 118
_M_cache_locale(__loc); 
# 119
if ((this->rdbuf()) != 0) { 
# 120
((this->rdbuf())->pubimbue(__loc)); }  
# 121
return __old; 
# 122
} 
# 124
template< class _CharT, class _Traits> void 
# 126
basic_ios< _CharT, _Traits> ::init(basic_streambuf< _CharT, _Traits>  *__sb) 
# 127
{ 
# 129
this->ios_base::_M_init(); 
# 132
_M_cache_locale(ios_base::_M_ios_locale); 
# 146
(_M_fill) = _CharT(); 
# 147
(_M_fill_init) = false; 
# 149
(_M_tie) = 0; 
# 150
(ios_base::_M_exception) = goodbit; 
# 151
(_M_streambuf) = __sb; 
# 152
(ios_base::_M_streambuf_state) = ((__sb) ? goodbit : badbit); 
# 153
} 
# 155
template< class _CharT, class _Traits> void 
# 157
basic_ios< _CharT, _Traits> ::_M_cache_locale(const locale &__loc) 
# 158
{ 
# 159
if (__builtin_expect(has_facet< __ctype_type> (__loc), true)) { 
# 160
(_M_ctype) = (&use_facet< __ctype_type> (__loc)); } else { 
# 162
(_M_ctype) = 0; }  
# 164
if (__builtin_expect(has_facet< __num_put_type> (__loc), true)) { 
# 165
(_M_num_put) = (&use_facet< __num_put_type> (__loc)); } else { 
# 167
(_M_num_put) = 0; }  
# 169
if (__builtin_expect(has_facet< __num_get_type> (__loc), true)) { 
# 170
(_M_num_get) = (&use_facet< __num_get_type> (__loc)); } else { 
# 172
(_M_num_get) = 0; }  
# 173
} 
# 178
extern template class basic_ios< char, char_traits< char> > ;
# 181
extern template class basic_ios< wchar_t, char_traits< wchar_t> > ;
# 186
}
# 41 "/usr/include/c++/5/ostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57
template< class _CharT, class _Traits> 
# 58
class basic_ostream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef ::std::basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_ostream __ostream_type; 
# 73
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 84
explicit basic_ostream(__streambuf_type *__sb) 
# 85
{ (this->init(__sb)); } 
# 93
virtual ~basic_ostream() { } 
# 96
class sentry; 
# 97
friend class sentry; 
# 108
__ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) 
# 109
{ 
# 113
return __pf(*this); 
# 114
} 
# 117
__ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &)) 
# 118
{ 
# 122
__pf(*this); 
# 123
return *this; 
# 124
} 
# 127
__ostream_type &operator<<(::std::ios_base &(*__pf)(::std::ios_base &)) 
# 128
{ 
# 132
__pf(*this); 
# 133
return *this; 
# 134
} 
# 166
__ostream_type &operator<<(long __n) 
# 167
{ return _M_insert(__n); } 
# 170
__ostream_type &operator<<(unsigned long __n) 
# 171
{ return _M_insert(__n); } 
# 174
__ostream_type &operator<<(bool __n) 
# 175
{ return _M_insert(__n); } 
# 178
__ostream_type &operator<<(short __n); 
# 181
__ostream_type &operator<<(unsigned short __n) 
# 182
{ 
# 185
return _M_insert(static_cast< unsigned long>(__n)); 
# 186
} 
# 189
__ostream_type &operator<<(int __n); 
# 192
__ostream_type &operator<<(unsigned __n) 
# 193
{ 
# 196
return _M_insert(static_cast< unsigned long>(__n)); 
# 197
} 
# 201
__ostream_type &operator<<(long long __n) 
# 202
{ return _M_insert(__n); } 
# 205
__ostream_type &operator<<(unsigned long long __n) 
# 206
{ return _M_insert(__n); } 
# 220
__ostream_type &operator<<(double __f) 
# 221
{ return _M_insert(__f); } 
# 224
__ostream_type &operator<<(float __f) 
# 225
{ 
# 228
return _M_insert(static_cast< double>(__f)); 
# 229
} 
# 232
__ostream_type &operator<<(long double __f) 
# 233
{ return _M_insert(__f); } 
# 245
__ostream_type &operator<<(const void *__p) 
# 246
{ return _M_insert(__p); } 
# 270
__ostream_type &operator<<(__streambuf_type * __sb); 
# 303
__ostream_type &put(char_type __c); 
# 311
void _M_write(const char_type *__s, ::std::streamsize __n) 
# 312
{ 
# 313
const ::std::streamsize __put = ((this->rdbuf())->sputn(__s, __n)); 
# 314
if (__put != __n) { 
# 315
(this->setstate(ios_base::badbit)); }  
# 316
} 
# 335
__ostream_type &write(const char_type * __s, ::std::streamsize __n); 
# 348
__ostream_type &flush(); 
# 358
pos_type tellp(); 
# 369
__ostream_type &seekp(pos_type); 
# 381
__ostream_type &seekp(off_type, ::std::ios_base::seekdir); 
# 384
protected: basic_ostream() 
# 385
{ (this->init(0)); } 
# 413
template< class _ValueT> __ostream_type &_M_insert(_ValueT __v); 
# 416
}; 
# 425
template< class _CharT, class _Traits> 
# 426
class basic_ostream< _CharT, _Traits> ::sentry { 
# 429
bool _M_ok; 
# 430
basic_ostream &_M_os; 
# 445
public: explicit sentry(basic_ostream & __os); 
# 454
~sentry() 
# 455
{ 
# 457
if (((bool)(((_M_os).flags()) & ios_base::unitbuf)) && (!uncaught_exception())) 
# 458
{ 
# 460
if (((_M_os).rdbuf()) && ((((_M_os).rdbuf())->pubsync()) == (-1))) { 
# 461
((_M_os).setstate(ios_base::badbit)); }  
# 462
}  
# 463
} 
# 475
operator bool() const 
# 476
{ return _M_ok; } 
# 477
}; 
# 495
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 497
operator<<(basic_ostream< _CharT, _Traits>  &__out, _CharT __c) 
# 498
{ return __ostream_insert(__out, &__c, 1); } 
# 500
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 502
operator<<(basic_ostream< _CharT, _Traits>  &__out, char __c) 
# 503
{ return __out << (__out.widen(__c)); } 
# 506
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 508
operator<<(basic_ostream< char, _Traits>  &__out, char __c) 
# 509
{ return __ostream_insert(__out, &__c, 1); } 
# 512
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 514
operator<<(basic_ostream< char, _Traits>  &__out, signed char __c) 
# 515
{ return __out << (static_cast< char>(__c)); } 
# 517
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 519
operator<<(basic_ostream< char, _Traits>  &__out, unsigned char __c) 
# 520
{ return __out << (static_cast< char>(__c)); } 
# 537
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 539
operator<<(basic_ostream< _CharT, _Traits>  &__out, const _CharT *__s) 
# 540
{ 
# 541
if (!__s) { 
# 542
(__out.setstate(ios_base::badbit)); } else { 
# 544
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 546
return __out; 
# 547
} 
# 549
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __out, const char * __s); 
# 554
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 556
operator<<(basic_ostream< char, _Traits>  &__out, const char *__s) 
# 557
{ 
# 558
if (!__s) { 
# 559
(__out.setstate(ios_base::badbit)); } else { 
# 561
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 563
return __out; 
# 564
} 
# 567
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 569
operator<<(basic_ostream< char, _Traits>  &__out, const signed char *__s) 
# 570
{ return __out << (reinterpret_cast< const char *>(__s)); } 
# 572
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 574
operator<<(basic_ostream< char, _Traits>  &__out, const unsigned char *__s) 
# 575
{ return __out << (reinterpret_cast< const char *>(__s)); } 
# 588
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 590
endl(basic_ostream< _CharT, _Traits>  &__os) 
# 591
{ return flush((__os.put((__os.widen('\n'))))); } 
# 600
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 602
ends(basic_ostream< _CharT, _Traits>  &__os) 
# 603
{ return (__os.put(_CharT())); } 
# 610
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 612
flush(basic_ostream< _CharT, _Traits>  &__os) 
# 613
{ return (__os.flush()); } 
# 636
}
# 41 "/usr/include/c++/5/bits/ostream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_ostream< _CharT, _Traits> ::sentry::sentry(basic_ostream &__os) : _M_ok(false), _M_os(__os) 
# 49
{ 
# 51
if ((__os.tie()) && (__os.good())) { 
# 52
((__os.tie())->flush()); }  
# 54
if ((__os.good())) { 
# 55
(_M_ok) = true; } else { 
# 57
(__os.setstate(ios_base::failbit)); }  
# 58
} 
# 60
template< class _CharT, class _Traits> 
# 61
template< class _ValueT> basic_ostream< _CharT, _Traits>  &
# 64
basic_ostream< _CharT, _Traits> ::_M_insert(_ValueT __v) 
# 65
{ 
# 66
sentry __cerb(*this); 
# 67
if (__cerb) 
# 68
{ 
# 69
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 70
try 
# 71
{ 
# 72
const __num_put_type &__np = __check_facet((this->_M_num_put)); 
# 73
if (((__np.put(*this, *this, (this->fill()), __v)).failed())) { 
# 74
(__err |= ::std::ios_base::badbit); }  
# 75
} 
# 76
catch (::__cxxabiv1::__forced_unwind &) 
# 77
{ 
# 78
(this->_M_setstate(ios_base::badbit)); 
# 79
throw; 
# 80
} 
# 81
catch (...) 
# 82
{ (this->_M_setstate(ios_base::badbit)); }  
# 83
if (__err) { 
# 84
(this->setstate(__err)); }  
# 85
}  
# 86
return *this; 
# 87
} 
# 89
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 92
basic_ostream< _CharT, _Traits> ::operator<<(short __n) 
# 93
{ 
# 96
const ::std::ios_base::fmtflags __fmt = (this->flags()) & ios_base::basefield; 
# 97
if ((__fmt == ::std::ios_base::oct) || (__fmt == ::std::ios_base::hex)) { 
# 98
return _M_insert(static_cast< long>(static_cast< unsigned short>(__n))); } else { 
# 100
return _M_insert(static_cast< long>(__n)); }  
# 101
} 
# 103
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 106
basic_ostream< _CharT, _Traits> ::operator<<(int __n) 
# 107
{ 
# 110
const ::std::ios_base::fmtflags __fmt = (this->flags()) & ios_base::basefield; 
# 111
if ((__fmt == ::std::ios_base::oct) || (__fmt == ::std::ios_base::hex)) { 
# 112
return _M_insert(static_cast< long>(static_cast< unsigned>(__n))); } else { 
# 114
return _M_insert(static_cast< long>(__n)); }  
# 115
} 
# 117
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 120
basic_ostream< _CharT, _Traits> ::operator<<(__streambuf_type *__sbin) 
# 121
{ 
# 122
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 123
sentry __cerb(*this); 
# 124
if (__cerb && __sbin) 
# 125
{ 
# 126
try 
# 127
{ 
# 128
if (!__copy_streambufs(__sbin, (this->rdbuf()))) { 
# 129
(__err |= ::std::ios_base::failbit); }  
# 130
} 
# 131
catch (::__cxxabiv1::__forced_unwind &) 
# 132
{ 
# 133
(this->_M_setstate(ios_base::badbit)); 
# 134
throw; 
# 135
} 
# 136
catch (...) 
# 137
{ (this->_M_setstate(ios_base::failbit)); }  
# 138
} else { 
# 139
if (!__sbin) { 
# 140
(__err |= ::std::ios_base::badbit); }  }  
# 141
if (__err) { 
# 142
(this->setstate(__err)); }  
# 143
return *this; 
# 144
} 
# 146
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 149
basic_ostream< _CharT, _Traits> ::put(char_type __c) 
# 150
{ 
# 157
sentry __cerb(*this); 
# 158
if (__cerb) 
# 159
{ 
# 160
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 161
try 
# 162
{ 
# 163
const int_type __put = ((this->rdbuf())->sputc(__c)); 
# 164
if (traits_type::eq_int_type(__put, traits_type::eof())) { 
# 165
(__err |= ::std::ios_base::badbit); }  
# 166
} 
# 167
catch (::__cxxabiv1::__forced_unwind &) 
# 168
{ 
# 169
(this->_M_setstate(ios_base::badbit)); 
# 170
throw; 
# 171
} 
# 172
catch (...) 
# 173
{ (this->_M_setstate(ios_base::badbit)); }  
# 174
if (__err) { 
# 175
(this->setstate(__err)); }  
# 176
}  
# 177
return *this; 
# 178
} 
# 180
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 183
basic_ostream< _CharT, _Traits> ::write(const _CharT *__s, ::std::streamsize __n) 
# 184
{ 
# 192
sentry __cerb(*this); 
# 193
if (__cerb) 
# 194
{ 
# 195
try 
# 196
{ _M_write(__s, __n); } 
# 197
catch (::__cxxabiv1::__forced_unwind &) 
# 198
{ 
# 199
(this->_M_setstate(ios_base::badbit)); 
# 200
throw; 
# 201
} 
# 202
catch (...) 
# 203
{ (this->_M_setstate(ios_base::badbit)); }  
# 204
}  
# 205
return *this; 
# 206
} 
# 208
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::__ostream_type &
# 211
basic_ostream< _CharT, _Traits> ::flush() 
# 212
{ 
# 216
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 217
try 
# 218
{ 
# 219
if ((this->rdbuf()) && (((this->rdbuf())->pubsync()) == (-1))) { 
# 220
(__err |= ::std::ios_base::badbit); }  
# 221
} 
# 222
catch (::__cxxabiv1::__forced_unwind &) 
# 223
{ 
# 224
(this->_M_setstate(ios_base::badbit)); 
# 225
throw; 
# 226
} 
# 227
catch (...) 
# 228
{ (this->_M_setstate(ios_base::badbit)); }  
# 229
if (__err) { 
# 230
(this->setstate(__err)); }  
# 231
return *this; 
# 232
} 
# 234
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::pos_type 
# 237
basic_ostream< _CharT, _Traits> ::tellp() 
# 238
{ 
# 239
pos_type __ret = ((pos_type)(-1)); 
# 240
try 
# 241
{ 
# 242
if (!(this->fail())) { 
# 243
__ret = ((this->rdbuf())->pubseekoff(0, ios_base::cur, ios_base::out)); }  
# 244
} 
# 245
catch (::__cxxabiv1::__forced_unwind &) 
# 246
{ 
# 247
(this->_M_setstate(ios_base::badbit)); 
# 248
throw; 
# 249
} 
# 250
catch (...) 
# 251
{ (this->_M_setstate(ios_base::badbit)); }  
# 252
return __ret; 
# 253
} 
# 255
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 258
basic_ostream< _CharT, _Traits> ::seekp(pos_type __pos) 
# 259
{ 
# 260
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 261
try 
# 262
{ 
# 263
if (!(this->fail())) 
# 264
{ 
# 267
const pos_type __p = ((this->rdbuf())->pubseekpos(__pos, ios_base::out)); 
# 271
if (__p == ((pos_type)((off_type)(-1)))) { 
# 272
(__err |= ::std::ios_base::failbit); }  
# 273
}  
# 274
} 
# 275
catch (::__cxxabiv1::__forced_unwind &) 
# 276
{ 
# 277
(this->_M_setstate(ios_base::badbit)); 
# 278
throw; 
# 279
} 
# 280
catch (...) 
# 281
{ (this->_M_setstate(ios_base::badbit)); }  
# 282
if (__err) { 
# 283
(this->setstate(__err)); }  
# 284
return *this; 
# 285
} 
# 287
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 290
basic_ostream< _CharT, _Traits> ::seekp(off_type __off, ::std::ios_base::seekdir __dir) 
# 291
{ 
# 292
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 293
try 
# 294
{ 
# 295
if (!(this->fail())) 
# 296
{ 
# 299
const pos_type __p = ((this->rdbuf())->pubseekoff(__off, __dir, ios_base::out)); 
# 303
if (__p == ((pos_type)((off_type)(-1)))) { 
# 304
(__err |= ::std::ios_base::failbit); }  
# 305
}  
# 306
} 
# 307
catch (::__cxxabiv1::__forced_unwind &) 
# 308
{ 
# 309
(this->_M_setstate(ios_base::badbit)); 
# 310
throw; 
# 311
} 
# 312
catch (...) 
# 313
{ (this->_M_setstate(ios_base::badbit)); }  
# 314
if (__err) { 
# 315
(this->setstate(__err)); }  
# 316
return *this; 
# 317
} 
# 319
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 321
operator<<(basic_ostream< _CharT, _Traits>  &__out, const char *__s) 
# 322
{ 
# 323
if (!__s) { 
# 324
(__out.setstate(ios_base::badbit)); } else 
# 326
{ 
# 329
const size_t __clen = char_traits< char> ::length(__s); 
# 330
try 
# 331
{ 
# 332
struct __ptr_guard { 
# 334
_CharT *__p; 
# 335
__ptr_guard(_CharT *__ip) : __p(__ip) { } 
# 336
~__ptr_guard() { delete [] (__p); } 
# 337
_CharT *__get() { return __p; } 
# 338
} __pg(new _CharT [__clen]); 
# 340
_CharT *__ws = __pg.__get(); 
# 341
for (size_t __i = (0); __i < __clen; ++__i) { 
# 342
(__ws[__i]) = (__out.widen(__s[__i])); }  
# 343
__ostream_insert(__out, __ws, __clen); 
# 344
} 
# 345
catch (__cxxabiv1::__forced_unwind &) 
# 346
{ 
# 347
(__out._M_setstate(ios_base::badbit)); 
# 348
throw; 
# 349
} 
# 350
catch (...) 
# 351
{ (__out._M_setstate(ios_base::badbit)); }  
# 352
}  
# 353
return __out; 
# 354
} 
# 359
extern template class basic_ostream< char, char_traits< char> > ;
# 360
extern template basic_ostream< char, char_traits< char> >  &endl(basic_ostream< char, char_traits< char> >  & __os);
# 361
extern template basic_ostream< char, char_traits< char> >  &ends(basic_ostream< char, char_traits< char> >  & __os);
# 362
extern template basic_ostream< char, char_traits< char> >  &flush(basic_ostream< char, char_traits< char> >  & __os);
# 363
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, char __c);
# 364
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, unsigned char __c);
# 365
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, signed char __c);
# 366
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const char * __s);
# 367
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const unsigned char * __s);
# 368
extern template basic_ostream< char, char_traits< char> >  &operator<<(basic_ostream< char, char_traits< char> >  & __out, const signed char * __s);
# 370
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long __v);
# 371
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(unsigned long __v);
# 372
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(bool __v);
# 374
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long long __v);
# 375
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(unsigned long long __v);
# 377
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(double __v);
# 378
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(long double __v);
# 379
extern template basic_ostream< char, char_traits< char> > ::__ostream_type &basic_ostream< char, char_traits< char> > ::_M_insert(const void * __v);
# 382
extern template class basic_ostream< wchar_t, char_traits< wchar_t> > ;
# 383
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &endl(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 384
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &ends(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 385
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &flush(basic_ostream< wchar_t, char_traits< wchar_t> >  & __os);
# 386
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, wchar_t __c);
# 387
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, char __c);
# 388
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, const wchar_t * __s);
# 389
extern template basic_ostream< wchar_t, char_traits< wchar_t> >  &operator<<(basic_ostream< wchar_t, char_traits< wchar_t> >  & __out, const char * __s);
# 391
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long __v);
# 392
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(unsigned long __v);
# 393
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(bool __v);
# 395
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long long __v);
# 396
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(unsigned long long __v);
# 398
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(double __v);
# 399
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(long double __v);
# 400
extern template basic_ostream< wchar_t, char_traits< wchar_t> > ::__ostream_type &basic_ostream< wchar_t, char_traits< wchar_t> > ::_M_insert(const void * __v);
# 405
}
# 41 "/usr/include/c++/5/istream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57
template< class _CharT, class _Traits> 
# 58
class basic_istream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef ::std::basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_istream __istream_type; 
# 73
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 82
protected: ::std::streamsize _M_gcount; 
# 93
public: explicit basic_istream(__streambuf_type *__sb) : _M_gcount(((::std::streamsize)0)) 
# 95
{ (this->init(__sb)); } 
# 103
virtual ~basic_istream() 
# 104
{ (_M_gcount) = ((::std::streamsize)0); } 
# 107
class sentry; 
# 108
friend class sentry; 
# 120
__istream_type &operator>>(__istream_type &(*__pf)(__istream_type &)) 
# 121
{ return __pf(*this); } 
# 124
__istream_type &operator>>(__ios_type &(*__pf)(__ios_type &)) 
# 125
{ 
# 126
__pf(*this); 
# 127
return *this; 
# 128
} 
# 131
__istream_type &operator>>(::std::ios_base &(*__pf)(::std::ios_base &)) 
# 132
{ 
# 133
__pf(*this); 
# 134
return *this; 
# 135
} 
# 168
__istream_type &operator>>(bool &__n) 
# 169
{ return _M_extract(__n); } 
# 172
__istream_type &operator>>(short & __n); 
# 175
__istream_type &operator>>(unsigned short &__n) 
# 176
{ return _M_extract(__n); } 
# 179
__istream_type &operator>>(int & __n); 
# 182
__istream_type &operator>>(unsigned &__n) 
# 183
{ return _M_extract(__n); } 
# 186
__istream_type &operator>>(long &__n) 
# 187
{ return _M_extract(__n); } 
# 190
__istream_type &operator>>(unsigned long &__n) 
# 191
{ return _M_extract(__n); } 
# 195
__istream_type &operator>>(long long &__n) 
# 196
{ return _M_extract(__n); } 
# 199
__istream_type &operator>>(unsigned long long &__n) 
# 200
{ return _M_extract(__n); } 
# 214
__istream_type &operator>>(float &__f) 
# 215
{ return _M_extract(__f); } 
# 218
__istream_type &operator>>(double &__f) 
# 219
{ return _M_extract(__f); } 
# 222
__istream_type &operator>>(long double &__f) 
# 223
{ return _M_extract(__f); } 
# 235
__istream_type &operator>>(void *&__p) 
# 236
{ return _M_extract(__p); } 
# 259
__istream_type &operator>>(__streambuf_type * __sb); 
# 269
::std::streamsize gcount() const 
# 270
{ return _M_gcount; } 
# 302
int_type get(); 
# 316
__istream_type &get(char_type & __c); 
# 343
__istream_type &get(char_type * __s, ::std::streamsize __n, char_type __delim); 
# 354
__istream_type &get(char_type *__s, ::std::streamsize __n) 
# 355
{ return (this->get(__s, __n, (this->widen('\n')))); } 
# 377
__istream_type &get(__streambuf_type & __sb, char_type __delim); 
# 387
__istream_type &get(__streambuf_type &__sb) 
# 388
{ return (this->get(__sb, (this->widen('\n')))); } 
# 416
__istream_type &getline(char_type * __s, ::std::streamsize __n, char_type __delim); 
# 427
__istream_type &getline(char_type *__s, ::std::streamsize __n) 
# 428
{ return (this->getline(__s, __n, (this->widen('\n')))); } 
# 451
__istream_type &ignore(::std::streamsize __n, int_type __delim); 
# 454
__istream_type &ignore(::std::streamsize __n); 
# 457
__istream_type &ignore(); 
# 468
int_type peek(); 
# 486
__istream_type &read(char_type * __s, ::std::streamsize __n); 
# 505
::std::streamsize readsome(char_type * __s, ::std::streamsize __n); 
# 522
__istream_type &putback(char_type __c); 
# 538
__istream_type &unget(); 
# 556
int sync(); 
# 571
pos_type tellg(); 
# 586
__istream_type &seekg(pos_type); 
# 602
__istream_type &seekg(off_type, ::std::ios_base::seekdir); 
# 606
protected: basic_istream() : _M_gcount(((::std::streamsize)0)) 
# 608
{ (this->init(0)); } 
# 639
template< class _ValueT> __istream_type &_M_extract(_ValueT & __v); 
# 642
}; 
# 648
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 653
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::ignore(streamsize __n); 
# 658
template<> basic_istream< char, char_traits< char> >  &basic_istream< char, char_traits< char> > ::ignore(streamsize __n, int_type __delim); 
# 664
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 669
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::ignore(streamsize __n); 
# 674
template<> basic_istream< wchar_t, char_traits< wchar_t> >  &basic_istream< wchar_t, char_traits< wchar_t> > ::ignore(streamsize __n, int_type __delim); 
# 685
template< class _CharT, class _Traits> 
# 686
class basic_istream< _CharT, _Traits> ::sentry { 
# 689
bool _M_ok; 
# 693
public: typedef _Traits traits_type; 
# 694
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 695
typedef basic_istream __istream_type; 
# 696
typedef typename ::std::basic_istream< _CharT, _Traits> ::__ctype_type __ctype_type; 
# 697
typedef typename _Traits::int_type __int_type; 
# 722
explicit sentry(basic_istream & __is, bool __noskipws = false); 
# 734
operator bool() const 
# 735
{ return _M_ok; } 
# 736
}; 
# 750
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT & __c); 
# 754
template< class _Traits> inline basic_istream< char, _Traits>  &
# 756
operator>>(basic_istream< char, _Traits>  &__in, unsigned char &__c) 
# 757
{ return __in >> (reinterpret_cast< char &>(__c)); } 
# 759
template< class _Traits> inline basic_istream< char, _Traits>  &
# 761
operator>>(basic_istream< char, _Traits>  &__in, signed char &__c) 
# 762
{ return __in >> (reinterpret_cast< char &>(__c)); } 
# 792
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT * __s); 
# 799
template<> basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, char * __s); 
# 801
template< class _Traits> inline basic_istream< char, _Traits>  &
# 803
operator>>(basic_istream< char, _Traits>  &__in, unsigned char *__s) 
# 804
{ return __in >> (reinterpret_cast< char *>(__s)); } 
# 806
template< class _Traits> inline basic_istream< char, _Traits>  &
# 808
operator>>(basic_istream< char, _Traits>  &__in, signed char *__s) 
# 809
{ return __in >> (reinterpret_cast< char *>(__s)); } 
# 823
template< class _CharT, class _Traits> 
# 824
class basic_iostream : public basic_istream< _CharT, _Traits> , public basic_ostream< _CharT, _Traits>  { 
# 832
public: typedef _CharT char_type; 
# 833
typedef typename _Traits::int_type int_type; 
# 834
typedef typename _Traits::pos_type pos_type; 
# 835
typedef typename _Traits::off_type off_type; 
# 836
typedef _Traits traits_type; 
# 839
typedef ::std::basic_istream< _CharT, _Traits>  __istream_type; 
# 840
typedef ::std::basic_ostream< _CharT, _Traits>  __ostream_type; 
# 849
explicit basic_iostream(basic_streambuf< _CharT, _Traits>  *__sb) : __istream_type(__sb), __ostream_type(__sb) 
# 850
{ } 
# 856
virtual ~basic_iostream() { } 
# 859
protected: basic_iostream() : __istream_type(), __ostream_type() 
# 860
{ } 
# 884
}; 
# 906
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &ws(basic_istream< _CharT, _Traits>  & __is); 
# 932
}
# 41 "/usr/include/c++/5/bits/istream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_istream< _CharT, _Traits> ::sentry::sentry(basic_istream &__in, bool __noskip) : _M_ok(false) 
# 48
{ 
# 49
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 50
if ((__in.good())) 
# 51
{ 
# 52
if ((__in.tie())) { 
# 53
((__in.tie())->flush()); }  
# 54
if ((!__noskip) && ((bool)((__in.flags()) & ios_base::skipws))) 
# 55
{ 
# 56
const __int_type __eof = traits_type::eof(); 
# 57
__streambuf_type *__sb = (__in.rdbuf()); 
# 58
__int_type __c = (__sb->sgetc()); 
# 60
const __ctype_type &__ct = __check_facet((__in._M_ctype)); 
# 61
while ((!traits_type::eq_int_type(__c, __eof)) && (__ct.is(ctype_base::space, traits_type::to_char_type(__c)))) { 
# 64
__c = (__sb->snextc()); }  
# 69
if (traits_type::eq_int_type(__c, __eof)) { 
# 70
(__err |= ::std::ios_base::eofbit); }  
# 71
}  
# 72
}  
# 74
if ((__in.good()) && (__err == ::std::ios_base::goodbit)) { 
# 75
(_M_ok) = true; } else 
# 77
{ 
# 78
(__err |= ::std::ios_base::failbit); 
# 79
(__in.setstate(__err)); 
# 80
}  
# 81
} 
# 83
template< class _CharT, class _Traits> 
# 84
template< class _ValueT> basic_istream< _CharT, _Traits>  &
# 87
basic_istream< _CharT, _Traits> ::_M_extract(_ValueT &__v) 
# 88
{ 
# 89
sentry __cerb(*this, false); 
# 90
if (__cerb) 
# 91
{ 
# 92
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 93
try 
# 94
{ 
# 95
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 96
(__ng.get(*this, 0, *this, __err, __v)); 
# 97
} 
# 98
catch (::__cxxabiv1::__forced_unwind &) 
# 99
{ 
# 100
(this->_M_setstate(ios_base::badbit)); 
# 101
throw; 
# 102
} 
# 103
catch (...) 
# 104
{ (this->_M_setstate(ios_base::badbit)); }  
# 105
if (__err) { 
# 106
(this->setstate(__err)); }  
# 107
}  
# 108
return *this; 
# 109
} 
# 111
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 114
basic_istream< _CharT, _Traits> ::operator>>(short &__n) 
# 115
{ 
# 118
sentry __cerb(*this, false); 
# 119
if (__cerb) 
# 120
{ 
# 121
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 122
try 
# 123
{ 
# 124
long __l; 
# 125
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 126
(__ng.get(*this, 0, *this, __err, __l)); 
# 130
if (__l < ::__gnu_cxx::__numeric_traits_integer< short> ::__min) 
# 131
{ 
# 132
(__err |= ::std::ios_base::failbit); 
# 133
__n = ::__gnu_cxx::__numeric_traits_integer< short> ::__min; 
# 134
} else { 
# 135
if (__l > ::__gnu_cxx::__numeric_traits_integer< short> ::__max) 
# 136
{ 
# 137
(__err |= ::std::ios_base::failbit); 
# 138
__n = ::__gnu_cxx::__numeric_traits_integer< short> ::__max; 
# 139
} else { 
# 141
__n = ((short)__l); }  }  
# 142
} 
# 143
catch (::__cxxabiv1::__forced_unwind &) 
# 144
{ 
# 145
(this->_M_setstate(ios_base::badbit)); 
# 146
throw; 
# 147
} 
# 148
catch (...) 
# 149
{ (this->_M_setstate(ios_base::badbit)); }  
# 150
if (__err) { 
# 151
(this->setstate(__err)); }  
# 152
}  
# 153
return *this; 
# 154
} 
# 156
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 159
basic_istream< _CharT, _Traits> ::operator>>(int &__n) 
# 160
{ 
# 163
sentry __cerb(*this, false); 
# 164
if (__cerb) 
# 165
{ 
# 166
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 167
try 
# 168
{ 
# 169
long __l; 
# 170
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 171
(__ng.get(*this, 0, *this, __err, __l)); 
# 175
if (__l < ::__gnu_cxx::__numeric_traits_integer< int> ::__min) 
# 176
{ 
# 177
(__err |= ::std::ios_base::failbit); 
# 178
__n = ::__gnu_cxx::__numeric_traits_integer< int> ::__min; 
# 179
} else { 
# 180
if (__l > ::__gnu_cxx::__numeric_traits_integer< int> ::__max) 
# 181
{ 
# 182
(__err |= ::std::ios_base::failbit); 
# 183
__n = ::__gnu_cxx::__numeric_traits_integer< int> ::__max; 
# 184
} else { 
# 186
__n = ((int)__l); }  }  
# 187
} 
# 188
catch (::__cxxabiv1::__forced_unwind &) 
# 189
{ 
# 190
(this->_M_setstate(ios_base::badbit)); 
# 191
throw; 
# 192
} 
# 193
catch (...) 
# 194
{ (this->_M_setstate(ios_base::badbit)); }  
# 195
if (__err) { 
# 196
(this->setstate(__err)); }  
# 197
}  
# 198
return *this; 
# 199
} 
# 201
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 204
basic_istream< _CharT, _Traits> ::operator>>(__streambuf_type *__sbout) 
# 205
{ 
# 206
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 207
sentry __cerb(*this, false); 
# 208
if (__cerb && __sbout) 
# 209
{ 
# 210
try 
# 211
{ 
# 212
bool __ineof; 
# 213
if (!__copy_streambufs_eof((this->rdbuf()), __sbout, __ineof)) { 
# 214
(__err |= ::std::ios_base::failbit); }  
# 215
if (__ineof) { 
# 216
(__err |= ::std::ios_base::eofbit); }  
# 217
} 
# 218
catch (::__cxxabiv1::__forced_unwind &) 
# 219
{ 
# 220
(this->_M_setstate(ios_base::failbit)); 
# 221
throw; 
# 222
} 
# 223
catch (...) 
# 224
{ (this->_M_setstate(ios_base::failbit)); }  
# 225
} else { 
# 226
if (!__sbout) { 
# 227
(__err |= ::std::ios_base::failbit); }  }  
# 228
if (__err) { 
# 229
(this->setstate(__err)); }  
# 230
return *this; 
# 231
} 
# 233
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 236
basic_istream< _CharT, _Traits> ::get() 
# 237
{ 
# 238
const int_type __eof = traits_type::eof(); 
# 239
int_type __c = __eof; 
# 240
(_M_gcount) = (0); 
# 241
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 242
sentry __cerb(*this, true); 
# 243
if (__cerb) 
# 244
{ 
# 245
try 
# 246
{ 
# 247
__c = ((this->rdbuf())->sbumpc()); 
# 249
if (!traits_type::eq_int_type(__c, __eof)) { 
# 250
(_M_gcount) = (1); } else { 
# 252
(__err |= ::std::ios_base::eofbit); }  
# 253
} 
# 254
catch (::__cxxabiv1::__forced_unwind &) 
# 255
{ 
# 256
(this->_M_setstate(ios_base::badbit)); 
# 257
throw; 
# 258
} 
# 259
catch (...) 
# 260
{ (this->_M_setstate(ios_base::badbit)); }  
# 261
}  
# 262
if (!(_M_gcount)) { 
# 263
(__err |= ::std::ios_base::failbit); }  
# 264
if (__err) { 
# 265
(this->setstate(__err)); }  
# 266
return __c; 
# 267
} 
# 269
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 272
basic_istream< _CharT, _Traits> ::get(char_type &__c) 
# 273
{ 
# 274
(_M_gcount) = (0); 
# 275
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 276
sentry __cerb(*this, true); 
# 277
if (__cerb) 
# 278
{ 
# 279
try 
# 280
{ 
# 281
const int_type __cb = ((this->rdbuf())->sbumpc()); 
# 283
if (!traits_type::eq_int_type(__cb, traits_type::eof())) 
# 284
{ 
# 285
(_M_gcount) = (1); 
# 286
__c = traits_type::to_char_type(__cb); 
# 287
} else { 
# 289
(__err |= ::std::ios_base::eofbit); }  
# 290
} 
# 291
catch (::__cxxabiv1::__forced_unwind &) 
# 292
{ 
# 293
(this->_M_setstate(ios_base::badbit)); 
# 294
throw; 
# 295
} 
# 296
catch (...) 
# 297
{ (this->_M_setstate(ios_base::badbit)); }  
# 298
}  
# 299
if (!(_M_gcount)) { 
# 300
(__err |= ::std::ios_base::failbit); }  
# 301
if (__err) { 
# 302
(this->setstate(__err)); }  
# 303
return *this; 
# 304
} 
# 306
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 309
basic_istream< _CharT, _Traits> ::get(char_type *__s, ::std::streamsize __n, char_type __delim) 
# 310
{ 
# 311
(_M_gcount) = (0); 
# 312
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 313
sentry __cerb(*this, true); 
# 314
if (__cerb) 
# 315
{ 
# 316
try 
# 317
{ 
# 318
const int_type __idelim = traits_type::to_int_type(__delim); 
# 319
const int_type __eof = traits_type::eof(); 
# 320
__streambuf_type *__sb = (this->rdbuf()); 
# 321
int_type __c = (__sb->sgetc()); 
# 323
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 326
{ 
# 327
(*(__s++)) = traits_type::to_char_type(__c); 
# 328
++(_M_gcount); 
# 329
__c = (__sb->snextc()); 
# 330
}  
# 331
if (traits_type::eq_int_type(__c, __eof)) { 
# 332
(__err |= ::std::ios_base::eofbit); }  
# 333
} 
# 334
catch (::__cxxabiv1::__forced_unwind &) 
# 335
{ 
# 336
(this->_M_setstate(ios_base::badbit)); 
# 337
throw; 
# 338
} 
# 339
catch (...) 
# 340
{ (this->_M_setstate(ios_base::badbit)); }  
# 341
}  
# 344
if (__n > (0)) { 
# 345
(*__s) = char_type(); }  
# 346
if (!(_M_gcount)) { 
# 347
(__err |= ::std::ios_base::failbit); }  
# 348
if (__err) { 
# 349
(this->setstate(__err)); }  
# 350
return *this; 
# 351
} 
# 353
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 356
basic_istream< _CharT, _Traits> ::get(__streambuf_type &__sb, char_type __delim) 
# 357
{ 
# 358
(_M_gcount) = (0); 
# 359
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 360
sentry __cerb(*this, true); 
# 361
if (__cerb) 
# 362
{ 
# 363
try 
# 364
{ 
# 365
const int_type __idelim = traits_type::to_int_type(__delim); 
# 366
const int_type __eof = traits_type::eof(); 
# 367
__streambuf_type *__this_sb = (this->rdbuf()); 
# 368
int_type __c = (__this_sb->sgetc()); 
# 369
char_type __c2 = traits_type::to_char_type(__c); 
# 371
while ((!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim)) && (!traits_type::eq_int_type((__sb.sputc(__c2)), __eof))) 
# 374
{ 
# 375
++(_M_gcount); 
# 376
__c = (__this_sb->snextc()); 
# 377
__c2 = traits_type::to_char_type(__c); 
# 378
}  
# 379
if (traits_type::eq_int_type(__c, __eof)) { 
# 380
(__err |= ::std::ios_base::eofbit); }  
# 381
} 
# 382
catch (::__cxxabiv1::__forced_unwind &) 
# 383
{ 
# 384
(this->_M_setstate(ios_base::badbit)); 
# 385
throw; 
# 386
} 
# 387
catch (...) 
# 388
{ (this->_M_setstate(ios_base::badbit)); }  
# 389
}  
# 390
if (!(_M_gcount)) { 
# 391
(__err |= ::std::ios_base::failbit); }  
# 392
if (__err) { 
# 393
(this->setstate(__err)); }  
# 394
return *this; 
# 395
} 
# 397
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 400
basic_istream< _CharT, _Traits> ::getline(char_type *__s, ::std::streamsize __n, char_type __delim) 
# 401
{ 
# 402
(_M_gcount) = (0); 
# 403
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 404
sentry __cerb(*this, true); 
# 405
if (__cerb) 
# 406
{ 
# 407
try 
# 408
{ 
# 409
const int_type __idelim = traits_type::to_int_type(__delim); 
# 410
const int_type __eof = traits_type::eof(); 
# 411
__streambuf_type *__sb = (this->rdbuf()); 
# 412
int_type __c = (__sb->sgetc()); 
# 414
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 417
{ 
# 418
(*(__s++)) = traits_type::to_char_type(__c); 
# 419
__c = (__sb->snextc()); 
# 420
++(_M_gcount); 
# 421
}  
# 422
if (traits_type::eq_int_type(__c, __eof)) { 
# 423
(__err |= ::std::ios_base::eofbit); } else 
# 425
{ 
# 426
if (traits_type::eq_int_type(__c, __idelim)) 
# 427
{ 
# 428
(__sb->sbumpc()); 
# 429
++(_M_gcount); 
# 430
} else { 
# 432
(__err |= ::std::ios_base::failbit); }  
# 433
}  
# 434
} 
# 435
catch (::__cxxabiv1::__forced_unwind &) 
# 436
{ 
# 437
(this->_M_setstate(ios_base::badbit)); 
# 438
throw; 
# 439
} 
# 440
catch (...) 
# 441
{ (this->_M_setstate(ios_base::badbit)); }  
# 442
}  
# 445
if (__n > (0)) { 
# 446
(*__s) = char_type(); }  
# 447
if (!(_M_gcount)) { 
# 448
(__err |= ::std::ios_base::failbit); }  
# 449
if (__err) { 
# 450
(this->setstate(__err)); }  
# 451
return *this; 
# 452
} 
# 457
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 460
basic_istream< _CharT, _Traits> ::ignore() 
# 461
{ 
# 462
(_M_gcount) = (0); 
# 463
sentry __cerb(*this, true); 
# 464
if (__cerb) 
# 465
{ 
# 466
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 467
try 
# 468
{ 
# 469
const int_type __eof = traits_type::eof(); 
# 470
__streambuf_type *__sb = (this->rdbuf()); 
# 472
if (traits_type::eq_int_type((__sb->sbumpc()), __eof)) { 
# 473
(__err |= ::std::ios_base::eofbit); } else { 
# 475
(_M_gcount) = (1); }  
# 476
} 
# 477
catch (::__cxxabiv1::__forced_unwind &) 
# 478
{ 
# 479
(this->_M_setstate(ios_base::badbit)); 
# 480
throw; 
# 481
} 
# 482
catch (...) 
# 483
{ (this->_M_setstate(ios_base::badbit)); }  
# 484
if (__err) { 
# 485
(this->setstate(__err)); }  
# 486
}  
# 487
return *this; 
# 488
} 
# 490
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 493
basic_istream< _CharT, _Traits> ::ignore(::std::streamsize __n) 
# 494
{ 
# 495
(_M_gcount) = (0); 
# 496
sentry __cerb(*this, true); 
# 497
if (__cerb && (__n > (0))) 
# 498
{ 
# 499
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 500
try 
# 501
{ 
# 502
const int_type __eof = traits_type::eof(); 
# 503
__streambuf_type *__sb = (this->rdbuf()); 
# 504
int_type __c = (__sb->sgetc()); 
# 513
bool __large_ignore = false; 
# 514
while (true) 
# 515
{ 
# 516
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof))) 
# 518
{ 
# 519
++(_M_gcount); 
# 520
__c = (__sb->snextc()); 
# 521
}  
# 522
if ((__n == ::__gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof))) 
# 524
{ 
# 525
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 527
__large_ignore = true; 
# 528
} else { 
# 530
break; }  
# 531
}  
# 533
if (__large_ignore) { 
# 534
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 536
if (traits_type::eq_int_type(__c, __eof)) { 
# 537
(__err |= ::std::ios_base::eofbit); }  
# 538
} 
# 539
catch (::__cxxabiv1::__forced_unwind &) 
# 540
{ 
# 541
(this->_M_setstate(ios_base::badbit)); 
# 542
throw; 
# 543
} 
# 544
catch (...) 
# 545
{ (this->_M_setstate(ios_base::badbit)); }  
# 546
if (__err) { 
# 547
(this->setstate(__err)); }  
# 548
}  
# 549
return *this; 
# 550
} 
# 552
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 555
basic_istream< _CharT, _Traits> ::ignore(::std::streamsize __n, int_type __delim) 
# 556
{ 
# 557
(_M_gcount) = (0); 
# 558
sentry __cerb(*this, true); 
# 559
if (__cerb && (__n > (0))) 
# 560
{ 
# 561
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 562
try 
# 563
{ 
# 564
const int_type __eof = traits_type::eof(); 
# 565
__streambuf_type *__sb = (this->rdbuf()); 
# 566
int_type __c = (__sb->sgetc()); 
# 569
bool __large_ignore = false; 
# 570
while (true) 
# 571
{ 
# 572
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 575
{ 
# 576
++(_M_gcount); 
# 577
__c = (__sb->snextc()); 
# 578
}  
# 579
if ((__n == ::__gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 582
{ 
# 583
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 585
__large_ignore = true; 
# 586
} else { 
# 588
break; }  
# 589
}  
# 591
if (__large_ignore) { 
# 592
(_M_gcount) = ::__gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 594
if (traits_type::eq_int_type(__c, __eof)) { 
# 595
(__err |= ::std::ios_base::eofbit); } else { 
# 596
if (traits_type::eq_int_type(__c, __delim)) 
# 597
{ 
# 598
if ((_M_gcount) < ::__gnu_cxx::__numeric_traits_integer< long> ::__max) { 
# 600
++(_M_gcount); }  
# 601
(__sb->sbumpc()); 
# 602
}  }  
# 603
} 
# 604
catch (::__cxxabiv1::__forced_unwind &) 
# 605
{ 
# 606
(this->_M_setstate(ios_base::badbit)); 
# 607
throw; 
# 608
} 
# 609
catch (...) 
# 610
{ (this->_M_setstate(ios_base::badbit)); }  
# 611
if (__err) { 
# 612
(this->setstate(__err)); }  
# 613
}  
# 614
return *this; 
# 615
} 
# 617
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 620
basic_istream< _CharT, _Traits> ::peek() 
# 621
{ 
# 622
int_type __c = traits_type::eof(); 
# 623
(_M_gcount) = (0); 
# 624
sentry __cerb(*this, true); 
# 625
if (__cerb) 
# 626
{ 
# 627
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 628
try 
# 629
{ 
# 630
__c = ((this->rdbuf())->sgetc()); 
# 631
if (traits_type::eq_int_type(__c, traits_type::eof())) { 
# 632
(__err |= ::std::ios_base::eofbit); }  
# 633
} 
# 634
catch (::__cxxabiv1::__forced_unwind &) 
# 635
{ 
# 636
(this->_M_setstate(ios_base::badbit)); 
# 637
throw; 
# 638
} 
# 639
catch (...) 
# 640
{ (this->_M_setstate(ios_base::badbit)); }  
# 641
if (__err) { 
# 642
(this->setstate(__err)); }  
# 643
}  
# 644
return __c; 
# 645
} 
# 647
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 650
basic_istream< _CharT, _Traits> ::read(char_type *__s, ::std::streamsize __n) 
# 651
{ 
# 652
(_M_gcount) = (0); 
# 653
sentry __cerb(*this, true); 
# 654
if (__cerb) 
# 655
{ 
# 656
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 657
try 
# 658
{ 
# 659
(_M_gcount) = ((this->rdbuf())->sgetn(__s, __n)); 
# 660
if ((_M_gcount) != __n) { 
# 661
(__err |= ((::std::ios_base::eofbit | ::std::ios_base::failbit))); }  
# 662
} 
# 663
catch (::__cxxabiv1::__forced_unwind &) 
# 664
{ 
# 665
(this->_M_setstate(ios_base::badbit)); 
# 666
throw; 
# 667
} 
# 668
catch (...) 
# 669
{ (this->_M_setstate(ios_base::badbit)); }  
# 670
if (__err) { 
# 671
(this->setstate(__err)); }  
# 672
}  
# 673
return *this; 
# 674
} 
# 676
template< class _CharT, class _Traits> streamsize 
# 679
basic_istream< _CharT, _Traits> ::readsome(char_type *__s, ::std::streamsize __n) 
# 680
{ 
# 681
(_M_gcount) = (0); 
# 682
sentry __cerb(*this, true); 
# 683
if (__cerb) 
# 684
{ 
# 685
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 686
try 
# 687
{ 
# 689
const ::std::streamsize __num = ((this->rdbuf())->in_avail()); 
# 690
if (__num > (0)) { 
# 691
(_M_gcount) = ((this->rdbuf())->sgetn(__s, std::min(__num, __n))); } else { 
# 692
if (__num == (-1)) { 
# 693
(__err |= ::std::ios_base::eofbit); }  }  
# 694
} 
# 695
catch (::__cxxabiv1::__forced_unwind &) 
# 696
{ 
# 697
(this->_M_setstate(ios_base::badbit)); 
# 698
throw; 
# 699
} 
# 700
catch (...) 
# 701
{ (this->_M_setstate(ios_base::badbit)); }  
# 702
if (__err) { 
# 703
(this->setstate(__err)); }  
# 704
}  
# 705
return _M_gcount; 
# 706
} 
# 708
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 711
basic_istream< _CharT, _Traits> ::putback(char_type __c) 
# 712
{ 
# 715
(_M_gcount) = (0); 
# 717
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 718
sentry __cerb(*this, true); 
# 719
if (__cerb) 
# 720
{ 
# 721
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 722
try 
# 723
{ 
# 724
const int_type __eof = traits_type::eof(); 
# 725
__streambuf_type *__sb = (this->rdbuf()); 
# 726
if ((!__sb) || traits_type::eq_int_type((__sb->sputbackc(__c)), __eof)) { 
# 728
(__err |= ::std::ios_base::badbit); }  
# 729
} 
# 730
catch (::__cxxabiv1::__forced_unwind &) 
# 731
{ 
# 732
(this->_M_setstate(ios_base::badbit)); 
# 733
throw; 
# 734
} 
# 735
catch (...) 
# 736
{ (this->_M_setstate(ios_base::badbit)); }  
# 737
if (__err) { 
# 738
(this->setstate(__err)); }  
# 739
}  
# 740
return *this; 
# 741
} 
# 743
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 746
basic_istream< _CharT, _Traits> ::unget() 
# 747
{ 
# 750
(_M_gcount) = (0); 
# 752
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 753
sentry __cerb(*this, true); 
# 754
if (__cerb) 
# 755
{ 
# 756
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 757
try 
# 758
{ 
# 759
const int_type __eof = traits_type::eof(); 
# 760
__streambuf_type *__sb = (this->rdbuf()); 
# 761
if ((!__sb) || traits_type::eq_int_type((__sb->sungetc()), __eof)) { 
# 763
(__err |= ::std::ios_base::badbit); }  
# 764
} 
# 765
catch (::__cxxabiv1::__forced_unwind &) 
# 766
{ 
# 767
(this->_M_setstate(ios_base::badbit)); 
# 768
throw; 
# 769
} 
# 770
catch (...) 
# 771
{ (this->_M_setstate(ios_base::badbit)); }  
# 772
if (__err) { 
# 773
(this->setstate(__err)); }  
# 774
}  
# 775
return *this; 
# 776
} 
# 778
template< class _CharT, class _Traits> int 
# 781
basic_istream< _CharT, _Traits> ::sync() 
# 782
{ 
# 785
int __ret = (-1); 
# 786
sentry __cerb(*this, true); 
# 787
if (__cerb) 
# 788
{ 
# 789
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 790
try 
# 791
{ 
# 792
__streambuf_type *__sb = (this->rdbuf()); 
# 793
if (__sb) 
# 794
{ 
# 795
if ((__sb->pubsync()) == (-1)) { 
# 796
(__err |= ::std::ios_base::badbit); } else { 
# 798
__ret = 0; }  
# 799
}  
# 800
} 
# 801
catch (::__cxxabiv1::__forced_unwind &) 
# 802
{ 
# 803
(this->_M_setstate(ios_base::badbit)); 
# 804
throw; 
# 805
} 
# 806
catch (...) 
# 807
{ (this->_M_setstate(ios_base::badbit)); }  
# 808
if (__err) { 
# 809
(this->setstate(__err)); }  
# 810
}  
# 811
return __ret; 
# 812
} 
# 814
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::pos_type 
# 817
basic_istream< _CharT, _Traits> ::tellg() 
# 818
{ 
# 821
pos_type __ret = ((pos_type)(-1)); 
# 822
sentry __cerb(*this, true); 
# 823
if (__cerb) 
# 824
{ 
# 825
try 
# 826
{ 
# 827
if (!(this->fail())) { 
# 828
__ret = ((this->rdbuf())->pubseekoff(0, ios_base::cur, ios_base::in)); }  
# 830
} 
# 831
catch (::__cxxabiv1::__forced_unwind &) 
# 832
{ 
# 833
(this->_M_setstate(ios_base::badbit)); 
# 834
throw; 
# 835
} 
# 836
catch (...) 
# 837
{ (this->_M_setstate(ios_base::badbit)); }  
# 838
}  
# 839
return __ret; 
# 840
} 
# 842
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 845
basic_istream< _CharT, _Traits> ::seekg(pos_type __pos) 
# 846
{ 
# 850
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 851
sentry __cerb(*this, true); 
# 852
if (__cerb) 
# 853
{ 
# 854
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 855
try 
# 856
{ 
# 857
if (!(this->fail())) 
# 858
{ 
# 860
const pos_type __p = ((this->rdbuf())->pubseekpos(__pos, ios_base::in)); 
# 864
if (__p == ((pos_type)((off_type)(-1)))) { 
# 865
(__err |= ::std::ios_base::failbit); }  
# 866
}  
# 867
} 
# 868
catch (::__cxxabiv1::__forced_unwind &) 
# 869
{ 
# 870
(this->_M_setstate(ios_base::badbit)); 
# 871
throw; 
# 872
} 
# 873
catch (...) 
# 874
{ (this->_M_setstate(ios_base::badbit)); }  
# 875
if (__err) { 
# 876
(this->setstate(__err)); }  
# 877
}  
# 878
return *this; 
# 879
} 
# 881
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 884
basic_istream< _CharT, _Traits> ::seekg(off_type __off, ::std::ios_base::seekdir __dir) 
# 885
{ 
# 889
(this->clear((this->rdstate()) & ((~::std::ios_base::eofbit)))); 
# 890
sentry __cerb(*this, true); 
# 891
if (__cerb) 
# 892
{ 
# 893
::std::ios_base::iostate __err = ::std::ios_base::goodbit; 
# 894
try 
# 895
{ 
# 896
if (!(this->fail())) 
# 897
{ 
# 899
const pos_type __p = ((this->rdbuf())->pubseekoff(__off, __dir, ios_base::in)); 
# 903
if (__p == ((pos_type)((off_type)(-1)))) { 
# 904
(__err |= ::std::ios_base::failbit); }  
# 905
}  
# 906
} 
# 907
catch (::__cxxabiv1::__forced_unwind &) 
# 908
{ 
# 909
(this->_M_setstate(ios_base::badbit)); 
# 910
throw; 
# 911
} 
# 912
catch (...) 
# 913
{ (this->_M_setstate(ios_base::badbit)); }  
# 914
if (__err) { 
# 915
(this->setstate(__err)); }  
# 916
}  
# 917
return *this; 
# 918
} 
# 921
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 923
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT &__c) 
# 924
{ 
# 925
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 926
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 928
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 929
if (__cerb) 
# 930
{ 
# 931
ios_base::iostate __err = ios_base::goodbit; 
# 932
try 
# 933
{ 
# 934
const __int_type __cb = ((__in.rdbuf())->sbumpc()); 
# 935
if (!_Traits::eq_int_type(__cb, _Traits::eof())) { 
# 936
__c = _Traits::to_char_type(__cb); } else { 
# 938
(__err |= ((ios_base::eofbit | ios_base::failbit))); }  
# 939
} 
# 940
catch (__cxxabiv1::__forced_unwind &) 
# 941
{ 
# 942
(__in._M_setstate(ios_base::badbit)); 
# 943
throw; 
# 944
} 
# 945
catch (...) 
# 946
{ (__in._M_setstate(ios_base::badbit)); }  
# 947
if (__err) { 
# 948
(__in.setstate(__err)); }  
# 949
}  
# 950
return __in; 
# 951
} 
# 953
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 955
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT *__s) 
# 956
{ 
# 957
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 958
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 959
typedef typename _Traits::int_type int_type; 
# 960
typedef _CharT char_type; 
# 961
typedef ctype< _CharT>  __ctype_type; 
# 963
streamsize __extracted = (0); 
# 964
ios_base::iostate __err = ios_base::goodbit; 
# 965
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 966
if (__cerb) 
# 967
{ 
# 968
try 
# 969
{ 
# 971
streamsize __num = (__in.width()); 
# 972
if (__num <= (0)) { 
# 973
__num = __gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 975
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 977
const int_type __eof = _Traits::eof(); 
# 978
__streambuf_type *__sb = (__in.rdbuf()); 
# 979
int_type __c = (__sb->sgetc()); 
# 981
while ((__extracted < (__num - (1))) && (!_Traits::eq_int_type(__c, __eof)) && (!(__ct.is(ctype_base::space, _Traits::to_char_type(__c))))) 
# 985
{ 
# 986
(*(__s++)) = _Traits::to_char_type(__c); 
# 987
++__extracted; 
# 988
__c = (__sb->snextc()); 
# 989
}  
# 990
if (_Traits::eq_int_type(__c, __eof)) { 
# 991
(__err |= ios_base::eofbit); }  
# 995
(*__s) = char_type(); 
# 996
(__in.width(0)); 
# 997
} 
# 998
catch (__cxxabiv1::__forced_unwind &) 
# 999
{ 
# 1000
(__in._M_setstate(ios_base::badbit)); 
# 1001
throw; 
# 1002
} 
# 1003
catch (...) 
# 1004
{ (__in._M_setstate(ios_base::badbit)); }  
# 1005
}  
# 1006
if (!__extracted) { 
# 1007
(__err |= ios_base::failbit); }  
# 1008
if (__err) { 
# 1009
(__in.setstate(__err)); }  
# 1010
return __in; 
# 1011
} 
# 1014
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1016
ws(basic_istream< _CharT, _Traits>  &__in) 
# 1017
{ 
# 1018
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1019
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 1020
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1021
typedef ctype< _CharT>  __ctype_type; 
# 1023
const __ctype_type &__ct = use_facet< ctype< _CharT> > ((__in.getloc())); 
# 1024
const __int_type __eof = _Traits::eof(); 
# 1025
__streambuf_type *__sb = (__in.rdbuf()); 
# 1026
__int_type __c = (__sb->sgetc()); 
# 1028
while ((!_Traits::eq_int_type(__c, __eof)) && (__ct.is(ctype_base::space, _Traits::to_char_type(__c)))) { 
# 1030
__c = (__sb->snextc()); }  
# 1032
if (_Traits::eq_int_type(__c, __eof)) { 
# 1033
(__in.setstate(ios_base::eofbit)); }  
# 1034
return __in; 
# 1035
} 
# 1040
extern template class basic_istream< char, char_traits< char> > ;
# 1041
extern template basic_istream< char, char_traits< char> >  &ws(basic_istream< char, char_traits< char> >  & __is);
# 1042
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, char & __c);
# 1043
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  &, char *);
# 1044
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, unsigned char & __c);
# 1045
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, signed char & __c);
# 1046
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, unsigned char * __s);
# 1047
extern template basic_istream< char, char_traits< char> >  &operator>>(basic_istream< char, char_traits< char> >  & __in, signed char * __s);
# 1049
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned short & __v);
# 1050
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned & __v);
# 1051
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long & __v);
# 1052
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned long & __v);
# 1053
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(bool & __v);
# 1055
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long long & __v);
# 1056
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(unsigned long long & __v);
# 1058
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(float & __v);
# 1059
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(double & __v);
# 1060
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(long double & __v);
# 1061
extern template basic_istream< char, char_traits< char> > ::__istream_type &basic_istream< char, char_traits< char> > ::_M_extract(void *& __v);
# 1063
extern template class basic_iostream< char, char_traits< char> > ;
# 1066
extern template class basic_istream< wchar_t, char_traits< wchar_t> > ;
# 1067
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &ws(basic_istream< wchar_t, char_traits< wchar_t> >  & __is);
# 1068
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  & __in, wchar_t & __c);
# 1069
extern template basic_istream< wchar_t, char_traits< wchar_t> >  &operator>>(basic_istream< wchar_t, char_traits< wchar_t> >  &, wchar_t *);
# 1071
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned short & __v);
# 1072
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned & __v);
# 1073
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long & __v);
# 1074
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned long & __v);
# 1075
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(bool & __v);
# 1077
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long long & __v);
# 1078
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(unsigned long long & __v);
# 1080
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(float & __v);
# 1081
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(double & __v);
# 1082
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(long double & __v);
# 1083
extern template basic_istream< wchar_t, char_traits< wchar_t> > ::__istream_type &basic_istream< wchar_t, char_traits< wchar_t> > ::_M_extract(void *& __v);
# 1085
extern template class basic_iostream< wchar_t, char_traits< wchar_t> > ;
# 1090
}
# 37 "/usr/include/c++/5/bits/stream_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
template< class _Tp, class _CharT = char, class 
# 48
_Traits = char_traits< _CharT> , class _Dist = ptrdiff_t> 
# 49
class istream_iterator : public iterator< input_iterator_tag, _Tp, _Dist, const _Tp *, const _Tp &>  { 
# 53
public: typedef _CharT char_type; 
# 54
typedef _Traits traits_type; 
# 55
typedef basic_istream< _CharT, _Traits>  istream_type; 
# 58
private: istream_type *_M_stream; 
# 59
_Tp _M_value; 
# 60
bool _M_ok; 
# 64
public: istream_iterator() : _M_stream((0)), _M_value(), _M_ok(false) 
# 65
{ } 
# 68
istream_iterator(istream_type &__s) : _M_stream((&__s)) 
# 70
{ _M_read(); } 
# 72
istream_iterator(const istream_iterator &__obj) : _M_stream(__obj._M_stream), _M_value(__obj._M_value), _M_ok(__obj._M_ok) 
# 75
{ } 
# 78
const _Tp &operator*() const 
# 79
{ 
# 82
; 
# 83
return _M_value; 
# 84
} 
# 87
const _Tp *operator->() const { return &operator*(); } 
# 90
istream_iterator &operator++() 
# 91
{ 
# 94
; 
# 95
_M_read(); 
# 96
return *this; 
# 97
} 
# 100
istream_iterator operator++(int) 
# 101
{ 
# 104
; 
# 105
istream_iterator __tmp = *this; 
# 106
_M_read(); 
# 107
return __tmp; 
# 108
} 
# 111
bool _M_equal(const istream_iterator &__x) const 
# 112
{ return ((_M_ok) == (__x._M_ok)) && ((!(_M_ok)) || ((_M_stream) == (__x._M_stream))); } 
# 116
private: void _M_read() 
# 117
{ 
# 118
(_M_ok) = (((_M_stream) && (*(_M_stream))) ? true : false); 
# 119
if (_M_ok) 
# 120
{ 
# 121
(*(_M_stream)) >> (_M_value); 
# 122
(_M_ok) = ((*(_M_stream)) ? true : false); 
# 123
}  
# 124
} 
# 125
}; 
# 128
template< class _Tp, class _CharT, class _Traits, class _Dist> inline bool 
# 130
operator==(const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &__x, const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &
# 131
__y) 
# 132
{ return (__x._M_equal(__y)); } 
# 135
template< class _Tp, class _CharT, class _Traits, class _Dist> inline bool 
# 137
operator!=(const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &__x, const istream_iterator< _Tp, _CharT, _Traits, _Dist>  &
# 138
__y) 
# 139
{ return !(__x._M_equal(__y)); } 
# 152
template< class _Tp, class _CharT = char, class 
# 153
_Traits = char_traits< _CharT> > 
# 154
class ostream_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 160
public: typedef _CharT char_type; 
# 161
typedef _Traits traits_type; 
# 162
typedef basic_ostream< _CharT, _Traits>  ostream_type; 
# 166
private: ostream_type *_M_stream; 
# 167
const _CharT *_M_string; 
# 171
public: ostream_iterator(ostream_type &__s) : _M_stream((&__s)), _M_string((0)) { } 
# 183
ostream_iterator(ostream_type &__s, const _CharT *__c) : _M_stream((&__s)), _M_string(__c) 
# 184
{ } 
# 187
ostream_iterator(const ostream_iterator &__obj) : _M_stream(__obj._M_stream), _M_string(__obj._M_string) 
# 188
{ } 
# 193
ostream_iterator &operator=(const _Tp &__value) 
# 194
{ 
# 197
; 
# 198
(*(_M_stream)) << __value; 
# 199
if (_M_string) { (*(_M_stream)) << (_M_string); }  
# 200
return *this; 
# 201
} 
# 204
ostream_iterator &operator*() 
# 205
{ return *this; } 
# 208
ostream_iterator &operator++() 
# 209
{ return *this; } 
# 212
ostream_iterator &operator++(int) 
# 213
{ return *this; } 
# 214
}; 
# 219
}
# 36 "/usr/local/cuda/include/thrust/iterator/iterator_traits.h"
namespace thrust { 
# 42
template< class T> 
# 43
struct iterator_traits { 
# 45
typedef typename T::difference_type difference_type; 
# 46
typedef typename T::value_type value_type; 
# 47
typedef typename T::pointer pointer; 
# 48
typedef typename T::reference reference; 
# 49
typedef typename T::iterator_category iterator_category; 
# 50
}; 
# 53
template< class T> 
# 54
struct iterator_traits< T *>  { 
# 56
typedef std::ptrdiff_t difference_type; 
# 57
typedef T value_type; 
# 58
typedef T *pointer; 
# 59
typedef T &reference; 
# 60
typedef std::random_access_iterator_tag iterator_category; 
# 61
}; 
# 63
template< class T> 
# 64
struct iterator_traits< const T *>  { 
# 66
typedef std::ptrdiff_t difference_type; 
# 67
typedef T value_type; 
# 68
typedef const T *pointer; 
# 69
typedef const T &reference; 
# 70
typedef std::random_access_iterator_tag iterator_category; 
# 71
}; 
# 73
template< class Iterator> struct iterator_value; 
# 75
template< class Iterator> struct iterator_pointer; 
# 77
template< class Iterator> struct iterator_reference; 
# 79
template< class Iterator> struct iterator_difference; 
# 81
template< class Iterator> struct iterator_traversal; 
# 83
template< class Iterator> struct iterator_system; 
# 86
template< class Iterator> 
# 87
struct __attribute((deprecated)) iterator_space { 
# 89
__attribute((deprecated)) typedef typename iterator_system< Iterator> ::type type; 
# 90
}; 
# 93
}
# 19 "/usr/local/cuda/include/thrust/iterator/detail/iterator_traversal_tags.h"
namespace thrust { 
# 23
struct no_traversal_tag { }; 
# 25
struct incrementable_traversal_tag : public no_traversal_tag { 
# 26
}; 
# 28
struct single_pass_traversal_tag : public incrementable_traversal_tag { 
# 29
}; 
# 31
struct forward_traversal_tag : public single_pass_traversal_tag { 
# 32
}; 
# 34
struct bidirectional_traversal_tag : public forward_traversal_tag { 
# 35
}; 
# 37
struct random_access_traversal_tag : public bidirectional_traversal_tag { 
# 38
}; 
# 40
}
# 21 "/usr/local/cuda/include/thrust/detail/execution_policy.h"
namespace thrust { 
# 23
namespace detail { 
# 41
template< class DerivedPolicy> struct execution_policy_base { }; 
# 44
template< class DerivedPolicy> inline execution_policy_base< DerivedPolicy>  &
# 46
strip_const(const execution_policy_base< DerivedPolicy>  &x) 
# 47
{ 
# 48
return const_cast< execution_policy_base< DerivedPolicy>  &>(x); 
# 49
} 
# 52
template< class DerivedPolicy> inline DerivedPolicy &
# 54
derived_cast(execution_policy_base< DerivedPolicy>  &x) 
# 55
{ 
# 56
return static_cast< DerivedPolicy &>(x); 
# 57
} 
# 60
template< class DerivedPolicy> inline const DerivedPolicy &
# 62
derived_cast(const execution_policy_base< DerivedPolicy>  &x) 
# 63
{ 
# 64
return static_cast< const DerivedPolicy &>(x); 
# 65
} 
# 68
}
# 71
template< class DerivedPolicy> 
# 72
struct execution_policy : public detail::execution_policy_base< DerivedPolicy>  { 
# 74
}; 
# 77
}
# 22 "/usr/local/cuda/include/thrust/system/detail/sequential/execution_policy.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace sequential { 
# 39
struct tag; 
# 42
template< class > struct execution_policy; 
# 46
template<> struct execution_policy< tag>  : public thrust::execution_policy< tag>  { 
# 48
}; 
# 51
struct tag : public execution_policy< tag>  { 
# 53
tag() { } 
# 54
}; 
# 57
template< class Derived> 
# 58
struct execution_policy : public thrust::execution_policy< Derived>  { 
# 62
operator ::thrust::system::detail::sequential::tag() const 
# 63
{ 
# 64
return ::thrust::system::detail::sequential::tag(); 
# 65
} 
# 66
}; 
# 72
static const tag seq; 
# 76
}
# 77
}
# 78
}
# 79
}
# 22 "/usr/local/cuda/include/thrust/system/cpp/detail/execution_policy.h"
namespace thrust { 
# 24
namespace system { 
# 27
namespace cpp { 
# 29
namespace detail { 
# 39
struct tag; 
# 42
template< class > struct execution_policy; 
# 46
template<> struct execution_policy< tag>  : public system::detail::sequential::execution_policy< tag>  { 
# 48
}; 
# 52
struct tag : public execution_policy< tag>  { }; 
# 55
template< class Derived> 
# 56
struct execution_policy : public system::detail::sequential::execution_policy< Derived>  { 
# 60
operator ::thrust::system::cpp::detail::tag() const 
# 61
{ 
# 62
return ::thrust::system::cpp::detail::tag(); 
# 63
} 
# 64
}; 
# 66
}
# 69
using detail::execution_policy;
# 70
using detail::tag;
# 72
}
# 73
}
# 76
namespace cpp { 
# 79
using system::cpp::execution_policy;
# 80
using system::cpp::tag;
# 82
}
# 83
}
# 26 "/usr/local/cuda/include/thrust/iterator/detail/host_system_tag.h"
namespace thrust { 
# 29
typedef system::cpp::detail::tag host_system_tag; 
# 31
}
# 34
namespace thrust { 
# 37
__attribute((deprecated)) typedef host_system_tag host_space_tag; 
# 39
}
# 22 "/usr/local/cuda/include/thrust/iterator/detail/any_system_tag.h"
namespace thrust { 
# 25
struct any_system_tag : public execution_policy< any_system_tag>  { 
# 30
template< class T> operator T() const { return T(); } 
# 31
}; 
# 34
__attribute((deprecated)) typedef any_system_tag any_space_tag; 
# 36
}
# 24 "/usr/local/cuda/include/thrust/system/cuda/detail/execution_policy.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace cuda { 
# 31
namespace detail { 
# 41
struct tag; 
# 44
template< class > struct execution_policy; 
# 48
template<> struct execution_policy< tag>  : public thrust::execution_policy< tag>  { 
# 50
}; 
# 54
struct tag : public execution_policy< tag>  { }; 
# 57
template< class Derived> 
# 58
struct execution_policy : public thrust::execution_policy< Derived>  { 
# 62
operator ::thrust::system::cuda::detail::tag() const 
# 63
{ 
# 64
return ::thrust::system::cuda::detail::tag(); 
# 65
} 
# 66
}; 
# 69
template< class System1, class System2> 
# 70
struct cross_system : public thrust::execution_policy< cross_system< System1, System2> >  { 
# 74
cross_system(::thrust::execution_policy< System1>  &system1, ::thrust::execution_policy< System2>  &
# 75
system2) : system1(system1), system2(system2) 
# 77
{ } 
# 79
::thrust::execution_policy< System1>  &system1; 
# 80
::thrust::execution_policy< System2>  &system2; 
# 83
::thrust::system::cuda::detail::cross_system< System2, System1>  rotate() const 
# 84
{ 
# 85
return ::thrust::system::cuda::detail::cross_system< System2, System1> (system2, system1); 
# 86
} 
# 87
}; 
# 93
template< class System1, class System2> inline cross_system< System1, System2>  
# 95
select_system(const execution_policy< System1>  &system1, const cpp::detail::execution_policy< System2>  &system2) 
# 96
{ 
# 97
thrust::execution_policy< System1>  &non_const_system1 = const_cast< execution_policy< System1>  &>(system1); 
# 98
cpp::detail::execution_policy< System2>  &non_const_system2 = const_cast< cpp::detail::execution_policy< System2>  &>(system2); 
# 99
return cross_system< System1, System2> (non_const_system1, non_const_system2); 
# 100
} 
# 103
template< class System1, class System2> inline cross_system< System1, System2>  
# 105
select_system(const cpp::detail::execution_policy< System1>  &system1, execution_policy< System2>  &system2) 
# 106
{ 
# 107
cpp::detail::execution_policy< System1>  &non_const_system1 = const_cast< cpp::detail::execution_policy< System1>  &>(system1); 
# 108
thrust::execution_policy< System2>  &non_const_system2 = const_cast< execution_policy< System2>  &>(system2); 
# 109
return cross_system< System1, System2> (non_const_system1, non_const_system2); 
# 110
} 
# 113
}
# 116
using detail::execution_policy;
# 117
using detail::tag;
# 119
}
# 120
}
# 123
namespace cuda { 
# 126
using system::cuda::execution_policy;
# 127
using system::cuda::tag;
# 129
}
# 130
}
# 26 "/usr/local/cuda/include/thrust/iterator/detail/device_system_tag.h"
namespace thrust { 
# 29
typedef system::cuda::detail::tag device_system_tag; 
# 31
}
# 34
namespace thrust { 
# 37
__attribute((deprecated)) typedef device_system_tag device_space_tag; 
# 39
}
# 21 "/usr/local/cuda/include/thrust/iterator/detail/iterator_category_with_system_and_traversal.h"
namespace thrust { 
# 23
namespace detail { 
# 27
template< class Category, class System, class Traversal> 
# 28
struct iterator_category_with_system_and_traversal : public Category { 
# 31
}; 
# 35
template< class Category> struct iterator_category_to_system; 
# 37
template< class Category, class System, class Traversal> 
# 38
struct iterator_category_to_system< iterator_category_with_system_and_traversal< Category, System, Traversal> >  { 
# 40
typedef System type; 
# 41
}; 
# 45
template< class Category> struct iterator_category_to_traversal; 
# 47
template< class Category, class System, class Traversal> 
# 48
struct iterator_category_to_traversal< iterator_category_with_system_and_traversal< Category, System, Traversal> >  { 
# 50
typedef Traversal type; 
# 51
}; 
# 55
}
# 56
}
# 42 "/usr/local/cuda/include/thrust/iterator/iterator_categories.h"
namespace thrust { 
# 64
struct input_device_iterator_tag : public detail::iterator_category_with_system_and_traversal< std::input_iterator_tag, system::cuda::detail::tag, single_pass_traversal_tag>  { 
# 70
}; 
# 83
struct output_device_iterator_tag : public detail::iterator_category_with_system_and_traversal< std::output_iterator_tag, system::cuda::detail::tag, single_pass_traversal_tag>  { 
# 89
}; 
# 102
struct forward_device_iterator_tag : public detail::iterator_category_with_system_and_traversal< std::forward_iterator_tag, system::cuda::detail::tag, forward_traversal_tag>  { 
# 108
}; 
# 121
struct bidirectional_device_iterator_tag : public detail::iterator_category_with_system_and_traversal< std::bidirectional_iterator_tag, system::cuda::detail::tag, bidirectional_traversal_tag>  { 
# 127
}; 
# 140
struct random_access_device_iterator_tag : public detail::iterator_category_with_system_and_traversal< std::random_access_iterator_tag, system::cuda::detail::tag, random_access_traversal_tag>  { 
# 146
}; 
# 160
typedef std::input_iterator_tag input_host_iterator_tag; 
# 174
typedef std::output_iterator_tag output_host_iterator_tag; 
# 188
typedef std::forward_iterator_tag forward_host_iterator_tag; 
# 202
typedef std::bidirectional_iterator_tag bidirectional_host_iterator_tag; 
# 216
typedef std::random_access_iterator_tag random_access_host_iterator_tag; 
# 221
}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/universal_categories.h"
namespace thrust { 
# 29
struct input_universal_iterator_tag { 
# 31
operator input_host_iterator_tag() { return input_host_iterator_tag(); } 
# 33
operator input_device_iterator_tag() { return input_device_iterator_tag(); } 
# 34
}; 
# 36
struct output_universal_iterator_tag { 
# 38
operator output_host_iterator_tag() { return output_host_iterator_tag(); } 
# 40
operator output_device_iterator_tag() { return output_device_iterator_tag(); } 
# 41
}; 
# 43
struct forward_universal_iterator_tag : public input_universal_iterator_tag { 
# 46
operator forward_host_iterator_tag() { return forward_host_iterator_tag(); } 
# 48
operator forward_device_iterator_tag() { return forward_device_iterator_tag(); } 
# 49
}; 
# 51
struct bidirectional_universal_iterator_tag : public forward_universal_iterator_tag { 
# 54
operator bidirectional_host_iterator_tag() { return bidirectional_host_iterator_tag(); } 
# 56
operator bidirectional_device_iterator_tag() { return bidirectional_device_iterator_tag(); } 
# 57
}; 
# 60
namespace detail { 
# 64
template< class T> 
# 65
struct one_degree_of_separation : public T { 
# 68
}; 
# 70
}
# 73
struct random_access_universal_iterator_tag { 
# 76
operator random_access_host_iterator_tag() { return random_access_host_iterator_tag(); } 
# 78
operator random_access_device_iterator_tag() { return random_access_device_iterator_tag(); } 
# 81
operator detail::one_degree_of_separation< bidirectional_universal_iterator_tag> () { return detail::one_degree_of_separation< bidirectional_universal_iterator_tag> (); } 
# 83
}; 
# 86
}
# 27 "/usr/local/cuda/include/thrust/iterator/detail/iterator_category_to_system.h"
namespace thrust { 
# 30
namespace detail { 
# 34
template< class > struct is_iterator_system; 
# 36
template< class > struct device_iterator_category_to_backend_system; 
# 40
template< class Category> 
# 41
struct iterator_category_to_system : public eval_if< or_< is_convertible< Category, std::input_iterator_tag> , is_convertible< Category, std::output_iterator_tag> > ::value, identity_< system::cpp::detail::tag> , eval_if< or_< is_convertible< Category, input_device_iterator_tag> , is_convertible< Category, output_device_iterator_tag> > ::value, identity_< system::cuda::detail::tag> , identity_< void> > >  { 
# 65
}; 
# 68
template< class CategoryOrTraversal> 
# 69
struct iterator_category_or_traversal_to_system : public eval_if< is_iterator_system< CategoryOrTraversal> ::value, identity_< CategoryOrTraversal> , iterator_category_to_system< CategoryOrTraversal> >  { 
# 76
}; 
# 78
}
# 79
}
# 25 "/usr/local/cuda/include/thrust/iterator/detail/iterator_category_to_traversal.h"
namespace thrust { 
# 28
namespace detail { 
# 32
template< class > struct is_iterator_system; 
# 33
template< class > struct is_iterator_traversal; 
# 36
using namespace detail;
# 38
template< class Category> 
# 39
struct host_system_category_to_traversal : public eval_if< is_convertible< Category, std::random_access_iterator_tag> ::value, identity_< random_access_traversal_tag> , eval_if< is_convertible< Category, std::bidirectional_iterator_tag> ::value, identity_< bidirectional_traversal_tag> , eval_if< is_convertible< Category, std::forward_iterator_tag> ::value, identity_< forward_traversal_tag> , eval_if< is_convertible< Category, std::input_iterator_tag> ::value, identity_< single_pass_traversal_tag> , eval_if< is_convertible< Category, std::output_iterator_tag> ::value, identity_< incrementable_traversal_tag> , void> > > > >  { 
# 62
}; 
# 66
template< class Category> 
# 67
struct device_system_category_to_traversal : public eval_if< is_convertible< Category, random_access_device_iterator_tag> ::value, identity_< random_access_traversal_tag> , eval_if< is_convertible< Category, bidirectional_device_iterator_tag> ::value, identity_< bidirectional_traversal_tag> , eval_if< is_convertible< Category, forward_device_iterator_tag> ::value, identity_< forward_traversal_tag> , eval_if< is_convertible< Category, input_device_iterator_tag> ::value, identity_< single_pass_traversal_tag> , eval_if< is_convertible< Category, output_device_iterator_tag> ::value, identity_< incrementable_traversal_tag> , void> > > > >  { 
# 90
}; 
# 93
template< class Category> 
# 94
struct category_to_traversal : public eval_if< or_< is_convertible< Category, std::input_iterator_tag> , is_convertible< Category, std::output_iterator_tag> > ::value, host_system_category_to_traversal< Category> , eval_if< or_< is_convertible< Category, input_device_iterator_tag> , is_convertible< Category, output_device_iterator_tag> > ::value, device_system_category_to_traversal< Category> , void> >  { 
# 117
}; 
# 120
template< class CategoryOrTraversal> 
# 121
struct iterator_category_to_traversal : public eval_if< is_iterator_traversal< CategoryOrTraversal> ::value, identity_< CategoryOrTraversal> , category_to_traversal< CategoryOrTraversal> >  { 
# 128
}; 
# 131
}
# 133
}
# 26 "/usr/local/cuda/include/thrust/iterator/detail/iterator_traits.inl"
namespace thrust { 
# 29
template< class Iterator> 
# 30
struct iterator_value { 
# 32
typedef typename iterator_traits< Iterator> ::value_type type; 
# 33
}; 
# 36
template< class Iterator> 
# 37
struct iterator_pointer { 
# 39
typedef typename iterator_traits< Iterator> ::pointer type; 
# 40
}; 
# 43
template< class Iterator> 
# 44
struct iterator_reference { 
# 46
typedef typename iterator_traits< Iterator> ::reference type; 
# 47
}; 
# 50
template< class Iterator> 
# 51
struct iterator_difference { 
# 53
typedef typename iterator_traits< Iterator> ::difference_type type; 
# 54
}; 
# 57
template< class Iterator> 
# 58
struct iterator_system : public detail::iterator_category_to_system< typename iterator_traits< Iterator> ::iterator_category>  { 
# 63
}; 
# 67
template<> struct iterator_system< void *>  { 
# 69
typedef detail::eval_if< detail::integral_constant< bool, true> ::value, detail::identity_< system::cpp::detail::tag> , detail::eval_if< detail::integral_constant< bool, false> ::value, detail::identity_< system::cuda::detail::tag> , detail::identity_< void> > > ::type type; 
# 70
}; 
# 73
template<> struct iterator_system< const void *>  { 
# 75
typedef detail::eval_if< true, detail::identity_< system::cpp::detail::tag> , detail::eval_if< false, detail::identity_< system::cuda::detail::tag> , detail::identity_< void> > > ::type type; 
# 76
}; 
# 79
template< class Iterator> 
# 80
struct iterator_traversal : public detail::iterator_category_to_traversal< typename iterator_traits< Iterator> ::iterator_category>  { 
# 85
}; 
# 87
namespace detail { 
# 90
template< class T> 
# 91
struct is_iterator_traversal : public is_convertible< T, incrementable_traversal_tag>  { 
# 94
}; 
# 97
template< class T> 
# 98
struct is_iterator_system : public or_< is_convertible< T, any_system_tag> , or_< is_convertible< T, system::cpp::detail::tag> , is_convertible< T, system::cuda::detail::tag> > >  { 
# 107
}; 
# 110
}
# 111
}
# 26 "/usr/local/cuda/include/thrust/detail/type_traits/pointer_traits.h"
namespace thrust { 
# 28
namespace detail { 
# 31
template< class Ptr> struct pointer_element; 
# 33
template< template< class >  class Ptr, class Arg> 
# 34
struct pointer_element< Ptr< Arg> >  { 
# 36
typedef Arg type; 
# 37
}; 
# 39
template< template< class , class >  class Ptr, class Arg1, class Arg2> 
# 40
struct pointer_element< Ptr< Arg1, Arg2> >  { 
# 42
typedef Arg1 type; 
# 43
}; 
# 45
template< template< class , class , class >  class Ptr, class Arg1, class Arg2, class Arg3> 
# 46
struct pointer_element< Ptr< Arg1, Arg2, Arg3> >  { 
# 48
typedef Arg1 type; 
# 49
}; 
# 51
template< template< class , class , class , class >  class Ptr, class Arg1, class Arg2, class Arg3, class Arg4> 
# 52
struct pointer_element< Ptr< Arg1, Arg2, Arg3, Arg4> >  { 
# 54
typedef Arg1 type; 
# 55
}; 
# 57
template< template< class , class , class , class , class >  class Ptr, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> 
# 58
struct pointer_element< Ptr< Arg1, Arg2, Arg3, Arg4, Arg5> >  { 
# 60
typedef Arg1 type; 
# 61
}; 
# 63
template< class T> 
# 64
struct pointer_element< T *>  { 
# 66
typedef T type; 
# 67
}; 
# 69
template< class Ptr> 
# 70
struct pointer_difference { 
# 72
typedef typename Ptr::difference_type type; 
# 73
}; 
# 75
template< class T> 
# 76
struct pointer_difference< T *>  { 
# 78
typedef std::ptrdiff_t type; 
# 79
}; 
# 81
template< class Ptr, class T> struct rebind_pointer; 
# 83
template< class T, class U> 
# 84
struct rebind_pointer< T *, U>  { 
# 86
typedef U *type; 
# 87
}; 
# 89
template< template< class >  class Ptr, class Arg, class T> 
# 90
struct rebind_pointer< Ptr< Arg> , T>  { 
# 92
typedef Ptr< T>  type; 
# 93
}; 
# 95
template< template< class , class >  class Ptr, class Arg1, class Arg2, class T> 
# 96
struct rebind_pointer< Ptr< Arg1, Arg2> , T>  { 
# 98
typedef Ptr< T, Arg2>  type; 
# 99
}; 
# 101
template< template< class , class , class >  class Ptr, class Arg1, class Arg2, class Arg3, class T> 
# 102
struct rebind_pointer< Ptr< Arg1, Arg2, Arg3> , T>  { 
# 104
typedef Ptr< T, Arg2, Arg3>  type; 
# 105
}; 
# 107
template< template< class , class , class , class >  class Ptr, class Arg1, class Arg2, class Arg3, class Arg4, class T> 
# 108
struct rebind_pointer< Ptr< Arg1, Arg2, Arg3, Arg4> , T>  { 
# 110
typedef Ptr< T, Arg2, Arg3, Arg4>  type; 
# 111
}; 
# 114
template< class T> struct has_raw_pointer { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::raw_pointer *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 116
namespace pointer_traits_detail { 
# 119
template< class Ptr, class Enable = void> struct pointer_raw_pointer_impl { }; 
# 121
template< class T> 
# 122
struct pointer_raw_pointer_impl< T *, void>  { 
# 124
typedef T *type; 
# 125
}; 
# 127
template< class Ptr> 
# 128
struct pointer_raw_pointer_impl< Ptr, typename enable_if< has_raw_pointer< Ptr> ::value> ::type>  { 
# 130
typedef typename Ptr::raw_pointer type; 
# 131
}; 
# 133
}
# 135
template< class T> 
# 136
struct pointer_raw_pointer : public pointer_traits_detail::pointer_raw_pointer_impl< T>  { 
# 138
}; 
# 140
namespace pointer_traits_detail { 
# 143
template< class Void> 
# 144
struct capture_address { 
# 146
template< class T> 
# 148
capture_address(T &r) : m_addr((&r)) 
# 150
{ } 
# 153
Void *operator&() const 
# 154
{ 
# 155
return m_addr; 
# 156
} 
# 158
Void *m_addr; 
# 159
}; 
# 162
template< class T> 
# 163
struct pointer_to_param : public eval_if< is_void< T> ::value, identity_< capture_address< T> > , add_reference< T> >  { 
# 169
}; 
# 171
}
# 173
template< class Ptr> 
# 174
struct pointer_traits { 
# 176
typedef Ptr pointer; 
# 177
typedef typename pointer_element< Ptr> ::type element_type; 
# 178
typedef typename pointer_difference< Ptr> ::type difference_type; 
# 180
template< class U> 
# 181
struct rebind { 
# 183
typedef typename rebind_pointer< Ptr, U> ::type other; 
# 184
}; 
# 187
static pointer pointer_to(typename pointer_traits_detail::pointer_to_param< typename pointer_element< Ptr> ::type> ::type r) 
# 188
{ 
# 192
return (pointer)(&r); 
# 193
} 
# 196
typedef typename pointer_raw_pointer< Ptr> ::type raw_pointer; 
# 199
static raw_pointer get(pointer ptr) 
# 200
{ 
# 201
return (ptr.get()); 
# 202
} 
# 203
}; 
# 205
template< class T> 
# 206
struct pointer_traits< T *>  { 
# 208
typedef T *pointer; 
# 209
typedef T element_type; 
# 210
typedef typename pointer_difference< T *> ::type difference_type; 
# 212
template< class U> 
# 213
struct rebind { 
# 215
typedef U *other; 
# 216
}; 
# 219
static pointer pointer_to(typename pointer_traits_detail::pointer_to_param< T> ::type r) 
# 220
{ 
# 221
return &r; 
# 222
} 
# 225
typedef typename pointer_raw_pointer< T *> ::type raw_pointer; 
# 228
static raw_pointer get(pointer ptr) 
# 229
{ 
# 230
return ptr; 
# 231
} 
# 232
}; 
# 234
template< class FromPtr, class ToPtr> 
# 235
struct is_pointer_convertible : public and_< is_convertible< typename pointer_element< FromPtr> ::type *, typename pointer_element< ToPtr> ::type *> , is_convertible< typename iterator_system< FromPtr> ::type, typename iterator_system< ToPtr> ::type> >  { 
# 246
}; 
# 250
template< class T> 
# 251
struct is_thrust_pointer : public is_metafunction_defined< pointer_raw_pointer< T> >  { 
# 253
}; 
# 256
template< class FromPtr, class ToPtr> 
# 257
struct lazy_is_pointer_convertible : public eval_if< is_thrust_pointer< FromPtr> ::value && is_thrust_pointer< ToPtr> ::value, is_pointer_convertible< FromPtr, ToPtr> , identity_< integral_constant< bool, false> > >  { 
# 263
}; 
# 265
template< class FromPtr, class ToPtr, class T = void> 
# 266
struct enable_if_pointer_is_convertible : public enable_if< lazy_is_pointer_convertible< FromPtr, ToPtr> ::type::value, T>  { 
# 271
}; 
# 274
}
# 275
}
# 23 "/usr/local/cuda/include/thrust/iterator/detail/is_iterator_category.h"
namespace thrust { 
# 26
namespace detail { 
# 29
template< class T> 
# 30
struct is_host_iterator_category : public or_< is_convertible< T, std::input_iterator_tag> , is_convertible< T, std::output_iterator_tag> >  { 
# 36
}; 
# 38
template< class T> 
# 39
struct is_device_iterator_category : public or_< is_convertible< T, input_device_iterator_tag> , is_convertible< T, output_device_iterator_tag> >  { 
# 45
}; 
# 48
template< class T> 
# 49
struct is_iterator_category : public or_< is_host_iterator_category< T> , is_device_iterator_category< T> >  { 
# 55
}; 
# 57
}
# 59
}
# 30 "/usr/local/cuda/include/thrust/iterator/detail/iterator_facade_category.h"
namespace thrust { 
# 33
namespace detail { 
# 81
template< class System, class Traversal, class ValueParam, class Reference> struct iterator_facade_default_category; 
# 95
template< class Traversal, class ValueParam, class Reference> 
# 96
struct iterator_facade_default_category_std : public eval_if< is_convertible< Traversal, forward_traversal_tag> ::value, eval_if< is_convertible< Traversal, random_access_traversal_tag> ::value, identity_< std::random_access_iterator_tag> , eval_if< is_convertible< Traversal, bidirectional_traversal_tag> ::value, identity_< std::bidirectional_iterator_tag> , identity_< std::forward_iterator_tag> > > , eval_if< is_convertible< Traversal, single_pass_traversal_tag> ::value, identity_< std::input_iterator_tag> , identity_< Traversal> > >  { 
# 115
}; 
# 119
template< class Traversal, class ValueParam, class Reference> 
# 120
struct iterator_facade_default_category_host : public eval_if< is_convertible< Traversal, forward_traversal_tag> ::value, eval_if< is_convertible< Traversal, random_access_traversal_tag> ::value, identity_< std::random_access_iterator_tag> , eval_if< is_convertible< Traversal, bidirectional_traversal_tag> ::value, identity_< std::bidirectional_iterator_tag> , identity_< std::forward_iterator_tag> > > , eval_if< is_convertible< Traversal, single_pass_traversal_tag> ::value, identity_< std::input_iterator_tag> , identity_< Traversal> > >  { 
# 139
}; 
# 143
template< class Traversal, class ValueParam, class Reference> 
# 144
struct iterator_facade_default_category_device : public eval_if< is_convertible< Traversal, forward_traversal_tag> ::value, eval_if< is_convertible< Traversal, random_access_traversal_tag> ::value, identity_< random_access_device_iterator_tag> , eval_if< is_convertible< Traversal, bidirectional_traversal_tag> ::value, identity_< bidirectional_device_iterator_tag> , identity_< forward_device_iterator_tag> > > , eval_if< is_convertible< Traversal, single_pass_traversal_tag> ::value, identity_< input_device_iterator_tag> , identity_< Traversal> > >  { 
# 163
}; 
# 167
template< class Traversal, class ValueParam, class Reference> 
# 168
struct iterator_facade_default_category_any { 
# 174
typedef iterator_category_with_system_and_traversal< typename iterator_facade_default_category_std< Traversal, ValueParam, Reference> ::type, any_system_tag, Traversal>  type; 
# 175
}; 
# 178
template< class System, class Traversal, class ValueParam, class Reference> 
# 179
struct iterator_facade_default_category : public eval_if< is_convertible< System, any_system_tag> ::value, iterator_facade_default_category_any< Traversal, ValueParam, Reference> , eval_if< is_convertible< System, system::cpp::detail::tag> ::value, iterator_facade_default_category_host< Traversal, ValueParam, Reference> , eval_if< is_convertible< System, system::cuda::detail::tag> ::value, iterator_facade_default_category_device< Traversal, ValueParam, Reference> , identity_< iterator_category_with_system_and_traversal< typename iterator_facade_default_category_std< Traversal, ValueParam, Reference> ::type, System, Traversal> > > > >  { 
# 207
}; 
# 210
template< class System, class Traversal, class ValueParam, class Reference> 
# 211
struct iterator_facade_category_impl { 
# 215
typedef typename iterator_facade_default_category< System, Traversal, ValueParam, Reference> ::type category; 
# 232
typedef typename eval_if< and_< is_same< Traversal, typename iterator_category_to_traversal< typename iterator_facade_default_category< System, Traversal, ValueParam, Reference> ::type> ::type> , is_same< System, typename iterator_category_to_system< typename iterator_facade_default_category< System, Traversal, ValueParam, Reference> ::type> ::type> > ::value, identity_< typename iterator_facade_default_category< System, Traversal, ValueParam, Reference> ::type> , identity_< iterator_category_with_system_and_traversal< typename iterator_facade_default_category< System, Traversal, ValueParam, Reference> ::type, System, Traversal> > > ::type type; 
# 233
}; 
# 236
template< class CategoryOrSystem, class 
# 237
CategoryOrTraversal, class 
# 238
ValueParam, class 
# 239
Reference> 
# 240
struct iterator_facade_category { 
# 247
typedef typename eval_if< is_iterator_category< CategoryOrTraversal> ::value, identity_< CategoryOrTraversal> , iterator_facade_category_impl< CategoryOrSystem, CategoryOrTraversal, ValueParam, Reference> > ::type type; 
# 248
}; 
# 251
}
# 252
}
# 22 "/usr/local/cuda/include/thrust/iterator/detail/distance_from_result.h"
namespace thrust { 
# 25
namespace detail { 
# 30
template< class IteratorFacade1, class IteratorFacade2> 
# 31
struct distance_from_result : public eval_if< is_convertible< IteratorFacade2, IteratorFacade1> ::value, identity_< typename IteratorFacade1::difference_type> , identity_< typename IteratorFacade2::difference_type> >  { 
# 37
}; 
# 39
}
# 41
}
# 40 "/usr/local/cuda/include/thrust/iterator/iterator_facade.h"
namespace thrust { 
# 55
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> class iterator_facade; 
# 61
class iterator_core_access { 
# 67
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> friend class iterator_facade; 
# 70
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 71
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 70
operator==(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 77
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 78
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 77
operator!=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 84
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 85
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 84
operator<(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 91
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 92
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 91
operator>(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 98
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 99
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 98
operator<=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 105
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 106
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline bool 
# 105
operator>=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 113
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 114
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> friend inline typename detail::distance_from_result< iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1> , iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2> > ::type 
# 113
operator-(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  & lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  & rhs); 
# 124
template< class Facade> static typename Facade::reference 
# 126
dereference(const Facade &f) 
# 127
{ 
# 128
return (f.dereference()); 
# 129
} 
# 131
template< class Facade> static void 
# 133
increment(Facade &f) 
# 134
{ 
# 135
(f.increment()); 
# 136
} 
# 138
template< class Facade> static void 
# 140
decrement(Facade &f) 
# 141
{ 
# 142
(f.decrement()); 
# 143
} 
# 145
template< class Facade1, class Facade2> static bool 
# 147
equal(const Facade1 &f1, const Facade2 &f2) 
# 148
{ 
# 149
return (f1.equal(f2)); 
# 150
} 
# 167
template< class Facade> static void 
# 169
advance(Facade &f, typename Facade::difference_type n) 
# 170
{ 
# 171
(f.advance(n)); 
# 172
} 
# 176
template< class Facade1, class Facade2> static typename Facade1::difference_type 
# 179
distance_from(const Facade1 &f1, const Facade2 &f2, detail::true_type) 
# 180
{ 
# 181
return -(f1.distance_to(f2)); 
# 182
} 
# 186
template< class Facade1, class Facade2> static typename Facade2::difference_type 
# 189
distance_from(const Facade1 &f1, const Facade2 &f2, detail::false_type) 
# 190
{ 
# 191
return (f2.distance_to(f1)); 
# 192
} 
# 194
template< class Facade1, class Facade2> static typename detail::distance_from_result< Facade1, Facade2> ::type 
# 197
distance_from(const Facade1 &f1, const Facade2 &f2) 
# 198
{ 
# 201
return distance_from(f1, f2, typename detail::is_convertible< Facade2, Facade1> ::type()); 
# 203
} 
# 208
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> static Derived &
# 210
derived(iterator_facade< Derived, Value, System, Traversal, Reference, Difference>  &facade) 
# 211
{ 
# 212
return *(static_cast< Derived *>(&facade)); 
# 213
} 
# 215
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> static const Derived &
# 217
derived(const iterator_facade< Derived, Value, System, Traversal, Reference, Difference>  &facade) 
# 218
{ 
# 219
return *(static_cast< const Derived *>(&facade)); 
# 220
} 
# 224
}; 
# 246
template< class Derived, class 
# 247
Value, class 
# 248
System, class 
# 249
Traversal, class 
# 250
Reference, class 
# 251
Difference = std::ptrdiff_t> 
# 252
class iterator_facade { 
# 262
Derived &derived() 
# 263
{ 
# 264
return *(static_cast< Derived *>(this)); 
# 265
} 
# 268
const Derived &derived() const 
# 269
{ 
# 270
return *(static_cast< const Derived *>(this)); 
# 271
} 
# 278
public: typedef typename detail::remove_const< Value> ::type value_type; 
# 282
typedef Reference reference; 
# 291
typedef void pointer; 
# 296
typedef Difference difference_type; 
# 302
typedef typename detail::iterator_facade_category< System, Traversal, Value, Reference> ::type iterator_category; 
# 308
reference operator*() const 
# 309
{ 
# 310
return iterator_core_access::dereference(this->derived()); 
# 311
} 
# 326
reference operator[](difference_type n) const 
# 327
{ 
# 328
return *(this->derived() + n); 
# 329
} 
# 335
Derived &operator++() 
# 336
{ 
# 337
iterator_core_access::increment(this->derived()); 
# 338
return this->derived(); 
# 339
} 
# 345
Derived operator++(int) 
# 346
{ 
# 347
Derived tmp(this->derived()); 
# 348
++(*this); 
# 349
return tmp; 
# 350
} 
# 356
Derived &operator--() 
# 357
{ 
# 358
iterator_core_access::decrement(this->derived()); 
# 359
return this->derived(); 
# 360
} 
# 366
Derived operator--(int) 
# 367
{ 
# 368
Derived tmp(this->derived()); 
# 369
--(*this); 
# 370
return tmp; 
# 371
} 
# 378
Derived &operator+=(difference_type n) 
# 379
{ 
# 380
iterator_core_access::advance(this->derived(), n); 
# 381
return this->derived(); 
# 382
} 
# 389
Derived &operator-=(difference_type n) 
# 390
{ 
# 391
iterator_core_access::advance(this->derived(), -n); 
# 392
return this->derived(); 
# 393
} 
# 400
Derived operator-(difference_type n) const 
# 401
{ 
# 402
Derived result(this->derived()); 
# 403
return result -= n; 
# 404
} 
# 405
}; 
# 411
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 412
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 417
operator==(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 418
rhs) 
# 419
{ 
# 420
return iterator_core_access::equal(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 423
} 
# 425
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 426
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 431
operator!=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 432
rhs) 
# 433
{ 
# 434
return !iterator_core_access::equal(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 437
} 
# 439
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 440
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 445
operator<(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 446
rhs) 
# 447
{ 
# 448
return 0 > iterator_core_access::distance_from(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 451
} 
# 453
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 454
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 459
operator>(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 460
rhs) 
# 461
{ 
# 462
return 0 < iterator_core_access::distance_from(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 465
} 
# 467
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 468
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 473
operator<=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 474
rhs) 
# 475
{ 
# 476
return 0 >= iterator_core_access::distance_from(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 479
} 
# 481
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 482
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline bool 
# 487
operator>=(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 488
rhs) 
# 489
{ 
# 490
return 0 <= iterator_core_access::distance_from(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 493
} 
# 496
template< class Derived1, class Value1, class System1, class Traversal1, class Reference1, class Difference1, class 
# 497
Derived2, class Value2, class System2, class Traversal2, class Reference2, class Difference2> inline typename detail::distance_from_result< iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1> , iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2> > ::type 
# 506
operator-(const iterator_facade< Derived1, Value1, System1, Traversal1, Reference1, Difference1>  &lhs, const iterator_facade< Derived2, Value2, System2, Traversal2, Reference2, Difference2>  &
# 507
rhs) 
# 508
{ 
# 509
return iterator_core_access::distance_from(*(static_cast< const Derived1 *>(&lhs)), *(static_cast< const Derived2 *>(&rhs))); 
# 512
} 
# 515
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> inline Derived 
# 517
operator+(const iterator_facade< Derived, Value, System, Traversal, Reference, Difference>  &i, typename Derived::difference_type 
# 518
n) 
# 519
{ 
# 520
Derived tmp(static_cast< const Derived &>(i)); 
# 521
return tmp += n; 
# 522
} 
# 524
template< class Derived, class Value, class System, class Traversal, class Reference, class Difference> inline Derived 
# 526
operator+(typename Derived::difference_type n, const iterator_facade< Derived, Value, System, Traversal, Reference, Difference>  &
# 527
i) 
# 528
{ 
# 529
Derived tmp(static_cast< const Derived &>(i)); 
# 530
return tmp += n; 
# 531
} 
# 542
}
# 21 "/usr/local/cuda/include/thrust/detail/use_default.h"
namespace thrust { 
# 24
struct use_default { }; 
# 26
}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/iterator_adaptor_base.h"
namespace thrust { 
# 29
template< class Derived, class 
# 30
Base, class 
# 31
Value, class 
# 32
System, class 
# 33
Traversal, class 
# 34
Reference, class 
# 35
Difference> class iterator_adaptor; 
# 40
namespace detail { 
# 46
template< class T, class DefaultNullaryFn> 
# 47
struct ia_dflt_help : public eval_if< is_same< T, use_default> ::value, DefaultNullaryFn, identity_< T> >  { 
# 54
}; 
# 59
template< class Derived, class 
# 60
Base, class 
# 61
Value, class 
# 62
System, class 
# 63
Traversal, class 
# 64
Reference, class 
# 65
Difference> 
# 67
struct iterator_adaptor_base { 
# 72
typedef typename ia_dflt_help< Value, iterator_value< Base> > ::type value; 
# 77
typedef typename ia_dflt_help< System, iterator_system< Base> > ::type system; 
# 82
typedef typename ia_dflt_help< Traversal, iterator_traversal< Base> > ::type traversal; 
# 91
typedef typename ia_dflt_help< Reference, eval_if< is_same< Value, use_default> ::value, iterator_reference< Base> , add_reference< Value> > > ::type reference; 
# 96
typedef typename ia_dflt_help< Difference, iterator_difference< Base> > ::type difference; 
# 105
typedef iterator_facade< Derived, typename ia_dflt_help< Value, iterator_value< Base> > ::type, typename ia_dflt_help< System, iterator_system< Base> > ::type, typename ia_dflt_help< Traversal, iterator_traversal< Base> > ::type, typename ia_dflt_help< Reference, eval_if< is_same< Value, use_default> ::value, iterator_reference< Base> , add_reference< Value> > > ::type, typename ia_dflt_help< Difference, iterator_difference< Base> > ::type>  type; 
# 106
}; 
# 109
}
# 110
}
# 40 "/usr/local/cuda/include/thrust/iterator/iterator_adaptor.h"
namespace thrust { 
# 114
template< class Derived, class 
# 115
Base, class 
# 116
Value = use_default, class 
# 117
System = use_default, class 
# 118
Traversal = use_default, class 
# 119
Reference = use_default, class 
# 120
Difference = use_default> 
# 121
class iterator_adaptor : public detail::iterator_adaptor_base< Derived, Base, Value, System, Traversal, Reference, Difference> ::type { 
# 129
friend class iterator_core_access; 
# 134
protected: typedef typename ::thrust::detail::iterator_adaptor_base< Derived, Base, Value, System, Traversal, Reference, Difference> ::type super_t; 
# 143
public: iterator_adaptor() { } 
# 148
explicit iterator_adaptor(const Base &iter) : m_iterator(iter) 
# 150
{ } 
# 154
typedef Base base_type; 
# 158
typedef typename ::thrust::detail::iterator_adaptor_base< Derived, Base, Value, System, Traversal, Reference, Difference> ::type::reference reference; 
# 160
typedef typename ::thrust::detail::iterator_adaptor_base< Derived, Base, Value, System, Traversal, Reference, Difference> ::type::difference_type difference_type; 
# 167
const Base &base() const 
# 168
{ return m_iterator; } 
# 174
protected: const Base &base_reference() const 
# 175
{ return m_iterator; } 
# 180
Base &base_reference() 
# 181
{ return m_iterator; } 
# 189
private: reference dereference() const 
# 190
{ return *(m_iterator); } 
# 193
template< class OtherDerived, class OtherIterator, class V, class S, class T, class R, class D> bool 
# 195
equal(const ::thrust::iterator_adaptor< OtherDerived, OtherIterator, V, S, T, R, D>  &x) const 
# 196
{ return (m_iterator) == (x.base()); } 
# 200
void advance(difference_type n) 
# 201
{ 
# 203
(m_iterator) += n; 
# 204
} 
# 208
void increment() 
# 209
{ ++(m_iterator); } 
# 213
void decrement() 
# 214
{ 
# 216
--(m_iterator); 
# 217
} 
# 220
template< class OtherDerived, class OtherIterator, class V, class S, class T, class R, class D> difference_type 
# 222
distance_to(const ::thrust::iterator_adaptor< OtherDerived, OtherIterator, V, S, T, R, D>  &y) const 
# 223
{ return (y.base()) - (m_iterator); } 
# 226
Base m_iterator; 
# 230
}; 
# 238
}
# 22 "/usr/local/cuda/include/thrust/detail/reference_forward_declaration.h"
namespace thrust { 
# 25
template< class Element, class Pointer, class Derived = use_default> class reference; 
# 27
}
# 28 "/usr/local/cuda/include/thrust/detail/pointer.h"
namespace thrust { 
# 32
template< class Element, class Tag, class Reference = use_default, class Derived = use_default> class pointer; 
# 34
}
# 41
namespace thrust { 
# 44
template< class Element, class Tag, class Reference, class Derived> 
# 45
struct iterator_traits< pointer< Element, Tag, Reference, Derived> >  { 
# 48
private: typedef thrust::pointer< Element, Tag, Reference, Derived>  ptr; 
# 51
public: typedef typename thrust::pointer< Element, Tag, Reference, Derived> ::iterator_category iterator_category; 
# 52
typedef typename thrust::pointer< Element, Tag, Reference, Derived> ::value_type value_type; 
# 53
typedef typename thrust::pointer< Element, Tag, Reference, Derived> ::difference_type difference_type; 
# 55
typedef void pointer; 
# 56
typedef typename thrust::pointer< Element, Tag, Reference, Derived> ::reference reference; 
# 57
}; 
# 59
}
# 62
namespace thrust { 
# 65
namespace detail { 
# 69
template< class Element, class Tag, class Reference, class Derived> 
# 70
struct pointer_base { 
# 78
typedef typename eval_if< is_void< typename remove_const< Element> ::type> ::value, identity_< void> , remove_cv< Element> > ::type value_type; 
# 85
typedef typename eval_if< is_same< Derived, use_default> ::value, identity_< pointer< Element, Tag, Reference, Derived> > , identity_< Derived> > ::type derived_type; 
# 97
typedef typename eval_if< is_void< typename remove_const< Element> ::type> ::value, identity_< void> , eval_if< is_same< Reference, use_default> ::value, identity_< reference< Element, typename eval_if< is_same< Derived, use_default> ::value, identity_< pointer< Element, Tag, Reference, Derived> > , identity_< Derived> > ::type> > , identity_< Reference> > > ::type reference_arg; 
# 107
typedef iterator_adaptor< typename eval_if< is_same< Derived, use_default> ::value, identity_< pointer< Element, Tag, Reference, Derived> > , identity_< Derived> > ::type, Element *, typename eval_if< is_void< typename remove_const< Element> ::type> ::value, identity_< void> , remove_cv< Element> > ::type, Tag, random_access_traversal_tag, typename eval_if< is_void< typename remove_const< Element> ::type> ::value, identity_< void> , eval_if< is_same< Reference, use_default> ::value, identity_< reference< Element, typename eval_if< is_same< Derived, use_default> ::value, identity_< pointer< Element, Tag, Reference, Derived> > , identity_< Derived> > ::type> > , identity_< Reference> > > ::type, long>  type; 
# 108
}; 
# 111
}
# 121
template< class Element, class Tag, class Reference, class Derived> 
# 122
class pointer : public detail::pointer_base< Element, Tag, Reference, Derived> ::type { 
# 126
typedef typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type super_t; 
# 128
typedef typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::derived_type derived_type; 
# 131
friend class iterator_core_access; 
# 134
typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type::reference dereference() const; 
# 137
using ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type::base;
# 138
using ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type::base_type;
# 141
public: typedef typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type::base_type raw_pointer; 
# 146
pointer(); 
# 150
template< class OtherElement> explicit pointer(OtherElement * ptr); 
# 156
template< class OtherPointer> pointer(const OtherPointer & other, typename ::thrust::detail::enable_if_pointer_is_convertible< OtherPointer, pointer> ::type * = 0); 
# 168
template< class OtherPointer> typename ::thrust::detail::enable_if_pointer_is_convertible< OtherPointer, pointer, typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::derived_type &> ::type operator=(const OtherPointer & other); 
# 180
Element *get() const; 
# 181
}; 
# 184
template< class Element, class Tag, class Reference, class Derived, class 
# 185
charT, class traits> std::basic_ostream< charT, traits>  &
# 184
operator<<(std::basic_ostream< charT, traits>  & os, const pointer< Element, Tag, Reference, Derived>  & p); 
# 190
}
# 21 "/usr/local/cuda/include/thrust/detail/pointer.inl"
namespace thrust { 
# 25
template< class Element, class Tag, class Reference, class Derived> 
# 27
pointer< Element, Tag, Reference, Derived> ::pointer() : super_t(static_cast< Element *>(0)) 
# 29
{ } 
# 32
template< class Element, class Tag, class Reference, class Derived> 
# 33
template< class OtherElement> 
# 35
pointer< Element, Tag, Reference, Derived> ::pointer(OtherElement *other) : super_t(other) 
# 37
{ } 
# 40
template< class Element, class Tag, class Reference, class Derived> 
# 41
template< class OtherPointer> 
# 43
pointer< Element, Tag, Reference, Derived> ::pointer(const OtherPointer &other, typename ::thrust::detail::enable_if_pointer_is_convertible< OtherPointer, pointer> ::type *) : super_t(thrust::detail::pointer_traits< OtherPointer> ::get(other)) 
# 49
{ } 
# 52
template< class Element, class Tag, class Reference, class Derived> 
# 53
template< class OtherPointer> typename detail::enable_if_pointer_is_convertible< OtherPointer, pointer< Element, Tag, Reference, Derived> , typename detail::pointer_base< Element, Tag, Reference, Derived> ::derived_type &> ::type 
# 60
pointer< Element, Tag, Reference, Derived> ::operator=(const OtherPointer &other) 
# 61
{ 
# 62
super_t::base_reference() = thrust::detail::pointer_traits< OtherPointer> ::get(other); 
# 63
return static_cast< derived_type &>(*this); 
# 64
} 
# 67
template< class Element, class Tag, class Reference, class Derived> typename detail::pointer_base< Element, Tag, Reference, Derived> ::type::reference 
# 70
pointer< Element, Tag, Reference, Derived> ::dereference() const 
# 71
{ 
# 72
return (typename ::thrust::detail::pointer_base< Element, Tag, Reference, Derived> ::type::reference)(static_cast< const derived_type &>(*this)); 
# 73
} 
# 76
template< class Element, class Tag, class Reference, class Derived> Element *
# 78
pointer< Element, Tag, Reference, Derived> ::get() const 
# 79
{ 
# 80
return super_t::base(); 
# 81
} 
# 83
template< class Element, class Tag, class Reference, class Derived, class 
# 84
charT, class traits> std::basic_ostream< charT, traits>  &
# 86
operator<<(std::basic_ostream< charT, traits>  &os, const pointer< Element, Tag, Reference, Derived>  &
# 87
p) { 
# 88
return os << (p.get()); 
# 89
} 
# 91
namespace detail { 
# 146
}
# 149
}
# 26 "/usr/local/cuda/include/thrust/detail/reference.h"
namespace thrust { 
# 28
namespace detail { 
# 31
template< class > struct is_wrapped_reference; 
# 33
}
# 42
template< class Element, class Pointer, class Derived> 
# 43
class reference { 
# 50
typedef typename detail::eval_if< detail::is_same< Derived, use_default> ::value, detail::identity_< reference> , detail::identity_< Derived> > ::type derived_type; 
# 54
struct wrapped_reference_hint { }; 
# 55
template< class > friend struct detail::is_wrapped_reference; 
# 58
public: typedef Pointer pointer; 
# 59
typedef typename detail::remove_const< Element> ::type value_type; 
# 62
explicit reference(const pointer & ptr); 
# 64
template< class OtherElement, class OtherPointer, class OtherDerived> reference(const thrust::reference< OtherElement, OtherPointer, OtherDerived>  & other, typename detail::enable_if_convertible< typename thrust::reference< OtherElement, OtherPointer, OtherDerived> ::pointer, Pointer> ::type * = 0); 
# 73
derived_type &operator=(const reference & other); 
# 76
template< class OtherElement, class OtherPointer, class OtherDerived> derived_type &operator=(const thrust::reference< OtherElement, OtherPointer, OtherDerived>  & other); 
# 81
derived_type &operator=(const value_type & x); 
# 84
pointer operator&() const; 
# 87
operator value_type() const; 
# 90
void swap(derived_type & other); 
# 92
derived_type &operator++(); 
# 94
value_type operator++(int); 
# 97
derived_type &operator+=(const value_type & rhs); 
# 99
derived_type &operator--(); 
# 101
value_type operator--(int); 
# 104
derived_type &operator-=(const value_type & rhs); 
# 107
derived_type &operator*=(const value_type & rhs); 
# 110
derived_type &operator/=(const value_type & rhs); 
# 113
derived_type &operator%=(const value_type & rhs); 
# 116
derived_type &operator<<=(const value_type & rhs); 
# 119
derived_type &operator>>=(const value_type & rhs); 
# 122
derived_type &operator&=(const value_type & rhs); 
# 125
derived_type &operator|=(const value_type & rhs); 
# 128
derived_type &operator^=(const value_type & rhs); 
# 131
private: const pointer m_ptr; 
# 134
template< class OtherElement, class OtherPointer, class OtherDerived> friend class reference; 
# 136
template< class System> inline value_type strip_const_get_value(const System & system) const; 
# 140
template< class OtherPointer> inline void assign_from(OtherPointer src); 
# 145
template< class System1, class System2, class OtherPointer> inline void assign_from(System1 * system1, System2 * system2, OtherPointer src); 
# 149
template< class System, class OtherPointer> inline void strip_const_assign_value(const System & system, OtherPointer src); 
# 154
template< class System> inline void swap(System * system, derived_type & other); 
# 159
template< class System> inline value_type convert_to_value_type(System * system) const; 
# 162
}; 
# 165
template< class Element, class Pointer, class Derived, class 
# 166
charT, class traits> std::basic_ostream< charT, traits>  &
# 165
operator<<(std::basic_ostream< charT, traits>  & os, const reference< Element, Pointer, Derived>  & y); 
# 171
}
# 21 "/usr/local/cuda/include/thrust/detail/type_traits/minimum_type.h"
namespace thrust { 
# 24
namespace detail { 
# 27
namespace minimum_type_detail { 
# 34
template< class T1, class T2, bool GreaterEqual, bool LessEqual> struct minimum_type_impl { }; 
# 36
template< class T1, class T2> 
# 37
struct minimum_type_impl< T1, T2, true, false>  { 
# 39
typedef T2 type; 
# 40
}; 
# 42
template< class T1, class T2> 
# 43
struct minimum_type_impl< T1, T2, false, true>  { 
# 45
typedef T1 type; 
# 46
}; 
# 48
template< class T1, class T2> 
# 49
struct minimum_type_impl< T1, T2, true, true>  { 
# 51
typedef T1 type; 
# 52
}; 
# 54
template< class T1, class T2> 
# 55
struct primitive_minimum_type : public minimum_type_impl< T1, T2, is_convertible< T1, T2> ::value, is_convertible< T2, T1> ::value>  { 
# 63
}; 
# 67
template< class T> 
# 68
struct primitive_minimum_type< T, T>  { 
# 70
typedef T type; 
# 71
}; 
# 74
struct any_conversion { 
# 76
template< class T> operator T(); 
# 77
}; 
# 79
}
# 81
template< class T1, class 
# 82
T2 = minimum_type_detail::any_conversion, class 
# 83
T3 = minimum_type_detail::any_conversion, class 
# 84
T4 = minimum_type_detail::any_conversion, class 
# 85
T5 = minimum_type_detail::any_conversion, class 
# 86
T6 = minimum_type_detail::any_conversion, class 
# 87
T7 = minimum_type_detail::any_conversion, class 
# 88
T8 = minimum_type_detail::any_conversion, class 
# 89
T9 = minimum_type_detail::any_conversion, class 
# 90
T10 = minimum_type_detail::any_conversion, class 
# 91
T11 = minimum_type_detail::any_conversion, class 
# 92
T12 = minimum_type_detail::any_conversion, class 
# 93
T13 = minimum_type_detail::any_conversion, class 
# 94
T14 = minimum_type_detail::any_conversion, class 
# 95
T15 = minimum_type_detail::any_conversion, class 
# 96
T16 = minimum_type_detail::any_conversion> struct minimum_type; 
# 100
template< class T1, class T2> 
# 101
struct minimum_type< T1, T2, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion, minimum_type_detail::any_conversion>  : public minimum_type_detail::primitive_minimum_type< T1, T2>  { 
# 103
}; 
# 105
template< class T1, class T2> 
# 106
struct lazy_minimum_type : public minimum_type< typename T1::type, typename T2::type>  { 
# 111
}; 
# 114
template< class T1, class T2, class T3, class T4, class 
# 115
T5, class T6, class T7, class T8, class 
# 116
T9, class T10, class T11, class T12, class 
# 117
T13, class T14, class T15, class T16> 
# 118
struct minimum_type : public lazy_minimum_type< lazy_minimum_type< lazy_minimum_type< minimum_type< T1, T2> , minimum_type< T3, T4> > , lazy_minimum_type< minimum_type< T5, T6> , minimum_type< T7, T8> > > , lazy_minimum_type< lazy_minimum_type< minimum_type< T9, T10> , minimum_type< T11, T12> > , lazy_minimum_type< minimum_type< T13, T14> , minimum_type< T15, T16> > > >  { 
# 157
}; 
# 159
}
# 161
}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/minimum_system.h"
namespace thrust { 
# 26
namespace detail { 
# 30
template< class T1, class 
# 31
T2 = void, class 
# 32
T3 = void, class 
# 33
T4 = void, class 
# 34
T5 = void, class 
# 35
T6 = void, class 
# 36
T7 = void, class 
# 37
T8 = void, class 
# 38
T9 = void, class 
# 39
T10 = void, class 
# 40
T11 = void, class 
# 41
T12 = void, class 
# 42
T13 = void, class 
# 43
T14 = void, class 
# 44
T15 = void, class 
# 45
T16 = void> 
# 46
struct unrelated_systems { }; 
# 51
template< class T1, class 
# 52
T2 = minimum_type_detail::any_conversion, class 
# 53
T3 = minimum_type_detail::any_conversion, class 
# 54
T4 = minimum_type_detail::any_conversion, class 
# 55
T5 = minimum_type_detail::any_conversion, class 
# 56
T6 = minimum_type_detail::any_conversion, class 
# 57
T7 = minimum_type_detail::any_conversion, class 
# 58
T8 = minimum_type_detail::any_conversion, class 
# 59
T9 = minimum_type_detail::any_conversion, class 
# 60
T10 = minimum_type_detail::any_conversion, class 
# 61
T11 = minimum_type_detail::any_conversion, class 
# 62
T12 = minimum_type_detail::any_conversion, class 
# 63
T13 = minimum_type_detail::any_conversion, class 
# 64
T14 = minimum_type_detail::any_conversion, class 
# 65
T15 = minimum_type_detail::any_conversion, class 
# 66
T16 = minimum_type_detail::any_conversion> 
# 67
struct minimum_system : public eval_if< is_metafunction_defined< minimum_type< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> > ::value, minimum_type< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> , identity_< unrelated_systems< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> > >  { 
# 77
}; 
# 80
}
# 81
}
# 26 "/usr/local/cuda/include/thrust/system/detail/generic/type_traits.h"
namespace thrust { 
# 30
struct any_system_tag; 
# 32
namespace system { 
# 34
namespace detail { 
# 38
namespace generic_type_traits_ns { 
# 41
typedef char yes; 
# 42
typedef char (&no)[2]; 
# 44
struct any_conversion { 
# 46
template< class T> any_conversion(const T &); 
# 49
any_conversion(const any_system_tag &); 
# 50
}; 
# 52
namespace select_system_exists_ns { 
# 54
no select_system(const any_conversion &); 
# 55
no select_system(const any_conversion &, const any_conversion &); 
# 56
no select_system(const any_conversion &, const any_conversion &, const any_conversion &); 
# 57
no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &); 
# 58
no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &); 
# 59
no select_system(const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &, const any_conversion &); 
# 61
template< class T> yes check(const T &); 
# 63
no check(no); 
# 65
template< class Tag> 
# 66
struct select_system1_exists { 
# 68
static Tag &tag; 
# 70
static const bool value = (sizeof(check(select_system(tag))) == sizeof(yes)); 
# 71
}; 
# 73
template< class Tag1, class Tag2> 
# 74
struct select_system2_exists { 
# 76
static Tag1 &tag1; 
# 77
static Tag2 &tag2; 
# 79
static const bool value = (sizeof(check(select_system(tag1, tag2))) == sizeof(yes)); 
# 80
}; 
# 82
template< class Tag1, class Tag2, class Tag3> 
# 83
struct select_system3_exists { 
# 85
static Tag1 &tag1; 
# 86
static Tag2 &tag2; 
# 87
static Tag3 &tag3; 
# 89
static const bool value = (sizeof(check(select_system(tag1, tag2, tag3))) == sizeof(yes)); 
# 90
}; 
# 92
template< class Tag1, class Tag2, class Tag3, class Tag4> 
# 93
struct select_system4_exists { 
# 95
static Tag1 &tag1; 
# 96
static Tag2 &tag2; 
# 97
static Tag3 &tag3; 
# 98
static Tag4 &tag4; 
# 100
static const bool value = (sizeof(check(select_system(tag1, tag2, tag3, tag4))) == sizeof(yes)); 
# 101
}; 
# 103
template< class Tag1, class Tag2, class Tag3, class Tag4, class Tag5> 
# 104
struct select_system5_exists { 
# 106
static Tag1 &tag1; 
# 107
static Tag2 &tag2; 
# 108
static Tag3 &tag3; 
# 109
static Tag4 &tag4; 
# 110
static Tag5 &tag5; 
# 112
static const bool value = (sizeof(check(select_system(tag1, tag2, tag3, tag4, tag5))) == sizeof(yes)); 
# 113
}; 
# 115
template< class Tag1, class Tag2, class Tag3, class Tag4, class Tag5, class Tag6> 
# 116
struct select_system6_exists { 
# 118
static Tag1 &tag1; 
# 119
static Tag2 &tag2; 
# 120
static Tag3 &tag3; 
# 121
static Tag4 &tag4; 
# 122
static Tag5 &tag5; 
# 123
static Tag6 &tag6; 
# 125
static const bool value = (sizeof(check(select_system(tag1, tag2, tag3, tag4, tag5, tag6))) == sizeof(yes)); 
# 126
}; 
# 127
}
# 129
}
# 131
namespace generic { 
# 134
template< class Tag> 
# 135
struct select_system1_exists : public generic_type_traits_ns::select_system_exists_ns::select_system1_exists< Tag>  { 
# 137
}; 
# 139
template< class Tag1, class Tag2> 
# 140
struct select_system2_exists : public generic_type_traits_ns::select_system_exists_ns::select_system2_exists< Tag1, Tag2>  { 
# 142
}; 
# 144
template< class Tag1, class Tag2, class Tag3> 
# 145
struct select_system3_exists : public generic_type_traits_ns::select_system_exists_ns::select_system3_exists< Tag1, Tag2, Tag3>  { 
# 147
}; 
# 149
template< class Tag1, class Tag2, class Tag3, class Tag4> 
# 150
struct select_system4_exists : public generic_type_traits_ns::select_system_exists_ns::select_system4_exists< Tag1, Tag2, Tag3, Tag4>  { 
# 152
}; 
# 154
template< class Tag1, class Tag2, class Tag3, class Tag4, class Tag5> 
# 155
struct select_system5_exists : public generic_type_traits_ns::select_system_exists_ns::select_system5_exists< Tag1, Tag2, Tag3, Tag4, Tag5>  { 
# 157
}; 
# 159
template< class Tag1, class Tag2, class Tag3, class Tag4, class Tag5, class Tag6> 
# 160
struct select_system6_exists : public generic_type_traits_ns::select_system_exists_ns::select_system6_exists< Tag1, Tag2, Tag3, Tag4, Tag5, Tag6>  { 
# 162
}; 
# 164
}
# 165
}
# 166
}
# 167
}
# 27 "/usr/local/cuda/include/thrust/system/detail/generic/select_system.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace detail { 
# 33
namespace generic { 
# 35
namespace select_system_detail { 
# 40
template< class System> System &
# 42
min_system(execution_policy< System>  &system1, execution_policy< System>  &) 
# 44
{ 
# 45
return thrust::detail::derived_cast(system1); 
# 46
} 
# 50
template< class System1, class System2> typename thrust::detail::enable_if< thrust::detail::is_same< System1, typename thrust::detail::minimum_system< System1, System2> ::type> ::value, System1 &> ::type 
# 59
min_system(execution_policy< System1>  &system1, execution_policy< System2>  &) 
# 60
{ 
# 61
return thrust::detail::derived_cast(system1); 
# 62
} 
# 66
template< class System1, class System2> typename thrust::detail::enable_if< thrust::detail::is_same< System2, typename thrust::detail::minimum_system< System1, System2> ::type> ::value, System2 &> ::type 
# 75
min_system(execution_policy< System1>  &, execution_policy< System2>  &system2) 
# 76
{ 
# 77
return thrust::detail::derived_cast(system2); 
# 78
} 
# 81
}
# 84
template< class System> typename thrust::detail::disable_if< select_system1_exists< System> ::value, System &> ::type 
# 90
select_system(execution_policy< System>  &system) 
# 91
{ 
# 92
return thrust::detail::derived_cast(system); 
# 93
} 
# 96
template< class System1, class System2> typename thrust::detail::enable_if_defined< thrust::detail::minimum_system< System1, System2> > ::type &
# 101
select_system(execution_policy< System1>  &system1, execution_policy< System2>  &
# 102
system2) 
# 103
{ 
# 104
return select_system_detail::min_system(system1, system2); 
# 105
} 
# 108
template< class System1, class System2, class System3> typename thrust::detail::lazy_disable_if< select_system3_exists< System1, System2, System3> ::value, thrust::detail::minimum_system< System1, System2, System3> > ::type &
# 114
select_system(execution_policy< System1>  &system1, execution_policy< System2>  &
# 115
system2, execution_policy< System3>  &
# 116
system3) 
# 117
{ 
# 118
return select_system(select_system(system1, system2), system3); 
# 119
} 
# 122
template< class System1, class System2, class System3, class System4> typename thrust::detail::lazy_disable_if< select_system4_exists< System1, System2, System3, System4> ::value, thrust::detail::minimum_system< System1, System2, System3, System4> > ::type &
# 128
select_system(execution_policy< System1>  &system1, execution_policy< System2>  &
# 129
system2, execution_policy< System3>  &
# 130
system3, execution_policy< System4>  &
# 131
system4) 
# 132
{ 
# 133
return select_system(select_system(system1, system2, system3), system4); 
# 134
} 
# 137
template< class System1, class System2, class System3, class System4, class System5> typename thrust::detail::lazy_disable_if< select_system5_exists< System1, System2, System3, System4, System5> ::value, thrust::detail::minimum_system< System1, System2, System3, System4, System5> > ::type &
# 143
select_system(execution_policy< System1>  &system1, execution_policy< System2>  &
# 144
system2, execution_policy< System3>  &
# 145
system3, execution_policy< System4>  &
# 146
system4, execution_policy< System5>  &
# 147
system5) 
# 148
{ 
# 149
return select_system(select_system(system1, system2, system3, system4), system5); 
# 150
} 
# 153
template< class System1, class System2, class System3, class System4, class System5, class System6> typename thrust::detail::lazy_disable_if< select_system6_exists< System1, System2, System3, System4, System5, System6> ::value, thrust::detail::minimum_system< System1, System2, System3, System4, System5, System6> > ::type &
# 159
select_system(execution_policy< System1>  &system1, execution_policy< System2>  &
# 160
system2, execution_policy< System3>  &
# 161
system3, execution_policy< System4>  &
# 162
system4, execution_policy< System5>  &
# 163
system5, execution_policy< System6>  &
# 164
system6) 
# 165
{ 
# 166
return select_system(select_system(system1, system2, system3, system4, system5), system6); 
# 167
} 
# 172
inline device_system_tag select_system(any_system_tag) 
# 173
{ 
# 174
return device_system_tag(); 
# 175
} 
# 178
}
# 179
}
# 180
}
# 181
}
# 26 "/usr/local/cuda/include/thrust/system/detail/generic/tag.h"
namespace thrust { 
# 28
namespace system { 
# 30
namespace detail { 
# 32
namespace generic { 
# 37
struct tag { 
# 39
template< class T> 
# 41
tag(const T &) { } 
# 42
}; 
# 44
}
# 45
}
# 46
}
# 47
}
# 67 "/usr/include/c++/5/bits/stl_relops.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
namespace rel_ops { 
# 85
template< class _Tp> inline bool 
# 87
operator!=(const _Tp &__x, const _Tp &__y) 
# 88
{ return !(__x == __y); } 
# 98
template< class _Tp> inline bool 
# 100
operator>(const _Tp &__x, const _Tp &__y) 
# 101
{ return __y < __x; } 
# 111
template< class _Tp> inline bool 
# 113
operator<=(const _Tp &__x, const _Tp &__y) 
# 114
{ return !(__y < __x); } 
# 124
template< class _Tp> inline bool 
# 126
operator>=(const _Tp &__x, const _Tp &__y) 
# 127
{ return !(__x < __y); } 
# 130
}
# 132
}
# 26 "/usr/local/cuda/include/thrust/pair.h"
namespace thrust { 
# 48
template< class T1, class T2> 
# 49
struct pair { 
# 53
typedef T1 first_type; 
# 57
typedef T2 second_type; 
# 61
first_type first; 
# 65
second_type second; 
# 71
pair(); 
# 79
inline pair(const T1 & x, const T2 & y); 
# 90
template< class U1, class U2> inline pair(const thrust::pair< U1, U2>  & p); 
# 103
template< class U1, class U2> inline pair(const std::pair< U1, U2>  & p); 
# 112
inline void swap(pair & p); 
# 113
}; 
# 125
template< class T1, class T2> inline bool operator==(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 139
template< class T1, class T2> inline bool operator<(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 153
template< class T1, class T2> inline bool operator!=(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 167
template< class T1, class T2> inline bool operator>(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 181
template< class T1, class T2> inline bool operator<=(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 195
template< class T1, class T2> inline bool operator>=(const pair< T1, T2>  & x, const pair< T1, T2>  & y); 
# 205
template< class T1, class T2> inline void swap(pair< T1, T2>  & x, pair< T1, T2>  & y); 
# 219
template< class T1, class T2> inline pair< T1, T2>  make_pair(T1 x, T2 y); 
# 231
template< int N, class T> struct tuple_element; 
# 240
template< class Pair> struct tuple_size; 
# 280
}
# 22 "/usr/local/cuda/include/thrust/detail/swap.h"
namespace thrust { 
# 26
template< class Assignable1, class Assignable2> inline void 
# 28
swap(Assignable1 &a, Assignable2 &b) 
# 29
{ 
# 30
Assignable1 temp = a; 
# 31
a = b; 
# 32
b = temp; 
# 33
} 
# 35
}
# 20 "/usr/local/cuda/include/thrust/detail/pair.inl"
namespace thrust { 
# 23
template< class T1, class T2> 
# 25
pair< T1, T2> ::pair() : first(), second() 
# 27
{ 
# 28
; 
# 29
} 
# 32
template< class T1, class T2> inline 
# 34
pair< T1, T2> ::pair(const T1 &x, const T2 &y) : first(x), second(y) 
# 36
{ 
# 37
; 
# 38
} 
# 41
template< class T1, class T2> 
# 42
template< class U1, class U2> inline 
# 44
pair< T1, T2> ::pair(const thrust::pair< U1, U2>  &p) : first((p.first)), second((p.second)) 
# 46
{ 
# 47
; 
# 48
} 
# 51
template< class T1, class T2> 
# 52
template< class U1, class U2> inline 
# 54
pair< T1, T2> ::pair(const std::pair< U1, U2>  &p) : first((p.first)), second((p.second)) 
# 56
{ 
# 57
; 
# 58
} 
# 61
template< class T1, class T2> inline void 
# 64
pair< T1, T2> ::swap(pair &p) 
# 65
{ 
# 66
using thrust::swap;
# 68
swap(first, p.first); 
# 69
swap(second, p.second); 
# 70
} 
# 73
template< class T1, class T2> inline bool 
# 75
operator==(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 76
{ 
# 77
return ((x.first) == (y.first)) && ((x.second) == (y.second)); 
# 78
} 
# 81
template< class T1, class T2> inline bool 
# 83
operator<(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 84
{ 
# 85
return ((x.first) < (y.first)) || ((!((y.first) < (x.first))) && ((x.second) < (y.second))); 
# 86
} 
# 89
template< class T1, class T2> inline bool 
# 91
operator!=(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 92
{ 
# 93
return !(x == y); 
# 94
} 
# 97
template< class T1, class T2> inline bool 
# 99
operator>(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 100
{ 
# 101
return y < x; 
# 102
} 
# 105
template< class T1, class T2> inline bool 
# 107
operator<=(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 108
{ 
# 109
return !(y < x); 
# 110
} 
# 113
template< class T1, class T2> inline bool 
# 115
operator>=(const pair< T1, T2>  &x, const pair< T1, T2>  &y) 
# 116
{ 
# 117
return !(x < y); 
# 118
} 
# 121
template< class T1, class T2> inline void 
# 123
swap(pair< T1, T2>  &x, pair< T1, T2>  &y) 
# 124
{ 
# 125
return (x.swap(y)); 
# 126
} 
# 129
template< class T1, class T2> inline pair< T1, T2>  
# 131
make_pair(T1 x, T2 y) 
# 132
{ 
# 133
return pair< T1, T2> (x, y); 
# 134
} 
# 138
template< class T1, class T2> 
# 139
struct tuple_element< 0, pair< T1, T2> >  { 
# 141
typedef T1 type; 
# 142
}; 
# 144
template< class T1, class T2> 
# 145
struct tuple_element< 1, pair< T1, T2> >  { 
# 147
typedef T2 type; 
# 148
}; 
# 152
template< class T1, class T2> 
# 153
struct tuple_size< pair< T1, T2> >  { 
# 155
static const unsigned value = (2); 
# 156
}; 
# 160
namespace detail { 
# 164
template< int N, class Pair> struct pair_get { }; 
# 166
template< class Pair> 
# 167
struct pair_get< 0, Pair>  { 
# 171
const typename tuple_element< 0, Pair> ::type &operator()(const Pair &p) const 
# 172
{ 
# 173
return p.first; 
# 174
} 
# 178
typename tuple_element< 0, Pair> ::type &operator()(Pair &p) const 
# 179
{ 
# 180
return p.first; 
# 181
} 
# 182
}; 
# 185
template< class Pair> 
# 186
struct pair_get< 1, Pair>  { 
# 190
const typename tuple_element< 1, Pair> ::type &operator()(const Pair &p) const 
# 191
{ 
# 192
return p.second; 
# 193
} 
# 197
typename tuple_element< 1, Pair> ::type &operator()(Pair &p) const 
# 198
{ 
# 199
return p.second; 
# 200
} 
# 201
}; 
# 203
}
# 207
template< unsigned N, class T1, class T2> inline typename tuple_element< N, pair< T1, T2> > ::type &
# 210
get(pair< T1, T2>  &p) 
# 211
{ 
# 212
return detail::pair_get< N, pair< T1, T2> > ()(p); 
# 213
} 
# 215
template< unsigned N, class T1, class T2> inline const typename tuple_element< N, pair< T1, T2> > ::type &
# 218
get(const pair< T1, T2>  &p) 
# 219
{ 
# 220
return detail::pair_get< N, pair< T1, T2> > ()(p); 
# 221
} 
# 224
}
# 33 "/usr/local/cuda/include/thrust/system/detail/generic/memory.h"
namespace thrust { 
# 35
namespace system { 
# 37
namespace detail { 
# 39
namespace generic { 
# 42
template< class DerivedPolicy, class Size> void malloc(execution_policy< DerivedPolicy>  &, Size); 
# 46
template< class T, class DerivedPolicy> pointer< T, DerivedPolicy, use_default, use_default>  malloc(execution_policy< DerivedPolicy>  & s, std::size_t n); 
# 50
template< class DerivedPolicy, class Pointer> void free(execution_policy< DerivedPolicy>  &, Pointer); 
# 54
template< class Pointer1, class Pointer2> void assign_value(tag, Pointer1, Pointer2); 
# 58
template< class DerivedPolicy, class Pointer> void get_value(execution_policy< DerivedPolicy>  &, Pointer); 
# 62
template< class Pointer1, class Pointer2> void iter_swap(tag, Pointer1, Pointer2); 
# 66
}
# 67
}
# 68
}
# 69
}
# 22 "/usr/local/cuda/include/thrust/detail/raw_pointer_cast.h"
namespace thrust { 
# 25
template< class Pointer> inline typename detail::pointer_traits< Pointer> ::raw_pointer 
# 27
raw_pointer_cast(const Pointer &ptr) 
# 28
{ 
# 29
return thrust::detail::pointer_traits< Pointer> ::get(ptr); 
# 30
} 
# 32
}
# 24 "/usr/local/cuda/include/thrust/system/detail/sequential/malloc_and_free.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace sequential { 
# 34
template< class DerivedPolicy> inline void *
# 36
malloc(execution_policy< DerivedPolicy>  &, std::size_t n) 
# 37
{ 
# 39
return std::malloc(n); 
# 43
} 
# 46
template< class DerivedPolicy, class Pointer> inline void 
# 48
free(execution_policy< DerivedPolicy>  &, Pointer ptr) 
# 49
{ 
# 51
std::free(thrust::raw_pointer_cast(ptr)); 
# 53
} 
# 56
}
# 57
}
# 58
}
# 59
}
# 27 "/usr/local/cuda/include/thrust/system/detail/errno.h"
namespace thrust { 
# 30
namespace system { 
# 33
namespace detail { 
# 36
static const int eafnosupport = 9901; 
# 37
static const int eaddrinuse = 9902; 
# 38
static const int eaddrnotavail = 9903; 
# 39
static const int eisconn = 9904; 
# 40
static const int ebadmsg = 9905; 
# 41
static const int econnaborted = 9906; 
# 42
static const int ealready = 9907; 
# 43
static const int econnrefused = 9908; 
# 44
static const int econnreset = 9909; 
# 45
static const int edestaddrreq = 9910; 
# 46
static const int ehostunreach = 9911; 
# 47
static const int eidrm = 9912; 
# 48
static const int emsgsize = 9913; 
# 49
static const int enetdown = 9914; 
# 50
static const int enetreset = 9915; 
# 51
static const int enetunreach = 9916; 
# 52
static const int enobufs = 9917; 
# 53
static const int enolink = 9918; 
# 54
static const int enodata = 9919; 
# 55
static const int enomsg = 9920; 
# 56
static const int enoprotoopt = 9921; 
# 57
static const int enosr = 9922; 
# 58
static const int enotsock = 9923; 
# 59
static const int enostr = 9924; 
# 60
static const int enotconn = 9925; 
# 61
static const int enotsup = 9926; 
# 62
static const int ecanceled = 9927; 
# 63
static const int einprogress = 9928; 
# 64
static const int eopnotsupp = 9929; 
# 65
static const int ewouldblock = 9930; 
# 66
static const int eownerdead = 9931; 
# 67
static const int eproto = 9932; 
# 68
static const int eprotonosupport = 9933; 
# 69
static const int enotrecoverable = 9934; 
# 70
static const int etime = 9935; 
# 71
static const int etxtbsy = 9936; 
# 72
static const int etimedout = 9938; 
# 73
static const int eloop = 9939; 
# 74
static const int eoverflow = 9940; 
# 75
static const int eprototype = 9941; 
# 76
static const int enosys = 9942; 
# 77
static const int einval = 9943; 
# 78
static const int erange = 9944; 
# 79
static const int eilseq = 9945; 
# 80
static const int e2big = 9946; 
# 81
static const int edom = 9947; 
# 82
static const int efault = 9948; 
# 83
static const int ebadf = 9949; 
# 84
static const int epipe = 9950; 
# 85
static const int exdev = 9951; 
# 86
static const int ebusy = 9952; 
# 87
static const int enotempty = 9953; 
# 88
static const int enoexec = 9954; 
# 89
static const int eexist = 9955; 
# 90
static const int efbig = 9956; 
# 91
static const int enametoolong = 9957; 
# 92
static const int enotty = 9958; 
# 93
static const int eintr = 9959; 
# 94
static const int espipe = 9960; 
# 95
static const int eio = 9961; 
# 96
static const int eisdir = 9962; 
# 97
static const int echild = 9963; 
# 98
static const int enolck = 9964; 
# 99
static const int enospc = 9965; 
# 100
static const int enxio = 9966; 
# 101
static const int enodev = 9967; 
# 102
static const int enoent = 9968; 
# 103
static const int esrch = 9969; 
# 104
static const int enotdir = 9970; 
# 105
static const int enomem = 9971; 
# 106
static const int eperm = 9972; 
# 107
static const int eacces = 9973; 
# 108
static const int erofs = 9974; 
# 109
static const int edeadlk = 9975; 
# 110
static const int eagain = 9976; 
# 111
static const int enfile = 9977; 
# 112
static const int emfile = 9978; 
# 113
static const int emlink = 9979; 
# 115
}
# 117
}
# 119
}
# 42 "/usr/include/c++/5/iostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 60
extern istream cin; 
# 61
extern ostream cout; 
# 62
extern ostream cerr; 
# 63
extern ostream clog; 
# 66
extern wistream wcin; 
# 67
extern wostream wcout; 
# 68
extern wostream wcerr; 
# 69
extern wostream wclog; 
# 74
static ios_base::Init __ioinit; 
# 77
}
# 30 "/usr/local/cuda/include/thrust/system/error_code.h"
namespace thrust { 
# 33
namespace system { 
# 41
class error_condition; 
# 42
class error_code; 
# 46
template< class T> struct is_error_code_enum : public thrust::detail::false_type { }; 
# 50
template< class T> struct is_error_condition_enum : public thrust::detail::false_type { }; 
# 54
namespace errc { 
# 57
enum errc_t { 
# 59
address_family_not_supported = 9901, 
# 60
address_in_use, 
# 61
address_not_available, 
# 62
already_connected, 
# 63
argument_list_too_long = 9946, 
# 64
argument_out_of_domain, 
# 65
bad_address, 
# 66
bad_file_descriptor, 
# 67
bad_message = 9905, 
# 68
broken_pipe = 9950, 
# 69
connection_aborted = 9906, 
# 70
connection_already_in_progress, 
# 71
connection_refused, 
# 72
connection_reset, 
# 73
cross_device_link = 9951, 
# 74
destination_address_required = 9910, 
# 75
device_or_resource_busy = 9952, 
# 76
directory_not_empty, 
# 77
executable_format_error, 
# 78
file_exists, 
# 79
file_too_large, 
# 80
filename_too_long, 
# 81
function_not_supported = 9942, 
# 82
host_unreachable = 9911, 
# 83
identifier_removed, 
# 84
illegal_byte_sequence = 9945, 
# 85
inappropriate_io_control_operation = 9958, 
# 86
interrupted, 
# 87
invalid_argument = 9943, 
# 88
invalid_seek = 9960, 
# 89
io_error, 
# 90
is_a_directory, 
# 91
message_size = 9913, 
# 92
network_down, 
# 93
network_reset, 
# 94
network_unreachable, 
# 95
no_buffer_space, 
# 96
no_child_process = 9963, 
# 97
no_link = 9918, 
# 98
no_lock_available = 9964, 
# 99
no_message_available = 9919, 
# 100
no_message, 
# 101
no_protocol_option, 
# 102
no_space_on_device = 9965, 
# 103
no_stream_resources = 9922, 
# 104
no_such_device_or_address = 9966, 
# 105
no_such_device, 
# 106
no_such_file_or_directory, 
# 107
no_such_process, 
# 108
not_a_directory, 
# 109
not_a_socket = 9923, 
# 110
not_a_stream, 
# 111
not_connected, 
# 112
not_enough_memory = 9971, 
# 113
not_supported = 9926, 
# 114
operation_canceled, 
# 115
operation_in_progress, 
# 116
operation_not_permitted = 9972, 
# 117
operation_not_supported = 9929, 
# 118
operation_would_block, 
# 119
owner_dead, 
# 120
permission_denied = 9973, 
# 121
protocol_error = 9932, 
# 122
protocol_not_supported, 
# 123
read_only_file_system = 9974, 
# 124
resource_deadlock_would_occur, 
# 125
resource_unavailable_try_again, 
# 126
result_out_of_range = 9944, 
# 127
state_not_recoverable = 9934, 
# 128
stream_timeout, 
# 129
text_file_busy, 
# 130
timed_out = 9938, 
# 131
too_many_files_open_in_system = 9977, 
# 132
too_many_files_open, 
# 133
too_many_links, 
# 134
too_many_symbolic_link_levels = 9939, 
# 135
value_too_large, 
# 136
wrong_protocol_type
# 137
}; 
# 139
}
# 144
template<> struct is_error_condition_enum< errc::errc_t>  : public thrust::detail::true_type { }; 
# 154
class error_category { 
# 159
public: inline virtual ~error_category(); 
# 167
inline virtual const char *name() const = 0; 
# 171
inline virtual error_condition default_error_condition(int ev) const; 
# 175
inline virtual bool equivalent(int code, const error_condition & condition) const; 
# 179
inline virtual bool equivalent(const error_code & code, int condition) const; 
# 183
virtual std::__cxx11::string message(int ev) const = 0; 
# 187
inline bool operator==(const error_category & rhs) const; 
# 191
inline bool operator!=(const error_category & rhs) const; 
# 196
inline bool operator<(const error_category & rhs) const; 
# 197
}; 
# 208
inline const error_category &generic_category(); 
# 222
inline const error_category &system_category(); 
# 232
class error_code { 
# 240
public: inline error_code(); 
# 245
inline error_code(int val, const error_category & cat); 
# 250
template< class ErrorCodeEnum> error_code(ErrorCodeEnum e, typename thrust::detail::enable_if< is_error_code_enum< ErrorCodeEnum> ::value> ::type * = 0); 
# 262
inline void assign(int val, const error_category & cat); 
# 266
template< class ErrorCodeEnum> typename thrust::detail::enable_if< is_error_code_enum< ErrorCodeEnum> ::value, error_code> ::type &operator=(ErrorCodeEnum e); 
# 277
inline void clear(); 
# 283
inline int value() const; 
# 287
inline const error_category &category() const; 
# 291
inline error_condition default_error_condition() const; 
# 295
inline std::__cxx11::string message() const; 
# 302
inline operator bool() const; 
# 307
private: int m_val; 
# 308
const error_category *m_cat; 
# 311
}; 
# 320
inline error_code make_error_code(errc::errc_t e); 
# 325
inline bool operator<(const error_code & lhs, const error_code & rhs); 
# 330
template< class charT, class traits> std::basic_ostream< charT, traits>  &operator<<(std::basic_ostream< charT, traits>  & os, const error_code & ec); 
# 344
class error_condition { 
# 353
public: inline error_condition(); 
# 359
inline error_condition(int val, const error_category & cat); 
# 366
template< class ErrorConditionEnum> error_condition(ErrorConditionEnum e, typename thrust::detail::enable_if< is_error_condition_enum< ErrorConditionEnum> ::value> ::type * = 0); 
# 382
inline void assign(int val, const error_category & cat); 
# 390
template< class ErrorConditionEnum> typename thrust::detail::enable_if< is_error_condition_enum< ErrorConditionEnum> ::value, error_condition> ::type &operator=(ErrorConditionEnum e); 
# 403
inline void clear(); 
# 409
inline int value() const; 
# 413
inline const error_category &category() const; 
# 417
inline std::__cxx11::string message() const; 
# 424
inline operator bool() const; 
# 430
private: int m_val; 
# 431
const error_category *m_cat; 
# 435
}; 
# 444
inline error_condition make_error_condition(errc::errc_t e); 
# 449
inline bool operator<(const error_condition & lhs, const error_condition & rhs); 
# 457
inline bool operator==(const error_code & lhs, const error_code & rhs); 
# 462
inline bool operator==(const error_code & lhs, const error_condition & rhs); 
# 467
inline bool operator==(const error_condition & lhs, const error_code & rhs); 
# 472
inline bool operator==(const error_condition & lhs, const error_condition & rhs); 
# 477
inline bool operator!=(const error_code & lhs, const error_code & rhs); 
# 482
inline bool operator!=(const error_code & lhs, const error_condition & rhs); 
# 487
inline bool operator!=(const error_condition & lhs, const error_code & rhs); 
# 492
inline bool operator!=(const error_condition & lhs, const error_condition & rhs); 
# 498
}
# 502
using system::error_category;
# 503
using system::error_code;
# 504
using system::error_condition;
# 505
using system::is_error_code_enum;
# 506
using system::is_error_condition_enum;
# 507
using system::make_error_code;
# 508
using system::make_error_condition;
# 511
namespace errc = system::errc;
# 513
using system::generic_category;
# 514
using system::system_category;
# 516
}
# 20 "/usr/local/cuda/include/thrust/detail/tuple.inl"
namespace thrust { 
# 24
struct null_type { }; 
# 28
inline bool operator==(const null_type &, const null_type &) { return true; } 
# 31
inline bool operator>=(const null_type &, const null_type &) { return true; } 
# 34
inline bool operator<=(const null_type &, const null_type &) { return true; } 
# 37
inline bool operator!=(const null_type &, const null_type &) { return false; } 
# 40
inline bool operator<(const null_type &, const null_type &) { return false; } 
# 43
inline bool operator>(const null_type &, const null_type &) { return false; } 
# 46
template< class 
# 47
T0 = null_type, class T1 = null_type, class T2 = null_type, class 
# 48
T3 = null_type, class T4 = null_type, class T5 = null_type, class 
# 49
T6 = null_type, class T7 = null_type, class T8 = null_type, class 
# 50
T9 = null_type> class tuple; 
# 54
template< int i, class T> struct tuple_element; 
# 57
template< class T> 
# 58
struct tuple_element< 0, T>  { 
# 60
typedef typename T::head_type type; 
# 61
}; 
# 63
template< int N, class T> 
# 64
struct tuple_element< N, const T>  { 
# 67
private: typedef typename T::tail_type Next; 
# 68
typedef typename thrust::tuple_element< N - 1, typename T::tail_type> ::type unqualified_type; 
# 71
public: typedef typename detail::add_const< typename thrust::tuple_element< N - 1, typename T::tail_type> ::type> ::type type; 
# 72
}; 
# 74
template< class T> 
# 75
struct tuple_element< 0, const T>  { 
# 77
typedef typename detail::add_const< typename T::head_type> ::type type; 
# 78
}; 
# 83
template< class T> struct tuple_size; 
# 87
template<> struct tuple_size< tuple<> >  { 
# 89
static const int value = 0; 
# 90
}; 
# 93
template<> struct tuple_size< null_type>  { 
# 95
static const int value = 0; 
# 96
}; 
# 101
namespace detail { 
# 104
template< class HT, class TT> struct cons; 
# 106
}
# 110
template< class T> struct access_traits { 
# 112
typedef const T &const_type; 
# 113
typedef T &non_const_type; 
# 115
typedef const typename detail::remove_cv< T> ::type &parameter_type; 
# 122
}; 
# 124
template< class T> struct access_traits< T &>  { 
# 126
typedef T &const_type; 
# 127
typedef T &non_const_type; 
# 129
typedef T &parameter_type; 
# 130
}; 
# 133
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::non_const_type get(detail::cons< HT, TT>  & c); 
# 142
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::const_type get(const detail::cons< HT, TT>  & c); 
# 151
namespace detail { 
# 156
template< class T> class generate_error; 
# 162
template< int N> 
# 163
struct get_class { 
# 165
template< class RET, class HT, class TT> static RET 
# 167
get(const cons< HT, TT>  &t) 
# 168
{ 
# 171
return detail::get_class< N - 1> ::template get< RET> ((t.tail)); 
# 175
} 
# 177
template< class RET, class HT, class TT> static RET 
# 179
get(cons< HT, TT>  &t) 
# 180
{ 
# 183
return detail::get_class< N - 1> ::template get< RET> ((t.tail)); 
# 187
} 
# 188
}; 
# 191
template<> struct get_class< 0>  { 
# 193
template< class RET, class HT, class TT> static RET 
# 195
get(const cons< HT, TT>  &t) 
# 196
{ 
# 197
return t.head; 
# 198
} 
# 200
template< class RET, class HT, class TT> static RET 
# 202
get(cons< HT, TT>  &t) 
# 203
{ 
# 204
return t.head; 
# 205
} 
# 206
}; 
# 209
template< bool If, class Then, class Else> struct IF { 
# 211
typedef Then RET; 
# 212
}; 
# 214
template< class Then, class Else> struct IF< false, Then, Else>  { 
# 216
typedef Else RET; 
# 217
}; 
# 225
template< class T> class non_storeable_type { 
# 228
non_storeable_type(); 
# 229
}; 
# 231
template< class T> struct wrap_non_storeable_type { 
# 238
typedef T type; 
# 239
}; 
# 241
template<> struct wrap_non_storeable_type< void>  { 
# 243
typedef non_storeable_type< void>  type; 
# 244
}; 
# 247
template< class HT, class TT> 
# 248
struct cons { 
# 250
typedef HT head_type; 
# 251
typedef TT tail_type; 
# 254
typedef typename wrap_non_storeable_type< HT> ::type stored_head_type; 
# 256
stored_head_type head; 
# 257
tail_type tail; 
# 261
typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::non_const_type get_head() { return head; } 
# 265
typename access_traits< TT> ::non_const_type get_tail() { return tail; } 
# 269
typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::const_type get_head() const { return head; } 
# 273
typename access_traits< TT> ::const_type get_tail() const { return tail; } 
# 276
cons() : head(), tail() { } 
# 285
cons(typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::parameter_type h, const tail_type &
# 286
t) : head(h), tail(t) 
# 287
{ } 
# 289
template< class T1, class T2, class T3, class T4, class T5, class 
# 290
T6, class T7, class T8, class T9, class T10> 
# 292
cons(T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &
# 293
t6, T7 &t7, T8 &t8, T9 &t9, T10 &t10) : head(t1), tail(t2, t3, t4, t5, t6, t7, t8, t9, t10, static_cast< const null_type &>(null_type())) 
# 296
{ } 
# 298
template< class T2, class T3, class T4, class T5, class 
# 299
T6, class T7, class T8, class T9, class T10> 
# 301
cons(const null_type &, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &
# 302
t6, T7 &t7, T8 &t8, T9 &t9, T10 &t10) : head(), tail(t2, t3, t4, t5, t6, t7, t8, t9, t10, static_cast< const null_type &>(null_type())) 
# 305
{ } 
# 308
template< class HT2, class TT2> 
# 310
cons(const detail::cons< HT2, TT2>  &u) : head((u.head)), tail((u.tail)) { } 
# 312
template< class HT2, class TT2> cons &
# 314
operator=(const detail::cons< HT2, TT2>  &u) { 
# 315
(head) = (u.head); (tail) = (u.tail); return *this; 
# 316
} 
# 321
cons &operator=(const cons &u) { 
# 322
(head) = (u.head); (tail) = (u.tail); return *this; 
# 323
} 
# 334
template< int N> typename access_traits< typename tuple_element< N, cons> ::type> ::non_const_type 
# 339
get() { 
# 340
return thrust::get< N> (*this); 
# 341
} 
# 343
template< int N> typename access_traits< typename tuple_element< N, cons> ::type> ::const_type 
# 348
get() const { 
# 349
return thrust::get< N> (*this); 
# 350
} 
# 353
void swap(cons &c) 
# 354
{ 
# 355
using thrust::swap;
# 357
swap(head, c.head); 
# 358
((tail).swap(c.tail)); 
# 359
} 
# 360
}; 
# 362
template< class HT> 
# 363
struct cons< HT, null_type>  { 
# 365
typedef HT head_type; 
# 366
typedef null_type tail_type; 
# 367
typedef detail::cons< HT, null_type>  self_type; 
# 370
typedef typename wrap_non_storeable_type< HT> ::type stored_head_type; 
# 371
stored_head_type head; 
# 375
typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::non_const_type get_head() { return head; } 
# 378
null_type get_tail() { return null_type(); } 
# 382
typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::const_type get_head() const { return head; } 
# 385
null_type get_tail() const { return null_type(); } 
# 388
cons() : head() { } 
# 391
cons(typename access_traits< typename wrap_non_storeable_type< HT> ::type> ::parameter_type h, const null_type & = null_type()) : head(h) 
# 393
{ } 
# 395
template< class T1> 
# 397
cons(T1 &t1, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &) : head(t1) 
# 400
{ } 
# 403
cons(const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &, const null_type &) : head() 
# 407
{ } 
# 409
template< class HT2> 
# 411
cons(const detail::cons< HT2, null_type>  &u) : head((u.head)) { } 
# 413
template< class HT2> detail::cons< HT, null_type>  &
# 415
operator=(const detail::cons< HT2, null_type>  &u) 
# 416
{ 
# 417
(head) = (u.head); 
# 418
return *this; 
# 419
} 
# 424
detail::cons< HT, null_type>  &operator=(const detail::cons< HT, null_type>  &u) { (head) = (u.head); return *this; } 
# 426
template< int N> typename access_traits< typename tuple_element< N, detail::cons< HT, null_type> > ::type> ::non_const_type 
# 433
get() 
# 434
{ 
# 435
return thrust::get< N> (*this); 
# 436
} 
# 438
template< int N> typename access_traits< typename tuple_element< N, detail::cons< HT, null_type> > ::type> ::const_type 
# 445
get() const 
# 446
{ 
# 447
return thrust::get< N> (*this); 
# 448
} 
# 451
void swap(detail::cons< HT, null_type>  &c) 
# 452
{ 
# 453
using thrust::swap;
# 455
swap(head, c.head); 
# 456
} 
# 457
}; 
# 459
template< class T0, class T1, class T2, class T3, class T4, class 
# 460
T5, class T6, class T7, class T8, class T9> 
# 461
struct map_tuple_to_cons { 
# 466
typedef cons< T0, typename detail::map_tuple_to_cons< T1, T2, T3, T4, T5, T6, T7, T8, T9, null_type> ::type>  type; 
# 467
}; 
# 471
template<> struct map_tuple_to_cons< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  { 
# 473
typedef null_type type; 
# 474
}; 
# 492
template< class T> 
# 493
struct make_tuple_traits { 
# 494
typedef T type; 
# 502
}; 
# 516
template< class T> 
# 517
struct make_tuple_traits< T &>  { 
# 520
typedef typename generate_error< T &> ::do_not_use_with_reference_type error; 
# 521
}; 
# 527
template< class T, int n> struct make_tuple_traits< T [n]>  { 
# 528
typedef const T (&type)[n]; 
# 529
}; 
# 531
template< class T, int n> 
# 532
struct make_tuple_traits< const T [n]>  { 
# 533
typedef const T (&type)[n]; 
# 534
}; 
# 536
template< class T, int n> struct make_tuple_traits< volatile T [n]>  { 
# 537
typedef const volatile T (&type)[n]; 
# 538
}; 
# 540
template< class T, int n> 
# 541
struct make_tuple_traits< const volatile T [n]>  { 
# 542
typedef const volatile T (&type)[n]; 
# 543
}; 
# 559
template< class 
# 560
T0 = null_type, class T1 = null_type, class T2 = null_type, class 
# 561
T3 = null_type, class T4 = null_type, class T5 = null_type, class 
# 562
T6 = null_type, class T7 = null_type, class T8 = null_type, class 
# 563
T9 = null_type> 
# 565
struct make_tuple_mapper { 
# 576
typedef tuple< typename make_tuple_traits< T0> ::type, typename make_tuple_traits< T1> ::type, typename make_tuple_traits< T2> ::type, typename make_tuple_traits< T3> ::type, typename make_tuple_traits< T4> ::type, typename make_tuple_traits< T5> ::type, typename make_tuple_traits< T6> ::type, typename make_tuple_traits< T7> ::type, typename make_tuple_traits< T8> ::type, typename make_tuple_traits< T9> ::type>  type; 
# 577
}; 
# 579
}
# 582
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::non_const_type 
# 587
get(detail::cons< HT, TT>  &c) 
# 588
{ 
# 594
return detail::get_class< N> ::template get< typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::non_const_type, HT, TT> (c); 
# 601
} 
# 607
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::const_type 
# 612
get(const detail::cons< HT, TT>  &c) 
# 613
{ 
# 619
return detail::get_class< N> ::template get< typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::const_type, HT, TT> (c); 
# 626
} 
# 629
template< class T0> inline typename detail::make_tuple_mapper< T0> ::type 
# 632
make_tuple(const T0 &t0) 
# 633
{ 
# 634
typedef typename detail::make_tuple_mapper< T0> ::type t; 
# 635
return (t)t0; 
# 636
} 
# 638
template< class T0, class T1> inline typename detail::make_tuple_mapper< T0, T1> ::type 
# 641
make_tuple(const T0 &t0, const T1 &t1) 
# 642
{ 
# 643
typedef typename detail::make_tuple_mapper< T0, T1> ::type t; 
# 644
return t(t0, t1); 
# 645
} 
# 647
template< class T0, class T1, class T2> inline typename detail::make_tuple_mapper< T0, T1, T2> ::type 
# 650
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2) 
# 651
{ 
# 652
typedef typename detail::make_tuple_mapper< T0, T1, T2> ::type t; 
# 653
return t(t0, t1, t2); 
# 654
} 
# 656
template< class T0, class T1, class T2, class T3> inline typename detail::make_tuple_mapper< T0, T1, T2, T3> ::type 
# 659
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3) 
# 660
{ 
# 661
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3> ::type t; 
# 662
return t(t0, t1, t2, t3); 
# 663
} 
# 665
template< class T0, class T1, class T2, class T3, class T4> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4> ::type 
# 668
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4) 
# 669
{ 
# 670
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4> ::type t; 
# 671
return t(t0, t1, t2, t3, t4); 
# 672
} 
# 674
template< class T0, class T1, class T2, class T3, class T4, class T5> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5> ::type 
# 677
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5) 
# 678
{ 
# 679
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5> ::type t; 
# 680
return t(t0, t1, t2, t3, t4, t5); 
# 681
} 
# 683
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6> ::type 
# 686
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6) 
# 687
{ 
# 688
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6> ::type t; 
# 689
return t(t0, t1, t2, t3, t4, t5, t6); 
# 690
} 
# 692
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7> ::type 
# 695
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6, const T7 &t7) 
# 696
{ 
# 697
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7> ::type t; 
# 698
return t(t0, t1, t2, t3, t4, t5, t6, t7); 
# 699
} 
# 701
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8> ::type 
# 704
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6, const T7 &t7, const T8 &t8) 
# 705
{ 
# 706
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8> ::type t; 
# 707
return t(t0, t1, t2, t3, t4, t5, t6, t7, t8); 
# 708
} 
# 710
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type 
# 713
make_tuple(const T0 &t0, const T1 &t1, const T2 &t2, const T3 &t3, const T4 &t4, const T5 &t5, const T6 &t6, const T7 &t7, const T8 &t8, const T9 &t9) 
# 714
{ 
# 715
typedef typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type t; 
# 716
return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9); 
# 717
} 
# 720
template< class T0> inline tuple< T0 &>  
# 722
tie(T0 &t0) 
# 723
{ 
# 724
return ((tuple< T0 &> )(t0)); 
# 725
} 
# 727
template< class T0, class T1> inline tuple< T0 &, T1 &>  
# 729
tie(T0 &t0, T1 &t1) 
# 730
{ 
# 731
return tuple< T0 &, T1 &> (t0, t1); 
# 732
} 
# 734
template< class T0, class T1, class T2> inline tuple< T0 &, T1 &, T2 &>  
# 736
tie(T0 &t0, T1 &t1, T2 &t2) 
# 737
{ 
# 738
return tuple< T0 &, T1 &, T2 &> (t0, t1, t2); 
# 739
} 
# 741
template< class T0, class T1, class T2, class T3> inline tuple< T0 &, T1 &, T2 &, T3 &>  
# 743
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3) 
# 744
{ 
# 745
return tuple< T0 &, T1 &, T2 &, T3 &> (t0, t1, t2, t3); 
# 746
} 
# 748
template< class T0, class T1, class T2, class T3, class T4> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &>  
# 750
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4) 
# 751
{ 
# 752
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &> (t0, t1, t2, t3, t4); 
# 753
} 
# 755
template< class T0, class T1, class T2, class T3, class T4, class T5> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &>  
# 757
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5) 
# 758
{ 
# 759
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &> (t0, t1, t2, t3, t4, t5); 
# 760
} 
# 762
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &>  
# 764
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6) 
# 765
{ 
# 766
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &> (t0, t1, t2, t3, t4, t5, t6); 
# 767
} 
# 769
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &>  
# 771
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7) 
# 772
{ 
# 773
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &> (t0, t1, t2, t3, t4, t5, t6, t7); 
# 774
} 
# 776
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &>  
# 778
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8) 
# 779
{ 
# 780
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &> (t0, t1, t2, t3, t4, t5, t6, t7, t8); 
# 781
} 
# 783
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, T9 &>  
# 785
tie(T0 &t0, T1 &t1, T2 &t2, T3 &t3, T4 &t4, T5 &t5, T6 &t6, T7 &t7, T8 &t8, T9 &t9) 
# 786
{ 
# 787
return tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, T9 &> (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9); 
# 788
} 
# 790
template< class 
# 791
T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class 
# 792
U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7, class U8, class U9> inline void 
# 795
swap(tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  &x, tuple< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9>  &
# 796
y) 
# 797
{ 
# 798
return (x.swap(y)); 
# 799
} 
# 803
namespace detail { 
# 806
template< class T1, class T2> inline bool 
# 808
eq(const T1 &lhs, const T2 &rhs) { 
# 809
return ((lhs.get_head()) == (rhs.get_head())) && eq((lhs.get_tail()), (rhs.get_tail())); 
# 811
} 
# 813
template<> inline bool eq< null_type, null_type> (const null_type &, const null_type &) { return true; } 
# 815
template< class T1, class T2> inline bool 
# 817
neq(const T1 &lhs, const T2 &rhs) { 
# 818
return ((lhs.get_head()) != (rhs.get_head())) || neq((lhs.get_tail()), (rhs.get_tail())); 
# 820
} 
# 823
template<> inline bool neq< null_type, null_type> (const null_type &, const null_type &) { return false; } 
# 825
template< class T1, class T2> inline bool 
# 827
lt(const T1 &lhs, const T2 &rhs) { 
# 828
return ((lhs.get_head()) < (rhs.get_head())) || ((!((rhs.get_head()) < (lhs.get_head()))) && lt((lhs.get_tail()), (rhs.get_tail()))); 
# 831
} 
# 834
template<> inline bool lt< null_type, null_type> (const null_type &, const null_type &) { return false; } 
# 836
template< class T1, class T2> inline bool 
# 838
gt(const T1 &lhs, const T2 &rhs) { 
# 839
return ((lhs.get_head()) > (rhs.get_head())) || ((!((rhs.get_head()) > (lhs.get_head()))) && gt((lhs.get_tail()), (rhs.get_tail()))); 
# 842
} 
# 845
template<> inline bool gt< null_type, null_type> (const null_type &, const null_type &) { return false; } 
# 847
template< class T1, class T2> inline bool 
# 849
lte(const T1 &lhs, const T2 &rhs) { 
# 850
return ((lhs.get_head()) <= (rhs.get_head())) && ((!((rhs.get_head()) <= (lhs.get_head()))) || lte((lhs.get_tail()), (rhs.get_tail()))); 
# 853
} 
# 856
template<> inline bool lte< null_type, null_type> (const null_type &, const null_type &) { return true; } 
# 858
template< class T1, class T2> inline bool 
# 860
gte(const T1 &lhs, const T2 &rhs) { 
# 861
return ((lhs.get_head()) >= (rhs.get_head())) && ((!((rhs.get_head()) >= (lhs.get_head()))) || gte((lhs.get_tail()), (rhs.get_tail()))); 
# 864
} 
# 867
template<> inline bool gte< null_type, null_type> (const null_type &, const null_type &) { return true; } 
# 869
}
# 875
template< class T1, class T2, class S1, class S2> inline bool 
# 877
operator==(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 878
{ 
# 883
return detail::eq(lhs, rhs); 
# 884
} 
# 888
template< class T1, class T2, class S1, class S2> inline bool 
# 890
operator!=(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 891
{ 
# 896
return detail::neq(lhs, rhs); 
# 897
} 
# 900
template< class T1, class T2, class S1, class S2> inline bool 
# 902
operator<(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 903
{ 
# 908
return detail::lt(lhs, rhs); 
# 909
} 
# 912
template< class T1, class T2, class S1, class S2> inline bool 
# 914
operator>(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 915
{ 
# 920
return detail::gt(lhs, rhs); 
# 921
} 
# 924
template< class T1, class T2, class S1, class S2> inline bool 
# 926
operator<=(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 927
{ 
# 932
return detail::lte(lhs, rhs); 
# 933
} 
# 936
template< class T1, class T2, class S1, class S2> inline bool 
# 938
operator>=(const detail::cons< T1, T2>  &lhs, const detail::cons< S1, S2>  &rhs) 
# 939
{ 
# 944
return detail::gte(lhs, rhs); 
# 945
} 
# 947
}
# 37 "/usr/local/cuda/include/thrust/tuple.h"
namespace thrust { 
# 51
struct null_type; 
# 65
template< int N, class T> 
# 66
struct tuple_element { 
# 69
private: typedef typename T::tail_type Next; 
# 74
public: typedef typename thrust::tuple_element< N - 1, typename T::tail_type> ::type type; 
# 75
}; 
# 85
template< class T> 
# 86
struct tuple_size { 
# 90
static const int value = (1 + tuple_size< typename T::tail_type> ::value); 
# 91
}; 
# 118
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::non_const_type get(detail::cons< HT, TT>  & t); 
# 149
template< int N, class HT, class TT> inline typename access_traits< typename tuple_element< N, detail::cons< HT, TT> > ::type> ::const_type get(const detail::cons< HT, TT>  & t); 
# 195
template< class T0, class T1, class T2, class T3, class T4, class 
# 196
T5, class T6, class T7, class T8, class T9> 
# 197
class tuple : public detail::map_tuple_to_cons< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type { 
# 204
typedef typename ::thrust::detail::map_tuple_to_cons< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type inherited; 
# 213
public: tuple() { } 
# 220
tuple(typename access_traits< T0> ::parameter_type t0) : inherited(t0, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 230
{ } 
# 239
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 240
t1) : inherited(t0, t1, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 249
{ } 
# 255
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 256
t1, typename access_traits< T2> ::parameter_type 
# 257
t2) : inherited(t0, t1, t2, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 265
{ } 
# 268
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 269
t1, typename access_traits< T2> ::parameter_type 
# 270
t2, typename access_traits< T3> ::parameter_type 
# 271
t3) : inherited(t0, t1, t2, t3, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 278
{ } 
# 281
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 282
t1, typename access_traits< T2> ::parameter_type 
# 283
t2, typename access_traits< T3> ::parameter_type 
# 284
t3, typename access_traits< T4> ::parameter_type 
# 285
t4) : inherited(t0, t1, t2, t3, t4, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 291
{ } 
# 294
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 295
t1, typename access_traits< T2> ::parameter_type 
# 296
t2, typename access_traits< T3> ::parameter_type 
# 297
t3, typename access_traits< T4> ::parameter_type 
# 298
t4, typename access_traits< T5> ::parameter_type 
# 299
t5) : inherited(t0, t1, t2, t3, t4, t5, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 304
{ } 
# 307
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 308
t1, typename access_traits< T2> ::parameter_type 
# 309
t2, typename access_traits< T3> ::parameter_type 
# 310
t3, typename access_traits< T4> ::parameter_type 
# 311
t4, typename access_traits< T5> ::parameter_type 
# 312
t5, typename access_traits< T6> ::parameter_type 
# 313
t6) : inherited(t0, t1, t2, t3, t4, t5, t6, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 317
{ } 
# 320
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 321
t1, typename access_traits< T2> ::parameter_type 
# 322
t2, typename access_traits< T3> ::parameter_type 
# 323
t3, typename access_traits< T4> ::parameter_type 
# 324
t4, typename access_traits< T5> ::parameter_type 
# 325
t5, typename access_traits< T6> ::parameter_type 
# 326
t6, typename access_traits< T7> ::parameter_type 
# 327
t7) : inherited(t0, t1, t2, t3, t4, t5, t6, t7, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 330
{ } 
# 333
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 334
t1, typename access_traits< T2> ::parameter_type 
# 335
t2, typename access_traits< T3> ::parameter_type 
# 336
t3, typename access_traits< T4> ::parameter_type 
# 337
t4, typename access_traits< T5> ::parameter_type 
# 338
t5, typename access_traits< T6> ::parameter_type 
# 339
t6, typename access_traits< T7> ::parameter_type 
# 340
t7, typename access_traits< T8> ::parameter_type 
# 341
t8) : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 343
{ } 
# 346
tuple(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 347
t1, typename access_traits< T2> ::parameter_type 
# 348
t2, typename access_traits< T3> ::parameter_type 
# 349
t3, typename access_traits< T4> ::parameter_type 
# 350
t4, typename access_traits< T5> ::parameter_type 
# 351
t5, typename access_traits< T6> ::parameter_type 
# 352
t6, typename access_traits< T7> ::parameter_type 
# 353
t7, typename access_traits< T8> ::parameter_type 
# 354
t8, typename access_traits< T9> ::parameter_type 
# 355
t9) : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) 
# 356
{ } 
# 359
template< class U1, class U2> 
# 361
tuple(const ::thrust::detail::cons< U1, U2>  &p) : inherited(p) { } 
# 363
template< class U1, class U2> tuple &
# 365
operator=(const ::thrust::detail::cons< U1, U2>  &k) 
# 366
{ 
# 367
::thrust::detail::map_tuple_to_cons< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type::operator=(k); 
# 368
return *this; 
# 369
} 
# 377
template< class U1, class U2> tuple &
# 379
operator=(const pair< U1, U2>  &k) { 
# 381
(this->head) = (k.first); 
# 382
((this->tail).head) = (k.second); 
# 383
return *this; 
# 384
} 
# 391
void swap(tuple &t) 
# 392
{ 
# 393
inherited::swap(t); 
# 394
} 
# 395
}; 
# 401
template<> class tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  : public null_type { 
# 405
public: typedef null_type inherited; 
# 406
}; 
# 418
template< class T0> inline typename detail::make_tuple_mapper< T0> ::type make_tuple(const T0 & t0); 
# 434
template< class T0, class T1> inline typename detail::make_tuple_mapper< T0, T1> ::type make_tuple(const T0 & t0, const T1 & t1); 
# 445
template< class T0> inline tuple< T0 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  tie(T0 & t0); 
# 460
template< class T0, class T1> inline tuple< T0 &, T1 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1); 
# 469
template< class 
# 470
T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class 
# 471
U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7, class U8, class U9> inline void 
# 469
swap(tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  & x, tuple< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9>  & y); 
# 482
template< class T0, class T1, class T2> inline typename detail::make_tuple_mapper< T0, T1, T2> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2); 
# 487
template< class T0, class T1, class T2, class T3> inline typename detail::make_tuple_mapper< T0, T1, T2, T3> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3); 
# 492
template< class T0, class T1, class T2, class T3, class T4> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4); 
# 497
template< class T0, class T1, class T2, class T3, class T4, class T5> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4, const T5 & t5); 
# 502
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4, const T5 & t5, const T6 & t6); 
# 507
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4, const T5 & t5, const T6 & t6, const T7 & t7); 
# 512
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4, const T5 & t5, const T6 & t6, const T7 & t7, const T8 & t8); 
# 517
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> inline typename detail::make_tuple_mapper< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::type make_tuple(const T0 & t0, const T1 & t1, const T2 & t2, const T3 & t3, const T4 & t4, const T5 & t5, const T6 & t6, const T7 & t7, const T8 & t8, const T9 & t9); 
# 522
template< class T0, class T1, class T2> inline tuple< T0 &, T1 &, T2 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2); 
# 526
template< class T0, class T1, class T2, class T3> inline tuple< T0 &, T1 &, T2 &, T3 &, null_type, null_type, null_type, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3); 
# 530
template< class T0, class T1, class T2, class T3, class T4> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, null_type, null_type, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4); 
# 534
template< class T0, class T1, class T2, class T3, class T4, class T5> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, null_type, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5); 
# 538
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, null_type, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5, T6 & t6); 
# 542
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, null_type, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5, T6 & t6, T7 & t7); 
# 546
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, null_type>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5, T6 & t6, T7 & t7, T8 & t8); 
# 550
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> inline tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, T9 &>  tie(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5, T6 & t6, T7 & t7, T8 & t8, T9 & t9); 
# 556
inline bool operator==(const null_type &, const null_type &); 
# 559
inline bool operator>=(const null_type &, const null_type &); 
# 562
inline bool operator<=(const null_type &, const null_type &); 
# 565
inline bool operator!=(const null_type &, const null_type &); 
# 568
inline bool operator<(const null_type &, const null_type &); 
# 571
inline bool operator>(const null_type &, const null_type &); 
# 582
}
# 31 "/usr/local/cuda/include/thrust/detail/functional/value.h"
namespace thrust { 
# 33
namespace detail { 
# 35
namespace functional { 
# 39
template< class Eval> struct actor; 
# 42
template< class T> 
# 43
class value { 
# 48
public: 
# 47
template< class Env> 
# 48
struct result { 
# 50
typedef T type; 
# 51
}; 
# 54
value(const T &arg) : m_val(arg) 
# 56
{ } 
# 58
template< class Env> T 
# 60
eval(const Env &) const 
# 61
{ 
# 62
return m_val; 
# 63
} 
# 66
private: T m_val; 
# 67
}; 
# 69
template< class T> actor< value< T> >  
# 71
val(const T &x) 
# 72
{ 
# 73
return ((value< T> )(x)); 
# 74
} 
# 77
}
# 78
}
# 79
}
# 31 "/usr/local/cuda/include/thrust/detail/functional/composite.h"
namespace thrust { 
# 33
namespace detail { 
# 35
namespace functional { 
# 39
template< class Eval0, class 
# 40
Eval1 = null_type, class 
# 41
Eval2 = null_type, class 
# 42
Eval3 = null_type, class 
# 43
Eval4 = null_type, class 
# 44
Eval5 = null_type, class 
# 45
Eval6 = null_type, class 
# 46
Eval7 = null_type, class 
# 47
Eval8 = null_type, class 
# 48
Eval9 = null_type, class 
# 49
Eval10 = null_type> class composite; 
# 52
template< class Eval0, class Eval1> 
# 53
class composite< Eval0, Eval1, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  { 
# 68
public: 
# 67
template< class Env> 
# 68
struct result { 
# 74
typedef typename Eval0::template result< tuple< typename Eval1::template result< Env> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type type; 
# 75
}; 
# 78
composite(const Eval0 &e0, const Eval1 &e1) : m_eval0(e0), m_eval1(e1) 
# 81
{ } 
# 83
template< class Env> typename result< Env> ::type 
# 86
eval(const Env &x) const 
# 87
{ 
# 88
typename Eval1::template result< Env> ::type result1 = ((m_eval1).eval(x)); 
# 89
return ((m_eval0).eval(thrust::tie(result1))); 
# 90
} 
# 93
private: Eval0 m_eval0; 
# 94
Eval1 m_eval1; 
# 95
}; 
# 97
template< class Eval0, class Eval1, class Eval2> 
# 98
class composite< Eval0, Eval1, Eval2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  { 
# 113
public: 
# 112
template< class Env> 
# 113
struct result { 
# 120
typedef typename Eval0::template result< tuple< typename Eval1::template result< Env> ::type, typename Eval2::template result< Env> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type type; 
# 121
}; 
# 124
composite(const Eval0 &e0, const Eval1 &e1, const Eval2 &e2) : m_eval0(e0), m_eval1(e1), m_eval2(e2) 
# 128
{ } 
# 130
template< class Env> typename result< Env> ::type 
# 133
eval(const Env &x) const 
# 134
{ 
# 135
typename Eval1::template result< Env> ::type result1 = ((m_eval1).eval(x)); 
# 136
typename Eval2::template result< Env> ::type result2 = ((m_eval2).eval(x)); 
# 137
return ((m_eval0).eval(thrust::tie(result1, result2))); 
# 138
} 
# 141
private: Eval0 m_eval0; 
# 142
Eval1 m_eval1; 
# 143
Eval2 m_eval2; 
# 144
}; 
# 146
template< class Eval0, class Eval1> actor< composite< Eval0, Eval1> >  
# 148
compose(const Eval0 &e0, const Eval1 &e1) 
# 149
{ 
# 150
return ((actor< composite< Eval0, Eval1> > )(composite< Eval0, Eval1> (e0, e1))); 
# 151
} 
# 153
template< class Eval0, class Eval1, class Eval2> actor< composite< Eval0, Eval1, Eval2> >  
# 155
compose(const Eval0 &e0, const Eval1 &e1, const Eval2 &e2) 
# 156
{ 
# 157
return ((actor< composite< Eval0, Eval1, Eval2> > )(composite< Eval0, Eval1, Eval2> (e0, e1, e2))); 
# 158
} 
# 160
}
# 161
}
# 162
}
# 23 "/usr/local/cuda/include/thrust/detail/functional/operators/operator_adaptors.h"
namespace thrust { 
# 25
namespace detail { 
# 27
namespace functional { 
# 32
template< template< class >  class UnaryOperator> 
# 33
struct unary_operator { 
# 35
template< class Env> 
# 36
struct argument : public eval_if< tuple_size< Env> ::value == 0, identity_< null_type> , tuple_element< 0, Env> >  { 
# 43
}; 
# 45
template< class Env> 
# 46
struct operator_type { 
# 52
typedef UnaryOperator< typename remove_reference< typename argument< Env> ::type> ::type>  type; 
# 53
}; 
# 55
template< class Env> 
# 56
struct result { 
# 58
typedef typename operator_type< Env> ::type op_type; 
# 59
typedef typename operator_type< Env> ::type::result_type type; 
# 60
}; 
# 62
template< class Env> typename result< Env> ::type 
# 64
eval(const Env &e) const 
# 65
{ 
# 66
typename operator_type< Env> ::type op; 
# 67
return op(thrust::get< 0> (e)); 
# 68
} 
# 69
}; 
# 73
template< template< class >  class BinaryOperator> 
# 74
struct binary_operator { 
# 76
template< class Env> 
# 77
struct first_argument : public eval_if< tuple_size< Env> ::value == 0, identity_< null_type> , tuple_element< 0, Env> >  { 
# 84
}; 
# 86
template< class Env> 
# 87
struct operator_type { 
# 93
typedef BinaryOperator< typename remove_reference< typename first_argument< Env> ::type> ::type>  type; 
# 94
}; 
# 96
template< class Env> 
# 97
struct result { 
# 99
typedef typename operator_type< Env> ::type op_type; 
# 100
typedef typename operator_type< Env> ::type::result_type type; 
# 101
}; 
# 103
template< class Env> typename result< Env> ::type 
# 105
eval(const Env &e) const 
# 106
{ 
# 107
typename operator_type< Env> ::type op; 
# 108
return op(thrust::get< 0> (e), thrust::get< 1> (e)); 
# 109
} 
# 110
}; 
# 112
}
# 113
}
# 114
}
# 25 "/usr/local/cuda/include/thrust/detail/functional/operators/assignment_operator.h"
namespace thrust { 
# 29
template< class , class , class > struct binary_function; 
# 31
namespace detail { 
# 33
namespace functional { 
# 37
template< class > struct as_actor; 
# 40
template< class T> 
# 41
struct assign : public binary_function< T &, T, T &>  { 
# 44
T &operator()(T &lhs, const T &rhs) const { return lhs = rhs; } 
# 45
}; 
# 47
template< class Eval, class T> 
# 48
struct assign_result { 
# 56
typedef actor< composite< binary_operator< assign> , actor< Eval> , typename as_actor< T> ::type> >  type; 
# 57
}; 
# 59
template< class Eval, class T> typename assign_result< Eval, T> ::type 
# 62
do_assign(const actor< Eval>  &_1, const T &_2) 
# 63
{ 
# 64
return compose(binary_operator< assign> (), _1, as_actor< T> ::convert(_2)); 
# 67
} 
# 69
}
# 70
}
# 71
}
# 22 "/usr/local/cuda/include/thrust/detail/type_traits/function_traits.h"
namespace thrust { 
# 26
template< class T> struct plus; 
# 27
template< class T> struct multiplies; 
# 28
template< class T> struct minimum; 
# 29
template< class T> struct maximum; 
# 30
template< class T> struct logical_or; 
# 31
template< class T> struct logical_and; 
# 32
template< class T> struct bit_or; 
# 33
template< class T> struct bit_and; 
# 34
template< class T> struct bit_xor; 
# 36
namespace detail { 
# 42
template< class T> struct has_result_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::result_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 44
template< class T> struct has_argument_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::argument_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 46
template< class T> struct has_first_argument_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::first_argument_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 48
template< class T> struct has_second_argument_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::second_argument_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 51
template< class AdaptableBinaryFunction> 
# 52
struct result_type { 
# 54
typedef typename AdaptableBinaryFunction::result_type type; 
# 55
}; 
# 58
template< class T> 
# 59
struct is_adaptable_unary_function : public and_< has_result_type< T> , has_argument_type< T> >  { 
# 64
}; 
# 67
template< class T> 
# 68
struct is_adaptable_binary_function : public and_< has_result_type< T> , and_< has_first_argument_type< T> , has_second_argument_type< T> > >  { 
# 76
}; 
# 79
template< class BinaryFunction> 
# 80
struct is_commutative : public false_type { 
# 82
}; 
# 84
template< class T> struct is_commutative< plus< T> >  : public is_arithmetic< T>  { }; 
# 85
template< class T> struct is_commutative< multiplies< T> >  : public is_arithmetic< T>  { }; 
# 86
template< class T> struct is_commutative< minimum< T> >  : public is_arithmetic< T>  { }; 
# 87
template< class T> struct is_commutative< maximum< T> >  : public is_arithmetic< T>  { }; 
# 88
template< class T> struct is_commutative< logical_or< T> >  : public is_arithmetic< T>  { }; 
# 89
template< class T> struct is_commutative< logical_and< T> >  : public is_arithmetic< T>  { }; 
# 90
template< class T> struct is_commutative< bit_or< T> >  : public is_arithmetic< T>  { }; 
# 91
template< class T> struct is_commutative< bit_and< T> >  : public is_arithmetic< T>  { }; 
# 92
template< class T> struct is_commutative< bit_xor< T> >  : public is_arithmetic< T>  { }; 
# 94
}
# 95
}
# 23 "/usr/local/cuda/include/thrust/detail/type_traits/result_of_adaptable_function.h"
namespace thrust { 
# 25
namespace detail { 
# 33
template< class Signature, class Enable = void> struct result_of_adaptable_function; 
# 38
template< class Functor, class Arg1> 
# 39
struct result_of_adaptable_function< Functor (Arg1), typename enable_if< has_result_type< Functor> ::value> ::type>  { 
# 44
typedef typename Functor::result_type type; 
# 45
}; 
# 48
template< class Functor, class Arg1, class Arg2> 
# 49
struct result_of_adaptable_function< Functor (Arg1, Arg2), typename enable_if< has_result_type< Functor> ::value> ::type>  { 
# 54
typedef typename Functor::result_type type; 
# 55
}; 
# 58
}
# 59
}
# 35 "/usr/local/cuda/include/thrust/detail/functional/actor.h"
namespace thrust { 
# 37
namespace detail { 
# 39
namespace functional { 
# 42
template< class Action, class Env> 
# 43
struct apply_actor { 
# 45
typedef typename Action::template result< Env> ::type type; 
# 46
}; 
# 48
template< class Eval> 
# 49
struct actor : public Eval { 
# 52
typedef Eval eval_type; 
# 55
actor(); 
# 58
actor(const Eval & base); 
# 62
typename apply_actor< Eval, ::thrust::null_type> ::type operator()() const; 
# 64
template< class T0> typename apply_actor< Eval, tuple< T0 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0) const; 
# 69
template< class T0, class T1> typename apply_actor< Eval, tuple< T0 &, T1 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1) const; 
# 74
template< class T0, class T1, class T2> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2) const; 
# 79
template< class T0, class T1, class T2, class T3> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3) const; 
# 84
template< class T0, class T1, class T2, class T3, class T4> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4) const; 
# 89
template< class T0, class T1, class T2, class T3, class T4, class T5> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4, T5 & _5) const; 
# 94
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4, T5 & _5, T6 & _6) const; 
# 99
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, ::thrust::null_type, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4, T5 & _5, T6 & _6, T7 & _7) const; 
# 104
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, ::thrust::null_type> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4, T5 & _5, T6 & _6, T7 & _7, T8 & _8) const; 
# 109
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, T9 &> > ::type operator()(T0 & _0, T1 & _1, T2 & _2, T3 & _3, T4 & _4, T5 & _5, T6 & _6, T7 & _7, T8 & _8, T9 & _9) const; 
# 114
template< class T> typename assign_result< Eval, T> ::type operator=(const T & _1) const; 
# 118
}; 
# 121
template< class T> 
# 122
struct as_actor { 
# 124
typedef value< T>  type; 
# 126
static type convert(const T &x) 
# 127
{ 
# 128
return val(x); 
# 129
} 
# 130
}; 
# 133
template< class Eval> 
# 134
struct as_actor< actor< Eval> >  { 
# 136
typedef actor< Eval>  type; 
# 138
static const type &convert(const actor< Eval>  &x) 
# 139
{ 
# 140
return x; 
# 141
} 
# 142
}; 
# 144
template< class T> typename as_actor< T> ::type 
# 147
make_actor(const T &x) 
# 148
{ 
# 149
return as_actor< T> ::convert(x); 
# 150
} 
# 152
}
# 155
template< class Eval> 
# 156
struct result_of_adaptable_function< functional::actor< Eval>  (void), void>  { 
# 163
typedef typename functional::apply_actor< functional::actor< Eval> , null_type> ::type type; 
# 164
}; 
# 166
template< class Eval, class Arg1> 
# 167
struct result_of_adaptable_function< functional::actor< Eval>  (Arg1), void>  { 
# 174
typedef typename functional::apply_actor< functional::actor< Eval> , tuple< Arg1, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type type; 
# 175
}; 
# 177
template< class Eval, class Arg1, class Arg2> 
# 178
struct result_of_adaptable_function< functional::actor< Eval>  (Arg1, Arg2), void>  { 
# 185
typedef typename functional::apply_actor< functional::actor< Eval> , tuple< Arg1, Arg2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type type; 
# 186
}; 
# 188
}
# 189
}
# 31 "/usr/local/cuda/include/thrust/detail/functional/actor.inl"
namespace thrust { 
# 34
namespace detail { 
# 36
namespace functional { 
# 39
template< class Eval> 
# 41
actor< Eval> ::actor() : eval_type() 
# 43
{ } 
# 45
template< class Eval> 
# 47
actor< Eval> ::actor(const Eval &base) : eval_type(base) 
# 49
{ } 
# 51
template< class Eval> typename apply_actor< Eval, null_type> ::type 
# 57
actor< Eval> ::operator()() const 
# 58
{ 
# 59
return eval_type::eval(::thrust::null_type()); 
# 60
} 
# 62
template< class Eval> 
# 63
template< class T0> typename apply_actor< Eval, tuple< T0 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type 
# 69
actor< Eval> ::operator()(T0 &_0) const 
# 70
{ 
# 71
return eval_type::eval(::thrust::tie(_0)); 
# 72
} 
# 74
template< class Eval> 
# 75
template< class T0, class T1> typename apply_actor< Eval, tuple< T0 &, T1 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type 
# 81
actor< Eval> ::operator()(T0 &_0, T1 &_1) const 
# 82
{ 
# 83
return eval_type::eval(::thrust::tie(_0, _1)); 
# 84
} 
# 86
template< class Eval> 
# 87
template< class T0, class T1, class T2> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ::type 
# 93
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2) const 
# 94
{ 
# 95
return eval_type::eval(::thrust::tie(_0, _1, _2)); 
# 96
} 
# 98
template< class Eval> 
# 99
template< class T0, class T1, class T2, class T3> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, null_type, null_type, null_type, null_type, null_type, null_type> > ::type 
# 105
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3) const 
# 106
{ 
# 107
return eval_type::eval(::thrust::tie(_0, _1, _2, _3)); 
# 108
} 
# 110
template< class Eval> 
# 111
template< class T0, class T1, class T2, class T3, class T4> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, null_type, null_type, null_type, null_type, null_type> > ::type 
# 117
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4) const 
# 118
{ 
# 119
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4)); 
# 120
} 
# 122
template< class Eval> 
# 123
template< class T0, class T1, class T2, class T3, class T4, class T5> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, null_type, null_type, null_type, null_type> > ::type 
# 129
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5) const 
# 130
{ 
# 131
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4, _5)); 
# 132
} 
# 134
template< class Eval> 
# 135
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, null_type, null_type, null_type> > ::type 
# 141
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6) const 
# 142
{ 
# 143
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4, _5, _6)); 
# 144
} 
# 146
template< class Eval> 
# 147
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, null_type, null_type> > ::type 
# 153
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7) const 
# 154
{ 
# 155
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4, _5, _6, _7)); 
# 156
} 
# 158
template< class Eval> 
# 159
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, null_type> > ::type 
# 165
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8) const 
# 166
{ 
# 167
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4, _5, _6, _7, _8)); 
# 168
} 
# 170
template< class Eval> 
# 171
template< class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> typename apply_actor< Eval, tuple< T0 &, T1 &, T2 &, T3 &, T4 &, T5 &, T6 &, T7 &, T8 &, T9 &> > ::type 
# 177
actor< Eval> ::operator()(T0 &_0, T1 &_1, T2 &_2, T3 &_3, T4 &_4, T5 &_5, T6 &_6, T7 &_7, T8 &_8, T9 &_9) const 
# 178
{ 
# 179
return eval_type::eval(::thrust::tie(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9)); 
# 180
} 
# 182
template< class Eval> 
# 183
template< class T> typename assign_result< Eval, T> ::type 
# 186
actor< Eval> ::operator=(const T &_1) const 
# 187
{ 
# 188
return do_assign(*this, _1); 
# 189
} 
# 191
}
# 192
}
# 193
}
# 31 "/usr/local/cuda/include/thrust/detail/functional/argument.h"
namespace thrust { 
# 33
namespace detail { 
# 35
namespace functional { 
# 38
template< unsigned i, class Env> 
# 39
struct argument_helper { 
# 41
typedef typename tuple_element< i, Env> ::type type; 
# 42
}; 
# 44
template< unsigned i> 
# 45
struct argument_helper< i, null_type>  { 
# 47
typedef null_type type; 
# 48
}; 
# 51
template< unsigned i> 
# 52
class argument { 
# 56
public: 
# 55
template< class Env> 
# 56
struct result : public argument_helper< i, Env>  { 
# 59
}; 
# 62
argument() { } 
# 64
template< class Env> typename result< Env> ::type 
# 66
eval(const Env &e) const 
# 67
{ 
# 68
return thrust::get< i> (e); 
# 69
} 
# 70
}; 
# 72
}
# 73
}
# 74
}
# 23 "/usr/local/cuda/include/thrust/detail/functional/placeholder.h"
namespace thrust { 
# 25
namespace detail { 
# 27
namespace functional { 
# 30
template< unsigned i> 
# 31
struct placeholder { 
# 33
typedef actor< argument< i> >  type; 
# 34
}; 
# 36
}
# 37
}
# 38
}
# 28 "/usr/local/cuda/include/thrust/functional.h"
namespace thrust { 
# 34
template< class Operation> struct unary_traits; 
# 36
template< class Operation> struct binary_traits; 
# 68
template< class Argument, class 
# 69
Result> 
# 70
struct unary_function { 
# 75
typedef Argument argument_type; 
# 80
typedef Result result_type; 
# 81
}; 
# 108
template< class Argument1, class 
# 109
Argument2, class 
# 110
Result> 
# 111
struct binary_function { 
# 116
typedef Argument1 first_argument_type; 
# 121
typedef Argument2 second_argument_type; 
# 126
typedef Result result_type; 
# 127
}; 
# 175
template< class T> 
# 176
struct plus { 
# 181
typedef T first_argument_type; 
# 186
typedef T second_argument_type; 
# 191
typedef T result_type; 
# 195
T operator()(const T &lhs, const T &rhs) const { return lhs + rhs; } 
# 196
}; 
# 231
template< class T> 
# 232
struct minus { 
# 237
typedef T first_argument_type; 
# 242
typedef T second_argument_type; 
# 247
typedef T result_type; 
# 251
T operator()(const T &lhs, const T &rhs) const { return lhs - rhs; } 
# 252
}; 
# 287
template< class T> 
# 288
struct multiplies { 
# 293
typedef T first_argument_type; 
# 298
typedef T second_argument_type; 
# 303
typedef T result_type; 
# 307
T operator()(const T &lhs, const T &rhs) const { return lhs * rhs; } 
# 308
}; 
# 343
template< class T> 
# 344
struct divides { 
# 349
typedef T first_argument_type; 
# 354
typedef T second_argument_type; 
# 359
typedef T result_type; 
# 363
T operator()(const T &lhs, const T &rhs) const { return lhs / rhs; } 
# 364
}; 
# 399
template< class T> 
# 400
struct modulus { 
# 405
typedef T first_argument_type; 
# 410
typedef T second_argument_type; 
# 415
typedef T result_type; 
# 419
T operator()(const T &lhs, const T &rhs) const { return lhs % rhs; } 
# 420
}; 
# 452
template< class T> 
# 453
struct negate { 
# 458
typedef T argument_type; 
# 463
typedef T result_type; 
# 467
T operator()(const T &x) const { return -x; } 
# 468
}; 
# 489
template< class T> 
# 490
struct equal_to { 
# 495
typedef T first_argument_type; 
# 500
typedef T second_argument_type; 
# 505
typedef bool result_type; 
# 509
bool operator()(const T &lhs, const T &rhs) const { return lhs == rhs; } 
# 510
}; 
# 523
template< class T> 
# 524
struct not_equal_to { 
# 529
typedef T first_argument_type; 
# 534
typedef T second_argument_type; 
# 539
typedef bool result_type; 
# 543
bool operator()(const T &lhs, const T &rhs) const { return lhs != rhs; } 
# 544
}; 
# 557
template< class T> 
# 558
struct greater { 
# 563
typedef T first_argument_type; 
# 568
typedef T second_argument_type; 
# 573
typedef bool result_type; 
# 577
bool operator()(const T &lhs, const T &rhs) const { return lhs > rhs; } 
# 578
}; 
# 591
template< class T> 
# 592
struct less { 
# 597
typedef T first_argument_type; 
# 602
typedef T second_argument_type; 
# 607
typedef bool result_type; 
# 611
bool operator()(const T &lhs, const T &rhs) const { return lhs < rhs; } 
# 612
}; 
# 625
template< class T> 
# 626
struct greater_equal { 
# 631
typedef T first_argument_type; 
# 636
typedef T second_argument_type; 
# 641
typedef bool result_type; 
# 645
bool operator()(const T &lhs, const T &rhs) const { return lhs >= rhs; } 
# 646
}; 
# 659
template< class T> 
# 660
struct less_equal { 
# 665
typedef T first_argument_type; 
# 670
typedef T second_argument_type; 
# 675
typedef bool result_type; 
# 679
bool operator()(const T &lhs, const T &rhs) const { return lhs <= rhs; } 
# 680
}; 
# 702
template< class T> 
# 703
struct logical_and { 
# 708
typedef T first_argument_type; 
# 713
typedef T second_argument_type; 
# 718
typedef bool result_type; 
# 722
bool operator()(const T &lhs, const T &rhs) const { return lhs && rhs; } 
# 723
}; 
# 736
template< class T> 
# 737
struct logical_or { 
# 742
typedef T first_argument_type; 
# 747
typedef T second_argument_type; 
# 752
typedef bool result_type; 
# 756
bool operator()(const T &lhs, const T &rhs) const { return lhs || rhs; } 
# 757
}; 
# 784
template< class T> 
# 785
struct logical_not { 
# 790
typedef T first_argument_type; 
# 795
typedef T second_argument_type; 
# 800
typedef bool result_type; 
# 804
bool operator()(const T &x) const { return !x; } 
# 805
}; 
# 847
template< class T> 
# 848
struct bit_and { 
# 853
typedef T first_argument_type; 
# 858
typedef T second_argument_type; 
# 863
typedef T result_type; 
# 867
T operator()(const T &lhs, const T &rhs) const { return lhs & rhs; } 
# 868
}; 
# 902
template< class T> 
# 903
struct bit_or { 
# 908
typedef T first_argument_type; 
# 913
typedef T second_argument_type; 
# 918
typedef T result_type; 
# 922
T operator()(const T &lhs, const T &rhs) const { return lhs | rhs; } 
# 923
}; 
# 957
template< class T> 
# 958
struct bit_xor { 
# 963
typedef T first_argument_type; 
# 968
typedef T second_argument_type; 
# 973
typedef T result_type; 
# 977
T operator()(const T &lhs, const T &rhs) const { return lhs ^ rhs; } 
# 978
}; 
# 1008
template< class T> 
# 1009
struct identity { 
# 1014
typedef T argument_type; 
# 1019
typedef T result_type; 
# 1023
const T &operator()(const T &x) const { return x; } 
# 1024
}; 
# 1050
template< class T> 
# 1051
struct maximum { 
# 1056
typedef T first_argument_type; 
# 1061
typedef T second_argument_type; 
# 1066
typedef T result_type; 
# 1070
T operator()(const T &lhs, const T &rhs) const { return (lhs < rhs) ? rhs : lhs; } 
# 1071
}; 
# 1097
template< class T> 
# 1098
struct minimum { 
# 1103
typedef T first_argument_type; 
# 1108
typedef T second_argument_type; 
# 1113
typedef T result_type; 
# 1117
T operator()(const T &lhs, const T &rhs) const { return (lhs < rhs) ? lhs : rhs; } 
# 1118
}; 
# 1138
template< class T1, class T2> 
# 1139
struct project1st { 
# 1144
typedef T1 first_argument_type; 
# 1149
typedef T2 second_argument_type; 
# 1154
typedef T1 result_type; 
# 1158
const T1 &operator()(const T1 &lhs, const T2 &rhs) const { return lhs; } 
# 1159
}; 
# 1179
template< class T1, class T2> 
# 1180
struct project2nd { 
# 1185
typedef T1 first_argument_type; 
# 1190
typedef T2 second_argument_type; 
# 1195
typedef T2 result_type; 
# 1199
const T2 &operator()(const T1 &lhs, const T2 &rhs) const { return rhs; } 
# 1200
}; 
# 1223
template< class Predicate> 
# 1224
struct unary_negate : public unary_function< typename Predicate::argument_type, bool>  { 
# 1231
explicit unary_negate(Predicate p) : pred(p) { } 
# 1236
bool operator()(const typename Predicate::argument_type &x) { return !(pred)(x); } 
# 1240
Predicate pred; 
# 1243
}; 
# 1261
template< class Predicate> unary_negate< Predicate>  not1(const Predicate & pred); 
# 1275
template< class Predicate> 
# 1276
struct binary_negate : public binary_function< typename Predicate::first_argument_type, typename Predicate::second_argument_type, bool>  { 
# 1285
explicit binary_negate(Predicate p) : pred(p) { } 
# 1290
bool operator()(const typename Predicate::first_argument_type &x, const typename Predicate::second_argument_type &y) 
# 1291
{ 
# 1292
return !(pred)(x, y); 
# 1293
} 
# 1297
Predicate pred; 
# 1300
}; 
# 1318
template< class BinaryPredicate> binary_negate< BinaryPredicate>  not2(const BinaryPredicate & pred); 
# 1374
namespace placeholders { 
# 1383
static const detail::functional::placeholder< 0U> ::type _1; 
# 1392
static const detail::functional::placeholder< 1U> ::type _2; 
# 1401
static const detail::functional::placeholder< 2U> ::type _3; 
# 1410
static const detail::functional::placeholder< 3U> ::type _4; 
# 1419
static const detail::functional::placeholder< 4U> ::type _5; 
# 1428
static const detail::functional::placeholder< 5U> ::type _6; 
# 1437
static const detail::functional::placeholder< 6U> ::type _7; 
# 1446
static const detail::functional::placeholder< 7U> ::type _8; 
# 1455
static const detail::functional::placeholder< 8U> ::type _9; 
# 1464
static const detail::functional::placeholder< 9U> ::type _10; 
# 1468
}
# 1475
}
# 19 "/usr/local/cuda/include/thrust/detail/functional.inl"
namespace thrust { 
# 22
namespace detail { 
# 25
template< class Operation> struct unary_traits_imp; 
# 28
template< class Operation> 
# 29
struct unary_traits_imp< Operation *>  { 
# 31
typedef Operation function_type; 
# 32
typedef const function_type &param_type; 
# 33
typedef typename Operation::result_type result_type; 
# 34
typedef typename Operation::argument_type argument_type; 
# 35
}; 
# 37
template< class Result, class Argument> 
# 38
struct unary_traits_imp< Result (*)(Argument)>  { 
# 40
typedef Result (*function_type)(Argument); 
# 41
typedef Result (*param_type)(Argument); 
# 42
typedef Result result_type; 
# 43
typedef Argument argument_type; 
# 44
}; 
# 46
template< class Operation> struct binary_traits_imp; 
# 49
template< class Operation> 
# 50
struct binary_traits_imp< Operation *>  { 
# 52
typedef Operation function_type; 
# 53
typedef const function_type &param_type; 
# 54
typedef typename Operation::result_type result_type; 
# 55
typedef typename Operation::first_argument_type first_argument_type; 
# 56
typedef typename Operation::second_argument_type second_argument_type; 
# 57
}; 
# 59
template< class Result, class Argument1, class Argument2> 
# 60
struct binary_traits_imp< Result (*)(Argument1, Argument2)>  { 
# 62
typedef Result (*function_type)(Argument1, Argument2); 
# 63
typedef Result (*param_type)(Argument1, Argument2); 
# 64
typedef Result result_type; 
# 65
typedef Argument1 first_argument_type; 
# 66
typedef Argument2 second_argument_type; 
# 67
}; 
# 69
}
# 71
template< class Operation> 
# 72
struct unary_traits { 
# 74
typedef typename detail::unary_traits_imp< Operation *> ::function_type function_type; 
# 75
typedef typename detail::unary_traits_imp< Operation *> ::param_type param_type; 
# 76
typedef typename detail::unary_traits_imp< Operation *> ::result_type result_type; 
# 77
typedef typename detail::unary_traits_imp< Operation *> ::argument_type argument_type; 
# 78
}; 
# 80
template< class Result, class Argument> 
# 81
struct unary_traits< Result (*)(Argument)>  { 
# 83
typedef Result (*function_type)(Argument); 
# 84
typedef Result (*param_type)(Argument); 
# 85
typedef Result result_type; 
# 86
typedef Argument argument_type; 
# 87
}; 
# 89
template< class Operation> 
# 90
struct binary_traits { 
# 92
typedef typename detail::binary_traits_imp< Operation *> ::function_type function_type; 
# 93
typedef typename detail::binary_traits_imp< Operation *> ::param_type param_type; 
# 94
typedef typename detail::binary_traits_imp< Operation *> ::result_type result_type; 
# 95
typedef typename detail::binary_traits_imp< Operation *> ::first_argument_type first_argument_type; 
# 96
typedef typename detail::binary_traits_imp< Operation *> ::second_argument_type second_argument_type; 
# 97
}; 
# 99
template< class Result, class Argument1, class Argument2> 
# 100
struct binary_traits< Result (*)(Argument1, Argument2)>  { 
# 102
typedef Result (*function_type)(Argument1, Argument2); 
# 103
typedef Result (*param_type)(Argument1, Argument2); 
# 104
typedef Result result_type; 
# 105
typedef Argument1 first_argument_type; 
# 106
typedef Argument2 second_argument_type; 
# 107
}; 
# 109
template< class Predicate> unary_negate< Predicate>  
# 110
not1(const Predicate &pred) 
# 111
{ 
# 112
return ((unary_negate< Predicate> )(pred)); 
# 113
} 
# 115
template< class BinaryPredicate> binary_negate< BinaryPredicate>  
# 116
not2(const BinaryPredicate &pred) 
# 117
{ 
# 118
return ((binary_negate< BinaryPredicate> )(pred)); 
# 119
} 
# 121
}
# 25 "/usr/local/cuda/include/thrust/detail/functional/operators/arithmetic_operators.h"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace functional { 
# 32
template< class Eval> actor< composite< unary_operator< negate> , actor< Eval> > >  
# 41
operator-(const actor< Eval>  &_1) 
# 42
{ 
# 43
return compose(unary_operator< negate> (), _1); 
# 44
} 
# 47
template< class T> 
# 48
struct unary_plus : public unary_function< T, T>  { 
# 51
T operator()(const T &x) const { return +x; } 
# 52
}; 
# 54
template< class Eval> actor< composite< unary_operator< unary_plus> , actor< Eval> > >  
# 62
operator+(const actor< Eval>  &_1) 
# 63
{ 
# 64
return compose(unary_operator< unary_plus> (), _1); 
# 65
} 
# 67
template< class T1, class T2> actor< composite< binary_operator< plus> , actor< T1> , typename as_actor< T2> ::type> >  
# 76
operator+(const actor< T1>  &_1, const T2 &_2) 
# 77
{ 
# 78
return compose(binary_operator< plus> (), make_actor(_1), make_actor(_2)); 
# 81
} 
# 83
template< class T1, class T2> actor< composite< binary_operator< plus> , typename as_actor< T1> ::type, actor< T2> > >  
# 92
operator+(const T1 &_1, const actor< T2>  &_2) 
# 93
{ 
# 94
return compose(binary_operator< plus> (), make_actor(_1), make_actor(_2)); 
# 97
} 
# 99
template< class T1, class T2> actor< composite< binary_operator< plus> , actor< T1> , actor< T2> > >  
# 108
operator+(const actor< T1>  &_1, const actor< T2>  &_2) 
# 109
{ 
# 110
return compose(binary_operator< plus> (), make_actor(_1), make_actor(_2)); 
# 113
} 
# 115
template< class T1, class T2> actor< composite< binary_operator< minus> , typename as_actor< T1> ::type, actor< T2> > >  
# 124
operator-(const T1 &_1, const actor< T2>  &_2) 
# 125
{ 
# 126
return compose(binary_operator< minus> (), make_actor(_1), make_actor(_2)); 
# 129
} 
# 131
template< class T1, class T2> actor< composite< binary_operator< minus> , actor< T1> , typename as_actor< T2> ::type> >  
# 140
operator-(const actor< T1>  &_1, const T2 &_2) 
# 141
{ 
# 142
return compose(binary_operator< minus> (), make_actor(_1), make_actor(_2)); 
# 145
} 
# 147
template< class T1, class T2> actor< composite< binary_operator< minus> , actor< T1> , actor< T2> > >  
# 156
operator-(const actor< T1>  &_1, const actor< T2>  &_2) 
# 157
{ 
# 158
return compose(binary_operator< minus> (), make_actor(_1), make_actor(_2)); 
# 161
} 
# 163
template< class T1, class T2> actor< composite< binary_operator< multiplies> , typename as_actor< T1> ::type, actor< T2> > >  
# 172
operator*(const T1 &_1, const actor< T2>  &_2) 
# 173
{ 
# 174
return compose(binary_operator< multiplies> (), make_actor(_1), make_actor(_2)); 
# 177
} 
# 179
template< class T1, class T2> actor< composite< binary_operator< multiplies> , actor< T1> , typename as_actor< T2> ::type> >  
# 188
operator*(const actor< T1>  &_1, const T2 &_2) 
# 189
{ 
# 190
return compose(binary_operator< multiplies> (), make_actor(_1), make_actor(_2)); 
# 193
} 
# 195
template< class T1, class T2> actor< composite< binary_operator< multiplies> , actor< T1> , actor< T2> > >  
# 204
operator*(const actor< T1>  &_1, const actor< T2>  &_2) 
# 205
{ 
# 206
return compose(binary_operator< multiplies> (), make_actor(_1), make_actor(_2)); 
# 209
} 
# 211
template< class T1, class T2> actor< composite< binary_operator< divides> , actor< T1> , typename as_actor< T2> ::type> >  
# 220
operator/(const actor< T1>  &_1, const T2 &_2) 
# 221
{ 
# 222
return compose(binary_operator< divides> (), make_actor(_1), make_actor(_2)); 
# 225
} 
# 227
template< class T1, class T2> actor< composite< binary_operator< divides> , typename as_actor< T1> ::type, actor< T2> > >  
# 236
operator/(const T1 &_1, const actor< T2>  &_2) 
# 237
{ 
# 238
return compose(binary_operator< divides> (), make_actor(_1), make_actor(_2)); 
# 241
} 
# 243
template< class T1, class T2> actor< composite< binary_operator< divides> , actor< T1> , actor< T2> > >  
# 252
operator/(const actor< T1>  &_1, const actor< T2>  &_2) 
# 253
{ 
# 254
return compose(binary_operator< divides> (), make_actor(_1), make_actor(_2)); 
# 257
} 
# 259
template< class T1, class T2> actor< composite< binary_operator< modulus> , actor< T1> , typename as_actor< T2> ::type> >  
# 268
operator%(const actor< T1>  &_1, const T2 &_2) 
# 269
{ 
# 270
return compose(binary_operator< modulus> (), make_actor(_1), make_actor(_2)); 
# 273
} 
# 275
template< class T1, class T2> actor< composite< binary_operator< modulus> , typename as_actor< T1> ::type, actor< T2> > >  
# 284
operator%(const T1 &_1, const actor< T2>  &_2) 
# 285
{ 
# 286
return compose(binary_operator< modulus> (), make_actor(_1), make_actor(_2)); 
# 289
} 
# 291
template< class T1, class T2> actor< composite< binary_operator< modulus> , actor< T1> , actor< T2> > >  
# 300
operator%(const actor< T1>  &_1, const actor< T2>  &_2) 
# 301
{ 
# 302
return compose(binary_operator< modulus> (), make_actor(_1), make_actor(_2)); 
# 305
} 
# 308
template< class T> 
# 309
struct prefix_increment : public unary_function< T &, T &>  { 
# 312
T &operator()(T &x) const { return ++x; } 
# 313
}; 
# 315
template< class Eval> actor< composite< unary_operator< prefix_increment> , actor< Eval> > >  
# 323
operator++(const actor< Eval>  &_1) 
# 324
{ 
# 325
return compose(unary_operator< prefix_increment> (), _1); 
# 326
} 
# 329
template< class T> 
# 330
struct suffix_increment : public unary_function< T &, T>  { 
# 333
T operator()(T &x) const { return x++; } 
# 334
}; 
# 336
template< class Eval> actor< composite< unary_operator< suffix_increment> , actor< Eval> > >  
# 344
operator++(const actor< Eval>  &_1, int) 
# 345
{ 
# 346
return compose(unary_operator< suffix_increment> (), _1); 
# 347
} 
# 350
template< class T> 
# 351
struct prefix_decrement : public unary_function< T &, T &>  { 
# 354
T &operator()(T &x) const { return --x; } 
# 355
}; 
# 357
template< class Eval> actor< composite< unary_operator< prefix_decrement> , actor< Eval> > >  
# 365
operator--(const actor< Eval>  &_1) 
# 366
{ 
# 367
return compose(unary_operator< prefix_decrement> (), _1); 
# 368
} 
# 371
template< class T> 
# 372
struct suffix_decrement : public unary_function< T &, T>  { 
# 375
T operator()(T &x) const { return x--; } 
# 376
}; 
# 378
template< class Eval> actor< composite< unary_operator< suffix_decrement> , actor< Eval> > >  
# 386
operator--(const actor< Eval>  &_1, int) 
# 387
{ 
# 388
return compose(unary_operator< suffix_decrement> (), _1); 
# 389
} 
# 391
}
# 392
}
# 393
}
# 25 "/usr/local/cuda/include/thrust/detail/functional/operators/relational_operators.h"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace functional { 
# 32
template< class T1, class T2> actor< composite< binary_operator< thrust::equal_to> , actor< T1> , typename as_actor< T2> ::type> >  
# 41
operator==(const actor< T1>  &_1, const T2 &_2) 
# 42
{ 
# 43
return compose(binary_operator< thrust::equal_to> (), make_actor(_1), make_actor(_2)); 
# 46
} 
# 48
template< class T1, class T2> actor< composite< binary_operator< thrust::equal_to> , typename as_actor< T1> ::type, actor< T2> > >  
# 57
operator==(const T1 &_1, const actor< T2>  &_2) 
# 58
{ 
# 59
return compose(binary_operator< thrust::equal_to> (), make_actor(_1), make_actor(_2)); 
# 62
} 
# 64
template< class T1, class T2> actor< composite< binary_operator< thrust::equal_to> , actor< T1> , actor< T2> > >  
# 73
operator==(const actor< T1>  &_1, const actor< T2>  &_2) 
# 74
{ 
# 75
return compose(binary_operator< thrust::equal_to> (), make_actor(_1), make_actor(_2)); 
# 78
} 
# 80
template< class T1, class T2> actor< composite< binary_operator< not_equal_to> , actor< T1> , typename as_actor< T2> ::type> >  
# 89
operator!=(const actor< T1>  &_1, const T2 &_2) 
# 90
{ 
# 91
return compose(binary_operator< not_equal_to> (), make_actor(_1), make_actor(_2)); 
# 94
} 
# 96
template< class T1, class T2> actor< composite< binary_operator< not_equal_to> , typename as_actor< T1> ::type, actor< T2> > >  
# 105
operator!=(const T1 &_1, const actor< T2>  &_2) 
# 106
{ 
# 107
return compose(binary_operator< not_equal_to> (), make_actor(_1), make_actor(_2)); 
# 110
} 
# 112
template< class T1, class T2> actor< composite< binary_operator< not_equal_to> , actor< T1> , actor< T2> > >  
# 121
operator!=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 122
{ 
# 123
return compose(binary_operator< not_equal_to> (), make_actor(_1), make_actor(_2)); 
# 126
} 
# 128
template< class T1, class T2> actor< composite< binary_operator< greater> , actor< T1> , typename as_actor< T2> ::type> >  
# 137
operator>(const actor< T1>  &_1, const T2 &_2) 
# 138
{ 
# 139
return compose(binary_operator< greater> (), make_actor(_1), make_actor(_2)); 
# 142
} 
# 144
template< class T1, class T2> actor< composite< binary_operator< greater> , typename as_actor< T1> ::type, actor< T2> > >  
# 153
operator>(const T1 &_1, const actor< T2>  &_2) 
# 154
{ 
# 155
return compose(binary_operator< greater> (), make_actor(_1), make_actor(_2)); 
# 158
} 
# 160
template< class T1, class T2> actor< composite< binary_operator< greater> , actor< T1> , actor< T2> > >  
# 169
operator>(const actor< T1>  &_1, const actor< T2>  &_2) 
# 170
{ 
# 171
return compose(binary_operator< greater> (), make_actor(_1), make_actor(_2)); 
# 174
} 
# 176
template< class T1, class T2> actor< composite< binary_operator< less> , actor< T1> , typename as_actor< T2> ::type> >  
# 185
operator<(const actor< T1>  &_1, const T2 &_2) 
# 186
{ 
# 187
return compose(binary_operator< less> (), make_actor(_1), make_actor(_2)); 
# 190
} 
# 192
template< class T1, class T2> actor< composite< binary_operator< less> , typename as_actor< T1> ::type, actor< T2> > >  
# 201
operator<(const T1 &_1, const actor< T2>  &_2) 
# 202
{ 
# 203
return compose(binary_operator< less> (), make_actor(_1), make_actor(_2)); 
# 206
} 
# 208
template< class T1, class T2> actor< composite< binary_operator< less> , actor< T1> , actor< T2> > >  
# 217
operator<(const actor< T1>  &_1, const actor< T2>  &_2) 
# 218
{ 
# 219
return compose(binary_operator< less> (), make_actor(_1), make_actor(_2)); 
# 222
} 
# 224
template< class T1, class T2> actor< composite< binary_operator< greater_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 233
operator>=(const actor< T1>  &_1, const T2 &_2) 
# 234
{ 
# 235
return compose(binary_operator< greater_equal> (), make_actor(_1), make_actor(_2)); 
# 238
} 
# 240
template< class T1, class T2> actor< composite< binary_operator< greater_equal> , typename as_actor< T1> ::type, actor< T2> > >  
# 249
operator>=(const T1 &_1, const actor< T2>  &_2) 
# 250
{ 
# 251
return compose(binary_operator< greater_equal> (), make_actor(_1), make_actor(_2)); 
# 254
} 
# 256
template< class T1, class T2> actor< composite< binary_operator< greater_equal> , actor< T1> , actor< T2> > >  
# 265
operator>=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 266
{ 
# 267
return compose(binary_operator< greater_equal> (), make_actor(_1), make_actor(_2)); 
# 270
} 
# 272
template< class T1, class T2> actor< composite< binary_operator< less_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 281
operator<=(const actor< T1>  &_1, const T2 &_2) 
# 282
{ 
# 283
return compose(binary_operator< less_equal> (), make_actor(_1), make_actor(_2)); 
# 286
} 
# 288
template< class T1, class T2> actor< composite< binary_operator< less_equal> , typename as_actor< T1> ::type, actor< T2> > >  
# 297
operator<=(const T1 &_1, const actor< T2>  &_2) 
# 298
{ 
# 299
return compose(binary_operator< less_equal> (), make_actor(_1), make_actor(_2)); 
# 302
} 
# 304
template< class T1, class T2> actor< composite< binary_operator< less_equal> , actor< T1> , actor< T2> > >  
# 313
operator<=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 314
{ 
# 315
return compose(binary_operator< less_equal> (), make_actor(_1), make_actor(_2)); 
# 318
} 
# 320
}
# 321
}
# 322
}
# 25 "/usr/local/cuda/include/thrust/detail/functional/operators/logical_operators.h"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace functional { 
# 32
template< class T1, class T2> actor< composite< binary_operator< logical_and> , actor< T1> , typename as_actor< T2> ::type> >  
# 41
operator&&(const actor< T1>  &_1, const T2 &_2) 
# 42
{ 
# 43
return compose(binary_operator< logical_and> (), make_actor(_1), make_actor(_2)); 
# 46
} 
# 48
template< class T1, class T2> actor< composite< binary_operator< logical_and> , typename as_actor< T1> ::type, actor< T2> > >  
# 57
operator&&(const T1 &_1, const actor< T2>  &_2) 
# 58
{ 
# 59
return compose(binary_operator< logical_and> (), make_actor(_1), make_actor(_2)); 
# 62
} 
# 64
template< class T1, class T2> actor< composite< binary_operator< logical_and> , actor< T1> , actor< T2> > >  
# 73
operator&&(const actor< T1>  &_1, const actor< T2>  &_2) 
# 74
{ 
# 75
return compose(binary_operator< logical_and> (), make_actor(_1), make_actor(_2)); 
# 78
} 
# 80
template< class T1, class T2> actor< composite< binary_operator< logical_or> , actor< T1> , typename as_actor< T2> ::type> >  
# 89
operator||(const actor< T1>  &_1, const T2 &_2) 
# 90
{ 
# 91
return compose(binary_operator< logical_or> (), make_actor(_1), make_actor(_2)); 
# 94
} 
# 96
template< class T1, class T2> actor< composite< binary_operator< logical_or> , typename as_actor< T1> ::type, actor< T2> > >  
# 105
operator||(const T1 &_1, const actor< T2>  &_2) 
# 106
{ 
# 107
return compose(binary_operator< logical_or> (), make_actor(_1), make_actor(_2)); 
# 110
} 
# 112
template< class T1, class T2> actor< composite< binary_operator< logical_or> , actor< T1> , actor< T2> > >  
# 121
operator||(const actor< T1>  &_1, const actor< T2>  &_2) 
# 122
{ 
# 123
return compose(binary_operator< logical_or> (), make_actor(_1), make_actor(_2)); 
# 126
} 
# 128
template< class Eval> actor< composite< unary_operator< logical_not> , actor< Eval> > >  
# 136
operator!(const actor< Eval>  &_1) 
# 137
{ 
# 138
return compose(unary_operator< logical_not> (), _1); 
# 139
} 
# 141
}
# 142
}
# 143
}
# 25 "/usr/local/cuda/include/thrust/detail/functional/operators/bitwise_operators.h"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace functional { 
# 32
template< class T1, class T2> actor< composite< binary_operator< bit_and> , actor< T1> , typename as_actor< T2> ::type> >  
# 41
operator&(const actor< T1>  &_1, const T2 &_2) 
# 42
{ 
# 43
return compose(binary_operator< bit_and> (), make_actor(_1), make_actor(_2)); 
# 46
} 
# 48
template< class T1, class T2> actor< composite< binary_operator< bit_and> , typename as_actor< T1> ::type, actor< T2> > >  
# 57
operator&(const T1 &_1, const actor< T2>  &_2) 
# 58
{ 
# 59
return compose(binary_operator< bit_and> (), make_actor(_1), make_actor(_2)); 
# 62
} 
# 64
template< class T1, class T2> actor< composite< binary_operator< bit_and> , actor< T1> , actor< T2> > >  
# 73
operator&(const actor< T1>  &_1, const actor< T2>  &_2) 
# 74
{ 
# 75
return compose(binary_operator< bit_and> (), make_actor(_1), make_actor(_2)); 
# 78
} 
# 80
template< class T1, class T2> actor< composite< binary_operator< bit_or> , actor< T1> , typename as_actor< T2> ::type> >  
# 89
operator|(const actor< T1>  &_1, const T2 &_2) 
# 90
{ 
# 91
return compose(binary_operator< bit_or> (), make_actor(_1), make_actor(_2)); 
# 94
} 
# 96
template< class T1, class T2> actor< composite< binary_operator< bit_or> , typename as_actor< T1> ::type, actor< T2> > >  
# 105
operator|(const T1 &_1, const actor< T2>  &_2) 
# 106
{ 
# 107
return compose(binary_operator< bit_or> (), make_actor(_1), make_actor(_2)); 
# 110
} 
# 112
template< class T1, class T2> actor< composite< binary_operator< bit_or> , actor< T1> , actor< T2> > >  
# 121
operator|(const actor< T1>  &_1, const actor< T2>  &_2) 
# 122
{ 
# 123
return compose(binary_operator< bit_or> (), make_actor(_1), make_actor(_2)); 
# 126
} 
# 128
template< class T1, class T2> actor< composite< binary_operator< bit_xor> , actor< T1> , typename as_actor< T2> ::type> >  
# 137
operator^(const actor< T1>  &_1, const T2 &_2) 
# 138
{ 
# 139
return compose(binary_operator< bit_xor> (), make_actor(_1), make_actor(_2)); 
# 142
} 
# 144
template< class T1, class T2> actor< composite< binary_operator< bit_xor> , typename as_actor< T1> ::type, actor< T2> > >  
# 153
operator^(const T1 &_1, const actor< T2>  &_2) 
# 154
{ 
# 155
return compose(binary_operator< bit_xor> (), make_actor(_1), make_actor(_2)); 
# 158
} 
# 160
template< class T1, class T2> actor< composite< binary_operator< bit_xor> , actor< T1> , actor< T2> > >  
# 169
operator^(const actor< T1>  &_1, const actor< T2>  &_2) 
# 170
{ 
# 171
return compose(binary_operator< bit_xor> (), make_actor(_1), make_actor(_2)); 
# 174
} 
# 177
template< class T> 
# 178
struct bit_not : public unary_function< T, T>  { 
# 181
T operator()(const T &x) const { return ~x; } 
# 182
}; 
# 184
template< class Eval> actor< composite< unary_operator< bit_not> , actor< Eval> > >  
# 193
operator~(const actor< Eval>  &_1) 
# 194
{ 
# 195
return compose(unary_operator< bit_not> (), _1); 
# 196
} 
# 199
template< class T> 
# 200
struct bit_lshift : public binary_function< T, T, T>  { 
# 203
T operator()(const T &lhs, const T &rhs) const { return lhs << rhs; } 
# 204
}; 
# 206
template< class T1, class T2> actor< composite< binary_operator< bit_lshift> , actor< T1> , typename as_actor< T2> ::type> >  
# 215
operator<<(const actor< T1>  &_1, const T2 &_2) 
# 216
{ 
# 217
return compose(binary_operator< bit_lshift> (), make_actor(_1), make_actor(_2)); 
# 220
} 
# 222
template< class T1, class T2> actor< composite< binary_operator< bit_lshift> , typename as_actor< T1> ::type, actor< T2> > >  
# 231
operator<<(const T1 &_1, const actor< T2>  &_2) 
# 232
{ 
# 233
return compose(binary_operator< bit_lshift> (), make_actor(_1), make_actor(_2)); 
# 236
} 
# 238
template< class T1, class T2> actor< composite< binary_operator< bit_lshift> , actor< T1> , actor< T2> > >  
# 247
operator<<(const actor< T1>  &_1, const actor< T2>  &_2) 
# 248
{ 
# 249
return compose(binary_operator< bit_lshift> (), make_actor(_1), make_actor(_2)); 
# 252
} 
# 255
template< class T> 
# 256
struct bit_rshift : public binary_function< T, T, T>  { 
# 259
T operator()(const T &lhs, const T &rhs) const { return lhs >> rhs; } 
# 260
}; 
# 262
template< class T1, class T2> actor< composite< binary_operator< bit_rshift> , actor< T1> , typename as_actor< T2> ::type> >  
# 271
operator>>(const actor< T1>  &_1, const T2 &_2) 
# 272
{ 
# 273
return compose(binary_operator< bit_rshift> (), make_actor(_1), make_actor(_2)); 
# 276
} 
# 278
template< class T1, class T2> actor< composite< binary_operator< bit_rshift> , typename as_actor< T1> ::type, actor< T2> > >  
# 287
operator>>(const T1 &_1, const actor< T2>  &_2) 
# 288
{ 
# 289
return compose(binary_operator< bit_rshift> (), make_actor(_1), make_actor(_2)); 
# 292
} 
# 294
template< class T1, class T2> actor< composite< binary_operator< bit_rshift> , actor< T1> , actor< T2> > >  
# 303
operator>>(const actor< T1>  &_1, const actor< T2>  &_2) 
# 304
{ 
# 305
return compose(binary_operator< bit_rshift> (), make_actor(_1), make_actor(_2)); 
# 308
} 
# 310
}
# 311
}
# 312
}
# 24 "/usr/local/cuda/include/thrust/detail/functional/operators/compound_assignment_operators.h"
namespace thrust { 
# 26
namespace detail { 
# 28
namespace functional { 
# 31
template< class T> 
# 32
struct plus_equal : public binary_function< T &, T, T &>  { 
# 35
T &operator()(T &lhs, const T &rhs) const { return lhs += rhs; } 
# 36
}; 
# 38
template< class T1, class T2> actor< composite< binary_operator< plus_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 47
operator+=(const actor< T1>  &_1, const T2 &_2) 
# 48
{ 
# 49
return compose(binary_operator< plus_equal> (), make_actor(_1), make_actor(_2)); 
# 52
} 
# 54
template< class T1, class T2> actor< composite< binary_operator< plus_equal> , actor< T1> , actor< T2> > >  
# 63
operator+=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 64
{ 
# 65
return compose(binary_operator< plus_equal> (), make_actor(_1), make_actor(_2)); 
# 68
} 
# 70
template< class T> 
# 71
struct minus_equal : public binary_function< T &, T, T &>  { 
# 74
T &operator()(T &lhs, const T &rhs) const { return lhs -= rhs; } 
# 75
}; 
# 77
template< class T1, class T2> actor< composite< binary_operator< minus_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 86
operator-=(const actor< T1>  &_1, const T2 &_2) 
# 87
{ 
# 88
return compose(binary_operator< minus_equal> (), make_actor(_1), make_actor(_2)); 
# 91
} 
# 93
template< class T1, class T2> actor< composite< binary_operator< minus_equal> , actor< T1> , actor< T2> > >  
# 102
operator-=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 103
{ 
# 104
return compose(binary_operator< minus_equal> (), make_actor(_1), make_actor(_2)); 
# 107
} 
# 109
template< class T> 
# 110
struct multiplies_equal : public binary_function< T &, T, T &>  { 
# 113
T &operator()(T &lhs, const T &rhs) const { return lhs *= rhs; } 
# 114
}; 
# 116
template< class T1, class T2> actor< composite< binary_operator< multiplies_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 125
operator*=(const actor< T1>  &_1, const T2 &_2) 
# 126
{ 
# 127
return compose(binary_operator< multiplies_equal> (), make_actor(_1), make_actor(_2)); 
# 130
} 
# 132
template< class T1, class T2> actor< composite< binary_operator< multiplies_equal> , actor< T1> , actor< T2> > >  
# 141
operator*=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 142
{ 
# 143
return compose(binary_operator< multiplies_equal> (), make_actor(_1), make_actor(_2)); 
# 146
} 
# 148
template< class T> 
# 149
struct divides_equal : public binary_function< T &, T, T &>  { 
# 152
T &operator()(T &lhs, const T &rhs) const { return lhs /= rhs; } 
# 153
}; 
# 155
template< class T1, class T2> actor< composite< binary_operator< divides_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 164
operator/=(const actor< T1>  &_1, const T2 &_2) 
# 165
{ 
# 166
return compose(binary_operator< divides_equal> (), make_actor(_1), make_actor(_2)); 
# 169
} 
# 171
template< class T1, class T2> actor< composite< binary_operator< divides_equal> , actor< T1> , actor< T2> > >  
# 180
operator/=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 181
{ 
# 182
return compose(binary_operator< divides_equal> (), make_actor(_1), make_actor(_2)); 
# 185
} 
# 187
template< class T> 
# 188
struct modulus_equal : public binary_function< T &, T, T &>  { 
# 191
T &operator()(T &lhs, const T &rhs) const { return lhs %= rhs; } 
# 192
}; 
# 194
template< class T1, class T2> actor< composite< binary_operator< modulus_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 203
operator%=(const actor< T1>  &_1, const T2 &_2) 
# 204
{ 
# 205
return compose(binary_operator< modulus_equal> (), make_actor(_1), make_actor(_2)); 
# 208
} 
# 210
template< class T1, class T2> actor< composite< binary_operator< modulus_equal> , actor< T1> , actor< T2> > >  
# 219
operator%=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 220
{ 
# 221
return compose(binary_operator< modulus_equal> (), make_actor(_1), make_actor(_2)); 
# 224
} 
# 226
template< class T> 
# 227
struct bit_and_equal : public binary_function< T &, T, T &>  { 
# 230
T &operator()(T &lhs, const T &rhs) const { return lhs &= rhs; } 
# 231
}; 
# 233
template< class T1, class T2> actor< composite< binary_operator< bit_and_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 242
operator&=(const actor< T1>  &_1, const T2 &_2) 
# 243
{ 
# 244
return compose(binary_operator< bit_and_equal> (), make_actor(_1), make_actor(_2)); 
# 247
} 
# 249
template< class T1, class T2> actor< composite< binary_operator< bit_and_equal> , actor< T1> , actor< T2> > >  
# 258
operator&=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 259
{ 
# 260
return compose(binary_operator< bit_and_equal> (), make_actor(_1), make_actor(_2)); 
# 263
} 
# 265
template< class T> 
# 266
struct bit_or_equal : public binary_function< T &, T, T &>  { 
# 269
T &operator()(T &lhs, const T &rhs) const { return lhs |= rhs; } 
# 270
}; 
# 272
template< class T1, class T2> actor< composite< binary_operator< bit_or_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 281
operator|=(const actor< T1>  &_1, const T2 &_2) 
# 282
{ 
# 283
return compose(binary_operator< bit_or_equal> (), make_actor(_1), make_actor(_2)); 
# 286
} 
# 288
template< class T1, class T2> actor< composite< binary_operator< bit_or_equal> , actor< T1> , actor< T2> > >  
# 297
operator|=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 298
{ 
# 299
return compose(binary_operator< bit_or_equal> (), make_actor(_1), make_actor(_2)); 
# 302
} 
# 304
template< class T> 
# 305
struct bit_xor_equal : public binary_function< T &, T, T &>  { 
# 308
T &operator()(T &lhs, const T &rhs) const { return lhs ^= rhs; } 
# 309
}; 
# 311
template< class T1, class T2> actor< composite< binary_operator< bit_xor_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 320
operator^=(const actor< T1>  &_1, const T2 &_2) 
# 321
{ 
# 322
return compose(binary_operator< bit_xor_equal> (), make_actor(_1), make_actor(_2)); 
# 325
} 
# 327
template< class T1, class T2> actor< composite< binary_operator< bit_xor_equal> , actor< T1> , actor< T2> > >  
# 336
operator^=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 337
{ 
# 338
return compose(binary_operator< bit_xor_equal> (), make_actor(_1), make_actor(_2)); 
# 341
} 
# 343
template< class T> 
# 344
struct bit_lshift_equal : public binary_function< T &, T, T &>  { 
# 347
T &operator()(T &lhs, const T &rhs) const { return lhs <<= rhs; } 
# 348
}; 
# 350
template< class T1, class T2> actor< composite< binary_operator< bit_lshift_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 359
operator<<=(const actor< T1>  &_1, const T2 &_2) 
# 360
{ 
# 361
return compose(binary_operator< bit_lshift_equal> (), make_actor(_1), make_actor(_2)); 
# 364
} 
# 366
template< class T1, class T2> actor< composite< binary_operator< bit_lshift_equal> , actor< T1> , actor< T2> > >  
# 375
operator<<=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 376
{ 
# 377
return compose(binary_operator< bit_lshift_equal> (), make_actor(_1), make_actor(_2)); 
# 380
} 
# 382
template< class T> 
# 383
struct bit_rshift_equal : public binary_function< T &, T, T &>  { 
# 386
T &operator()(T &lhs, const T &rhs) const { return lhs >>= rhs; } 
# 387
}; 
# 389
template< class T1, class T2> actor< composite< binary_operator< bit_rshift_equal> , actor< T1> , typename as_actor< T2> ::type> >  
# 398
operator>>=(const actor< T1>  &_1, const T2 &_2) 
# 399
{ 
# 400
return compose(binary_operator< bit_rshift_equal> (), make_actor(_1), make_actor(_2)); 
# 403
} 
# 405
template< class T1, class T2> actor< composite< binary_operator< bit_rshift_equal> , actor< T1> , actor< T2> > >  
# 414
operator>>=(const actor< T1>  &_1, const actor< T2>  &_2) 
# 415
{ 
# 416
return compose(binary_operator< bit_rshift_equal> (), make_actor(_1), make_actor(_2)); 
# 419
} 
# 421
}
# 422
}
# 423
}
# 71 "/usr/include/c++/5/cstring" 3
namespace std __attribute((__visibility__("default"))) { 
# 75
using ::memchr;
# 76
using ::memcmp;
# 77
using ::memcpy;
# 78
using ::memmove;
# 79
using ::memset;
# 80
using ::strcat;
# 81
using ::strcmp;
# 82
using ::strcoll;
# 83
using ::strcpy;
# 84
using ::strcspn;
# 85
using ::strerror;
# 86
using ::strlen;
# 87
using ::strncat;
# 88
using ::strncmp;
# 89
using ::strncpy;
# 90
using ::strspn;
# 91
using ::strtok;
# 92
using ::strxfrm;
# 93
using ::strchr;
# 94
using ::strpbrk;
# 95
using ::strrchr;
# 96
using ::strstr;
# 121
}
# 25 "/usr/local/cuda/include/thrust/system/detail/error_category.inl"
namespace thrust { 
# 28
namespace system { 
# 32
inline error_category::~error_category() 
# 33
{ 
# 34
; 
# 35
} 
# 39
inline error_condition error_category::default_error_condition(int ev) const 
# 40
{ 
# 41
return error_condition(ev, *this); 
# 42
} 
# 46
inline bool error_category::equivalent(int code, const error_condition &condition) const 
# 47
{ 
# 48
return ((this->default_error_condition(code)) == condition); 
# 49
} 
# 53
inline bool error_category::equivalent(const error_code &code, int condition) const 
# 54
{ 
# 55
bool result = this->operator==(code.category()) && (code.value() == condition); 
# 56
return result; 
# 57
} 
# 61
inline bool error_category::operator==(const error_category &rhs) const 
# 62
{ 
# 63
return this == (&rhs); 
# 64
} 
# 68
inline bool error_category::operator!=(const error_category &rhs) const 
# 69
{ 
# 70
return !this->operator==(rhs); 
# 71
} 
# 75
inline bool error_category::operator<(const error_category &rhs) const 
# 76
{ 
# 77
return less< const error_category *> ()(this, &rhs); 
# 78
} 
# 81
namespace detail { 
# 85
class generic_error_category : public error_category { 
# 89
public: generic_error_category() { } 
# 91
virtual const char *name() const 
# 92
{ 
# 93
return "generic"; 
# 94
} 
# 96
virtual std::__cxx11::string message(int ev) const 
# 97
{ 
# 98
static const std::__cxx11::string unknown_err("Unknown error"); 
# 102
const char *c_str = std::strerror(ev); 
# 103
return ((c_str) ? ((std::__cxx11::string)(c_str)) : unknown_err); 
# 104
} 
# 105
}; 
# 108
class system_error_category : public error_category { 
# 112
public: system_error_category() { } 
# 114
virtual const char *name() const 
# 115
{ 
# 116
return "system"; 
# 117
} 
# 119
virtual std::__cxx11::string message(int ev) const 
# 120
{ 
# 121
return generic_category().message(ev); 
# 122
} 
# 124
virtual error_condition default_error_condition(int ev) const 
# 125
{ 
# 126
using namespace errc;
# 128
switch (ev) 
# 129
{ 
# 130
case eafnosupport:  return make_error_condition(address_family_not_supported); 
# 131
case eaddrinuse:  return make_error_condition(address_in_use); 
# 132
case eaddrnotavail:  return make_error_condition(address_not_available); 
# 133
case eisconn:  return make_error_condition(already_connected); 
# 134
case e2big:  return make_error_condition(argument_list_too_long); 
# 135
case edom:  return make_error_condition(argument_out_of_domain); 
# 136
case efault:  return make_error_condition(bad_address); 
# 137
case ebadf:  return make_error_condition(bad_file_descriptor); 
# 138
case ebadmsg:  return make_error_condition(bad_message); 
# 139
case epipe:  return make_error_condition(broken_pipe); 
# 140
case econnaborted:  return make_error_condition(connection_aborted); 
# 141
case ealready:  return make_error_condition(connection_already_in_progress); 
# 142
case econnrefused:  return make_error_condition(connection_refused); 
# 143
case econnreset:  return make_error_condition(connection_reset); 
# 144
case exdev:  return make_error_condition(cross_device_link); 
# 145
case edestaddrreq:  return make_error_condition(destination_address_required); 
# 146
case ebusy:  return make_error_condition(device_or_resource_busy); 
# 147
case enotempty:  return make_error_condition(directory_not_empty); 
# 148
case enoexec:  return make_error_condition(executable_format_error); 
# 149
case eexist:  return make_error_condition(file_exists); 
# 150
case efbig:  return make_error_condition(file_too_large); 
# 151
case enametoolong:  return make_error_condition(filename_too_long); 
# 152
case enosys:  return make_error_condition(function_not_supported); 
# 153
case ehostunreach:  return make_error_condition(host_unreachable); 
# 154
case eidrm:  return make_error_condition(identifier_removed); 
# 155
case eilseq:  return make_error_condition(illegal_byte_sequence); 
# 156
case enotty:  return make_error_condition(inappropriate_io_control_operation); 
# 157
case eintr:  return make_error_condition(interrupted); 
# 158
case einval:  return make_error_condition(invalid_argument); 
# 159
case espipe:  return make_error_condition(invalid_seek); 
# 160
case eio:  return make_error_condition(io_error); 
# 161
case eisdir:  return make_error_condition(is_a_directory); 
# 162
case emsgsize:  return make_error_condition(message_size); 
# 163
case enetdown:  return make_error_condition(network_down); 
# 164
case enetreset:  return make_error_condition(network_reset); 
# 165
case enetunreach:  return make_error_condition(network_unreachable); 
# 166
case enobufs:  return make_error_condition(no_buffer_space); 
# 167
case echild:  return make_error_condition(no_child_process); 
# 168
case enolink:  return make_error_condition(no_link); 
# 169
case enolck:  return make_error_condition(no_lock_available); 
# 170
case enodata:  return make_error_condition(no_message_available); 
# 171
case enomsg:  return make_error_condition(no_message); 
# 172
case enoprotoopt:  return make_error_condition(no_protocol_option); 
# 173
case enospc:  return make_error_condition(no_space_on_device); 
# 174
case enosr:  return make_error_condition(no_stream_resources); 
# 175
case enxio:  return make_error_condition(no_such_device_or_address); 
# 176
case enodev:  return make_error_condition(no_such_device); 
# 177
case enoent:  return make_error_condition(no_such_file_or_directory); 
# 178
case esrch:  return make_error_condition(no_such_process); 
# 179
case enotdir:  return make_error_condition(not_a_directory); 
# 180
case enotsock:  return make_error_condition(not_a_socket); 
# 181
case enostr:  return make_error_condition(not_a_stream); 
# 182
case enotconn:  return make_error_condition(not_connected); 
# 183
case enomem:  return make_error_condition(not_enough_memory); 
# 184
case enotsup:  return make_error_condition(not_supported); 
# 185
case ecanceled:  return make_error_condition(operation_canceled); 
# 186
case einprogress:  return make_error_condition(operation_in_progress); 
# 187
case eperm:  return make_error_condition(operation_not_permitted); 
# 188
case eopnotsupp:  return make_error_condition(operation_not_supported); 
# 189
case ewouldblock:  return make_error_condition(operation_would_block); 
# 190
case eownerdead:  return make_error_condition(owner_dead); 
# 191
case eacces:  return make_error_condition(permission_denied); 
# 192
case eproto:  return make_error_condition(protocol_error); 
# 193
case eprotonosupport:  return make_error_condition(protocol_not_supported); 
# 194
case erofs:  return make_error_condition(read_only_file_system); 
# 195
case edeadlk:  return make_error_condition(resource_deadlock_would_occur); 
# 196
case eagain:  return make_error_condition(resource_unavailable_try_again); 
# 197
case erange:  return make_error_condition(result_out_of_range); 
# 198
case enotrecoverable:  return make_error_condition(state_not_recoverable); 
# 199
case etime:  return make_error_condition(stream_timeout); 
# 200
case etxtbsy:  return make_error_condition(text_file_busy); 
# 201
case etimedout:  return make_error_condition(timed_out); 
# 202
case enfile:  return make_error_condition(too_many_files_open_in_system); 
# 203
case emfile:  return make_error_condition(too_many_files_open); 
# 204
case emlink:  return make_error_condition(too_many_links); 
# 205
case eloop:  return make_error_condition(too_many_symbolic_link_levels); 
# 206
case eoverflow:  return make_error_condition(value_too_large); 
# 207
case eprototype:  return make_error_condition(wrong_protocol_type); 
# 208
default:  return error_condition(ev, system_category()); 
# 209
}  
# 210
} 
# 211
}; 
# 214
}
# 217
inline const error_category &generic_category() 
# 218
{ 
# 219
static const detail::generic_error_category result; 
# 220
return result; 
# 221
} 
# 224
inline const error_category &system_category() 
# 225
{ 
# 226
static const detail::system_error_category result; 
# 227
return result; 
# 228
} 
# 231
}
# 233
}
# 22 "/usr/local/cuda/include/thrust/system/detail/error_code.inl"
namespace thrust { 
# 25
namespace system { 
# 29
inline error_code::error_code() : m_val(0), m_cat(&system_category()) 
# 31
{ 
# 32
; 
# 33
} 
# 37
inline error_code::error_code(int val, const error_category &cat) : m_val(val), m_cat(&cat) 
# 39
{ 
# 40
; 
# 41
} 
# 44
template< class ErrorCodeEnum> 
# 46
error_code::error_code(ErrorCodeEnum e, typename thrust::detail::enable_if< is_error_code_enum< ErrorCodeEnum> ::value> ::type *) 
# 52
{ 
# 53
(*this) = make_error_code(e); 
# 54
} 
# 58
inline void error_code::assign(int val, const error_category &cat) 
# 59
{ 
# 60
(m_val) = val; 
# 61
(m_cat) = (&cat); 
# 62
} 
# 65
template< class ErrorCodeEnum> typename thrust::detail::enable_if< is_error_code_enum< ErrorCodeEnum> ::value, error_code> ::type &
# 73
error_code::operator=(ErrorCodeEnum e) 
# 74
{ 
# 75
(*this) = make_error_code(e); 
# 76
return *this; 
# 77
} 
# 81
inline void error_code::clear() 
# 82
{ 
# 83
(m_val) = 0; 
# 84
(m_cat) = (&system_category()); 
# 85
} 
# 89
inline int error_code::value() const 
# 90
{ 
# 91
return m_val; 
# 92
} 
# 96
inline const error_category &error_code::category() const 
# 97
{ 
# 98
return *(m_cat); 
# 99
} 
# 103
inline error_condition error_code::default_error_condition() const 
# 104
{ 
# 105
return this->category().default_error_condition(this->value()); 
# 106
} 
# 110
inline std::__cxx11::string error_code::message() const 
# 111
{ 
# 112
return this->category().message(this->value()); 
# 113
} 
# 117
inline error_code::operator bool() const 
# 118
{ 
# 119
return this->value() != 0; 
# 120
} 
# 123
inline error_code make_error_code(errc::errc_t e) 
# 124
{ 
# 125
return error_code(static_cast< int>(e), generic_category()); 
# 126
} 
# 129
inline bool operator<(const error_code &lhs, const error_code &rhs) 
# 130
{ 
# 131
bool result = lhs.category().operator<(rhs.category()); 
# 132
result = (result || lhs.category().operator==(rhs.category())); 
# 133
result = (result || (lhs.value() < rhs.value())); 
# 134
return result; 
# 135
} 
# 138
template< class charT, class traits> std::basic_ostream< charT, traits>  &
# 140
operator<<(std::basic_ostream< charT, traits>  &os, const error_code &ec) 
# 141
{ 
# 142
return ((os << ec.category().name()) << ':') << ec.value(); 
# 143
} 
# 146
inline bool operator==(const error_code &lhs, const error_code &rhs) 
# 147
{ 
# 148
return lhs.category().operator==(rhs.category()) && (lhs.value() == rhs.value()); 
# 149
} 
# 152
inline bool operator==(const error_code &lhs, const error_condition &rhs) 
# 153
{ 
# 154
return lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs, rhs.value()); 
# 155
} 
# 158
inline bool operator==(const error_condition &lhs, const error_code &rhs) 
# 159
{ 
# 160
return rhs.category().equivalent(lhs.value(), lhs) || lhs.category().equivalent(rhs, lhs.value()); 
# 161
} 
# 164
inline bool operator==(const error_condition &lhs, const error_condition &rhs) 
# 165
{ 
# 166
return lhs.category().operator==(rhs.category()) && (lhs.value() == rhs.value()); 
# 167
} 
# 170
inline bool operator!=(const error_code &lhs, const error_code &rhs) 
# 171
{ 
# 172
return !((lhs == rhs)); 
# 173
} 
# 176
inline bool operator!=(const error_code &lhs, const error_condition &rhs) 
# 177
{ 
# 178
return !((lhs == rhs)); 
# 179
} 
# 182
inline bool operator!=(const error_condition &lhs, const error_code &rhs) 
# 183
{ 
# 184
return !((lhs == rhs)); 
# 185
} 
# 188
inline bool operator!=(const error_condition &lhs, const error_condition &rhs) 
# 189
{ 
# 190
return !((lhs == rhs)); 
# 191
} 
# 194
}
# 196
}
# 23 "/usr/local/cuda/include/thrust/system/detail/error_condition.inl"
namespace thrust { 
# 26
namespace system { 
# 30
inline error_condition::error_condition() : m_val(0), m_cat(&generic_category()) 
# 32
{ 
# 33
; 
# 34
} 
# 38
inline error_condition::error_condition(int val, const error_category &cat) : m_val(val), m_cat(&cat) 
# 40
{ 
# 41
; 
# 42
} 
# 45
template< class ErrorConditionEnum> 
# 47
error_condition::error_condition(ErrorConditionEnum e, typename thrust::detail::enable_if< is_error_condition_enum< ErrorConditionEnum> ::value> ::type *) 
# 53
{ 
# 54
(*this) = make_error_condition(e); 
# 55
} 
# 59
inline void error_condition::assign(int val, const error_category &cat) 
# 60
{ 
# 61
(m_val) = val; 
# 62
(m_cat) = (&cat); 
# 63
} 
# 66
template< class ErrorConditionEnum> typename thrust::detail::enable_if< is_error_condition_enum< ErrorConditionEnum> ::value, error_condition> ::type &
# 74
error_condition::operator=(ErrorConditionEnum e) 
# 75
{ 
# 76
(*this) = make_error_condition(e); 
# 77
return *this; 
# 78
} 
# 82
inline void error_condition::clear() 
# 83
{ 
# 84
(m_val) = 0; 
# 85
(m_cat) = (&generic_category()); 
# 86
} 
# 90
inline int error_condition::value() const 
# 91
{ 
# 92
return m_val; 
# 93
} 
# 97
inline const error_category &error_condition::category() const 
# 98
{ 
# 99
return *(m_cat); 
# 100
} 
# 104
inline std::__cxx11::string error_condition::message() const 
# 105
{ 
# 106
return this->category().message(this->value()); 
# 107
} 
# 111
inline error_condition::operator bool() const 
# 112
{ 
# 113
return this->value() != 0; 
# 114
} 
# 117
inline error_condition make_error_condition(errc::errc_t e) 
# 118
{ 
# 119
return error_condition(static_cast< int>(e), generic_category()); 
# 120
} 
# 123
inline bool operator<(const error_condition &lhs, const error_condition &
# 124
rhs) 
# 125
{ 
# 126
return lhs.category().operator<(rhs.category()) || (lhs.category().operator==(rhs.category()) && (lhs.value() < rhs.value())); 
# 127
} 
# 130
}
# 132
}
# 31 "/usr/local/cuda/include/thrust/system/system_error.h"
namespace thrust { 
# 34
namespace system { 
# 89
class system_error : public std::runtime_error { 
# 101
public: inline system_error(error_code ec, const std::__cxx11::string & what_arg); 
# 109
inline system_error(error_code ec, const char * what_arg); 
# 115
inline system_error(error_code ec); 
# 124
inline system_error(int ev, const error_category & ecat, const std::__cxx11::string & what_arg); 
# 133
inline system_error(int ev, const error_category & ecat, const char * what_arg); 
# 140
inline system_error(int ev, const error_category & ecat); 
# 144
virtual ~system_error() throw() { } 
# 150
inline const error_code &code() const throw(); 
# 156
inline virtual const char *what() const throw(); 
# 161
private: error_code m_error_code; 
# 162
mutable std::__cxx11::string m_what; 
# 166
}; 
# 168
}
# 174
using system::system_error;
# 176
}
# 22 "/usr/local/cuda/include/thrust/system/detail/system_error.inl"
namespace thrust { 
# 25
namespace system { 
# 30
inline system_error::system_error(error_code ec, const std::__cxx11::string &what_arg) : std::runtime_error(what_arg), m_error_code(ec) 
# 32
{ 
# 34
} 
# 38
inline system_error::system_error(error_code ec, const char *what_arg) : std::runtime_error(what_arg), m_error_code(ec) 
# 40
{ 
# 41
; 
# 42
} 
# 46
inline system_error::system_error(error_code ec) : std::runtime_error(""), m_error_code(ec) 
# 48
{ 
# 49
; 
# 50
} 
# 54
inline system_error::system_error(int ev, const error_category &ecat, const std::__cxx11::string &what_arg) : std::runtime_error(what_arg), m_error_code(ev, ecat) 
# 56
{ 
# 57
; 
# 58
} 
# 62
inline system_error::system_error(int ev, const error_category &ecat, const char *what_arg) : std::runtime_error(what_arg), m_error_code(ev, ecat) 
# 64
{ 
# 65
; 
# 66
} 
# 70
inline system_error::system_error(int ev, const error_category &ecat) : std::runtime_error(""), m_error_code(ev, ecat) 
# 72
{ 
# 73
; 
# 74
} 
# 78
inline const error_code &system_error::code() const throw() 
# 79
{ 
# 80
return m_error_code; 
# 81
} 
# 85
inline const char *system_error::what() const throw() 
# 86
{ 
# 87
if ((m_what).empty()) 
# 88
{ 
# 89
try 
# 90
{ 
# 91
((m_what) = (this->std::runtime_error::what())); 
# 92
if ((m_error_code)) 
# 93
{ 
# 94
if (!(m_what).empty()) { ((m_what) += (": ")); }  
# 95
((m_what) += ((m_error_code).message())); 
# 96
}  
# 97
} 
# 98
catch (...) 
# 99
{ 
# 100
return this->std::runtime_error::what(); 
# 101
}  
# 102
}  
# 104
return (m_what).c_str(); 
# 105
} 
# 108
}
# 110
}
# 29 "/usr/local/cuda/include/thrust/system/cuda/error.h"
namespace thrust { 
# 32
namespace system { 
# 35
namespace cuda { 
# 47
namespace errc { 
# 52
enum errc_t { 
# 56
success, 
# 57
missing_configuration, 
# 58
memory_allocation, 
# 59
initialization_error, 
# 60
launch_failure, 
# 61
prior_launch_failure, 
# 62
launch_timeout, 
# 63
launch_out_of_resources, 
# 64
invalid_device_function, 
# 65
invalid_configuration, 
# 66
invalid_device, 
# 67
invalid_value, 
# 68
invalid_pitch_value, 
# 69
invalid_symbol, 
# 70
map_buffer_object_failed, 
# 71
unmap_buffer_object_failed, 
# 72
invalid_host_pointer, 
# 73
invalid_device_pointer, 
# 74
invalid_texture, 
# 75
invalid_texture_binding, 
# 76
invalid_channel_descriptor, 
# 77
invalid_memcpy_direction, 
# 78
address_of_constant_error, 
# 79
texture_fetch_failed, 
# 80
texture_not_bound, 
# 81
synchronization_error, 
# 82
invalid_filter_setting, 
# 83
invalid_norm_setting, 
# 84
mixed_device_execution, 
# 85
cuda_runtime_unloading, 
# 86
unknown, 
# 87
not_yet_implemented, 
# 88
memory_value_too_large, 
# 89
invalid_resource_handle, 
# 90
not_ready, 
# 91
insufficient_driver, 
# 92
set_on_active_process_error, 
# 93
no_device = 38, 
# 94
ecc_uncorrectable, 
# 97
shared_object_symbol_not_found, 
# 98
shared_object_init_failed, 
# 99
unsupported_limit, 
# 100
duplicate_variable_name, 
# 101
duplicate_texture_name, 
# 102
duplicate_surface_name, 
# 103
devices_unavailable, 
# 104
invalid_kernel_image, 
# 105
no_kernel_image_for_device, 
# 106
incompatible_driver_context, 
# 107
peer_access_already_enabled, 
# 108
peer_access_not_enabled, 
# 109
device_already_in_use = 54, 
# 110
profiler_disabled, 
# 111
assert_triggered = 59, 
# 112
too_many_peers, 
# 113
host_memory_already_registered, 
# 114
host_memory_not_registered, 
# 115
operating_system_error, 
# 119
peer_access_unsupported, 
# 120
launch_max_depth_exceeded, 
# 121
launch_file_scoped_texture_used, 
# 122
launch_file_scoped_surface_used, 
# 123
sync_depth_exceeded, 
# 124
attempted_operation_not_permitted = 70, 
# 125
attempted_operation_not_supported, 
# 128
startup_failure = 127
# 129
}; 
# 132
}
# 134
}
# 146
inline const error_category &cuda_category(); 
# 153
template<> struct is_error_code_enum< cuda::errc::errc_t>  : public thrust::detail::true_type { }; 
# 159
inline error_code make_error_code(cuda::errc::errc_t e); 
# 165
inline error_condition make_error_condition(cuda::errc::errc_t e); 
# 171
}
# 173
namespace cuda { 
# 177
namespace errc = system::cuda::errc;
# 179
}
# 181
using system::cuda_category;
# 183
}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/error.inl"
namespace thrust { 
# 26
namespace system { 
# 30
inline error_code make_error_code(cuda::errc::errc_t e) 
# 31
{ 
# 32
return error_code(static_cast< int>(e), cuda_category()); 
# 33
} 
# 36
inline error_condition make_error_condition(cuda::errc::errc_t e) 
# 37
{ 
# 38
return error_condition(static_cast< int>(e), cuda_category()); 
# 39
} 
# 42
namespace cuda { 
# 45
namespace detail { 
# 49
class cuda_error_category : public error_category { 
# 53
public: cuda_error_category() { } 
# 55
virtual const char *name() const 
# 56
{ 
# 57
return "cuda"; 
# 58
} 
# 60
virtual std::__cxx11::string message(int ev) const 
# 61
{ 
# 62
static const std::__cxx11::string unknown_err("Unknown error"); 
# 63
const char *c_str = ::cudaGetErrorString(static_cast< cudaError_t>(ev)); 
# 64
return ((c_str) ? ((std::__cxx11::string)(c_str)) : unknown_err); 
# 65
} 
# 67
virtual error_condition default_error_condition(int ev) const 
# 68
{ 
# 69
using namespace errc;
# 71
if (ev < (::cudaErrorApiFailureBase)) 
# 72
{ 
# 73
return make_error_condition(static_cast< errc::errc_t>(ev)); 
# 74
}  
# 76
return system_category().default_error_condition(ev); 
# 77
} 
# 78
}; 
# 80
}
# 82
}
# 85
inline const error_category &cuda_category() 
# 86
{ 
# 87
static const cuda::detail::cuda_error_category result; 
# 88
return result; 
# 89
} 
# 92
}
# 94
}
# 23 "/usr/local/cuda/include/thrust/system/detail/bad_alloc.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 31
class bad_alloc : public std::bad_alloc { 
# 35
public: bad_alloc(const std::__cxx11::string &w) : std::bad_alloc(), m_what() 
# 37
{ 
# 38
((m_what) = (this->std::bad_alloc::what())); 
# 39
((m_what) += (": ")); 
# 40
((m_what) += w); 
# 41
} 
# 43
virtual ~bad_alloc() throw() { } 
# 45
virtual const char *what() const throw() 
# 46
{ 
# 47
return (m_what).c_str(); 
# 48
} 
# 51
private: std::__cxx11::string m_what; 
# 52
}; 
# 54
}
# 55
}
# 56
}
# 83 "/usr/local/cuda/include/thrust/version.h"
namespace thrust { 
# 86
}
# 29 "/usr/include/stdio.h" 3
extern "C" {
# 25 "/usr/include/_G_config.h" 3
typedef 
# 22
struct { 
# 23
__off_t __pos; 
# 24
__mbstate_t __state; 
# 25
} _G_fpos_t; 
# 30
typedef 
# 27
struct { 
# 28
__off64_t __pos; 
# 29
__mbstate_t __state; 
# 30
} _G_fpos64_t; 
# 144 "/usr/include/libio.h" 3
struct _IO_jump_t; struct _IO_FILE; 
# 150
typedef void _IO_lock_t; 
# 156
struct _IO_marker { 
# 157
_IO_marker *_next; 
# 158
_IO_FILE *_sbuf; 
# 162
int _pos; 
# 173
}; 
# 176
enum __codecvt_result { 
# 178
__codecvt_ok, 
# 179
__codecvt_partial, 
# 180
__codecvt_error, 
# 181
__codecvt_noconv
# 182
}; 
# 241
struct _IO_FILE { 
# 242
int _flags; 
# 247
char *_IO_read_ptr; 
# 248
char *_IO_read_end; 
# 249
char *_IO_read_base; 
# 250
char *_IO_write_base; 
# 251
char *_IO_write_ptr; 
# 252
char *_IO_write_end; 
# 253
char *_IO_buf_base; 
# 254
char *_IO_buf_end; 
# 256
char *_IO_save_base; 
# 257
char *_IO_backup_base; 
# 258
char *_IO_save_end; 
# 260
_IO_marker *_markers; 
# 262
_IO_FILE *_chain; 
# 264
int _fileno; 
# 268
int _flags2; 
# 270
__off_t _old_offset; 
# 274
unsigned short _cur_column; 
# 275
signed char _vtable_offset; 
# 276
char _shortbuf[1]; 
# 280
_IO_lock_t *_lock; 
# 289
__off64_t _offset; 
# 297
void *__pad1; 
# 298
void *__pad2; 
# 299
void *__pad3; 
# 300
void *__pad4; 
# 302
size_t __pad5; 
# 303
int _mode; 
# 305
char _unused2[(((15) * sizeof(int)) - ((4) * sizeof(void *))) - sizeof(size_t)]; 
# 307
}; 
# 313
struct _IO_FILE_plus; 
# 315
extern _IO_FILE_plus _IO_2_1_stdin_; 
# 316
extern _IO_FILE_plus _IO_2_1_stdout_; 
# 317
extern _IO_FILE_plus _IO_2_1_stderr_; 
# 333
typedef __ssize_t __io_read_fn(void * __cookie, char * __buf, size_t __nbytes); 
# 341
typedef __ssize_t __io_write_fn(void * __cookie, const char * __buf, size_t __n); 
# 350
typedef int __io_seek_fn(void * __cookie, __off64_t * __pos, int __w); 
# 353
typedef int __io_close_fn(void * __cookie); 
# 358
typedef __io_read_fn cookie_read_function_t; 
# 359
typedef __io_write_fn cookie_write_function_t; 
# 360
typedef __io_seek_fn cookie_seek_function_t; 
# 361
typedef __io_close_fn cookie_close_function_t; 
# 370
typedef 
# 365
struct { 
# 366
__io_read_fn *read; 
# 367
__io_write_fn *write; 
# 368
__io_seek_fn *seek; 
# 369
__io_close_fn *close; 
# 370
} _IO_cookie_io_functions_t; 
# 371
typedef _IO_cookie_io_functions_t cookie_io_functions_t; 
# 373
struct _IO_cookie_file; 
# 376
extern void _IO_cookie_init(_IO_cookie_file * __cfile, int __read_write, void * __cookie, _IO_cookie_io_functions_t __fns); 
# 382
extern "C" {
# 385
extern int __underflow(_IO_FILE *); 
# 386
extern int __uflow(_IO_FILE *); 
# 387
extern int __overflow(_IO_FILE *, int); 
# 429
extern int _IO_getc(_IO_FILE * __fp); 
# 430
extern int _IO_putc(int __c, _IO_FILE * __fp); 
# 431
extern int _IO_feof(_IO_FILE * __fp) throw(); 
# 432
extern int _IO_ferror(_IO_FILE * __fp) throw(); 
# 434
extern int _IO_peekc_locked(_IO_FILE * __fp); 
# 440
extern void _IO_flockfile(_IO_FILE *) throw(); 
# 441
extern void _IO_funlockfile(_IO_FILE *) throw(); 
# 442
extern int _IO_ftrylockfile(_IO_FILE *) throw(); 
# 459
extern int _IO_vfscanf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list, int *__restrict__); 
# 461
extern int _IO_vfprintf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list); 
# 463
extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t); 
# 464
extern size_t _IO_sgetn(_IO_FILE *, void *, size_t); 
# 466
extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int); 
# 467
extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int); 
# 469
extern void _IO_free_backup_area(_IO_FILE *) throw(); 
# 521
}
# 79 "/usr/include/stdio.h" 3
typedef __gnuc_va_list va_list; 
# 110
typedef _G_fpos_t fpos_t; 
# 116
typedef _G_fpos64_t fpos64_t; 
# 168
extern _IO_FILE *stdin; 
# 169
extern _IO_FILE *stdout; 
# 170
extern _IO_FILE *stderr; 
# 178
extern int remove(const char * __filename) throw(); 
# 180
extern int rename(const char * __old, const char * __new) throw(); 
# 185
extern int renameat(int __oldfd, const char * __old, int __newfd, const char * __new) throw(); 
# 195
extern FILE *tmpfile() __attribute((__warn_unused_result__)); 
# 205
extern FILE *tmpfile64() __attribute((__warn_unused_result__)); 
# 209
extern char *tmpnam(char * __s) throw() __attribute((__warn_unused_result__)); 
# 215
extern char *tmpnam_r(char * __s) throw() __attribute((__warn_unused_result__)); 
# 227
extern char *tempnam(const char * __dir, const char * __pfx) throw()
# 228
 __attribute((__malloc__)) __attribute((__warn_unused_result__)); 
# 237
extern int fclose(FILE * __stream); 
# 242
extern int fflush(FILE * __stream); 
# 252
extern int fflush_unlocked(FILE * __stream); 
# 262
extern int fcloseall(); 
# 272
extern FILE *fopen(const char *__restrict__ __filename, const char *__restrict__ __modes)
# 273
 __attribute((__warn_unused_result__)); 
# 278
extern FILE *freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream)
# 280
 __attribute((__warn_unused_result__)); 
# 297
extern FILE *fopen64(const char *__restrict__ __filename, const char *__restrict__ __modes)
# 298
 __attribute((__warn_unused_result__)); 
# 299
extern FILE *freopen64(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream)
# 301
 __attribute((__warn_unused_result__)); 
# 306
extern FILE *fdopen(int __fd, const char * __modes) throw() __attribute((__warn_unused_result__)); 
# 312
extern FILE *fopencookie(void *__restrict__ __magic_cookie, const char *__restrict__ __modes, _IO_cookie_io_functions_t __io_funcs) throw()
# 314
 __attribute((__warn_unused_result__)); 
# 319
extern FILE *fmemopen(void * __s, size_t __len, const char * __modes) throw()
# 320
 __attribute((__warn_unused_result__)); 
# 325
extern FILE *open_memstream(char ** __bufloc, size_t * __sizeloc) throw() __attribute((__warn_unused_result__)); 
# 332
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) throw(); 
# 336
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int __modes, size_t __n) throw(); 
# 343
extern void setbuffer(FILE *__restrict__ __stream, char *__restrict__ __buf, size_t __size) throw(); 
# 347
extern void setlinebuf(FILE * __stream) throw(); 
# 356
extern __attribute((gnu_inline)) inline int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...); 
# 362
extern __attribute((gnu_inline)) inline int printf(const char *__restrict__ __format, ...); 
# 364
extern __attribute((gnu_inline)) inline int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) throw(); 
# 371
extern __attribute((gnu_inline)) inline int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg); 
# 377
extern __attribute((gnu_inline)) inline int vprintf(const char *__restrict__ __format, __gnuc_va_list __arg); 
# 379
extern __attribute((gnu_inline)) inline int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 386
extern __attribute((gnu_inline)) inline int snprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, ...) throw()
# 388
 __attribute((__format__(__printf__, 3, 4))); 
# 390
extern __attribute((gnu_inline)) inline int vsnprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, __gnuc_va_list __arg) throw()
# 392
 __attribute((__format__(__printf__, 3, 0))); 
# 399
extern __attribute((gnu_inline)) inline int vasprintf(char **__restrict__ __ptr, const char *__restrict__ __f, __gnuc_va_list __arg) throw()
# 401
 __attribute((__format__(__printf__, 2, 0))) __attribute((__warn_unused_result__)); 
# 402
extern __attribute((gnu_inline)) inline int __asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 404
 __attribute((__format__(__printf__, 2, 3))) __attribute((__warn_unused_result__)); 
# 405
extern __attribute((gnu_inline)) inline int asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 407
 __attribute((__format__(__printf__, 2, 3))) __attribute((__warn_unused_result__)); 
# 412
extern __attribute((gnu_inline)) inline int vdprintf(int __fd, const char *__restrict__ __fmt, __gnuc_va_list __arg)
# 414
 __attribute((__format__(__printf__, 2, 0))); 
# 415
extern __attribute((gnu_inline)) inline int dprintf(int __fd, const char *__restrict__ __fmt, ...)
# 416
 __attribute((__format__(__printf__, 2, 3))); 
# 425
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...)
# 426
 __attribute((__warn_unused_result__)); 
# 431
extern int scanf(const char *__restrict__ __format, ...) __attribute((__warn_unused_result__)); 
# 433
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) throw(); 
# 471
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg)
# 473
 __attribute((__format__(__scanf__, 2, 0))) __attribute((__warn_unused_result__)); 
# 479
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list __arg)
# 480
 __attribute((__format__(__scanf__, 1, 0))) __attribute((__warn_unused_result__)); 
# 483
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw()
# 485
 __attribute((__format__(__scanf__, 2, 0))); 
# 531
extern int fgetc(FILE * __stream); 
# 532
extern int getc(FILE * __stream); 
# 538
extern __attribute((gnu_inline)) inline int getchar(); 
# 550
extern __attribute((gnu_inline)) inline int getc_unlocked(FILE * __stream); 
# 551
extern __attribute((gnu_inline)) inline int getchar_unlocked(); 
# 561
extern __attribute((gnu_inline)) inline int fgetc_unlocked(FILE * __stream); 
# 573
extern int fputc(int __c, FILE * __stream); 
# 574
extern int putc(int __c, FILE * __stream); 
# 580
extern __attribute((gnu_inline)) inline int putchar(int __c); 
# 594
extern __attribute((gnu_inline)) inline int fputc_unlocked(int __c, FILE * __stream); 
# 602
extern __attribute((gnu_inline)) inline int putc_unlocked(int __c, FILE * __stream); 
# 603
extern __attribute((gnu_inline)) inline int putchar_unlocked(int __c); 
# 610
extern int getw(FILE * __stream); 
# 613
extern int putw(int __w, FILE * __stream); 
# 622
extern __attribute((gnu_inline)) inline char *fgets(char *__restrict__ __s, int __n, FILE *__restrict__ __stream)
# 623
 __attribute((__warn_unused_result__)); 
# 638
extern char *gets(char * __s) __attribute((__warn_unused_result__)) __attribute((__deprecated__)); 
# 649
extern __attribute((gnu_inline)) inline char *fgets_unlocked(char *__restrict__ __s, int __n, FILE *__restrict__ __stream)
# 650
 __attribute((__warn_unused_result__)); 
# 665
extern __ssize_t __getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream)
# 667
 __attribute((__warn_unused_result__)); 
# 668
extern __ssize_t getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream)
# 670
 __attribute((__warn_unused_result__)); 
# 678
extern __attribute((gnu_inline)) inline __ssize_t getline(char **__restrict__ __lineptr, size_t *__restrict__ __n, FILE *__restrict__ __stream)
# 680
 __attribute((__warn_unused_result__)); 
# 689
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 695
extern int puts(const char * __s); 
# 702
extern int ungetc(int __c, FILE * __stream); 
# 709
extern __attribute((gnu_inline)) inline size_t fread(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream)
# 710
 __attribute((__warn_unused_result__)); 
# 715
extern size_t fwrite(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __s); 
# 726
extern int fputs_unlocked(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 737
extern __attribute((gnu_inline)) inline size_t fread_unlocked(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream)
# 738
 __attribute((__warn_unused_result__)); 
# 739
extern size_t fwrite_unlocked(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 749
extern int fseek(FILE * __stream, long __off, int __whence); 
# 754
extern long ftell(FILE * __stream) __attribute((__warn_unused_result__)); 
# 759
extern void rewind(FILE * __stream); 
# 773
extern int fseeko(FILE * __stream, __off_t __off, int __whence); 
# 778
extern __off_t ftello(FILE * __stream) __attribute((__warn_unused_result__)); 
# 798
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos); 
# 803
extern int fsetpos(FILE * __stream, const fpos_t * __pos); 
# 818
extern int fseeko64(FILE * __stream, __off64_t __off, int __whence); 
# 819
extern __off64_t ftello64(FILE * __stream) __attribute((__warn_unused_result__)); 
# 820
extern int fgetpos64(FILE *__restrict__ __stream, fpos64_t *__restrict__ __pos); 
# 821
extern int fsetpos64(FILE * __stream, const fpos64_t * __pos); 
# 826
extern void clearerr(FILE * __stream) throw(); 
# 828
extern int feof(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 830
extern int ferror(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 835
extern void clearerr_unlocked(FILE * __stream) throw(); 
# 836
extern __attribute((gnu_inline)) inline int feof_unlocked(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 837
extern __attribute((gnu_inline)) inline int ferror_unlocked(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 846
extern void perror(const char * __s); 
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3
extern int sys_nerr; 
# 27
extern const char *const sys_errlist[]; 
# 30
extern int _sys_nerr; 
# 31
extern const char *const _sys_errlist[]; 
# 858 "/usr/include/stdio.h" 3
extern int fileno(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 863
extern int fileno_unlocked(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 872
extern FILE *popen(const char * __command, const char * __modes) __attribute((__warn_unused_result__)); 
# 878
extern int pclose(FILE * __stream); 
# 884
extern char *ctermid(char * __s) throw(); 
# 890
extern char *cuserid(char * __s); 
# 895
struct obstack; 
# 898
extern __attribute((gnu_inline)) inline int obstack_printf(obstack *__restrict__ __obstack, const char *__restrict__ __format, ...) throw()
# 900
 __attribute((__format__(__printf__, 2, 3))); 
# 901
extern __attribute((gnu_inline)) inline int obstack_vprintf(obstack *__restrict__ __obstack, const char *__restrict__ __format, __gnuc_va_list __args) throw()
# 904
 __attribute((__format__(__printf__, 2, 0))); 
# 912
extern void flockfile(FILE * __stream) throw(); 
# 916
extern int ftrylockfile(FILE * __stream) throw() __attribute((__warn_unused_result__)); 
# 919
extern void funlockfile(FILE * __stream) throw(); 
# 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3
__attribute((__gnu_inline__)) extern inline int 
# 44
getchar() 
# 45
{ 
# 46
return _IO_getc(stdin); 
# 47
} 
# 52
__attribute((__gnu_inline__)) extern inline int 
# 53
fgetc_unlocked(FILE *__fp) 
# 54
{ 
# 55
return (__builtin_expect((__fp->_IO_read_ptr) >= (__fp->_IO_read_end), 0)) ? __uflow(__fp) : (*((unsigned char *)((__fp->_IO_read_ptr)++))); 
# 56
} 
# 62
__attribute((__gnu_inline__)) extern inline int 
# 63
getc_unlocked(FILE *__fp) 
# 64
{ 
# 65
return (__builtin_expect((__fp->_IO_read_ptr) >= (__fp->_IO_read_end), 0)) ? __uflow(__fp) : (*((unsigned char *)((__fp->_IO_read_ptr)++))); 
# 66
} 
# 69
__attribute((__gnu_inline__)) extern inline int 
# 70
getchar_unlocked() 
# 71
{ 
# 72
return (__builtin_expect((stdin->_IO_read_ptr) >= (stdin->_IO_read_end), 0)) ? __uflow(stdin) : (*((unsigned char *)((stdin->_IO_read_ptr)++))); 
# 73
} 
# 78
__attribute((__gnu_inline__)) extern inline int 
# 79
putchar(int __c) 
# 80
{ 
# 81
return _IO_putc(__c, stdout); 
# 82
} 
# 87
__attribute((__gnu_inline__)) extern inline int 
# 88
fputc_unlocked(int __c, FILE *__stream) 
# 89
{ 
# 90
return (__builtin_expect((__stream->_IO_write_ptr) >= (__stream->_IO_write_end), 0)) ? __overflow(__stream, (unsigned char)__c) : ((unsigned char)((*((__stream->_IO_write_ptr)++)) = __c)); 
# 91
} 
# 97
__attribute((__gnu_inline__)) extern inline int 
# 98
putc_unlocked(int __c, FILE *__stream) 
# 99
{ 
# 100
return (__builtin_expect((__stream->_IO_write_ptr) >= (__stream->_IO_write_end), 0)) ? __overflow(__stream, (unsigned char)__c) : ((unsigned char)((*((__stream->_IO_write_ptr)++)) = __c)); 
# 101
} 
# 104
__attribute((__gnu_inline__)) extern inline int 
# 105
putchar_unlocked(int __c) 
# 106
{ 
# 107
return (__builtin_expect((stdout->_IO_write_ptr) >= (stdout->_IO_write_end), 0)) ? __overflow(stdout, (unsigned char)__c) : ((unsigned char)((*((stdout->_IO_write_ptr)++)) = __c)); 
# 108
} 
# 114
__attribute((__gnu_inline__)) extern inline __ssize_t 
# 115
getline(char **__lineptr, size_t *__n, FILE *__stream) 
# 116
{ 
# 117
return __getdelim(__lineptr, __n, '\n', __stream); 
# 118
} 
# 124
__attribute((__gnu_inline__)) extern inline int
# 125
 __attribute((__leaf__)) feof_unlocked(FILE *__stream) throw() 
# 126
{ 
# 127
return ((__stream->_flags) & 16) != 0; 
# 128
} 
# 131
__attribute((__gnu_inline__)) extern inline int
# 132
 __attribute((__leaf__)) ferror_unlocked(FILE *__stream) throw() 
# 133
{ 
# 134
return ((__stream->_flags) & 32) != 0; 
# 135
} 
# 23 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3
extern int __sprintf_chk(char *__restrict__ __s, int __flag, size_t __slen, const char *__restrict__ __format, ...) throw(); 
# 25
extern int __vsprintf_chk(char *__restrict__ __s, int __flag, size_t __slen, const char *__restrict__ __format, __gnuc_va_list __ap) throw(); 
# 30
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 31
 __attribute((__leaf__)) sprintf(char *__restrict__ __s, const char *__restrict__ __fmt, ...) throw() 
# 32
{ 
# 33
return __builtin___sprintf_chk(__s, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __builtin_va_arg_pack()); 
# 35
} 
# 42
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 43
 __attribute((__leaf__)) vsprintf(char *__restrict__ __s, const char *__restrict__ __fmt, __gnuc_va_list __ap) throw() 
# 45
{ 
# 46
return __builtin___vsprintf_chk(__s, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __ap); 
# 48
} 
# 52
extern int __snprintf_chk(char *__restrict__ __s, size_t __n, int __flag, size_t __slen, const char *__restrict__ __format, ...) throw(); 
# 55
extern int __vsnprintf_chk(char *__restrict__ __s, size_t __n, int __flag, size_t __slen, const char *__restrict__ __format, __gnuc_va_list __ap) throw(); 
# 60
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 61
 __attribute((__leaf__)) snprintf(char *__restrict__ __s, size_t __n, const char *__restrict__ __fmt, ...) throw() 
# 63
{ 
# 64
return __builtin___snprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __builtin_va_arg_pack()); 
# 66
} 
# 73
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 74
 __attribute((__leaf__)) vsnprintf(char *__restrict__ __s, size_t __n, const char *__restrict__ __fmt, __gnuc_va_list __ap) throw() 
# 76
{ 
# 77
return __builtin___vsnprintf_chk(__s, __n, 2 - 1, __builtin_object_size(__s, 2 > 1), __fmt, __ap); 
# 79
} 
# 85
extern int __fprintf_chk(FILE *__restrict__ __stream, int __flag, const char *__restrict__ __format, ...); 
# 87
extern int __printf_chk(int __flag, const char *__restrict__ __format, ...); 
# 88
extern int __vfprintf_chk(FILE *__restrict__ __stream, int __flag, const char *__restrict__ __format, __gnuc_va_list __ap); 
# 90
extern int __vprintf_chk(int __flag, const char *__restrict__ __format, __gnuc_va_list __ap); 
# 94
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 95
fprintf(FILE *__restrict__ __stream, const char *__restrict__ __fmt, ...) 
# 96
{ 
# 97
return __fprintf_chk(__stream, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 99
} 
# 101
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 102
printf(const char *__restrict__ __fmt, ...) 
# 103
{ 
# 104
return __printf_chk(2 - 1, __fmt, __builtin_va_arg_pack()); 
# 105
} 
# 113
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 114
vprintf(const char *__restrict__ __fmt, __gnuc_va_list __ap) 
# 115
{ 
# 117
return __vfprintf_chk(stdout, 2 - 1, __fmt, __ap); 
# 121
} 
# 123
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 124
vfprintf(FILE *__restrict__ __stream, const char *__restrict__ 
# 125
__fmt, __gnuc_va_list __ap) 
# 126
{ 
# 127
return __vfprintf_chk(__stream, 2 - 1, __fmt, __ap); 
# 128
} 
# 131
extern int __dprintf_chk(int __fd, int __flag, const char *__restrict__ __fmt, ...)
# 132
 __attribute((__format__(__printf__, 3, 4))); 
# 133
extern int __vdprintf_chk(int __fd, int __flag, const char *__restrict__ __fmt, __gnuc_va_list __arg)
# 135
 __attribute((__format__(__printf__, 3, 0))); 
# 138
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 139
dprintf(int __fd, const char *__restrict__ __fmt, ...) 
# 140
{ 
# 141
return __dprintf_chk(__fd, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 143
} 
# 149
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int 
# 150
vdprintf(int __fd, const char *__restrict__ __fmt, __gnuc_va_list __ap) 
# 151
{ 
# 152
return __vdprintf_chk(__fd, 2 - 1, __fmt, __ap); 
# 153
} 
# 158
extern int __asprintf_chk(char **__restrict__ __ptr, int __flag, const char *__restrict__ __fmt, ...) throw()
# 160
 __attribute((__format__(__printf__, 3, 4))) __attribute((__warn_unused_result__)); 
# 161
extern int __vasprintf_chk(char **__restrict__ __ptr, int __flag, const char *__restrict__ __fmt, __gnuc_va_list __arg) throw()
# 163
 __attribute((__format__(__printf__, 3, 0))) __attribute((__warn_unused_result__)); 
# 164
extern int __obstack_printf_chk(obstack *__restrict__ __obstack, int __flag, const char *__restrict__ __format, ...) throw()
# 167
 __attribute((__format__(__printf__, 3, 4))); 
# 168
extern int __obstack_vprintf_chk(obstack *__restrict__ __obstack, int __flag, const char *__restrict__ __format, __gnuc_va_list __args) throw()
# 172
 __attribute((__format__(__printf__, 3, 0))); 
# 175
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 176
 __attribute((__leaf__)) asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw() 
# 177
{ 
# 178
return __asprintf_chk(__ptr, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 180
} 
# 182
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 183
 __attribute((__leaf__)) __asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw() 
# 185
{ 
# 186
return __asprintf_chk(__ptr, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 188
} 
# 190
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 191
 __attribute((__leaf__)) obstack_printf(obstack *__restrict__ __obstack, const char *__restrict__ __fmt, ...) throw() 
# 193
{ 
# 194
return __obstack_printf_chk(__obstack, 2 - 1, __fmt, __builtin_va_arg_pack()); 
# 196
} 
# 206
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 207
 __attribute((__leaf__)) vasprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, __gnuc_va_list __ap) throw() 
# 209
{ 
# 210
return __vasprintf_chk(__ptr, 2 - 1, __fmt, __ap); 
# 211
} 
# 213
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) extern inline int
# 214
 __attribute((__leaf__)) obstack_vprintf(obstack *__restrict__ __obstack, const char *__restrict__ __fmt, __gnuc_va_list __ap) throw() 
# 216
{ 
# 217
return __obstack_vprintf_chk(__obstack, 2 - 1, __fmt, __ap); 
# 219
} 
# 241
extern char *__fgets_chk(char *__restrict__ __s, size_t __size, int __n, FILE *__restrict__ __stream)
# 242
 __attribute((__warn_unused_result__)); 
# 243
extern char *__fgets_alias(char *__restrict__ __s, int __n, FILE *__restrict__ __stream) __asm__("fgets")
# 245
 __attribute((__warn_unused_result__)); 
# 246
extern char *__fgets_chk_warn(char *__restrict__ __s, size_t __size, int __n, FILE *__restrict__ __stream) __asm__("__fgets_chk")
# 249
 __attribute((__warn_unused_result__)) __attribute((__warning__("fgets called with bigger size than length of destination buffer"))); 
# 252
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline char *
# 253
fgets(char *__restrict__ __s, int __n, FILE *__restrict__ __stream) 
# 254
{ 
# 255
if (__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) 
# 256
{ 
# 257
if ((!(0)) || (__n <= 0)) { 
# 258
return __fgets_chk(__s, __builtin_object_size(__s, 2 > 1), __n, __stream); }  
# 260
if (((size_t)__n) > __builtin_object_size(__s, 2 > 1)) { 
# 261
return __fgets_chk_warn(__s, __builtin_object_size(__s, 2 > 1), __n, __stream); }  
# 262
}  
# 263
return __fgets_alias(__s, __n, __stream); 
# 264
} 
# 266
extern size_t __fread_chk(void *__restrict__ __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict__ __stream)
# 268
 __attribute((__warn_unused_result__)); 
# 269
extern size_t __fread_alias(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream) __asm__("fread")
# 272
 __attribute((__warn_unused_result__)); 
# 273
extern size_t __fread_chk_warn(void *__restrict__ __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict__ __stream) __asm__("__fread_chk")
# 278
 __attribute((__warn_unused_result__)) __attribute((__warning__("fread called with bigger size * nmemb than length of destination buffer"))); 
# 281
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline size_t 
# 282
fread(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ 
# 283
__stream) 
# 284
{ 
# 285
if (__builtin_object_size(__ptr, 0) != ((size_t)(-1))) 
# 286
{ 
# 287
if (((!(0)) || (!(0))) || ((__size | __n) >= (((size_t)1) << (((8) * sizeof(size_t)) / (2))))) { 
# 290
return __fread_chk(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream); }  
# 292
if ((__size * __n) > __builtin_object_size(__ptr, 0)) { 
# 293
return __fread_chk_warn(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream); }  
# 294
}  
# 295
return __fread_alias(__ptr, __size, __n, __stream); 
# 296
} 
# 299
extern char *__fgets_unlocked_chk(char *__restrict__ __s, size_t __size, int __n, FILE *__restrict__ __stream)
# 300
 __attribute((__warn_unused_result__)); 
# 301
extern char *__fgets_unlocked_alias(char *__restrict__ __s, int __n, FILE *__restrict__ __stream) __asm__("fgets_unlocked")
# 303
 __attribute((__warn_unused_result__)); 
# 304
extern char *__fgets_unlocked_chk_warn(char *__restrict__ __s, size_t __size, int __n, FILE *__restrict__ __stream) __asm__("__fgets_unlocked_chk")
# 307
 __attribute((__warn_unused_result__)) __attribute((__warning__("fgets_unlocked called with bigger size than length of destination buffer"))); 
# 310
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline char *
# 311
fgets_unlocked(char *__restrict__ __s, int __n, FILE *__restrict__ __stream) 
# 312
{ 
# 313
if (__builtin_object_size(__s, 2 > 1) != ((size_t)(-1))) 
# 314
{ 
# 315
if ((!(0)) || (__n <= 0)) { 
# 316
return __fgets_unlocked_chk(__s, __builtin_object_size(__s, 2 > 1), __n, __stream); }  
# 318
if (((size_t)__n) > __builtin_object_size(__s, 2 > 1)) { 
# 319
return __fgets_unlocked_chk_warn(__s, __builtin_object_size(__s, 2 > 1), __n, __stream); }  
# 320
}  
# 321
return __fgets_unlocked_alias(__s, __n, __stream); 
# 322
} 
# 327
extern size_t __fread_unlocked_chk(void *__restrict__ __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict__ __stream)
# 329
 __attribute((__warn_unused_result__)); 
# 330
extern size_t __fread_unlocked_alias(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream) __asm__("fread_unlocked")
# 333
 __attribute((__warn_unused_result__)); 
# 334
extern size_t __fread_unlocked_chk_warn(void *__restrict__ __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict__ __stream) __asm__("__fread_unlocked_chk")
# 339
 __attribute((__warn_unused_result__)) __attribute((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))); 
# 342
__attribute((__always_inline__)) __attribute((__gnu_inline__)) __attribute((__artificial__)) __attribute((__warn_unused_result__)) extern inline size_t 
# 343
fread_unlocked(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ 
# 344
__stream) 
# 345
{ 
# 346
if (__builtin_object_size(__ptr, 0) != ((size_t)(-1))) 
# 347
{ 
# 348
if (((!(0)) || (!(0))) || ((__size | __n) >= (((size_t)1) << (((8) * sizeof(size_t)) / (2))))) { 
# 351
return __fread_unlocked_chk(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream); }  
# 354
if ((__size * __n) > __builtin_object_size(__ptr, 0)) { 
# 355
return __fread_unlocked_chk_warn(__ptr, __builtin_object_size(__ptr, 0), __size, __n, __stream); }  
# 357
}  
# 360
if ((0) && (0) && ((__size | __n) < (((size_t)1) << (((8) * sizeof(size_t)) / (2)))) && ((__size * __n) <= (8))) 
# 364
{ 
# 365
size_t __cnt = __size * __n; 
# 366
char *__cptr = (char *)__ptr; 
# 367
if (__cnt == (0)) { 
# 368
return 0; }  
# 370
for (; __cnt > (0); --__cnt) 
# 371
{ 
# 372
int __c = (__builtin_expect((__stream->_IO_read_ptr) >= (__stream->_IO_read_end), 0)) ? __uflow(__stream) : (*((unsigned char *)((__stream->_IO_read_ptr)++))); 
# 373
if (__c == (-1)) { 
# 374
break; }  
# 375
(*(__cptr++)) = __c; 
# 376
}  
# 377
return (__cptr - ((char *)__ptr)) / __size; 
# 378
}  
# 380
return __fread_unlocked_alias(__ptr, __size, __n, __stream); 
# 381
} 
# 942 "/usr/include/stdio.h" 3
}
# 96 "/usr/include/c++/5/cstdio" 3
namespace std { 
# 98
using ::FILE;
# 99
using ::fpos_t;
# 101
using ::clearerr;
# 102
using ::fclose;
# 103
using ::feof;
# 104
using ::ferror;
# 105
using ::fflush;
# 106
using ::fgetc;
# 107
using ::fgetpos;
# 108
using ::fgets;
# 109
using ::fopen;
# 110
using ::fprintf;
# 111
using ::fputc;
# 112
using ::fputs;
# 113
using ::fread;
# 114
using ::freopen;
# 115
using ::fscanf;
# 116
using ::fseek;
# 117
using ::fsetpos;
# 118
using ::ftell;
# 119
using ::fwrite;
# 120
using ::getc;
# 121
using ::getchar;
# 124
using ::gets;
# 126
using ::perror;
# 127
using ::printf;
# 128
using ::putc;
# 129
using ::putchar;
# 130
using ::puts;
# 131
using ::remove;
# 132
using ::rename;
# 133
using ::rewind;
# 134
using ::scanf;
# 135
using ::setbuf;
# 136
using ::setvbuf;
# 137
using ::sprintf;
# 138
using ::sscanf;
# 139
using ::tmpfile;
# 141
using ::tmpnam;
# 143
using ::ungetc;
# 144
using ::vfprintf;
# 145
using ::vprintf;
# 146
using ::vsprintf;
# 147
}
# 157
namespace __gnu_cxx { 
# 175
using ::snprintf;
# 176
using ::vfscanf;
# 177
using ::vscanf;
# 178
using ::vsnprintf;
# 179
using ::vsscanf;
# 181
}
# 183
namespace std { 
# 185
using __gnu_cxx::snprintf;
# 186
using __gnu_cxx::vfscanf;
# 187
using __gnu_cxx::vscanf;
# 188
using __gnu_cxx::vsnprintf;
# 189
using __gnu_cxx::vsscanf;
# 190
}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/terminate.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 24
namespace bulk_ { 
# 26
namespace detail { 
# 31
inline void terminate() 
# 32
{ 
# 36
std::terminate(); 
# 38
} 
# 42
inline void terminate_with_message(const char *message) 
# 43
{ 
# 45
std::printf("%s\n", message); 
# 48
bulk_::detail::terminate(); 
# 49
} 
# 53
inline void terminate_on_error(cudaError_t e, const char *message) 
# 54
{ 
# 55
if (e) 
# 56
{ 
# 58
printf("Error after: %s: %s\n", message, cudaGetErrorString(e)); 
# 62
bulk_::detail::terminate(); 
# 63
}  
# 64
} 
# 67
}
# 68
}
# 69
}}}}
# 25 "/usr/local/cuda/include/thrust/system_error.h"
namespace thrust { 
# 40
namespace system { 
# 42
}
# 47
}
# 26 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/throw_on_error.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 27
namespace bulk_ { 
# 29
namespace detail { 
# 34
inline void throw_on_error(cudaError_t e, const char *message) 
# 35
{ 
# 36
if (e) 
# 37
{ 
# 39
throw system_error(e, thrust::cuda_category(), message); 
# 48
}  
# 49
} 
# 52
}
# 53
}
# 54
}}}}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/future.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 29
namespace bulk_ { 
# 31
namespace detail { 
# 35
struct future_core_access; 
# 38
}
# 41
template< class T> class future; 
# 45
template<> class future< void>  { 
# 49
public: ~future() 
# 50
{ 
# 51
if (this->valid()) 
# 52
{ 
# 55
cudaError_t e = cudaEventDestroy(m_event); 
# 58
if (e) 
# 59
{ 
# 60
printf("CUDA error after cudaEventDestroy in future dtor: %s", cudaGetErrorString(e)); 
# 61
}  
# 64
if (m_owns_stream) 
# 65
{ 
# 66
e = cudaStreamDestroy(m_stream); 
# 69
if (e) 
# 70
{ 
# 71
printf("CUDA error after cudaStreamDestroy in future dtor: %s", cudaGetErrorString(e)); 
# 72
}  
# 74
}  
# 76
}  
# 77
} 
# 80
void wait() const 
# 81
{ 
# 88
bulk_::detail::throw_on_error(cudaEventSynchronize(m_event), "cudaEventSynchronize in future::wait"); 
# 98
} 
# 101
bool valid() const 
# 102
{ 
# 103
return (m_event) != (0); 
# 104
} 
# 107
future() : m_stream((0)), m_event((0)), m_owns_stream(false) 
# 109
{ } 
# 114
future(const bulk_::future< void>  &other) : m_stream((0)), m_event((0)), m_owns_stream(false) 
# 116
{ 
# 117
thrust::swap(m_stream, (const_cast< bulk_::future< void>  &>(other)).m_stream); 
# 118
thrust::swap(m_event, (const_cast< bulk_::future< void>  &>(other)).m_event); 
# 119
thrust::swap(m_owns_stream, (const_cast< bulk_::future< void>  &>(other)).m_owns_stream); 
# 120
} 
# 125
bulk_::future< void>  &operator=(const bulk_::future< void>  &other) 
# 126
{ 
# 127
thrust::swap(m_stream, (const_cast< bulk_::future< void>  &>(other)).m_stream); 
# 128
thrust::swap(m_event, (const_cast< bulk_::future< void>  &>(other)).m_event); 
# 129
thrust::swap(m_owns_stream, (const_cast< bulk_::future< void>  &>(other)).m_owns_stream); 
# 130
return *this; 
# 131
} 
# 134
friend struct detail::future_core_access; 
# 137
private: future(cudaStream_t s, bool owns_stream) : m_stream(s), m_owns_stream(owns_stream) 
# 139
{ 
# 141
bulk_::detail::throw_on_error(cudaEventCreateWithFlags(&(m_event), create_flags), "cudaEventCreateWithFlags in future ctor"); 
# 142
bulk_::detail::throw_on_error(cudaEventRecord(m_event, m_stream), "cudaEventRecord in future ctor"); 
# 144
} 
# 148
static const int create_flags = 2; 
# 150
cudaStream_t m_stream; 
# 151
cudaEvent_t m_event; 
# 152
bool m_owns_stream; 
# 153
}; 
# 156
namespace detail { 
# 160
struct future_core_access { 
# 163
static future< void>  create(cudaStream_t s, bool owns_stream) 
# 164
{ 
# 165
return future< void> (s, owns_stream); 
# 166
} 
# 169
static cudaEvent_t event(const future< void>  &f) 
# 170
{ 
# 171
return f.m_event; 
# 172
} 
# 173
}; 
# 176
}
# 179
}
# 180
}}}}
# 21 "/usr/local/cuda/include/thrust/detail/minmax.h"
namespace thrust { 
# 25
template< class T, class BinaryPredicate> T 
# 27
min(const T &lhs, const T &rhs, BinaryPredicate comp) 
# 28
{ 
# 29
return (comp(rhs, lhs)) ? rhs : lhs; 
# 30
} 
# 32
template< class T> T 
# 34
min(const T &lhs, const T &rhs) 
# 35
{ 
# 36
return (rhs < lhs) ? rhs : lhs; 
# 37
} 
# 39
template< class T, class BinaryPredicate> T 
# 41
max(const T &lhs, const T &rhs, BinaryPredicate comp) 
# 42
{ 
# 43
return (comp(lhs, rhs)) ? rhs : lhs; 
# 44
} 
# 46
template< class T> T 
# 48
max(const T &lhs, const T &rhs) 
# 49
{ 
# 50
return (lhs < rhs) ? rhs : lhs; 
# 51
} 
# 54
}
# 26 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launch_config.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 27
namespace bulk_ { 
# 29
namespace detail { 
# 35
struct device_properties_t { 
# 39
int major; 
# 40
int maxGridSize[3]; 
# 41
int maxThreadsPerBlock; 
# 42
int maxThreadsPerMultiProcessor; 
# 43
int minor; 
# 44
int multiProcessorCount; 
# 45
int regsPerBlock; 
# 46
size_t sharedMemPerBlock; 
# 47
int warpSize; 
# 48
}; 
# 53
struct function_attributes_t { 
# 57
size_t constSizeBytes; 
# 58
size_t localSizeBytes; 
# 59
int maxThreadsPerBlock; 
# 60
int numRegs; 
# 61
int ptxVersion; 
# 62
size_t sharedSizeBytes; 
# 63
}; 
# 75
inline std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t & attributes, const device_properties_t & properties); 
# 89
template< class UnaryFunction> inline std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t & attributes, const device_properties_t & properties, UnaryFunction block_size_to_dynamic_smem_size); 
# 104
inline size_t proportional_smem_allocation(const device_properties_t & properties, const function_attributes_t & attributes, size_t blocks_per_processor); 
# 109
template< class UnaryFunction> inline size_t max_blocksize_subject_to_smem_usage(const device_properties_t & properties, const function_attributes_t & attributes, UnaryFunction blocksize_to_dynamic_smem_usage); 
# 117
namespace cuda_launch_config_detail { 
# 120
using std::size_t;
# 122
namespace util { 
# 126
template< class T> inline T 
# 128
min_(const T &lhs, const T &rhs) 
# 129
{ 
# 130
return (rhs < lhs) ? rhs : lhs; 
# 131
} 
# 134
template< class T> 
# 135
struct zero_function { 
# 138
T operator()(T) 
# 139
{ 
# 140
return 0; 
# 141
} 
# 142
}; 
# 146
template< class L, class R> inline L 
# 147
divide_ri(const L x, const R y) 
# 148
{ 
# 149
return (x + (y - 1)) / y; 
# 150
} 
# 153
template< class L, class R> inline L 
# 154
divide_rz(const L x, const R y) 
# 155
{ 
# 156
return x / y; 
# 157
} 
# 160
template< class L, class R> inline L 
# 161
round_i(const L x, const R y) { return y * divide_ri(x, y); } 
# 164
template< class L, class R> inline L 
# 165
round_z(const L x, const R y) { return y * divide_rz(x, y); } 
# 167
}
# 173
inline std::size_t smem_allocation_unit(const device_properties_t &properties) 
# 174
{ 
# 175
switch (properties.major) 
# 176
{ 
# 177
case 1:  return 512; 
# 178
case 2:  return 128; 
# 179
case 3:  return 256; 
# 180
default:  return 256; 
# 181
}  
# 182
} 
# 187
inline int reg_allocation_unit(const device_properties_t &properties, const std::size_t regsPerThread) 
# 188
{ 
# 189
switch (properties.major) 
# 190
{ 
# 191
case 1:  return ((properties.minor) <= 1) ? 256 : 512; 
# 192
case 2:  switch (regsPerThread) 
# 193
{ 
# 194
case 21:  
# 195
case 22:  
# 196
case 29:  
# 197
case 30:  
# 198
case 37:  
# 199
case 38:  
# 200
case 45:  
# 201
case 46:  
# 202
return 128; 
# 203
default:  
# 204
return 64; 
# 205
}  
# 206
case 3:  return 256; 
# 207
default:  return 256; 
# 208
}  
# 209
} 
# 214
inline std::size_t warp_allocation_multiple(const device_properties_t &properties) 
# 215
{ 
# 216
return ((properties.major) <= 1) ? 2 : 1; 
# 217
} 
# 221
inline std::size_t num_sides_per_multiprocessor(const device_properties_t &properties) 
# 222
{ 
# 223
switch (properties.major) 
# 224
{ 
# 225
case 1:  return 1; 
# 226
case 2:  return 2; 
# 227
case 3:  return 4; 
# 228
default:  return 4; 
# 229
}  
# 230
} 
# 234
inline std::size_t max_blocks_per_multiprocessor(const device_properties_t &properties) 
# 235
{ 
# 236
return ((properties.major) <= 2) ? 8 : 16; 
# 237
} 
# 241
inline std::size_t max_active_blocks_per_multiprocessor(const device_properties_t &properties, const function_attributes_t &
# 242
attributes, std::size_t 
# 243
CTA_SIZE, std::size_t 
# 244
dynamic_smem_bytes) 
# 245
{ 
# 252
const std::size_t maxThreadsPerSM = properties.maxThreadsPerMultiProcessor; 
# 253
const std::size_t maxBlocksPerSM = max_blocks_per_multiprocessor(properties); 
# 256
const std::size_t ctaLimitThreads = (CTA_SIZE <= ((std::size_t)(properties.maxThreadsPerBlock))) ? maxThreadsPerSM / CTA_SIZE : (0); 
# 257
const std::size_t ctaLimitBlocks = maxBlocksPerSM; 
# 262
const std::size_t smemAllocationUnit = smem_allocation_unit(properties); 
# 263
const std::size_t smemBytes = (attributes.sharedSizeBytes) + dynamic_smem_bytes; 
# 264
const std::size_t smemPerCTA = util::round_i(smemBytes, smemAllocationUnit); 
# 267
const std::size_t ctaLimitSMem = (smemPerCTA > (0)) ? (properties.sharedMemPerBlock) / smemPerCTA : maxBlocksPerSM; 
# 272
const int regAllocationUnit = reg_allocation_unit(properties, attributes.numRegs); 
# 273
const std::size_t warpAllocationMultiple = warp_allocation_multiple(properties); 
# 274
const std::size_t numWarps = util::round_i(util::divide_ri(CTA_SIZE, properties.warpSize), warpAllocationMultiple); 
# 277
std::size_t ctaLimitRegs; 
# 278
if ((properties.major) <= 1) 
# 279
{ 
# 282
const std::size_t regsPerCTA = util::round_i(((attributes.numRegs) * (properties.warpSize)) * numWarps, regAllocationUnit); 
# 283
ctaLimitRegs = ((regsPerCTA > (0)) ? (properties.regsPerBlock) / regsPerCTA : maxBlocksPerSM); 
# 284
} else 
# 286
{ 
# 289
const std::size_t regsPerWarp = util::round_i((attributes.numRegs) * (properties.warpSize), regAllocationUnit); 
# 290
const std::size_t numSides = num_sides_per_multiprocessor(properties); 
# 291
const std::size_t numRegsPerSide = (properties.regsPerBlock) / numSides; 
# 292
ctaLimitRegs = ((regsPerWarp > (0)) ? ((numRegsPerSide / regsPerWarp) * numSides) / numWarps : maxBlocksPerSM); 
# 293
}  
# 298
return util::min_(ctaLimitRegs, util::min_(ctaLimitSMem, util::min_(ctaLimitThreads, ctaLimitBlocks))); 
# 299
} 
# 302
}
# 305
template< class UnaryFunction> inline std::size_t 
# 307
block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes, const device_properties_t &
# 308
properties, UnaryFunction 
# 309
block_size_to_dynamic_smem_size) 
# 310
{ 
# 311
size_t max_occupancy = properties.maxThreadsPerMultiProcessor; 
# 312
size_t largest_blocksize = cuda_launch_config_detail::util::min_(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock); 
# 313
size_t granularity = properties.warpSize; 
# 314
size_t max_blocksize = (0); 
# 315
size_t highest_occupancy = (0); 
# 317
for (size_t blocksize = largest_blocksize; blocksize != (0); blocksize -= granularity) 
# 318
{ 
# 319
size_t occupancy = blocksize * cuda_launch_config_detail::max_active_blocks_per_multiprocessor(properties, attributes, blocksize, block_size_to_dynamic_smem_size(blocksize)); 
# 321
if (occupancy > highest_occupancy) 
# 322
{ 
# 323
max_blocksize = blocksize; 
# 324
highest_occupancy = occupancy; 
# 325
}  
# 328
if (highest_occupancy == max_occupancy) { 
# 329
break; }  
# 330
}  
# 332
return max_blocksize; 
# 333
} 
# 337
inline std::size_t block_size_with_maximum_potential_occupancy(const function_attributes_t &attributes, const device_properties_t &
# 338
properties) 
# 339
{ 
# 340
return block_size_with_maximum_potential_occupancy(attributes, properties, cuda_launch_config_detail::util::zero_function< unsigned long> ()); 
# 341
} 
# 345
inline size_t proportional_smem_allocation(const device_properties_t &properties, const function_attributes_t &
# 346
attributes, size_t 
# 347
blocks_per_processor) 
# 348
{ 
# 349
size_t smem_per_processor = properties.sharedMemPerBlock; 
# 350
size_t smem_allocation_unit = cuda_launch_config_detail::smem_allocation_unit(properties); 
# 352
size_t total_smem_per_block = cuda_launch_config_detail::util::round_z(smem_per_processor / blocks_per_processor, smem_allocation_unit); 
# 353
size_t static_smem_per_block = attributes.sharedSizeBytes; 
# 355
return total_smem_per_block - static_smem_per_block; 
# 356
} 
# 359
template< class UnaryFunction> inline size_t 
# 361
max_blocksize_subject_to_smem_usage(const device_properties_t &properties, const function_attributes_t &
# 362
attributes, UnaryFunction 
# 363
blocksize_to_dynamic_smem_usage) 
# 364
{ 
# 365
size_t largest_blocksize = (thrust::min)(properties.maxThreadsPerBlock, attributes.maxThreadsPerBlock); 
# 366
size_t granularity = properties.warpSize; 
# 368
for (int blocksize = largest_blocksize; blocksize > 0; blocksize -= granularity) 
# 369
{ 
# 370
size_t total_smem_usage = blocksize_to_dynamic_smem_usage(blocksize) + (attributes.sharedSizeBytes); 
# 372
if (total_smem_usage <= (properties.sharedMemPerBlock)) 
# 373
{ 
# 374
return blocksize; 
# 375
}  
# 376
}  
# 378
return 0; 
# 379
} 
# 382
}
# 383
}
# 384
}}}}
# 32 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 33
namespace bulk_ { 
# 35
namespace detail { 
# 42
inline int current_device(); 
# 48
inline device_properties_t device_properties(int device_id); 
# 54
inline device_properties_t device_properties(); 
# 59
template< class KernelFunction> inline function_attributes_t function_attributes(KernelFunction kernel); 
# 68
inline size_t compute_capability(const device_properties_t & properties); 
# 71
inline size_t compute_capability(); 
# 74
}
# 75
}
# 76
}}}}
# 22 "/usr/local/cuda/include/thrust/detail/util/blocking.h"
namespace thrust { 
# 25
namespace detail { 
# 28
namespace util { 
# 32
template< class L, class R> inline L 
# 33
divide_ri(const L x, const R y) 
# 34
{ 
# 35
return (x + (y - 1)) / y; 
# 36
} 
# 39
template< class L, class R> inline L 
# 40
divide_rz(const L x, const R y) 
# 41
{ 
# 42
return x / y; 
# 43
} 
# 46
template< class L, class R> inline L 
# 47
round_i(const L x, const R y) { return y * divide_ri(x, y); } 
# 50
template< class L, class R> inline L 
# 51
round_z(const L x, const R y) { return y * divide_rz(x, y); } 
# 53
}
# 55
}
# 57
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/runtime_introspection.inl"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 28
namespace bulk_ { 
# 30
namespace detail { 
# 35
inline device_properties_t device_properties_uncached(int device_id) 
# 36
{ 
# 37
device_properties_t prop = {0, {0, 0, 0}, 0, 0, 0, 0, 0, (0), 0}; 
# 39
cudaError_t error = cudaErrorNoDevice; 
# 42
error = cudaDeviceGetAttribute(&(prop.major), cudaDevAttrComputeCapabilityMajor, device_id); 
# 43
error = cudaDeviceGetAttribute(&((prop.maxGridSize)[0]), cudaDevAttrMaxGridDimX, device_id); 
# 44
error = cudaDeviceGetAttribute(&((prop.maxGridSize)[1]), cudaDevAttrMaxGridDimY, device_id); 
# 45
error = cudaDeviceGetAttribute(&((prop.maxGridSize)[2]), cudaDevAttrMaxGridDimZ, device_id); 
# 46
error = cudaDeviceGetAttribute(&(prop.maxThreadsPerBlock), cudaDevAttrMaxThreadsPerBlock, device_id); 
# 47
error = cudaDeviceGetAttribute(&(prop.maxThreadsPerMultiProcessor), cudaDevAttrMaxThreadsPerMultiProcessor, device_id); 
# 48
error = cudaDeviceGetAttribute(&(prop.minor), cudaDevAttrComputeCapabilityMinor, device_id); 
# 49
error = cudaDeviceGetAttribute(&(prop.multiProcessorCount), cudaDevAttrMultiProcessorCount, device_id); 
# 50
error = cudaDeviceGetAttribute(&(prop.regsPerBlock), cudaDevAttrMaxRegistersPerBlock, device_id); 
# 51
int temp; 
# 52
error = cudaDeviceGetAttribute(&temp, cudaDevAttrMaxSharedMemoryPerBlock, device_id); 
# 53
(prop.sharedMemPerBlock) = temp; 
# 54
error = cudaDeviceGetAttribute(&(prop.warpSize), cudaDevAttrWarpSize, device_id); 
# 59
throw_on_error(error, "cudaDeviceGetProperty in get_device_properties"); 
# 61
return prop; 
# 62
} 
# 65
inline device_properties_t device_properties_cached(int device_id) 
# 66
{ 
# 69
static const int max_num_devices = 16; 
# 71
static bool properties_exist[max_num_devices] = {(0)}; 
# 72
static device_properties_t device_properties[max_num_devices] = {}; 
# 74
if (device_id >= max_num_devices) 
# 75
{ 
# 76
return device_properties_uncached(device_id); 
# 77
}  
# 79
if (!((properties_exist)[device_id])) 
# 80
{ 
# 81
((device_properties)[device_id]) = device_properties_uncached(device_id); 
# 85
__sync_synchronize(); 
# 87
((properties_exist)[device_id]) = true; 
# 88
}  
# 90
return (device_properties)[device_id]; 
# 91
} 
# 95
inline device_properties_t device_properties(int device_id) 
# 96
{ 
# 98
return device_properties_cached(device_id); 
# 102
} 
# 106
inline int current_device() 
# 107
{ 
# 108
int result = (-1); 
# 111
bulk_::detail::throw_on_error(cudaGetDevice(&result), "current_device(): after cudaGetDevice"); 
# 114
if (result < 0) 
# 115
{ 
# 116
bulk_::detail::throw_on_error(cudaErrorNoDevice, "current_device(): after cudaGetDevice"); 
# 117
}  
# 119
return result; 
# 120
} 
# 124
inline device_properties_t device_properties() 
# 125
{ 
# 126
return device_properties(current_device()); 
# 127
} 
# 130
template< class KernelFunction> inline function_attributes_t 
# 132
function_attributes(KernelFunction kernel) 
# 133
{ 
# 135
typedef void (*fun_ptr_type)(void); 
# 137
fun_ptr_type fun_ptr = reinterpret_cast< fun_ptr_type>(kernel); 
# 139
cudaFuncAttributes attributes; 
# 141
bulk_::detail::throw_on_error(cudaFuncGetAttributes(&attributes, fun_ptr), "function_attributes(): after cudaFuncGetAttributes"); 
# 144
function_attributes_t result = {attributes.constSizeBytes, attributes.localSizeBytes, attributes.maxThreadsPerBlock, attributes.numRegs, attributes.ptxVersion, attributes.sharedSizeBytes}; 
# 153
return result; 
# 157
} 
# 160
inline size_t compute_capability(const device_properties_t &properties) 
# 161
{ 
# 162
return (10 * (properties.major)) + (properties.minor); 
# 163
} 
# 167
inline size_t compute_capability() 
# 168
{ 
# 169
return compute_capability(device_properties()); 
# 170
} 
# 173
}
# 174
}
# 175
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 57
static const int invalid_index = 2147483647; 
# 62
template< std::size_t grainsize_ = 1UL> 
# 63
class agent { 
# 66
public: typedef int size_type; 
# 68
static const size_type static_grainsize = (grainsize_); 
# 71
agent(size_type i = invalid_index) : m_index(i) 
# 73
{ } 
# 76
size_type index() const 
# 77
{ 
# 78
return m_index; 
# 79
} 
# 82
size_type grainsize() const 
# 83
{ 
# 84
return static_grainsize; 
# 85
} 
# 88
private: const size_type m_index; 
# 89
}; 
# 92
static const int use_default = 2147483647; 
# 94
static const int dynamic_group_size = 0; 
# 97
namespace detail { 
# 99
namespace group_detail { 
# 103
template< class ExecutionAgent, std::size_t size_> 
# 104
class group_base { 
# 107
public: typedef ExecutionAgent agent_type; 
# 109
typedef int size_type; 
# 111
static const size_type static_size = (size_); 
# 114
group_base(agent_type exec = agent_type(), size_type i = invalid_index) : this_exec(exec), m_index(i) 
# 117
{ } 
# 120
size_type index() const 
# 121
{ 
# 122
return m_index; 
# 123
} 
# 126
size_type size() const 
# 127
{ 
# 128
return static_size; 
# 129
} 
# 132
size_type global_index() const 
# 133
{int volatile ___ = 1;
# 135
::exit(___);}
#if 0
# 133
{ 
# 134
return (index() * size()) + ((this_exec).index()); 
# 135
} 
#endif
# 137 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
agent_type this_exec; 
# 140
private: const size_type m_index; 
# 141
}; 
# 144
template< class ExecutionAgent> 
# 145
class group_base< ExecutionAgent, dynamic_group_size>  { 
# 148
public: typedef ExecutionAgent agent_type; 
# 150
typedef int size_type; 
# 153
group_base(size_type sz, agent_type exec = agent_type(), size_type i = invalid_index) : this_exec(exec), m_size(sz), m_index(i) 
# 157
{ } 
# 160
size_type index() const 
# 161
{ 
# 162
return m_index; 
# 163
} 
# 166
size_type size() const 
# 167
{ 
# 168
return m_size; 
# 169
} 
# 172
size_type global_index() const 
# 173
{ 
# 174
return (index() * size()) + ((this_exec).index()); 
# 175
} 
# 177
agent_type this_exec; 
# 180
private: const size_type m_size; 
# 181
const size_type m_index; 
# 182
}; 
# 185
}
# 186
}
# 190
template< class ExecutionAgent = agent<> , std::size_t 
# 191
size_ = 0UL> 
# 192
class parallel_group : public detail::group_detail::group_base< ExecutionAgent, size_>  { 
# 199
typedef ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, size_>  super_t; 
# 202
public: typedef typename ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, size_> ::agent_type agent_type; 
# 204
typedef typename ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, size_> ::size_type size_type; 
# 208
parallel_group(agent_type exec = agent_type(), size_type i = invalid_index) : super_t(exec, i) 
# 210
{ } 
# 211
}; 
# 214
template< class ExecutionAgent> 
# 215
class parallel_group< ExecutionAgent, dynamic_group_size>  : public detail::group_detail::group_base< ExecutionAgent, 0UL>  { 
# 222
typedef ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, 0UL>  super_t; 
# 225
public: typedef typename ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, 0UL> ::agent_type agent_type; 
# 227
typedef typename ::thrust::system::cuda::detail::bulk_::detail::group_detail::group_base< ExecutionAgent, 0UL> ::size_type size_type; 
# 231
parallel_group(size_type size, agent_type exec = agent_type(), size_type i = invalid_index) : super_t(size, exec, i) 
# 233
{ } 
# 234
}; 
# 239
inline parallel_group<>  par(size_t size) 
# 240
{ 
# 241
typedef parallel_group<> ::size_type size_type; 
# 242
return ((parallel_group<> )(static_cast< size_type>(size))); 
# 243
} 
# 247
template< class ExecutionAgent> parallel_group< ExecutionAgent>  
# 249
par(ExecutionAgent exec, size_t size) 
# 250
{ 
# 251
typedef typename parallel_group< ExecutionAgent> ::size_type size_type; 
# 252
return parallel_group< ExecutionAgent> (static_cast< size_type>(size), exec); 
# 253
} 
# 256
template< class ExecutionAgent> 
# 257
class async_launch { 
# 261
public: async_launch(ExecutionAgent exec, cudaStream_t s, cudaEvent_t be = 0) : stream_valid(true), e(exec), s(s), be(be) 
# 263
{ } 
# 266
async_launch(ExecutionAgent exec, cudaEvent_t be) : stream_valid(false), e(exec), s((0)), be(be) 
# 268
{ } 
# 271
ExecutionAgent exec() const 
# 272
{ 
# 273
return e; 
# 274
} 
# 277
cudaStream_t stream() const 
# 278
{ 
# 279
return s; 
# 280
} 
# 283
cudaEvent_t before_event() const 
# 284
{ 
# 285
return be; 
# 286
} 
# 289
bool is_stream_valid() const 
# 290
{ 
# 291
return stream_valid; 
# 292
} 
# 295
private: bool stream_valid; 
# 296
ExecutionAgent e; 
# 297
cudaStream_t s; 
# 298
cudaEvent_t be; 
# 299
}; 
# 303
inline async_launch< parallel_group<> >  par(cudaStream_t s, size_t num_threads) 
# 304
{ 
# 305
typedef parallel_group<> ::size_type size_type; 
# 306
return async_launch< parallel_group<> > (((parallel_group<> )(static_cast< size_type>(num_threads))), s); 
# 307
} 
# 310
template< class ExecutionAgent> inline async_launch< parallel_group< ExecutionAgent> >  
# 312
par(cudaStream_t s, ExecutionAgent exec, size_t num_groups) 
# 313
{ 
# 314
return async_launch< parallel_group< ExecutionAgent> > (bulk_::par(exec, num_groups), s); 
# 315
} 
# 318
inline async_launch< parallel_group<> >  par(future< void>  &before, size_t num_threads) 
# 319
{ 
# 320
cudaEvent_t before_event = bulk_::detail::future_core_access::event(before); 
# 322
typedef parallel_group<> ::size_type size_type; 
# 323
return async_launch< parallel_group<> > (((parallel_group<> )(static_cast< size_type>(num_threads))), before_event); 
# 324
} 
# 328
template< class ExecutionAgent = agent<> , std::size_t 
# 329
size_ = 0UL> 
# 330
class concurrent_group : public parallel_group< ExecutionAgent, size_>  { 
# 337
typedef ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, size_>  super_t; 
# 340
public: typedef typename ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, size_> ::agent_type agent_type; 
# 341
typedef typename ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, size_> ::size_type size_type; 
# 345
concurrent_group(size_type heap_size = use_default, agent_type 
# 346
exec = agent_type(), size_type 
# 347
i = invalid_index) : super_t(exec, i), m_heap_size(heap_size) 
# 350
{ } 
# 353
void wait() const 
# 354
{int volatile ___ = 1;
# 359
::exit(___);}
#if 0
# 354
{ 
# 359
} 
#endif
# 362 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
size_type heap_size() const 
# 363
{ 
# 364
return m_heap_size; 
# 365
} 
# 369
static size_type hardware_concurrency() 
# 370
{ 
# 372
return static_cast< size_type>(bulk_::detail::device_properties().multiProcessorCount); 
# 376
} 
# 379
private: size_type m_heap_size; 
# 380
}; 
# 383
template< class ExecutionAgent> 
# 384
class concurrent_group< ExecutionAgent, dynamic_group_size>  : public parallel_group< ExecutionAgent, 0UL>  { 
# 391
typedef ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, 0UL>  super_t; 
# 394
public: typedef typename ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, 0UL> ::agent_type agent_type; 
# 396
typedef typename ::thrust::system::cuda::detail::bulk_::parallel_group< ExecutionAgent, 0UL> ::size_type size_type; 
# 400
concurrent_group(size_type size, size_type 
# 401
heap_size = use_default, agent_type 
# 402
exec = agent_type(), size_type 
# 403
i = invalid_index) : super_t(size, exec, i), m_heap_size(heap_size) 
# 406
{ } 
# 409
void wait() 
# 410
{int volatile ___ = 1;
# 415
::exit(___);}
#if 0
# 410
{ 
# 415
} 
#endif
# 418 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/execution_policy.hpp"
size_type heap_size() const 
# 419
{ 
# 420
return m_heap_size; 
# 421
} 
# 425
static size_type hardware_concurrency() 
# 426
{ 
# 428
return static_cast< size_type>(bulk_::detail::device_properties().multiProcessorCount); 
# 432
} 
# 435
private: size_type m_heap_size; 
# 436
}; 
# 441
inline concurrent_group<>  con(size_t size, size_t heap_size = use_default) 
# 442
{ 
# 443
typedef concurrent_group<> ::size_type size_type; 
# 444
return concurrent_group<> (static_cast< size_type>(size), static_cast< size_type>(heap_size)); 
# 445
} 
# 449
template< class ExecutionAgent> concurrent_group< ExecutionAgent>  
# 451
con(ExecutionAgent exec, size_t size, size_t heap_size = use_default) 
# 452
{ 
# 453
typedef typename concurrent_group< ExecutionAgent> ::size_type size_type; 
# 454
return concurrent_group< ExecutionAgent> (static_cast< size_type>(size), static_cast< size_type>(heap_size), exec); 
# 455
} 
# 459
template< std::size_t groupsize, std::size_t grainsize> concurrent_group< agent< grainsize> , groupsize>  
# 462
con(size_t heap_size) 
# 463
{ 
# 464
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 465
return ((concurrent_group< agent< grainsize> , groupsize> )(static_cast< size_type>(heap_size))); 
# 466
} 
# 470
template< std::size_t bound_, class ExecutionAgent> 
# 471
class bounded : public ExecutionAgent { 
# 475
public: typedef typename ExecutionAgent::size_type size_type; 
# 477
static const size_type static_bound = (bound_); 
# 480
size_type bound() const 
# 481
{ 
# 482
return static_bound; 
# 483
} 
# 487
ExecutionAgent &unbound() 
# 488
{ 
# 489
return *this; 
# 490
} 
# 494
const ExecutionAgent &unbound() const 
# 495
{ 
# 496
return *this; 
# 497
} 
# 502
private: bounded(); 
# 504
bounded(const bounded &); 
# 505
}; 
# 508
template< std::size_t bound_, class ExecutionAgent> bounded< bound_, ExecutionAgent>  &
# 510
bound(ExecutionAgent &exec) 
# 511
{ 
# 512
return static_cast< bounded< bound_, ExecutionAgent>  &>(exec); 
# 513
} 
# 516
template< std::size_t bound_, class ExecutionAgent> const bounded< bound_, ExecutionAgent>  &
# 518
bound(const ExecutionAgent &exec) 
# 519
{ 
# 520
return static_cast< const bounded< bound_, ExecutionAgent>  &>(exec); 
# 521
} 
# 524
namespace detail { 
# 528
template< unsigned depth, class ExecutionAgent> 
# 529
struct agent_at_depth { 
# 533
typedef typename detail::agent_at_depth< depth - (1), ExecutionAgent> ::type parent_agent_type; 
# 535
typedef typename detail::agent_at_depth< depth - (1), ExecutionAgent> ::type::agent_type type; 
# 536
}; 
# 539
template< class ExecutionAgent> 
# 540
struct agent_at_depth< 0, ExecutionAgent>  { 
# 542
typedef ExecutionAgent type; 
# 543
}; 
# 546
template< class Cursor, class ExecutionGroup> 
# 547
struct cursor_result { 
# 549
typedef typename agent_at_depth< Cursor::depth, ExecutionGroup> ::type &type; 
# 550
}; 
# 553
template< unsigned d> struct cursor; 
# 556
template< unsigned d> 
# 557
struct cursor { 
# 559
static const unsigned depth = d; 
# 561
cursor() { } 
# 563
detail::cursor< depth + (1)>  this_exec; 
# 565
template< class ExecutionGroup> static typename cursor_result< cursor, ExecutionGroup> ::type 
# 568
get(ExecutionGroup &root) 
# 569
{ 
# 570
return cursor< depth - (1)> ::get((root.this_exec)); 
# 571
} 
# 572
}; 
# 575
template<> struct cursor< 3U>  { 
# 577
static const unsigned depth = (3); 
# 579
cursor() { } 
# 581
template< class ExecutionGroup> static typename cursor_result< detail::cursor< 3U> , ExecutionGroup> ::type 
# 584
get(ExecutionGroup &root) 
# 585
{ 
# 586
return detail::cursor< 2U> ::get((root.this_exec)); 
# 587
} 
# 588
}; 
# 591
template<> struct cursor< 0U>  { 
# 593
static const unsigned depth = (0); 
# 595
cursor() { } 
# 597
detail::cursor< 1U>  this_exec; 
# 600
template< class ExecutionAgent> static ExecutionAgent &
# 602
get(ExecutionAgent &root) 
# 603
{ 
# 604
return root; 
# 605
} 
# 606
}; 
# 609
template< class T> struct is_cursor : public thrust::detail::false_type { }; 
# 612
template< unsigned d> 
# 613
struct is_cursor< cursor< d> >  : public thrust::detail::true_type { 
# 615
}; 
# 618
}
# 624
static const detail::cursor< 0U>  root; 
# 630
inline parallel_group< concurrent_group<> >  grid(size_t num_groups = use_default, size_t group_size = use_default, size_t heap_size = use_default) 
# 631
{ 
# 632
return par(con(group_size, heap_size), num_groups); 
# 633
} 
# 642
inline async_launch< parallel_group< concurrent_group<> > >  grid(size_t num_groups, size_t group_size, size_t heap_size, cudaStream_t stream) 
# 643
{ 
# 644
return par(stream, con(group_size, heap_size), num_groups); 
# 645
} 
# 648
template< std::size_t groupsize, std::size_t grainsize> parallel_group< concurrent_group< agent< grainsize> , groupsize> >  
# 656
grid(size_t num_groups, size_t heap_size = use_default) 
# 657
{ 
# 658
return par(con< groupsize, grainsize> (heap_size), num_groups); 
# 659
} 
# 662
template< std::size_t groupsize, std::size_t grainsize> async_launch< parallel_group< concurrent_group< agent< grainsize> , groupsize> > >  
# 672
grid(size_t num_groups, size_t heap_size, cudaStream_t stream) 
# 673
{ 
# 674
return par(stream, con< groupsize, grainsize> (heap_size), num_groups); 
# 675
} 
# 678
}
# 679
}}}}
# 24 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/choose_sizes.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 25
namespace bulk_ { 
# 29
template< class Function> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f); 
# 36
template< class Function, class Arg1> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1); 
# 43
template< class Function, class Arg1, class Arg2> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2); 
# 50
template< class Function, class Arg1, class Arg2, class Arg3> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3); 
# 57
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4); 
# 64
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5); 
# 71
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> pair< int, int>  choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6); 
# 78
}
# 79
}}}}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/apply_from_tuple.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 23
namespace bulk_ { 
# 25
namespace detail { 
# 29
template< class Function> void 
# 31
apply_from_tuple(Function f, const tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  &) 
# 32
{ 
# 33
f(); 
# 34
} 
# 37
template< class Function, class Arg1> void 
# 39
apply_from_tuple(Function f, const tuple< Arg1, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  &args) 
# 40
{ 
# 41
f(thrust::get< 0> (args)); 
# 42
} 
# 45
template< class Function, class Arg1, class Arg2> void 
# 47
apply_from_tuple(Function f, const tuple< Arg1, Arg2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  &args) 
# 48
{ 
# 49
f(thrust::get< 0> (args), thrust::get< 1> (args)); 
# 51
} 
# 54
template< class Function, class Arg1, class Arg2, class Arg3> void 
# 56
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  &args) 
# 57
{ 
# 58
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args)); 
# 61
} 
# 64
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4> void 
# 66
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, null_type, null_type, null_type, null_type, null_type, null_type>  &args) 
# 67
{ 
# 68
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args)); 
# 72
} 
# 75
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> void 
# 77
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, null_type, null_type, null_type, null_type, null_type>  &args) 
# 78
{ 
# 79
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args)); 
# 84
} 
# 87
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> void 
# 89
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, null_type, null_type, null_type, null_type>  &args) 
# 90
{ 
# 91
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args), thrust::get< 5> (args)); 
# 97
} 
# 100
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7> void 
# 102
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, null_type, null_type, null_type>  &args) 
# 103
{ 
# 104
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args), thrust::get< 5> (args), thrust::get< 6> (args)); 
# 111
} 
# 114
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8> void 
# 116
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, null_type, null_type>  &args) 
# 117
{ 
# 118
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args), thrust::get< 5> (args), thrust::get< 6> (args), thrust::get< 7> (args)); 
# 126
} 
# 129
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9> void 
# 131
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, null_type>  &args) 
# 132
{ 
# 133
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args), thrust::get< 5> (args), thrust::get< 6> (args), thrust::get< 7> (args), thrust::get< 8> (args)); 
# 142
} 
# 145
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9, class Arg10> void 
# 147
apply_from_tuple(Function f, const tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10>  &args) 
# 148
{ 
# 149
f(thrust::get< 0> (args), thrust::get< 1> (args), thrust::get< 2> (args), thrust::get< 3> (args), thrust::get< 4> (args), thrust::get< 5> (args), thrust::get< 6> (args), thrust::get< 7> (args), thrust::get< 8> (args), thrust::get< 9> (args)); 
# 159
} 
# 162
}
# 163
}
# 164
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/closure.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 28
namespace detail { 
# 32
template< class Function, class Tuple> 
# 33
class closure { 
# 36
public: typedef Function function_type; 
# 38
typedef Tuple arguments_type; 
# 41
closure(function_type f, const arguments_type &args) : f(f), args(args) 
# 44
{ } 
# 48
void operator()() 
# 49
{ 
# 50
apply_from_tuple(f, args); 
# 51
} 
# 55
function_type function() const 
# 56
{ 
# 57
return f; 
# 58
} 
# 62
arguments_type arguments() const 
# 63
{ 
# 64
return args; 
# 65
} 
# 69
private: function_type f; 
# 70
arguments_type args; 
# 71
}; 
# 74
template< class Function, class Arguments> const closure< Function, Arguments>  &
# 76
make_closure(const closure< Function, Arguments>  &c) 
# 77
{ 
# 78
return c; 
# 79
} 
# 82
template< class Function> closure< Function, tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  
# 84
make_closure(Function f) 
# 85
{ 
# 86
return closure< Function, tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > (f, tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> ()); 
# 87
} 
# 90
template< class Function, class Arg1> closure< Function, tuple< Arg1, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  
# 92
make_closure(Function f, const Arg1 &a1) 
# 93
{ 
# 94
return closure< Function, tuple< Arg1, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1)); 
# 95
} 
# 98
template< class Function, class Arg1, class Arg2> closure< Function, tuple< Arg1, Arg2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  
# 104
make_closure(Function f, const Arg1 &a1, const Arg2 &a2) 
# 105
{ 
# 106
return closure< Function, tuple< Arg1, Arg2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2)); 
# 107
} 
# 110
template< class Function, class Arg1, class Arg2, class Arg3> closure< Function, tuple< Arg1, Arg2, Arg3, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  
# 116
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3) 
# 117
{ 
# 118
return closure< Function, tuple< Arg1, Arg2, Arg3, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3)); 
# 119
} 
# 122
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, null_type, null_type, null_type, null_type, null_type, null_type> >  
# 128
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4) 
# 129
{ 
# 130
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, null_type, null_type, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4)); 
# 131
} 
# 134
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, null_type, null_type, null_type, null_type, null_type> >  
# 140
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5) 
# 141
{ 
# 142
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, null_type, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4, a5)); 
# 143
} 
# 146
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, null_type, null_type, null_type, null_type> >  
# 152
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6) 
# 153
{ 
# 154
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, null_type, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4, a5, a6)); 
# 155
} 
# 158
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, null_type, null_type, null_type> >  
# 164
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7) 
# 165
{ 
# 166
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, null_type, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4, a5, a6, a7)); 
# 167
} 
# 170
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, null_type, null_type> >  
# 176
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8) 
# 177
{ 
# 178
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, null_type, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4, a5, a6, a7, a8)); 
# 179
} 
# 182
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, null_type> >  
# 188
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9) 
# 189
{ 
# 190
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, null_type> > (f, thrust::make_tuple(a1, a2, a3, a4, a5, a6, a7, a8, a9)); 
# 191
} 
# 194
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9, class Arg10> closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10> >  
# 200
make_closure(Function f, const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9, const Arg10 &a10) 
# 201
{ 
# 202
return closure< Function, tuple< Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10> > (f, thrust::make_tuple(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)); 
# 203
} 
# 206
}
# 207
}
# 208
}}}}
# 21 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/alignment.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 22
namespace bulk_ { 
# 24
namespace detail { 
# 26
namespace alignment_of_detail { 
# 30
template< class T> class alignment_of_impl; 
# 32
template< class T, std::size_t size_diff> 
# 33
struct helper { 
# 35
static const std::size_t value = size_diff; 
# 36
}; 
# 38
template< class T> 
# 39
class helper< T, 0>  { 
# 42
public: static const std::size_t value = (alignment_of_impl< T> ::value); 
# 43
}; 
# 45
template< class T> 
# 46
class alignment_of_impl { 
# 49
struct big { T x; char c; }; 
# 52
public: static const std::size_t value = (helper< big, sizeof(big) - sizeof(T)> ::value); 
# 53
}; 
# 56
}
# 59
template< class T> 
# 60
struct alignment_of : public alignment_of_detail::alignment_of_impl< T>  { 
# 62
}; 
# 65
template< std::size_t Align> struct aligned_type; 
# 190
template< std::size_t Align> struct aligned_type { 
# 192
struct __attribute((aligned(Align))) type { }; 
# 193
}; 
# 203
template< std::size_t Len, std::size_t Align> 
# 204
struct aligned_storage { 
# 206
union type { 
# 208
unsigned char data[Len]; 
# 210
typename aligned_type< Align> ::type align; 
# 211
}; 
# 212
}; 
# 215
}
# 216
}
# 217
}}}}
# 21 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 22
namespace bulk_ { 
# 24
namespace detail { 
# 28
__attribute__((unused)) inline unsigned __isShared(const void *ptr) 
# 29
{int volatile ___ = 1;(void)ptr;
# 50
::exit(___);}
#if 0
# 29
{ 
# 31
(void)ptr; 
# 33
unsigned ret; 
# 46
ret = (0); 
# 49
return ret; 
# 50
} 
#endif
# 53 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
__attribute__((unused)) inline bool is_shared(const void *ptr) 
# 54
{int volatile ___ = 1;(void)ptr;
# 56
::exit(___);}
#if 0
# 54
{ 
# 55
return __isShared(ptr); 
# 56
} 
#endif
# 59 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
__attribute__((unused)) inline bool is_global(const void *ptr) 
# 60
{int volatile ___ = 1;(void)ptr;
# 69
::exit(___);}
#if 0
# 60
{ 
# 62
(void)ptr; 
# 67
return false; 
# 69
} 
#endif
# 72 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/pointer_traits.hpp"
}
# 73
}
# 74
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/uninitialized.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 30
template< class T> 
# 31
class uninitialized { 
# 37
typename detail::aligned_storage< sizeof(T), detail::alignment_of< T> ::value> ::type storage; 
# 39
__attribute((always_inline)) const T *
# 40
ptr() const 
# 41
{ 
# 42
const void *result = (((storage).data)); 
# 43
return reinterpret_cast< const T *>(result); 
# 44
} 
# 46
__attribute((always_inline)) T *
# 47
ptr() 
# 48
{ 
# 49
void *result = (((storage).data)); 
# 50
return reinterpret_cast< T *>(result); 
# 51
} 
# 56
public: 
# 55
__attribute((always_inline)) uninitialized &
# 56
operator=(const T &other) 
# 57
{ 
# 58
T &self = *this; 
# 59
self = other; 
# 60
return *this; 
# 61
} 
# 63
__attribute((always_inline)) T &
# 64
get() 
# 65
{ 
# 66
return *this->ptr(); 
# 67
} 
# 69
__attribute((always_inline)) const T &
# 70
get() const 
# 71
{ 
# 72
return *this->ptr(); 
# 73
} 
# 75
__attribute((always_inline)) 
# 76
operator T &() 
# 77
{ 
# 78
return this->get(); 
# 79
} 
# 81
__attribute((always_inline)) 
# 82
operator const T &() const 
# 83
{ 
# 84
return this->get(); 
# 85
} 
# 88
__attribute((always_inline)) void 
# 89
construct() 
# 90
{ 
# 91
::new (this->ptr()) (T)(); 
# 92
} 
# 95
template< class Arg> 
# 96
__attribute((always_inline)) void 
# 97
construct(const Arg &a) 
# 98
{ 
# 99
::new (this->ptr()) (T)(a); 
# 100
} 
# 103
template< class Arg1, class Arg2> 
# 104
__attribute((always_inline)) void 
# 105
construct(const Arg1 &a1, const Arg2 &a2) 
# 106
{ 
# 107
::new (this->ptr()) (T)(a1, a2); 
# 108
} 
# 111
template< class Arg1, class Arg2, class Arg3> 
# 112
__attribute((always_inline)) void 
# 113
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3) 
# 114
{ 
# 115
::new (this->ptr()) (T)(a1, a2, a3); 
# 116
} 
# 119
template< class Arg1, class Arg2, class Arg3, class Arg4> 
# 120
__attribute((always_inline)) void 
# 121
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4) 
# 122
{ 
# 123
::new (this->ptr()) (T)(a1, a2, a3, a4); 
# 124
} 
# 127
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> 
# 128
__attribute((always_inline)) void 
# 129
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5) 
# 130
{ 
# 131
::new (this->ptr()) (T)(a1, a2, a3, a4, a5); 
# 132
} 
# 135
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> 
# 136
__attribute((always_inline)) void 
# 137
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6) 
# 138
{ 
# 139
::new (this->ptr()) (T)(a1, a2, a3, a4, a5, a6); 
# 140
} 
# 143
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7> 
# 144
__attribute((always_inline)) void 
# 145
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7) 
# 146
{ 
# 147
::new (this->ptr()) (T)(a1, a2, a3, a4, a5, a6, a7); 
# 148
} 
# 151
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8> 
# 152
__attribute((always_inline)) void 
# 153
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8) 
# 154
{ 
# 155
::new (this->ptr()) (T)(a1, a2, a3, a4, a5, a6, a7, a8); 
# 156
} 
# 159
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9> 
# 160
__attribute((always_inline)) void 
# 161
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9) 
# 162
{ 
# 163
::new (this->ptr()) (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9); 
# 164
} 
# 167
template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9, class Arg10> 
# 168
__attribute((always_inline)) void 
# 169
construct(const Arg1 &a1, const Arg2 &a2, const Arg3 &a3, const Arg4 &a4, const Arg5 &a5, const Arg6 &a6, const Arg7 &a7, const Arg8 &a8, const Arg9 &a9, const Arg10 &a10) 
# 170
{ 
# 171
::new (this->ptr()) (T)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); 
# 172
} 
# 175
__attribute((always_inline)) void 
# 176
destroy() 
# 177
{ 
# 178
T &self = *this; 
# 179
(self.~T()); 
# 180
} 
# 181
}; 
# 184
template< class T, std::size_t N> 
# 185
class uninitialized_array { 
# 188
public: typedef T value_type; 
# 189
typedef T &reference; 
# 190
typedef const T &const_reference; 
# 191
typedef T *pointer; 
# 192
typedef const T *const_pointer; 
# 193
typedef pointer iterator; 
# 194
typedef const_pointer const_iterator; 
# 195
typedef std::size_t size_type; 
# 197
__attribute((always_inline)) iterator 
# 198
begin() 
# 199
{ 
# 200
return this->data(); 
# 201
} 
# 203
__attribute((always_inline)) const_iterator 
# 204
begin() const 
# 205
{ 
# 206
return this->data(); 
# 207
} 
# 209
__attribute((always_inline)) iterator 
# 210
end() 
# 211
{ 
# 212
return this->begin() + size(); 
# 213
} 
# 215
__attribute((always_inline)) const_iterator 
# 216
end() const 
# 217
{ 
# 218
return this->begin() + size(); 
# 219
} 
# 221
__attribute((always_inline)) const_iterator 
# 222
cbegin() const 
# 223
{ 
# 224
return this->begin(); 
# 225
} 
# 227
__attribute((always_inline)) const_iterator 
# 228
cend() const 
# 229
{ 
# 230
return this->end(); 
# 231
} 
# 233
__attribute((always_inline)) size_type 
# 234
size() const 
# 235
{ 
# 236
return N; 
# 237
} 
# 239
__attribute((always_inline)) bool 
# 240
empty() const 
# 241
{ 
# 242
return false; 
# 243
} 
# 245
__attribute((always_inline)) T *
# 246
data() 
# 247
{ 
# 248
return ((impl).get()); 
# 249
} 
# 251
__attribute((always_inline)) const T *
# 252
data() const 
# 253
{ 
# 254
return ((impl).get()); 
# 255
} 
# 258
__attribute((always_inline)) reference 
# 259
operator[](size_type n) 
# 260
{ 
# 261
return this->data()[n]; 
# 262
} 
# 264
__attribute((always_inline)) const_reference 
# 265
operator[](size_type n) const 
# 266
{ 
# 267
return this->data()[n]; 
# 268
} 
# 270
__attribute((always_inline)) reference 
# 271
front() 
# 272
{ 
# 273
return *this->data(); 
# 274
} 
# 276
__attribute((always_inline)) const_reference 
# 277
front() const 
# 278
{ 
# 279
return *this->data(); 
# 280
} 
# 282
__attribute((always_inline)) reference 
# 283
back() 
# 284
{ 
# 285
return this->data()[size() - ((size_type)1)]; 
# 286
} 
# 288
__attribute((always_inline)) const_reference 
# 289
back() const 
# 290
{ 
# 291
return this->data()[size() - ((size_type)1)]; 
# 292
} 
# 295
private: uninitialized< T [N]>  impl; 
# 296
}; 
# 299
}
# 300
}}}}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 28
namespace bulk_ { 
# 32
__attribute__((unused)) inline bool is_on_chip(void *ptr) 
# 33
{int volatile ___ = 1;(void)ptr;
# 35
::exit(___);}
#if 0
# 33
{ 
# 34
return bulk_::detail::is_shared(ptr); 
# 35
} 
#endif
# 38 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
template< class T> __attribute__((unused)) inline T *
# 39
on_chip_cast(T *ptr) 
# 40
{int volatile ___ = 1;(void)ptr;
# 44
::exit(___);}
#if 0
# 40
{ 
# 41
__attribute__((unused)) extern char s_begin[]; 
# 42
void *result = ((reinterpret_cast< char *>(ptr)) - (s_begin)) + (s_begin); 
# 43
return reinterpret_cast< T *>(result); 
# 44
} 
#endif
# 47 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
namespace detail { 
# 51
__attribute__((unused)) extern int s_data_segment_begin[]; 
# 54
class os { 
# 57
public: os(size_t max_data_segment_size) : m_program_break(s_data_segment_begin), m_max_data_segment_size(max_data_segment_size) 
# 60
{int *volatile ___ = 0;(void)max_data_segment_size;
# 61
::free(___);}
#if 0
# 60
{ 
# 61
} 
#endif
# 64 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
int brk(void *end_data_segment) 
# 65
{int volatile ___ = 1;(void)end_data_segment;
# 73
::exit(___);}
#if 0
# 65
{ 
# 66
if (end_data_segment <= (m_program_break)) 
# 67
{ 
# 68
(m_program_break) = end_data_segment; 
# 69
return 0; 
# 70
}  
# 72
return -1; 
# 73
} 
#endif
# 76 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *sbrk(size_t increment) 
# 77
{int volatile ___ = 1;(void)increment;
# 88
::exit(___);}
#if 0
# 77
{ 
# 78
if ((this->data_segment_size() + increment) <= (m_max_data_segment_size)) 
# 79
{ 
# 80
(m_program_break) = ((reinterpret_cast< char *>(m_program_break)) + increment); 
# 81
} else 
# 83
{ 
# 84
return reinterpret_cast< void *>(-1); 
# 85
}  
# 87
return m_program_break; 
# 88
} 
#endif
# 91 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *program_break() const 
# 92
{int volatile ___ = 1;
# 94
::exit(___);}
#if 0
# 92
{ 
# 93
return m_program_break; 
# 94
} 
#endif
# 97 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *data_segment_begin() const 
# 98
{int volatile ___ = 1;
# 100
::exit(___);}
#if 0
# 98
{ 
# 99
return s_data_segment_begin; 
# 100
} 
#endif
# 104 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
private: size_t data_segment_size() 
# 105
{int volatile ___ = 1;
# 107
::exit(___);}
#if 0
# 105
{ 
# 106
return (reinterpret_cast< char *>(m_program_break)) - (reinterpret_cast< char *>(s_data_segment_begin)); 
# 107
} 
#endif
# 110 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *m_program_break; 
# 113
size_t m_max_data_segment_size; 
# 114
}; 
# 118
class singleton_unsafe_on_chip_allocator { 
# 121
public: singleton_unsafe_on_chip_allocator(size_t max_data_segment_size) : m_os(max_data_segment_size) 
# 123
{int *volatile ___ = 0;(void)max_data_segment_size;::free(___);}
#if 0
# 123
{ } 
#endif
# 125 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *allocate(size_t size) 
# 126
{int volatile ___ = 1;(void)size;
# 154
::exit(___);}
#if 0
# 126
{ 
# 127
size_t aligned_size = align8(size); 
# 129
block *prev = find_first_free_insertion_point(this->heap_begin(), this->heap_end(), aligned_size); 
# 131
block *b; 
# 133
if ((prev != this->heap_end()) && ((b = prev->next()) != this->heap_end())) 
# 134
{ 
# 136
if ((b->size() - aligned_size) >= sizeof(block)) 
# 137
{ 
# 138
this->split_block(b, aligned_size); 
# 139
}  
# 141
b->set_is_free(false); 
# 142
} else 
# 144
{ 
# 146
b = this->extend_heap(prev, aligned_size); 
# 147
if (b == this->heap_end()) 
# 148
{ 
# 149
return 0; 
# 150
}  
# 151
}  
# 153
return b->data(); 
# 154
} 
#endif
# 157 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void deallocate(void *ptr) 
# 158
{int volatile ___ = 1;(void)ptr;
# 184
::exit(___);}
#if 0
# 158
{ 
# 159
if (ptr != (0)) 
# 160
{ 
# 161
block *b = get_block(ptr); 
# 164
b->set_is_free(true); 
# 167
if ((b->prev()) && b->prev()->is_free()) 
# 168
{ 
# 169
b = b->prev(); 
# 170
this->fuse_block(b); 
# 171
}  
# 174
if (b->next() != this->heap_end()) 
# 175
{ 
# 176
this->fuse_block(b); 
# 177
} else 
# 179
{ 
# 181
(m_os).brk(b); 
# 182
}  
# 183
}  
# 184
} 
#endif
# 189 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
private: class block : public aligned_type< 16UL> ::type { 
# 192
public: size_t size() const 
# 193
{int volatile ___ = 1;
# 195
::exit(___);}
#if 0
# 193
{ 
# 194
return m_size; 
# 195
} 
#endif
# 197 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void set_size(size_t sz) 
# 198
{int volatile ___ = 1;(void)sz;
# 200
::exit(___);}
#if 0
# 198
{ 
# 199
(m_size) = sz; 
# 200
} 
#endif
# 202 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
block *prev() const 
# 203
{int volatile ___ = 1;
# 205
::exit(___);}
#if 0
# 203
{ 
# 204
return m_prev; 
# 205
} 
#endif
# 207 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void set_prev(block *p) 
# 208
{int volatile ___ = 1;(void)p;
# 210
::exit(___);}
#if 0
# 208
{ 
# 209
(m_prev) = p; 
# 210
} 
#endif
# 213 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *byte_at(size_t index) const 
# 214
{int volatile ___ = 1;(void)index;
# 216
::exit(___);}
#if 0
# 214
{ 
# 215
return (reinterpret_cast< char *>(this->data())) + index; 
# 216
} 
#endif
# 218 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
block *next() const 
# 219
{int volatile ___ = 1;
# 221
::exit(___);}
#if 0
# 219
{ 
# 220
return reinterpret_cast< block *>(this->byte_at(this->size())); 
# 221
} 
#endif
# 223 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
bool is_free() const 
# 224
{int volatile ___ = 1;
# 226
::exit(___);}
#if 0
# 224
{ 
# 225
return m_is_free; 
# 226
} 
#endif
# 228 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void set_is_free(bool f) 
# 229
{int volatile ___ = 1;(void)f;
# 231
::exit(___);}
#if 0
# 229
{ 
# 230
(m_is_free) = f; 
# 231
} 
#endif
# 233 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *data() const 
# 234
{int volatile ___ = 1;
# 236
::exit(___);}
#if 0
# 234
{ 
# 235
return (reinterpret_cast< char *>(const_cast< block *>(this))) + sizeof(block); 
# 236
} 
#endif
# 242 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
private: bool m_is_free:1; 
# 243
size_t m_size:((8) * sizeof(size_t)) - (1); 
# 244
block *m_prev; 
# 245
}; 
# 248
os m_os; 
# 250
block *heap_begin() const 
# 251
{int volatile ___ = 1;
# 253
::exit(___);}
#if 0
# 251
{ 
# 252
return reinterpret_cast< block *>((m_os).data_segment_begin()); 
# 253
} 
#endif
# 256 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
block *heap_end() const 
# 257
{int volatile ___ = 1;
# 259
::exit(___);}
#if 0
# 257
{ 
# 258
return reinterpret_cast< block *>((m_os).program_break()); 
# 259
} 
#endif
# 262 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void split_block(block *b, size_t size) 
# 263
{int volatile ___ = 1;(void)b;(void)size;
# 283
::exit(___);}
#if 0
# 263
{ 
# 264
block *new_block; 
# 267
new_block = (reinterpret_cast< block *>(b->byte_at(size))); 
# 270
new_block->set_size((b->size() - size) - sizeof(block)); 
# 272
new_block->set_prev(b); 
# 273
new_block->set_is_free(true); 
# 276
b->set_size(size); 
# 279
if (new_block->next() != this->heap_end()) 
# 280
{ 
# 281
new_block->next()->set_prev(new_block); 
# 282
}  
# 283
} 
#endif
# 286 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
bool fuse_block(block *b) 
# 287
{int volatile ___ = 1;(void)b;
# 302
::exit(___);}
#if 0
# 287
{ 
# 288
if ((b->next() != this->heap_end()) && b->next()->is_free()) 
# 289
{ 
# 291
b->set_size((sizeof(block) + b->next()->size()) + b->size()); 
# 293
if (b->next() != this->heap_end()) 
# 294
{ 
# 295
b->next()->set_prev(b); 
# 296
}  
# 298
return true; 
# 299
}  
# 301
return false; 
# 302
} 
#endif
# 305 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
static block *get_block(void *data) 
# 306
{int volatile ___ = 1;(void)data;
# 310
::exit(___);}
#if 0
# 306
{ 
# 308
void *ptr = (reinterpret_cast< char *>(data)) - sizeof(block); 
# 309
return reinterpret_cast< block *>(ptr); 
# 310
} 
#endif
# 313 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
static block *find_first_free_insertion_point(block *first, block *last, size_t size) 
# 314
{int volatile ___ = 1;(void)first;(void)last;(void)size;
# 324
::exit(___);}
#if 0
# 314
{ 
# 315
block *prev = last; 
# 317
while ((first != last) && (!(first->is_free() && (first->size() >= size)))) 
# 318
{ 
# 319
prev = first; 
# 320
first = first->next(); 
# 321
}  
# 323
return prev; 
# 324
} 
#endif
# 327 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
block *extend_heap(block *prev, size_t size) 
# 328
{int volatile ___ = 1;(void)prev;(void)size;
# 344
::exit(___);}
#if 0
# 328
{ 
# 330
block *new_block = this->heap_end(); 
# 333
if ((m_os).sbrk(sizeof(block) + size) == (reinterpret_cast< void *>(-1))) 
# 334
{ 
# 336
return new_block; 
# 337
}  
# 339
on_chip_cast(new_block)->set_size(size); 
# 340
on_chip_cast(new_block)->set_prev(prev); 
# 341
on_chip_cast(new_block)->set_is_free(false); 
# 343
return new_block; 
# 344
} 
#endif
# 347 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
static size_t align8(size_t size) 
# 348
{int volatile ___ = 1;(void)size;
# 350
::exit(___);}
#if 0
# 348
{ 
# 349
return (((size - (1)) >> 3) << 3) + (8); 
# 350
} 
#endif
# 351 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
}; 
# 354
class singleton_on_chip_allocator { 
# 359
public: singleton_on_chip_allocator(size_t max_data_segment_size) : m_mutex(), m_alloc(max_data_segment_size) 
# 362
{ } 
# 366
void *unsafe_allocate(size_t size) 
# 367
{int volatile ___ = 1;(void)size;
# 369
::exit(___);}
#if 0
# 367
{ 
# 368
return (m_alloc).allocate(size); 
# 369
} 
#endif
# 373 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void *allocate(size_t size) 
# 374
{int volatile ___ = 1;(void)size;
# 384
::exit(___);}
#if 0
# 374
{ 
# 375
void *result; 
# 377
(m_mutex).lock(); 
# 378
{ 
# 379
result = this->unsafe_allocate(size); 
# 380
} 
# 381
(m_mutex).unlock(); 
# 383
return result; 
# 384
} 
#endif
# 388 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void unsafe_deallocate(void *ptr) 
# 389
{int volatile ___ = 1;(void)ptr;
# 391
::exit(___);}
#if 0
# 389
{ 
# 390
(m_alloc).deallocate(ptr); 
# 391
} 
#endif
# 395 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void deallocate(void *ptr) 
# 396
{int volatile ___ = 1;(void)ptr;
# 402
::exit(___);}
#if 0
# 396
{ 
# 397
(m_mutex).lock(); 
# 398
{ 
# 399
this->unsafe_deallocate(ptr); 
# 400
} 
# 401
(m_mutex).unlock(); 
# 402
} 
#endif
# 406 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
private: class mutex { 
# 410
public: mutex() : m_in_use((0)) 
# 412
{int *volatile ___ = 0;::free(___);}
#if 0
# 412
{ } 
#endif
# 416 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
bool try_lock() 
# 417
{int volatile ___ = 1;
# 423
::exit(___);}
#if 0
# 417
{ 
# 421
return false; 
# 423
} 
#endif
# 427 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void lock() 
# 428
{int volatile ___ = 1;
# 434
::exit(___);}
#if 0
# 428
{ 
# 430
while (this->try_lock()) 
# 431
{ 
# 432
; 
# 433
}  
# 434
} 
#endif
# 438 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
void unlock() 
# 439
{int volatile ___ = 1;
# 441
::exit(___);}
#if 0
# 439
{ 
# 440
(m_in_use) = (0); 
# 441
} 
#endif
# 445 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
private: unsigned m_in_use; 
# 446
}; 
# 449
mutex m_mutex; 
# 450
singleton_unsafe_on_chip_allocator m_alloc; 
# 451
}; 
# 456
namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { }; using namespace ::thrust::system::cuda::detail::bulk_::detail::_GLOBAL__N__20_expected_val_cpp1_ii_71016e90; namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { 
# 458
__attribute__((unused)) static uninitialized< singleton_on_chip_allocator>  s_on_chip_allocator; 
# 460
}
# 463
__attribute__((unused)) inline void init_on_chip_malloc(size_t max_data_segment_size) 
# 464
{int volatile ___ = 1;(void)max_data_segment_size;
# 466
::exit(___);}
#if 0
# 464
{ 
# 465
s_on_chip_allocator.construct(max_data_segment_size); 
# 466
} 
#endif
# 469 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void *on_chip_malloc(size_t size) 
# 470
{int volatile ___ = 1;(void)size;
# 473
::exit(___);}
#if 0
# 470
{ 
# 471
void *result = s_on_chip_allocator.get().allocate(size); 
# 472
return on_chip_cast(result); 
# 473
} 
#endif
# 476 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void on_chip_free(void *ptr) 
# 477
{int volatile ___ = 1;(void)ptr;
# 479
::exit(___);}
#if 0
# 477
{ 
# 478
s_on_chip_allocator.get().deallocate(ptr); 
# 479
} 
#endif
# 482 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void *unsafe_on_chip_malloc(size_t size) 
# 483
{int volatile ___ = 1;(void)size;
# 486
::exit(___);}
#if 0
# 483
{ 
# 484
void *result = s_on_chip_allocator.get().unsafe_allocate(size); 
# 485
return on_chip_cast(result); 
# 486
} 
#endif
# 489 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void unsafe_on_chip_free(void *ptr) 
# 490
{int volatile ___ = 1;(void)ptr;
# 492
::exit(___);}
#if 0
# 490
{ 
# 491
s_on_chip_allocator.get().unsafe_deallocate(ptr); 
# 492
} 
#endif
# 495 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
}
# 498
__attribute__((unused)) inline void *shmalloc(size_t num_bytes) 
# 499
{int volatile ___ = 1;(void)num_bytes;
# 511
::exit(___);}
#if 0
# 499
{ 
# 501
void *result = detail::on_chip_malloc(num_bytes); 
# 510
return result; 
# 511
} 
#endif
# 514 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void *unsafe_shmalloc(size_t num_bytes) 
# 515
{int volatile ___ = 1;(void)num_bytes;
# 527
::exit(___);}
#if 0
# 515
{ 
# 517
void *result = detail::unsafe_on_chip_malloc(num_bytes); 
# 526
return result; 
# 527
} 
#endif
# 530 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void shfree(void *ptr) 
# 531
{int volatile ___ = 1;(void)ptr;
# 544
::exit(___);}
#if 0
# 531
{ 
# 542
bulk_::detail::on_chip_free(bulk_::on_chip_cast(ptr)); 
# 544
} 
#endif
# 547 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
__attribute__((unused)) inline void unsafe_shfree(void *ptr) 
# 548
{int volatile ___ = 1;(void)ptr;
# 561
::exit(___);}
#if 0
# 548
{ 
# 559
bulk_::detail::unsafe_on_chip_free(bulk_::on_chip_cast(ptr)); 
# 561
} 
#endif
# 564 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
template< class ConcurrentGroup> __attribute__((unused)) inline void *
# 566
malloc(ConcurrentGroup &g, size_t num_bytes) 
# 567
{int volatile ___ = 1;(void)g;(void)num_bytes;
# 582
::exit(___);}
#if 0
# 567
{ 
# 568
__attribute__((unused)) static void *s_result; 
# 572
(g.wait()); 
# 574
if (((g.this_exec).index()) == 0) 
# 575
{ 
# 576
s_result = bulk_::unsafe_shmalloc(num_bytes); 
# 577
}  
# 579
(g.wait()); 
# 581
return s_result; 
# 582
} 
#endif
# 585 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
template< class ConcurrentGroup> __attribute__((unused)) inline void 
# 587
free(ConcurrentGroup &g, void *ptr) 
# 588
{int volatile ___ = 1;(void)g;(void)ptr;
# 595
::exit(___);}
#if 0
# 588
{ 
# 589
if (((g.this_exec).index()) == 0) 
# 590
{ 
# 591
bulk_::unsafe_shfree(ptr); 
# 592
}  
# 594
(g.wait()); 
# 595
} 
#endif
# 598 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/malloc.hpp"
}
# 599
}}}}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/tuple_meta_transform.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 23
namespace bulk_ { 
# 25
namespace detail { 
# 29
template< class Tuple, 
# 30
template< class >  class UnaryMetaFunction, unsigned 
# 31
sz = tuple_size< Tuple> ::value> struct tuple_meta_transform; 
# 34
template< class Tuple, 
# 35
template< class >  class UnaryMetaFunction> 
# 36
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 0>  { 
# 38
typedef tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 39
}; 
# 41
template< class Tuple, 
# 42
template< class >  class UnaryMetaFunction> 
# 43
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 1>  { 
# 47
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 48
}; 
# 50
template< class Tuple, 
# 51
template< class >  class UnaryMetaFunction> 
# 52
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 2>  { 
# 57
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 58
}; 
# 60
template< class Tuple, 
# 61
template< class >  class UnaryMetaFunction> 
# 62
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 3>  { 
# 68
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 69
}; 
# 71
template< class Tuple, 
# 72
template< class >  class UnaryMetaFunction> 
# 73
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 4>  { 
# 80
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 81
}; 
# 83
template< class Tuple, 
# 84
template< class >  class UnaryMetaFunction> 
# 85
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 5>  { 
# 93
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type>  type; 
# 94
}; 
# 96
template< class Tuple, 
# 97
template< class >  class UnaryMetaFunction> 
# 98
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 6>  { 
# 107
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, null_type, null_type, null_type, null_type>  type; 
# 108
}; 
# 110
template< class Tuple, 
# 111
template< class >  class UnaryMetaFunction> 
# 112
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 7>  { 
# 122
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, null_type, null_type, null_type>  type; 
# 123
}; 
# 125
template< class Tuple, 
# 126
template< class >  class UnaryMetaFunction> 
# 127
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 8>  { 
# 138
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, null_type, null_type>  type; 
# 139
}; 
# 141
template< class Tuple, 
# 142
template< class >  class UnaryMetaFunction> 
# 143
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 9>  { 
# 155
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 8, Tuple> ::type> ::type, null_type>  type; 
# 156
}; 
# 158
template< class Tuple, 
# 159
template< class >  class UnaryMetaFunction> 
# 160
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 10>  { 
# 173
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 8, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 9, Tuple> ::type> ::type>  type; 
# 174
}; 
# 177
}
# 178
}
# 179
}}}}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/tuple_transform.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 24
namespace bulk_ { 
# 26
namespace detail { 
# 29
template< class Tuple, 
# 30
template< class >  class UnaryMetaFunction, class 
# 31
UnaryFunction, unsigned 
# 32
sz = tuple_size< Tuple> ::value> struct tuple_transform_functor; 
# 36
template< class Tuple, 
# 37
template< class >  class UnaryMetaFunction, class 
# 38
UnaryFunction> 
# 39
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 0>  { 
# 43
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 44
{ 
# 45
return tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> (); 
# 46
} 
# 50
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 51
{ 
# 52
return tuple< null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> (); 
# 53
} 
# 54
}; 
# 57
template< class Tuple, 
# 58
template< class >  class UnaryMetaFunction, class 
# 59
UnaryFunction> 
# 60
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 1>  { 
# 64
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 65
{ 
# 66
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 68
return (XfrmTuple)f(thrust::get< 0> (t)); 
# 69
} 
# 73
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 74
{ 
# 75
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 77
return (XfrmTuple)f(thrust::get< 0> (t)); 
# 78
} 
# 79
}; 
# 82
template< class Tuple, 
# 83
template< class >  class UnaryMetaFunction, class 
# 84
UnaryFunction> 
# 85
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 2>  { 
# 89
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 90
{ 
# 91
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 93
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t))); 
# 95
} 
# 99
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 100
{ 
# 101
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 103
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t))); 
# 105
} 
# 106
}; 
# 109
template< class Tuple, 
# 110
template< class >  class UnaryMetaFunction, class 
# 111
UnaryFunction> 
# 112
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 3>  { 
# 116
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 117
{ 
# 118
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 120
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t))); 
# 123
} 
# 127
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 128
{ 
# 129
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 131
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t))); 
# 134
} 
# 135
}; 
# 138
template< class Tuple, 
# 139
template< class >  class UnaryMetaFunction, class 
# 140
UnaryFunction> 
# 141
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 4>  { 
# 145
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 146
{ 
# 147
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 149
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t))); 
# 153
} 
# 157
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 158
{ 
# 159
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 161
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t))); 
# 165
} 
# 166
}; 
# 169
template< class Tuple, 
# 170
template< class >  class UnaryMetaFunction, class 
# 171
UnaryFunction> 
# 172
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 5>  { 
# 176
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 177
{ 
# 178
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 180
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t))); 
# 185
} 
# 189
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 190
{ 
# 191
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 193
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t))); 
# 198
} 
# 199
}; 
# 202
template< class Tuple, 
# 203
template< class >  class UnaryMetaFunction, class 
# 204
UnaryFunction> 
# 205
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 6>  { 
# 209
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 210
{ 
# 211
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 213
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t))); 
# 219
} 
# 223
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 224
{ 
# 225
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 227
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t))); 
# 233
} 
# 234
}; 
# 237
template< class Tuple, 
# 238
template< class >  class UnaryMetaFunction, class 
# 239
UnaryFunction> 
# 240
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 7>  { 
# 244
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 245
{ 
# 246
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 248
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t))); 
# 255
} 
# 259
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 260
{ 
# 261
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 263
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t))); 
# 270
} 
# 271
}; 
# 274
template< class Tuple, 
# 275
template< class >  class UnaryMetaFunction, class 
# 276
UnaryFunction> 
# 277
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 8>  { 
# 281
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 282
{ 
# 283
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 285
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t))); 
# 293
} 
# 297
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 298
{ 
# 299
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 301
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t))); 
# 309
} 
# 310
}; 
# 313
template< class Tuple, 
# 314
template< class >  class UnaryMetaFunction, class 
# 315
UnaryFunction> 
# 316
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 9>  { 
# 320
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 321
{ 
# 322
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 324
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t))); 
# 333
} 
# 337
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 338
{ 
# 339
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 341
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t))); 
# 350
} 
# 351
}; 
# 354
template< class Tuple, 
# 355
template< class >  class UnaryMetaFunction, class 
# 356
UnaryFunction> 
# 357
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 10>  { 
# 361
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 362
{ 
# 363
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 365
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t)), f(thrust::get< 9> (t))); 
# 375
} 
# 379
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 380
{ 
# 381
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 383
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t)), f(thrust::get< 9> (t))); 
# 393
} 
# 394
}; 
# 397
template< template< class >  class UnaryMetaFunction, class 
# 398
Tuple, class 
# 399
UnaryFunction> typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type 
# 401
tuple_host_transform(const Tuple &t, UnaryFunction f) 
# 402
{ 
# 403
return tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction> ::do_it_on_the_host(t, f); 
# 404
} 
# 406
template< template< class >  class UnaryMetaFunction, class 
# 407
Tuple, class 
# 408
UnaryFunction> typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type 
# 411
tuple_host_device_transform(const Tuple &t, UnaryFunction f) 
# 412
{ 
# 413
return tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction> ::do_it_on_the_host_or_device(t, f); 
# 414
} 
# 416
}
# 417
}
# 418
}}}}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 29
namespace bulk_ { 
# 31
namespace detail { 
# 35
template< class ExecutionGroup, class Closure> 
# 36
class task_base { 
# 39
public: typedef ExecutionGroup group_type; 
# 40
typedef Closure closure_type; 
# 43
task_base(group_type g, closure_type c) : c(c), g(g) 
# 45
{ } 
# 49
protected: static void substitute_placeholders_and_execute(group_type &g, closure_type &c) 
# 50
{ 
# 52
substituted_arguments_type new_args = (substitute_placeholders)(g, (c.arguments())); 
# 55
closure< typename Closure::function_type, typename tuple_meta_transform< typename Closure::arguments_type, substitutor_result> ::type>  new_c((c.function()), new_args); 
# 58
new_c(); 
# 59
} 
# 61
closure_type c; 
# 62
group_type g; 
# 66
private: 
# 65
template< class T> 
# 66
struct substitutor_result : public thrust::detail::eval_if< is_cursor< T> ::value, cursor_result< T, ExecutionGroup> , thrust::detail::identity_< T> >  { 
# 72
}; 
# 77
typedef typename tuple_meta_transform< typename Closure::arguments_type, substitutor_result> ::type substituted_arguments_type; 
# 79
struct substitutor { 
# 81
group_type &g; 
# 84
substitutor(group_type &g) : g(g) 
# 86
{int *volatile ___ = 0;(void)g;::free(___);}
#if 0
# 86
{ } 
#endif
# 88 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
template< unsigned depth> typename cursor_result< cursor< depth> , ExecutionGroup> ::type 
# 91
operator()(cursor< depth>  c) const 
# 92
{int volatile ___ = 1;(void)c;
# 94
::exit(___);}
#if 0
# 92
{ 
# 93
return (c.get(g)); 
# 94
} 
#endif
# 96 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
template< class T> T &
# 98
operator()(T &x) const 
# 99
{int volatile ___ = 1;(void)x;
# 101
::exit(___);}
#if 0
# 99
{ 
# 100
return x; 
# 101
} 
#endif
# 102 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
}; 
# 105
static substituted_arguments_type substitute_placeholders(group_type &g, typename Closure::arguments_type args) 
# 106
{ 
# 107
return detail::tuple_host_device_transform< substitutor_result> (args, (substitutor)g); 
# 108
} 
# 109
}; 
# 112
template< std::size_t blocksize, std::size_t grainsize> 
# 113
struct cuda_block { 
# 115
typedef concurrent_group< agent< grainsize> , blocksize>  type; 
# 116
}; 
# 119
template< std::size_t gridsize, std::size_t blocksize, std::size_t grainsize> 
# 120
struct cuda_grid { 
# 124
typedef parallel_group< typename cuda_block< blocksize, grainsize> ::type>  type; 
# 125
}; 
# 128
template< class Group, class Closure> class cuda_task; 
# 131
template< class Grid> 
# 132
struct grid_maker { 
# 135
static Grid make(typename Grid::size_type size, typename Grid::agent_type 
# 136
block, typename Grid::size_type 
# 137
index) 
# 138
{ 
# 139
return Grid(block, index); 
# 140
} 
# 141
}; 
# 144
template< class Block> 
# 145
struct grid_maker< parallel_group< Block, dynamic_group_size> >  { 
# 148
static parallel_group< Block, 0UL>  make(typename parallel_group< Block, 0UL> ::size_type size, Block 
# 149
block, typename parallel_group< Block, 0UL> ::size_type 
# 150
index) 
# 151
{ 
# 152
return parallel_group< Block, 0UL> (size, block, index); 
# 153
} 
# 154
}; 
# 157
template< class Block> 
# 158
struct block_maker { 
# 161
static Block make(typename Block::size_type size, typename Block::size_type 
# 162
heap_size, typename Block::agent_type 
# 163
thread, typename Block::size_type 
# 164
index) 
# 165
{ 
# 166
return Block(heap_size, thread, index); 
# 167
} 
# 168
}; 
# 170
template< class Thread> 
# 171
struct block_maker< concurrent_group< Thread, dynamic_group_size> >  { 
# 174
static concurrent_group< Thread, 0UL>  make(typename concurrent_group< Thread, 0UL> ::size_type size, typename concurrent_group< Thread, 0UL> ::size_type 
# 175
heap_size, Thread 
# 176
thread, typename concurrent_group< Thread, 0UL> ::size_type 
# 177
index) 
# 178
{ 
# 179
return concurrent_group< Thread, 0UL> (size, heap_size, thread, index); 
# 180
} 
# 181
}; 
# 184
template< class Grid> Grid 
# 186
make_grid(typename Grid::size_type size, typename Grid::agent_type block, typename Grid::size_type index = invalid_index) 
# 187
{ 
# 188
return grid_maker< Grid> ::make(size, block, index); 
# 189
} 
# 192
template< class Block> Block 
# 194
make_block(typename Block::size_type size, typename Block::size_type heap_size, typename Block::agent_type thread = typename Block::agent_type(), typename Block::size_type index = invalid_index) 
# 195
{ 
# 196
return block_maker< Block> ::make(size, heap_size, thread, index); 
# 197
} 
# 201
template< std::size_t gridsize, std::size_t blocksize, std::size_t grainsize, class Closure> 
# 202
class cuda_task< parallel_group< concurrent_group< agent< grainsize> , blocksize> , gridsize> , Closure>  : public task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure>  { 
# 214
typedef ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure>  super_t; 
# 217
public: typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::group_type grid_type; 
# 218
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::group_type::agent_type block_type; 
# 219
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::group_type::agent_type::agent_type thread_type; 
# 220
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::closure_type closure_type; 
# 221
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::group_type::size_type size_type; 
# 224
private: size_type block_offset; 
# 229
public: cuda_task(grid_type g, closure_type c, size_type offset) : super_t(g, c), block_offset(offset) 
# 232
{ } 
# 235
void operator()() 
# 236
{int volatile ___ = 1;
# 263
::exit(___);}
#if 0
# 236
{ 
# 263
} 
#endif
# 264 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
}; 
# 268
template< std::size_t blocksize, std::size_t grainsize, class Closure> 
# 269
class cuda_task< concurrent_group< agent< grainsize> , blocksize> , Closure>  : public task_base< typename cuda_block< blocksize, grainsize> ::type, Closure>  { 
# 278
typedef ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_block< blocksize, grainsize> ::type, Closure>  super_t; 
# 281
public: typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_block< blocksize, grainsize> ::type, Closure> ::group_type block_type; 
# 282
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_block< blocksize, grainsize> ::type, Closure> ::group_type::agent_type thread_type; 
# 283
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_block< blocksize, grainsize> ::type, Closure> ::closure_type closure_type; 
# 284
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< typename cuda_block< blocksize, grainsize> ::type, Closure> ::group_type::size_type size_type; 
# 288
cuda_task(block_type b, closure_type c) : super_t(b, c) 
# 290
{ } 
# 293
void operator()() 
# 294
{int volatile ___ = 1;
# 317
::exit(___);}
#if 0
# 294
{ 
# 317
} 
#endif
# 318 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
}; 
# 322
template< std::size_t groupsize, std::size_t grainsize, class Closure> 
# 323
class cuda_task< parallel_group< agent< grainsize> , groupsize> , Closure>  : public task_base< parallel_group< agent< grainsize> , groupsize> , Closure>  { 
# 327
typedef ::thrust::system::cuda::detail::bulk_::detail::task_base< parallel_group< agent< grainsize> , groupsize> , Closure>  super_t; 
# 330
public: typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< parallel_group< agent< grainsize> , groupsize> , Closure> ::closure_type closure_type; 
# 331
typedef typename ::thrust::system::cuda::detail::bulk_::detail::task_base< parallel_group< agent< grainsize> , groupsize> , Closure> ::group_type group_type; 
# 334
cuda_task(group_type g, closure_type c) : super_t(g, c) 
# 336
{ } 
# 339
void operator()() 
# 340
{int volatile ___ = 1;
# 361
::exit(___);}
#if 0
# 340
{ 
# 361
} 
#endif
# 362 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_task.hpp"
}; 
# 365
}
# 366
}
# 367
}}}}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/parameter_ptr.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 28
namespace bulk_ { 
# 30
namespace detail { 
# 35
template< class T> 
# 36
class parameter_ptr { 
# 39
public: typedef T element_type; 
# 42
explicit parameter_ptr(element_type *ptr) : m_ptr(ptr) 
# 44
{ } 
# 48
parameter_ptr(const parameter_ptr &other_) 
# 49
{ 
# 50
parameter_ptr &other = const_cast< parameter_ptr &>(other_); 
# 51
thrust::swap(m_ptr, other.m_ptr); 
# 52
} 
# 55
~parameter_ptr() 
# 56
{ 
# 58
if (m_ptr) 
# 59
{ 
# 60
detail::terminate_on_error(cudaFree(m_ptr), "in parameter_ptr dtor"); 
# 61
}  
# 65
} 
# 69
parameter_ptr &operator=(const parameter_ptr &other_) 
# 70
{ 
# 71
parameter_ptr &other = const_cast< parameter_ptr &>(other_); 
# 72
thrust::swap(m_ptr, other.m_ptr); 
# 73
return *this; 
# 74
} 
# 77
T *get() const 
# 78
{ 
# 79
return m_ptr; 
# 80
} 
# 83
private: T *m_ptr; 
# 84
}; 
# 87
template< class T> parameter_ptr< T>  
# 89
make_parameter(const T &x) 
# 90
{ 
# 91
T *raw_ptr = (0); 
# 95
detail::throw_on_error(cudaMalloc(&raw_ptr, sizeof(T)), "make_parameter(): after cudaMalloc"); 
# 102
detail::throw_on_error(cudaMemcpy(raw_ptr, &x, sizeof(T), cudaMemcpyHostToDevice), "make_parameter(): after cudaMemcpy"); 
# 108
return ((parameter_ptr< T> )(raw_ptr)); 
# 109
} 
# 112
}
# 113
}
# 114
}}}}
# 34 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 35
namespace bulk_ { 
# 37
namespace detail { 
# 57
template< unsigned block_size, class Function, bool by_value = sizeof(Function) <= (4096)> struct triple_chevron_launcher_base; 
# 60
template< unsigned block_size, class Function> static void 
# 63
__wrapper__device_stub_launch_by_value(Function &f) {exit(1);}
#if 0
# 64
{ 
# 65
f(); 
# 66
} 
#endif
# 60 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
template< unsigned block_size, class Function> void 
# 63
launch_by_value(Function f) 
# 64
{__wrapper__device_stub_launch_by_value<block_size,Function>(f);
# 66
return;}
#if 0
# 64
{ 
# 65
f(); 
# 66
} 
#endif
# 69 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
template< unsigned block_size, class Function> 
# 70
struct triple_chevron_launcher_base< block_size, Function, true>  { 
# 72
typedef void (*global_function_pointer_t)(Function); 
# 75
static global_function_pointer_t global_function_pointer() 
# 76
{ 
# 77
return &launch_by_value< block_size, Function> ; 
# 78
} 
# 79
}; 
# 82
template< unsigned block_size, class Function> static void 
# 85
__wrapper__device_stub_launch_by_pointer(const Function *&f) {exit(1);}
#if 0
# 86
{ 
# 88
Function f_reg = *f; 
# 89
f_reg(); 
# 90
} 
#endif
# 82 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
template< unsigned block_size, class Function> void 
# 85
launch_by_pointer(const Function *f) 
# 86
{__wrapper__device_stub_launch_by_pointer<block_size,Function>(f);
# 90
return;}
#if 0
# 86
{ 
# 88
Function f_reg = *f; 
# 89
f_reg(); 
# 90
} 
#endif
# 93 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/triple_chevron_launcher.hpp"
template< unsigned block_size, class Function> 
# 94
struct triple_chevron_launcher_base< block_size, Function, false>  { 
# 96
typedef void (*global_function_pointer_t)(const Function *); 
# 99
static global_function_pointer_t global_function_pointer() 
# 100
{ 
# 101
return &launch_by_pointer< block_size, Function> ; 
# 102
} 
# 103
}; 
# 108
template< unsigned block_size_, class Function, bool by_value = sizeof(Function) <= (4096)> 
# 109
class triple_chevron_launcher : protected triple_chevron_launcher_base< block_size_, Function>  { 
# 112
typedef triple_chevron_launcher_base< block_size_, Function>  super_t; 
# 115
public: typedef Function task_type; 
# 118
void launch(unsigned num_blocks, unsigned block_size, ::size_t num_dynamic_smem_bytes, ::cudaStream_t stream, task_type task) 
# 119
{ 
# 120
struct workaround { 
# 123
static void supported_path(unsigned num_blocks, unsigned block_size, ::size_t num_dynamic_smem_bytes, ::cudaStream_t stream, task_type task) 
# 124
{ 
# 127
cudaConfigureCall(((::dim3)(num_blocks)), ((::dim3)(block_size)), num_dynamic_smem_bytes, stream); 
# 128
cudaSetupArgument(task, 0); 
# 129
::thrust::system::cuda::detail::bulk_::detail::throw_on_error(cudaLaunch(super_t::global_function_pointer()), "after cudaLaunch in triple_chevron_launcher::launch()"); 
# 137
} 
# 140
static void unsupported_path(unsigned, unsigned, ::size_t, ::cudaStream_t, task_type) 
# 141
{ 
# 142
bulk_::detail::terminate_with_message("triple_chevron_launcher::launch(): CUDA kernel launch requires CUDART."); 
# 143
} 
# 144
}; 
# 147
(workaround::supported_path)(num_blocks, block_size, num_dynamic_smem_bytes, stream, task); 
# 151
} 
# 152
}; 
# 159
template< unsigned block_size_, class Function> 
# 160
class triple_chevron_launcher< block_size_, Function, false>  : protected triple_chevron_launcher_base< block_size_, Function>  { 
# 163
typedef triple_chevron_launcher_base< block_size_, Function>  super_t; 
# 166
public: typedef Function task_type; 
# 169
void launch(unsigned num_blocks, unsigned block_size, ::size_t num_dynamic_smem_bytes, ::cudaStream_t stream, task_type task) 
# 170
{ 
# 171
struct workaround { 
# 174
static void supported_path(unsigned num_blocks, unsigned block_size, ::size_t num_dynamic_smem_bytes, ::cudaStream_t stream, task_type task) 
# 175
{ 
# 176
parameter_ptr< Function>  parm = ::thrust::system::cuda::detail::bulk_::detail::make_parameter< task_type> (task); 
# 180
cudaConfigureCall(((::dim3)(num_blocks)), ((::dim3)(block_size)), num_dynamic_smem_bytes, stream); 
# 181
cudaSetupArgument(static_cast< const task_type *>((parm.get())), 0); 
# 182
::thrust::system::cuda::detail::bulk_::detail::throw_on_error(cudaLaunch(super_t::global_function_pointer()), "after cudaLaunch in triple_chevron_launcher::launch()"); 
# 191
} 
# 194
static void unsupported_path(unsigned, unsigned, ::size_t, ::cudaStream_t, task_type) 
# 195
{ 
# 196
bulk_::detail::terminate_with_message("triple_chevron_launcher::launch(): CUDA kernel launch requires CUDART."); 
# 197
} 
# 198
}; 
# 201
(workaround::supported_path)(num_blocks, block_size, num_dynamic_smem_bytes, stream, task); 
# 205
} 
# 206
}; 
# 209
}
# 210
}
# 211
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/synchronize.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 28
namespace detail { 
# 33
inline void synchronize(const char *message = "") 
# 34
{ 
# 36
bulk_::detail::throw_on_error(cudaDeviceSynchronize(), message); 
# 41
} 
# 45
inline void synchronize_if_enabled(const char *message = "") 
# 46
{ 
# 53
(void)message; 
# 55
} 
# 58
}
# 59
}
# 60
}}}}
# 40 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/cuda_launcher/cuda_launcher.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 41
namespace bulk_ { 
# 43
namespace detail { 
# 49
template< unsigned block_size_, class ExecutionGroup, class Closure> 
# 50
struct cuda_launcher_base : public triple_chevron_launcher< block_size_, cuda_task< ExecutionGroup, Closure> >  { 
# 56
typedef ::thrust::system::cuda::detail::bulk_::detail::triple_chevron_launcher< block_size_, cuda_task< ExecutionGroup, Closure> >  super_t; 
# 57
typedef typename ::thrust::system::cuda::detail::bulk_::detail::triple_chevron_launcher< block_size_, cuda_task< ExecutionGroup, Closure> > ::task_type task_type; 
# 58
typedef typename ExecutionGroup::size_type size_type; 
# 62
cuda_launcher_base() : m_device_properties(bulk_::detail::device_properties()) 
# 64
{ } 
# 68
void launch(size_type num_blocks, size_type block_size, size_type num_dynamic_smem_bytes, ::cudaStream_t stream, task_type task) 
# 69
{ 
# 70
if (num_blocks > 0) 
# 71
{ 
# 72
super_t::launch(num_blocks, block_size, num_dynamic_smem_bytes, stream, task); 
# 74
bulk_::detail::synchronize_if_enabled("bulk_kernel_by_value"); 
# 75
}  
# 76
} 
# 80
static size_type max_active_blocks_per_multiprocessor(const ::thrust::system::cuda::detail::bulk_::detail::device_properties_t &props, const ::thrust::system::cuda::detail::bulk_::detail::function_attributes_t &
# 81
attr, size_type 
# 82
num_threads_per_block, size_type 
# 83
num_smem_bytes_per_block) 
# 84
{ 
# 85
return static_cast< size_type>(::thrust::system::cuda::detail::bulk_::detail::cuda_launch_config_detail::max_active_blocks_per_multiprocessor(props, attr, num_threads_per_block, num_smem_bytes_per_block)); 
# 86
} 
# 93
static pair< typename ExecutionGroup::size_type, typename ExecutionGroup::size_type>  dynamic_smem_occupancy_limit(const ::thrust::system::cuda::detail::bulk_::detail::device_properties_t &props, const ::thrust::system::cuda::detail::bulk_::detail::function_attributes_t &attr, size_type num_threads_per_block, size_type num_smem_bytes_per_block) 
# 94
{ 
# 96
size_type occupancy = (max_active_blocks_per_multiprocessor)(props, attr, num_threads_per_block, num_smem_bytes_per_block); 
# 99
if (occupancy < 1) { return thrust::make_pair(0, 0); }  
# 101
return ::thrust::make_pair(static_cast< size_type>(::thrust::system::cuda::detail::bulk_::detail::proportional_smem_allocation(props, attr, occupancy)), occupancy); 
# 102
} 
# 106
size_type choose_heap_size(const ::thrust::system::cuda::detail::bulk_::detail::device_properties_t &props, size_type group_size, size_type requested_size) 
# 107
{ 
# 108
::thrust::system::cuda::detail::bulk_::detail::function_attributes_t attr = ::thrust::system::cuda::detail::bulk_::detail::function_attributes(super_t::global_function_pointer()); 
# 112
if (((attr.ptxVersion) < 20) || (requested_size == 0)) 
# 113
{ 
# 114
return 0; 
# 115
}  
# 118
size_type result = (0), occupancy = (0); 
# 119
::thrust::tie(result, occupancy) = (dynamic_smem_occupancy_limit)(props, attr, group_size, 0); 
# 124
if ((requested_size != use_default) && (requested_size > result) && (occupancy > 1)) 
# 125
{ 
# 127
requested_size += 48; 
# 130
if (requested_size > result) 
# 131
{ 
# 133
size_type next_level_result = (0), next_level_occupancy = (0); 
# 134
::thrust::tie(next_level_result, next_level_occupancy) = (dynamic_smem_occupancy_limit)(props, attr, group_size, requested_size); 
# 138
if (next_level_occupancy > 0) { result = next_level_result; }  
# 139
}  
# 140
}  
# 142
return result; 
# 143
} 
# 147
size_type choose_group_size(size_type requested_size) 
# 148
{ 
# 149
size_type result = requested_size; 
# 151
if (result == use_default) 
# 152
{ 
# 153
::thrust::system::cuda::detail::bulk_::detail::function_attributes_t attr = ::thrust::system::cuda::detail::bulk_::detail::function_attributes(super_t::global_function_pointer()); 
# 155
return static_cast< size_type>(::thrust::system::cuda::detail::bulk_::detail::block_size_with_maximum_potential_occupancy(attr, device_properties())); 
# 156
}  
# 158
return result; 
# 159
} 
# 163
size_type choose_subscription(size_type block_size) 
# 164
{ 
# 166
return (block_size > 0) ? (device_properties().maxThreadsPerMultiProcessor) / block_size : 0; 
# 167
} 
# 171
size_type choose_num_groups(size_type requested_num_groups, size_type group_size) 
# 172
{ 
# 173
size_type result = requested_num_groups; 
# 175
if (result == use_default) 
# 176
{ 
# 179
size_type subscription = choose_subscription(group_size); 
# 181
result = ::thrust::min< size_type> (subscription * (device_properties().multiProcessorCount), max_physical_grid_size()); 
# 182
}  
# 184
return result; 
# 185
} 
# 189
size_type max_physical_grid_size() 
# 190
{ 
# 192
int actual_limit = (device_properties().maxGridSize)[0]; 
# 195
int ptx_version = ((::thrust::system::cuda::detail::bulk_::detail::function_attributes(super_t::global_function_pointer()).ptxVersion)); 
# 197
int ptx_limit = 0; 
# 200
if (ptx_version < 30) 
# 201
{ 
# 202
ptx_limit = 65535; 
# 203
} else 
# 205
{ 
# 206
ptx_limit = ((1U << 31) - (1)); 
# 207
}  
# 209
return ::thrust::min< size_type> (actual_limit, ptx_limit); 
# 210
} 
# 214
const ::thrust::system::cuda::detail::bulk_::detail::device_properties_t &device_properties() const 
# 215
{ 
# 216
return m_device_properties; 
# 217
} 
# 220
::thrust::system::cuda::detail::bulk_::detail::device_properties_t m_device_properties; 
# 221
}; 
# 224
template< class ExecutionGroup, class Closure> struct cuda_launcher; 
# 227
template< std::size_t gridsize, std::size_t blocksize, std::size_t grainsize, class Closure> 
# 228
struct cuda_launcher< parallel_group< concurrent_group< agent< grainsize> , blocksize> , gridsize> , Closure>  : public cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure>  { 
# 240
typedef ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure>  super_t; 
# 241
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::size_type size_type; 
# 243
typedef typename cuda_grid< gridsize, blocksize, grainsize> ::type grid_type; 
# 244
typedef typename cuda_grid< gridsize, blocksize, grainsize> ::type::agent_type block_type; 
# 245
typedef typename cuda_grid< gridsize, blocksize, grainsize> ::type::agent_type::agent_type thread_type; 
# 247
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::task_type task_type; 
# 251
void launch(grid_type request, Closure c, ::cudaStream_t stream) 
# 252
{ 
# 253
grid_type g = configure(request); 
# 255
size_type num_blocks = (g.size()); 
# 256
size_type block_size = ((g.this_exec).size()); 
# 258
if ((num_blocks > 0) && (block_size > 0)) 
# 259
{ 
# 260
size_type heap_size = ((g.this_exec).heap_size()); 
# 262
size_type max_physical_grid_size = super_t::max_physical_grid_size(); 
# 267
if (block_size > 0) 
# 268
{ 
# 269
size_type num_remaining_physical_blocks = num_blocks; 
# 270
for (size_type block_offset = (0); block_offset < num_blocks; block_offset += max_physical_grid_size) 
# 273
{ 
# 274
task_type task(g, c, block_offset); 
# 276
size_type num_physical_blocks = ::thrust::min< size_type> (num_remaining_physical_blocks, max_physical_grid_size); 
# 278
super_t::launch(num_physical_blocks, block_size, heap_size, stream, task); 
# 280
num_remaining_physical_blocks -= num_physical_blocks; 
# 281
}  
# 282
}  
# 283
}  
# 284
} 
# 287
grid_type configure(grid_type g) 
# 288
{ 
# 289
size_type block_size = super_t::choose_group_size(((g.this_exec).size())); 
# 290
size_type heap_size = super_t::choose_heap_size(device_properties(), block_size, ((g.this_exec).heap_size())); 
# 291
size_type num_blocks = (g.size()); 
# 293
return make_grid< grid_type> (num_blocks, make_block< block_type> (block_size, heap_size)); 
# 294
} 
# 298
pair< typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::size_type, typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, typename cuda_grid< gridsize, blocksize, grainsize> ::type, Closure> ::size_type>  choose_sizes(size_type requested_num_groups, size_type requested_group_size) 
# 299
{ 
# 302
size_type group_size = (blocksize); 
# 303
if (group_size == 0) 
# 304
{ 
# 305
group_size = super_t::choose_group_size(requested_group_size); 
# 306
}  
# 310
size_type num_groups = (gridsize); 
# 311
if (num_groups == 0) 
# 312
{ 
# 313
num_groups = super_t::choose_num_groups(requested_num_groups, group_size); 
# 314
}  
# 316
return ::thrust::make_pair(num_groups, group_size); 
# 317
} 
# 318
}; 
# 321
template< std::size_t blocksize, std::size_t grainsize, class Closure> 
# 322
struct cuda_launcher< concurrent_group< agent< grainsize> , blocksize> , Closure>  : public cuda_launcher_base< blocksize, concurrent_group< agent< grainsize> , blocksize> , Closure>  { 
# 331
typedef ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, concurrent_group< agent< grainsize> , blocksize> , Closure>  super_t; 
# 332
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, concurrent_group< agent< grainsize> , blocksize> , Closure> ::size_type size_type; 
# 333
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< blocksize, concurrent_group< agent< grainsize> , blocksize> , Closure> ::task_type task_type; 
# 335
typedef concurrent_group< agent< grainsize> , blocksize>  block_type; 
# 338
void launch(block_type request, Closure c, ::cudaStream_t stream) 
# 339
{ 
# 340
block_type b = configure(request); 
# 342
size_type block_size = (b.size()); 
# 343
size_type heap_size = (b.heap_size()); 
# 345
if (block_size > 0) 
# 346
{ 
# 347
task_type task(b, c); 
# 348
super_t::launch(1, block_size, heap_size, stream, task); 
# 349
}  
# 350
} 
# 353
block_type configure(block_type b) 
# 354
{ 
# 355
size_type block_size = super_t::choose_group_size((b.size())); 
# 356
size_type heap_size = super_t::choose_heap_size(device_properties(), block_size, (b.heap_size())); 
# 357
return make_block< block_type> (block_size, heap_size); 
# 358
} 
# 359
}; 
# 362
template< std::size_t groupsize, std::size_t grainsize, class Closure> 
# 363
struct cuda_launcher< parallel_group< agent< grainsize> , groupsize> , Closure>  : public cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure>  { 
# 372
typedef ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure>  super_t; 
# 373
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure> ::size_type size_type; 
# 374
typedef typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure> ::task_type task_type; 
# 376
typedef parallel_group< agent< grainsize> , groupsize>  group_type; 
# 379
void launch(group_type g, Closure c, ::cudaStream_t stream) 
# 380
{ 
# 381
size_type num_blocks, block_size; 
# 382
::thrust::tie(num_blocks, block_size) = configure(g); 
# 384
if ((num_blocks > 0) && (block_size > 0)) 
# 385
{ 
# 386
task_type task(g, c); 
# 388
super_t::launch(num_blocks, block_size, 0, stream, task); 
# 389
}  
# 390
} 
# 393
tuple< typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure> ::size_type, typename ::thrust::system::cuda::detail::bulk_::detail::cuda_launcher_base< 0U, parallel_group< agent< grainsize> , groupsize> , Closure> ::size_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type, ::thrust::null_type>  configure(group_type g) 
# 394
{ 
# 395
size_type block_size = ::thrust::min< size_type> ((g.size()), super_t::choose_group_size(use_default)); 
# 398
size_type max_blocks = super_t::choose_num_groups(bulk_::use_default, block_size); 
# 401
size_type num_blocks = (block_size > 0) ? (((g.size()) + block_size) - 1) / block_size : 0; 
# 404
num_blocks = ::thrust::min< size_type> (num_blocks, max_blocks); 
# 406
return ::thrust::make_tuple(num_blocks, block_size); 
# 407
} 
# 408
}; 
# 411
}
# 412
}
# 413
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/choose_sizes.inl"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 28
namespace detail { 
# 32
template< class Closure> pair< int, int>  
# 36
choose_sizes(parallel_group< concurrent_group<> >  g, Closure) 
# 37
{ 
# 41
cuda_launcher< parallel_group< concurrent_group<> > , Closure>  launcher; 
# 43
return (launcher.choose_sizes(g.size(), (g.this_exec).size())); 
# 44
} 
# 47
}
# 50
template< class Function> pair< int, int>  
# 54
choose_sizes(parallel_group< concurrent_group<> >  g, Function f) 
# 55
{ 
# 56
return detail::choose_sizes(g, detail::make_closure(f)); 
# 57
} 
# 60
template< class Function, class Arg1> pair< int, int>  
# 64
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1) 
# 65
{ 
# 66
return detail::choose_sizes(g, detail::make_closure(f, arg1)); 
# 67
} 
# 70
template< class Function, class Arg1, class Arg2> pair< int, int>  
# 74
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2) 
# 75
{ 
# 76
return detail::choose_sizes(g, detail::make_closure(f, arg1, arg2)); 
# 77
} 
# 80
template< class Function, class Arg1, class Arg2, class Arg3> pair< int, int>  
# 84
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3) 
# 85
{ 
# 86
return detail::choose_sizes(g, detail::make_closure(f, arg1, arg2, arg3)); 
# 87
} 
# 90
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4> pair< int, int>  
# 94
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) 
# 95
{ 
# 96
return detail::choose_sizes(g, detail::make_closure(f, arg1, arg2, arg3, arg4)); 
# 97
} 
# 100
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> pair< int, int>  
# 104
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) 
# 105
{ 
# 106
return detail::choose_sizes(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5)); 
# 107
} 
# 110
template< class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> pair< int, int>  
# 114
choose_sizes(parallel_group< concurrent_group<> >  g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) 
# 115
{ 
# 116
return detail::choose_sizes(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6)); 
# 117
} 
# 120
}
# 121
}}}}
# 23 "/usr/local/cuda/include/thrust/detail/cstdint.h"
namespace thrust { 
# 25
namespace detail { 
# 50
typedef ::int8_t int8_t; 
# 51
typedef ::int16_t int16_t; 
# 52
typedef ::int32_t int32_t; 
# 53
typedef ::int64_t int64_t; 
# 54
typedef ::uint8_t uint8_t; 
# 55
typedef ::uint16_t uint16_t; 
# 56
typedef ::uint32_t uint32_t; 
# 57
typedef ::uint64_t uint64_t; 
# 63
template< int word_size = 8> struct divine_intptr_t; 
# 64
template< int word_size = 8> struct divine_uintptr_t; 
# 67
template<> struct divine_intptr_t< 4>  { typedef int32_t type; }; 
# 68
template<> struct divine_uintptr_t< 4>  { typedef uint32_t type; }; 
# 71
template<> struct divine_intptr_t<>  { typedef int64_t type; }; 
# 72
template<> struct divine_uintptr_t<>  { typedef uint64_t type; }; 
# 74
typedef divine_intptr_t<> ::type intptr_t; 
# 75
typedef divine_uintptr_t<> ::type uintptr_t; 
# 77
}
# 78
}
# 26 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/async.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 27
namespace bulk_ { 
# 31
template< class ExecutionGroup, class Function> future< void>  async(ExecutionGroup g, Function f); 
# 36
template< class ExecutionGroup, class Function, class Arg1> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1); 
# 41
template< class ExecutionGroup, class Function, class Arg1, class Arg2> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2); 
# 46
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3); 
# 51
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4); 
# 56
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5); 
# 61
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6); 
# 66
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7); 
# 71
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8); 
# 76
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9); 
# 81
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9, class Arg10> future< void>  async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10); 
# 86
}
# 87
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/async.inl"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 28
namespace detail { 
# 32
template< class ExecutionGroup, class Closure> future< void>  
# 34
async_in_stream(ExecutionGroup g, Closure c, cudaStream_t s, cudaEvent_t before_event) 
# 35
{ 
# 37
if (before_event != (0)) 
# 38
{ 
# 39
bulk_::detail::throw_on_error(cudaStreamWaitEvent(s, before_event, 0), "cudaStreamWaitEvent in async_in_stream"); 
# 40
}  
# 45
cuda_launcher< ExecutionGroup, Closure>  launcher; 
# 46
(launcher.launch(g, c, s)); 
# 48
return future_core_access::create(s, false); 
# 49
} 
# 52
template< class ExecutionGroup, class Closure> future< void>  
# 54
async(ExecutionGroup g, Closure c, cudaEvent_t before_event) 
# 55
{ 
# 56
cudaStream_t s; 
# 61
bulk_::detail::throw_on_error(cudaStreamCreate(&s), "cudaStreamCreate in bulk::detail::async"); 
# 68
if (before_event != (0)) 
# 69
{ 
# 70
bulk_::detail::throw_on_error(cudaStreamWaitEvent(s, before_event, 0), "cudaStreamWaitEvent in bulk::detail::async"); 
# 71
}  
# 76
cuda_launcher< ExecutionGroup, Closure>  launcher; 
# 77
(launcher.launch(g, c, s)); 
# 80
return future_core_access::create(s, true); 
# 81
} 
# 84
template< class ExecutionGroup, class Closure> future< void>  
# 86
async(ExecutionGroup g, Closure c) 
# 87
{ 
# 88
return detail::async_in_stream(g, c, 0, 0); 
# 89
} 
# 92
template< class ExecutionGroup, class Closure> future< void>  
# 94
async(async_launch< ExecutionGroup>  launch, Closure c) 
# 95
{ 
# 96
return ((launch.is_stream_valid())) ? detail::async_in_stream((launch.exec()), c, (launch.stream()), (launch.before_event())) : detail::async((launch.exec()), c, (launch.before_event())); 
# 99
} 
# 102
}
# 105
template< class ExecutionGroup, class Function> future< void>  
# 107
async(ExecutionGroup g, Function f) 
# 108
{ 
# 109
return detail::async(g, detail::make_closure(f)); 
# 110
} 
# 113
template< class ExecutionGroup, class Function, class Arg1> future< void>  
# 115
async(ExecutionGroup g, Function f, Arg1 arg1) 
# 116
{ 
# 117
return detail::async(g, detail::make_closure(f, arg1)); 
# 118
} 
# 121
template< class ExecutionGroup, class Function, class Arg1, class Arg2> future< void>  
# 123
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2) 
# 124
{ 
# 125
return detail::async(g, detail::make_closure(f, arg1, arg2)); 
# 126
} 
# 129
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3> future< void>  
# 131
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3) 
# 132
{ 
# 133
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3)); 
# 134
} 
# 137
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4> future< void>  
# 139
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) 
# 140
{ 
# 141
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4)); 
# 142
} 
# 145
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5> future< void>  
# 147
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) 
# 148
{ 
# 149
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5)); 
# 150
} 
# 153
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6> future< void>  
# 155
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) 
# 156
{ 
# 157
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6)); 
# 158
} 
# 161
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7> future< void>  
# 163
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) 
# 164
{ 
# 165
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7)); 
# 166
} 
# 169
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8> future< void>  
# 171
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) 
# 172
{ 
# 173
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)); 
# 174
} 
# 177
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9> future< void>  
# 179
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) 
# 180
{ 
# 181
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)); 
# 182
} 
# 185
template< class ExecutionGroup, class Function, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class Arg6, class Arg7, class Arg8, class Arg9, class Arg10> future< void>  
# 187
async(ExecutionGroup g, Function f, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) 
# 188
{ 
# 189
return detail::async(g, detail::make_closure(f, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)); 
# 190
} 
# 193
}
# 194
}}}}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/is_trivial_iterator.h"
namespace __gnu_cxx { 
# 27
template< class Iterator, class Container> class __normal_iterator; 
# 29
}
# 42
namespace thrust { 
# 44
namespace detail { 
# 48
template< class T> 
# 49
struct is_gnu_normal_iterator : public false_type { 
# 51
}; 
# 55
template< class Iterator, class Container> 
# 56
struct is_gnu_normal_iterator< __gnu_cxx::__normal_iterator< Iterator, Container> >  : public true_type { 
# 58
}; 
# 79
template< class T> 
# 80
struct is_trivial_iterator : public integral_constant< bool, (is_pointer< T> ::value | is_thrust_pointer< T> ::value) | is_gnu_normal_iterator< T> ::value>  { 
# 92
}; 
# 94
}
# 95
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/is_contiguous_iterator.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 23
namespace bulk_ { 
# 25
namespace detail { 
# 29
template< class T> 
# 30
struct is_contiguous_iterator : public thrust::detail::is_trivial_iterator< T>  { 
# 32
}; 
# 35
}
# 36
}
# 37
}}}}
# 26 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 27
namespace bulk_ { 
# 31
template< std::size_t bound, std::size_t 
# 32
grainsize, class 
# 33
RandomAccessIterator1, class 
# 34
Size, class 
# 35
RandomAccessIterator2> 
# 36
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 37
copy_n(const bounded< bound, agent< grainsize> >  &b, RandomAccessIterator1 
# 38
first, Size 
# 39
n, RandomAccessIterator2 
# 40
result) 
# 41
{int volatile ___ = 1;(void)b;(void)first;(void)n;(void)result;
# 64
::exit(___);}
#if 0
# 41
{ 
# 42
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 44
if (bound <= n) 
# 45
{ 
# 46
for (size_type i = (0); i < (b.bound()); ((++i), (++result)), (++first)) 
# 47
{ 
# 48
(*result) = (*first); 
# 49
}  
# 50
} else 
# 52
{ 
# 53
for (size_type i = (0); i < (b.bound()); (++i), (++first)) 
# 54
{ 
# 55
if (i < n) 
# 56
{ 
# 57
(*result) = (*first); 
# 58
++result; 
# 59
}  
# 60
}  
# 61
}  
# 63
return result; 
# 64
} 
#endif
# 68 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
namespace detail { 
# 72
template< class ConcurrentGroup, class 
# 73
RandomAccessIterator1, class 
# 74
Size, class 
# 75
RandomAccessIterator2> 
# 76
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 77
simple_copy_n(ConcurrentGroup &g, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result) 
# 78
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)result;
# 89
::exit(___);}
#if 0
# 78
{ 
# 79
for (Size i = ((g.this_exec).index()); i < n; i += (g.size())) 
# 82
{ 
# 83
(result[i]) = (first[i]); 
# 84
}  
# 86
(g.wait()); 
# 88
return result + n; 
# 89
} 
#endif
# 92 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
template< std::size_t size, std::size_t 
# 93
grainsize, class 
# 94
RandomAccessIterator1, class 
# 95
Size, class 
# 96
RandomAccessIterator2> 
# 97
__attribute((always_inline)) __attribute__((unused)) inline typename thrust::detail::enable_if< ((size * grainsize) > (0)), RandomAccessIterator2> ::type 
# 102
simple_copy_n(concurrent_group< agent< grainsize> , size>  &
# 105
g, RandomAccessIterator1 
# 106
first, Size n, RandomAccessIterator2 
# 107
result) 
# 108
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)result;
# 166
::exit(___);}
#if 0
# 108
{ 
# 112
typedef concurrent_group< agent< grainsize> , size>  group_type; 
# 114
RandomAccessIterator2 return_me = result + n; 
# 116
typedef typename concurrent_group< agent< grainsize> , size> ::size_type size_type; 
# 117
size_type chunk_size = (size * grainsize); 
# 119
size_type tid = ((g.this_exec).index()); 
# 122
if (chunk_size == n) 
# 123
{ 
# 125
first += tid; 
# 126
result += tid; 
# 128
for (size_type i = (0); i < grainsize; ((++i), (first += size)), (result += size)) 
# 129
{ 
# 130
(*result) = (*first); 
# 131
}  
# 132
} else 
# 134
{ 
# 136
for (RandomAccessIterator1 last = first + n; first < last; (first += chunk_size), (result += chunk_size)) 
# 139
{ 
# 141
if ((last - first) >= chunk_size) 
# 142
{ 
# 143
for (size_type i = (0); i < grainsize; ++i) 
# 144
{ 
# 145
size_type idx = (size * i) + tid; 
# 146
(result[idx]) = (first[idx]); 
# 147
}  
# 148
} else 
# 150
{ 
# 151
for (size_type i = (0); i < grainsize; ++i) 
# 152
{ 
# 153
size_type idx = (size * i) + tid; 
# 154
if (idx < (last - first)) 
# 155
{ 
# 156
(result[idx]) = (first[idx]); 
# 157
}  
# 158
}  
# 159
}  
# 160
}  
# 161
}  
# 163
(g.wait()); 
# 165
return return_me; 
# 166
} 
#endif
# 169 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
template< std::size_t size, std::size_t 
# 170
grainsize, class 
# 171
RandomAccessIterator1, class 
# 172
Size, class 
# 173
RandomAccessIterator2> 
# 174
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 175
copy_n(concurrent_group< agent< grainsize> , size>  &
# 178
g, RandomAccessIterator1 
# 179
first, Size 
# 180
n, RandomAccessIterator2 
# 181
result) 
# 182
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)result;
# 184
::exit(___);}
#if 0
# 182
{ 
# 183
return detail::simple_copy_n(g, first, n, result); 
# 184
} 
#endif
# 187 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
}
# 190
template< std::size_t groupsize, class 
# 191
Executor, class 
# 192
RandomAccessIterator1, class 
# 193
Size, class 
# 194
RandomAccessIterator2> 
# 195
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 197
copy_n(concurrent_group< Executor, groupsize>  &g, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result) 
# 198
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)result;
# 200
::exit(___);}
#if 0
# 198
{ 
# 199
return detail::copy_n(g, first, n, result); 
# 200
} 
#endif
# 203 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class Size, class RandomAccessIterator2> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize), RandomAccessIterator2> ::type 
# 209
copy_n(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 215
g, RandomAccessIterator1 
# 216
first, Size 
# 217
n, RandomAccessIterator2 
# 218
result) 
# 219
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)result;
# 276
::exit(___);}
#if 0
# 219
{ 
# 226
typedef bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  group_type; 
# 228
typedef typename bounded< bound, concurrent_group< agent< grainsize> , groupsize> > ::size_type size_type; 
# 230
size_type tid = ((g.this_exec).index()); 
# 232
typedef typename iterator_value< RandomAccessIterator1> ::type value_type; 
# 235
value_type stage[grainsize]; 
# 238
if ((groupsize * grainsize) <= n) 
# 239
{ 
# 240
for (size_type i = (0); i < grainsize; ++i) 
# 241
{ 
# 242
size_type src_idx = ((g.size()) * i) + tid; 
# 243
(stage[i]) = (first[src_idx]); 
# 244
}  
# 246
for (size_type i = (0); i < grainsize; ++i) 
# 247
{ 
# 248
size_type dst_idx = ((g.size()) * i) + tid; 
# 249
(result[dst_idx]) = (stage[i]); 
# 250
}  
# 251
} else 
# 253
{ 
# 254
for (size_type i = (0); i < grainsize; ++i) 
# 255
{ 
# 256
size_type src_idx = ((g.size()) * i) + tid; 
# 257
if (src_idx < n) 
# 258
{ 
# 259
(stage[i]) = (first[src_idx]); 
# 260
}  
# 261
}  
# 263
for (size_type i = (0); i < grainsize; ++i) 
# 264
{ 
# 265
size_type dst_idx = ((g.size()) * i) + tid; 
# 266
if (dst_idx < n) 
# 267
{ 
# 268
(result[dst_idx]) = (stage[i]); 
# 269
}  
# 270
}  
# 271
}  
# 273
(g.wait()); 
# 275
return result + thrust::min< Size> ((g.size()) * grainsize, n); 
# 276
} 
#endif
# 279 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/copy.hpp"
}
# 280
}}}}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/iterator/strided_iterator.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 24
namespace bulk_ { 
# 28
template< class Iterator, class 
# 29
Size = typename iterator_difference< Iterator> ::type> 
# 30
class strided_iterator : public iterator_adaptor< strided_iterator< Iterator> , Iterator>  { 
# 37
typedef ::thrust::iterator_adaptor< ::thrust::system::cuda::detail::bulk_::strided_iterator< Iterator> , Iterator>  super_t; 
# 40
public: typedef Size stride_type; 
# 43
strided_iterator() : super_t(), m_stride(1) 
# 45
{ } 
# 48
strided_iterator(const strided_iterator &other) : super_t(other), m_stride(other.m_stride) 
# 50
{ } 
# 53
strided_iterator(const Iterator &base, stride_type stride) : super_t(base), m_stride(stride) 
# 55
{ } 
# 58
stride_type stride() const 
# 59
{ 
# 60
return m_stride; 
# 61
} 
# 64
friend class ::thrust::iterator_core_access; 
# 67
private: void increment() 
# 68
{ 
# 69
super_t::base_reference() += stride(); 
# 70
} 
# 73
void decrement() 
# 74
{ 
# 75
super_t::base_reference() -= stride(); 
# 76
} 
# 79
void advance(typename ::thrust::iterator_adaptor< ::thrust::system::cuda::detail::bulk_::strided_iterator< Iterator> , Iterator> ::difference_type n) 
# 80
{ 
# 81
super_t::base_reference() += (n * stride()); 
# 82
} 
# 84
template< class OtherIterator> typename ::thrust::iterator_adaptor< ::thrust::system::cuda::detail::bulk_::strided_iterator< Iterator> , Iterator> ::difference_type 
# 86
distance_to(const ::thrust::system::cuda::detail::bulk_::strided_iterator< OtherIterator>  &other) const 
# 87
{ 
# 88
if ((other.base()) >= (this->base())) 
# 89
{ 
# 90
return (((other.base()) - (this->base())) + (stride() - 1)) / stride(); 
# 91
}  
# 93
return (((other.base()) - (this->base())) - (stride() - 1)) / stride(); 
# 94
} 
# 96
stride_type m_stride; 
# 97
}; 
# 100
template< class Iterator, class Size> strided_iterator< Iterator, Size>  
# 102
make_strided_iterator(Iterator iter, Size stride) 
# 103
{ 
# 104
return strided_iterator< Iterator, Size> (iter, stride); 
# 105
} 
# 108
}
# 109
}}}}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 29
namespace bulk_ { 
# 33
template< std::size_t bound, std::size_t 
# 34
grainsize, class 
# 35
RandomAccessIterator, class 
# 36
T, class 
# 37
BinaryFunction> 
# 38
__attribute((always_inline)) __attribute__((unused)) inline T 
# 39
reduce(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator 
# 40
first, RandomAccessIterator 
# 41
last, T 
# 42
init, BinaryFunction 
# 43
binary_op) 
# 44
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)init;(void)binary_op;
# 58
::exit(___);}
#if 0
# 44
{ 
# 45
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 47
size_type n = last - first; 
# 49
for (size_type i = (0); i < (exec.bound()); ++i) 
# 50
{ 
# 51
if (i < n) 
# 52
{ 
# 53
init = binary_op(init, first[i]); 
# 54
}  
# 55
}  
# 57
return init; 
# 58
} 
#endif
# 61 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
namespace detail { 
# 63
namespace reduce_detail { 
# 67
template< class ConcurrentGroup, class RandomAccessIterator, class Size, class T, class BinaryFunction> __attribute__((unused)) T 
# 68
destructive_reduce_n(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op) 
# 69
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)init;(void)binary_op;
# 103
::exit(___);}
#if 0
# 69
{ 
# 70
typedef int size_type; 
# 72
size_type tid = ((g.this_exec).index()); 
# 74
Size m = n; 
# 76
while (m > 1) 
# 77
{ 
# 78
Size half_m = m >> 1; 
# 80
if (tid < half_m) 
# 81
{ 
# 82
T old_val = first[tid]; 
# 84
(first[tid]) = binary_op(old_val, first[(m - tid) - 1]); 
# 85
}  
# 87
(g.wait()); 
# 89
m -= half_m; 
# 90
}  
# 92
(g.wait()); 
# 94
T result = init; 
# 95
if (n > 0) 
# 96
{ 
# 97
result = binary_op(result, first[0]); 
# 98
}  
# 100
(g.wait()); 
# 102
return result; 
# 103
} 
#endif
# 106 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
}
# 107
}
# 110
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator, class T, class BinaryFunction> __attribute__((unused)) T 
# 112
reduce(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator 
# 113
first, RandomAccessIterator 
# 114
last, T 
# 115
init, BinaryFunction 
# 116
binary_op) 
# 117
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)init;(void)binary_op;
# 219
::exit(___);}
#if 0
# 117
{ 
# 118
typedef int size_type; 
# 120
const size_type elements_per_group = (groupsize * grainsize); 
# 122
size_type tid = ((g.this_exec).index()); 
# 124
T this_sum; 
# 126
bool this_sum_defined = false; 
# 128
size_type n = last - first; 
# 133
for (size_type offset = 0; offset < n; (first += elements_per_group), (offset += elements_per_group)) 
# 134
{ 
# 135
size_type partition_size = thrust::min< int> (elements_per_group, last - first); 
# 137
typedef typename iterator_value< RandomAccessIterator> ::type input_type; 
# 140
input_type local_inputs[grainsize]; 
# 144
strided_iterator< RandomAccessIterator, int>  local_first = make_strided_iterator(first + tid, static_cast< size_type>(groupsize)); 
# 149
size_type local_size = 0; 
# 150
if (partition_size < elements_per_group) 
# 151
{ 
# 163
RandomAccessIterator iter = (local_first.base()); 
# 164
size_type index = tid; 
# 165
for (size_type i = 0; i < grainsize; ((++i), (index += groupsize)), (iter += groupsize)) 
# 166
{ 
# 167
if (index < partition_size) 
# 168
{ 
# 169
((local_inputs)[i]) = (*iter); 
# 170
++local_size; 
# 171
}  
# 172
}  
# 173
} else 
# 175
{ 
# 176
local_size = (grainsize); 
# 182
RandomAccessIterator iter = (local_first.base()); 
# 183
for (size_type i = 0; i < grainsize; (++i), (iter += groupsize)) 
# 184
{ 
# 185
((local_inputs)[i]) = (*iter); 
# 186
}  
# 187
}  
# 190
this_sum = (this_sum_defined ? bulk_::reduce(bulk_::bound< grainsize> ((g.this_exec)), local_inputs, (local_inputs) + local_size, this_sum, binary_op) : bulk_::reduce(bulk_::bound< grainsize - (1)> ((g.this_exec)), (local_inputs) + 1, (local_inputs) + local_size, (T)((local_inputs)[0]), binary_op)); 
# 194
this_sum_defined = true; 
# 195
}  
# 200
__attribute__((unused)) static uninitialized_array< T, groupsize>  buffer_impl; 
# 201
T *buffer = (buffer_impl.data()); 
# 204
if (this_sum_defined) 
# 205
{ 
# 206
(buffer[tid]) = this_sum; 
# 207
}  
# 209
(g.wait()); 
# 212
T result = detail::reduce_detail::destructive_reduce_n(g, buffer, thrust::min< int> (groupsize, n), init, binary_op); 
# 218
return result; 
# 219
} 
#endif
# 222 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
template< class RandomAccessIterator, class T, class BinaryFunction> __attribute__((unused)) T 
# 224
reduce(concurrent_group<>  &g, RandomAccessIterator 
# 225
first, RandomAccessIterator 
# 226
last, T 
# 227
init, BinaryFunction 
# 228
binary_op) 
# 229
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)init;(void)binary_op;
# 264
::exit(___);}
#if 0
# 229
{ 
# 230
typedef int size_type; 
# 232
size_type tid = (g.this_exec).index(); 
# 234
T this_sum; 
# 236
bool this_sum_defined = false; 
# 238
typename iterator_difference< RandomAccessIterator> ::type n = last - first; 
# 240
T *buffer = reinterpret_cast< T *>(bulk_::malloc(g, (g.size()) * sizeof(T))); 
# 242
for (size_type i = tid; i < n; i += g.size()) 
# 243
{ 
# 244
typedef typename iterator_value< RandomAccessIterator> ::type input_type; 
# 245
input_type x = first[i]; 
# 246
this_sum = (this_sum_defined ? binary_op(this_sum, x) : x); 
# 248
this_sum_defined = true; 
# 249
}  
# 251
if (this_sum_defined) 
# 252
{ 
# 253
(buffer[tid]) = this_sum; 
# 254
}  
# 256
g.wait(); 
# 259
T result = detail::reduce_detail::destructive_reduce_n(g, buffer, thrust::min< int> (g.size(), n), init, binary_op); 
# 261
bulk_::free(g, buffer); 
# 263
return result; 
# 264
} 
#endif
# 267 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce.hpp"
}
# 268
}}}}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 30
template< std::size_t bound, std::size_t 
# 31
grainsize, class 
# 32
RandomAccessIterator, class 
# 33
T, class 
# 34
BinaryFunction> 
# 35
__attribute((always_inline)) __attribute__((unused)) inline T 
# 36
accumulate(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator 
# 37
first, RandomAccessIterator 
# 38
last, T 
# 39
init, BinaryFunction 
# 40
binary_op) 
# 41
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)init;(void)binary_op;
# 55
::exit(___);}
#if 0
# 41
{ 
# 42
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 44
size_type n = last - first; 
# 46
for (size_type i = (0); i < (exec.bound()); ++i) 
# 47
{ 
# 48
if (i < n) 
# 49
{ 
# 50
init = binary_op(init, first[i]); 
# 51
}  
# 52
}  
# 54
return init; 
# 55
} 
#endif
# 58 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
namespace detail { 
# 60
namespace accumulate_detail { 
# 66
template< class ConcurrentGroup, class RandomAccessIterator, class Size, class T, class BinaryFunction> __attribute__((unused)) T 
# 67
destructive_accumulate_n(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op) 
# 68
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)init;(void)binary_op;
# 103
::exit(___);}
#if 0
# 68
{ 
# 69
typedef typename ConcurrentGroup::size_type size_type; 
# 71
size_type tid = ((g.this_exec).index()); 
# 73
T x = init; 
# 74
if (tid < n) 
# 75
{ 
# 76
x = (first[tid]); 
# 77
}  
# 79
(g.wait()); 
# 81
for (size_type offset = (1); offset < (g.size()); offset += offset) 
# 82
{ 
# 83
if ((tid >= offset) && ((tid - offset) < n)) 
# 84
{ 
# 85
x = binary_op(first[tid - offset], x); 
# 86
}  
# 88
(g.wait()); 
# 90
if (tid < n) 
# 91
{ 
# 92
(first[tid]) = x; 
# 93
}  
# 95
(g.wait()); 
# 96
}  
# 98
T result = binary_op(init, first[n - 1]); 
# 100
(g.wait()); 
# 102
return result; 
# 103
} 
#endif
# 106 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator, class T> 
# 107
struct buffer { 
# 109
typedef typename iterator_value< RandomAccessIterator> ::type value_type; 
# 112
union { 
# 113
uninitialized_array< typename iterator_value< RandomAccessIterator> ::type, groupsize * grainsize>  inputs; 
# 114
uninitialized_array< T, groupsize>  sums; 
# 115
}; 
# 116
}; 
# 119
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator, class T, class BinaryFunction> __attribute__((unused)) T 
# 121
accumulate(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator 
# 122
first, RandomAccessIterator 
# 123
last, T 
# 124
init, BinaryFunction 
# 125
binary_op) 
# 126
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)init;(void)binary_op;
# 193
::exit(___);}
#if 0
# 126
{ 
# 127
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 129
const size_type elements_per_group = (groupsize * grainsize); 
# 131
size_type tid = ((g.this_exec).index()); 
# 133
T sum = init; 
# 135
typename iterator_difference< RandomAccessIterator> ::type n = last - first; 
# 142
typedef accumulate_detail::buffer< groupsize, grainsize, RandomAccessIterator, T>  buffer_type; 
# 147
__attribute__((unused)) static uninitialized< accumulate_detail::buffer< groupsize, grainsize, RandomAccessIterator, T> >  buffer_impl; 
# 148
buffer_type *buffer = (&(buffer_impl.get())); 
# 151
for (; first < last; first += elements_per_group) 
# 152
{ 
# 155
size_type partition_size = thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (elements_per_group, last - first); 
# 158
bulk_::copy_n(g, first, partition_size, ((buffer->inputs).data())); 
# 160
T this_sum; 
# 161
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 163
size_type local_size = thrust::max< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (0, thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (grainsize, partition_size - (grainsize * tid))); 
# 165
if (local_size) 
# 166
{ 
# 167
this_sum = ((buffer->inputs)[local_offset]); 
# 168
this_sum = bulk_::accumulate(bound< grainsize - (1)> ((g.this_exec)), (((buffer->inputs).data()) + local_offset) + 1, (((buffer->inputs).data()) + local_offset) + local_size, this_sum, binary_op); 
# 173
}  
# 175
(g.wait()); 
# 177
if (local_size) 
# 178
{ 
# 179
((buffer->sums)[tid]) = this_sum; 
# 180
}  
# 182
(g.wait()); 
# 185
sum = accumulate_detail::destructive_accumulate_n(g, ((buffer->sums).data()), thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (groupsize, n), sum, binary_op); 
# 186
}  
# 192
return sum; 
# 193
} 
#endif
# 194 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
}
# 195
}
# 198
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator, class T, class BinaryFunction> __attribute__((unused)) T 
# 200
accumulate(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator 
# 201
first, RandomAccessIterator 
# 202
last, T 
# 203
init, BinaryFunction 
# 204
binary_op) 
# 205
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)init;(void)binary_op;
# 217
::exit(___);}
#if 0
# 205
{ 
# 207
if (thrust::detail::is_commutative< BinaryFunction> ::value) 
# 208
{ 
# 209
init = bulk_::reduce(g, first, last, init, binary_op); 
# 210
} else 
# 212
{ 
# 213
init = detail::accumulate_detail::accumulate(g, first, last, init, binary_op); 
# 214
}  
# 216
return init; 
# 217
} 
#endif
# 220 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/accumulate.hpp"
}
# 221
}}}}
# 21 "/usr/local/cuda/include/thrust/iterator/detail/any_assign.h"
namespace thrust { 
# 23
namespace detail { 
# 28
struct any_assign { 
# 30
any_assign() 
# 31
{ } 
# 33
template< class T> 
# 34
any_assign(T) 
# 35
{ } 
# 37
template< class T> any_assign &
# 39
operator=(T) 
# 40
{ 
# 41
if (0) 
# 42
{ 
# 44
int *x = (0); 
# 45
(*x) = 13; 
# 46
}  
# 48
return *this; 
# 49
} 
# 50
}; 
# 53
}
# 54
}
# 25 "/usr/local/cuda/include/thrust/detail/type_traits/iterator/is_output_iterator.h"
namespace thrust { 
# 28
namespace detail { 
# 32
template< class T> 
# 33
struct is_void_like : public or_< is_void< T> , is_same< T, any_assign> >  { 
# 38
}; 
# 41
template< class T> 
# 42
struct lazy_is_void_like : public is_void_like< typename T::type>  { 
# 44
}; 
# 53
template< class T> 
# 54
struct is_output_iterator : public eval_if< is_metafunction_defined< iterator_value< T> > ::value, lazy_is_void_like< iterator_value< T> > , integral_constant< bool, true> > ::type { 
# 61
}; 
# 63
}
# 65
}
# 30 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 31
namespace bulk_ { 
# 35
template< std::size_t bound, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class T, class BinaryFunction> 
# 36
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 38
inclusive_scan(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator1 
# 39
first, RandomAccessIterator1 
# 40
last, RandomAccessIterator2 
# 41
result, T 
# 42
init, BinaryFunction 
# 43
binary_op) 
# 44
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 55
::exit(___);}
#if 0
# 44
{ 
# 45
for (int i = 0; i < (exec.bound()); ++i) 
# 46
{ 
# 47
if ((first + i) < last) 
# 48
{ 
# 49
init = binary_op(init, first[i]); 
# 50
(result[i]) = init; 
# 51
}  
# 52
}  
# 54
return result + (last - first); 
# 55
} 
#endif
# 58 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t bound, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class T, class BinaryFunction> 
# 59
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator2 
# 61
exclusive_scan(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator1 
# 62
first, RandomAccessIterator1 
# 63
last, RandomAccessIterator2 
# 64
result, T 
# 65
init, BinaryFunction 
# 66
binary_op) 
# 67
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 78
::exit(___);}
#if 0
# 67
{ 
# 68
for (int i = 0; i < (exec.bound()); ++i) 
# 69
{ 
# 70
if ((first + i) < last) 
# 71
{ 
# 72
(result[i]) = init; 
# 73
init = binary_op(init, first[i]); 
# 74
}  
# 75
}  
# 77
return result + (last - first); 
# 78
} 
#endif
# 81 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
namespace detail { 
# 83
namespace scan_detail { 
# 87
template< class InputIterator, class OutputIterator, class BinaryFunction> 
# 88
struct scan_intermediate : public thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > >  { 
# 98
}; 
# 101
template< class ConcurrentGroup, class RandomAccessIterator, class T, class BinaryFunction> __attribute__((unused)) T 
# 102
inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, T init, BinaryFunction binary_op) 
# 103
{int volatile ___ = 1;(void)g;(void)first;(void)init;(void)binary_op;
# 149
::exit(___);}
#if 0
# 103
{ 
# 104
typedef typename ConcurrentGroup::size_type size_type; 
# 106
size_type tid = ((g.this_exec).index()); 
# 108
if (tid == 0) 
# 109
{ 
# 110
(first[0]) = binary_op(init, first[0]); 
# 111
}  
# 113
T x = first[tid]; 
# 115
(g.wait()); 
# 117
for (size_type offset = (1); offset < (g.size()); offset += offset) 
# 118
{ 
# 119
if (tid >= offset) 
# 120
{ 
# 121
x = binary_op(first[tid - offset], x); 
# 122
}  
# 124
(g.wait()); 
# 126
(first[tid]) = x; 
# 128
(g.wait()); 
# 129
}  
# 131
T result = first[(g.size()) - 1]; 
# 133
if (tid == 0) 
# 134
{ 
# 135
x = init; 
# 136
} else 
# 138
{ 
# 139
x = (first[tid - 1]); 
# 140
}  
# 142
(g.wait()); 
# 144
(first[tid]) = x; 
# 146
(g.wait()); 
# 148
return result; 
# 149
} 
#endif
# 152 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< class ConcurrentGroup, class RandomAccessIterator, class Size, class T, class BinaryFunction> __attribute__((unused)) T 
# 153
small_inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op) 
# 154
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)init;(void)binary_op;
# 209
::exit(___);}
#if 0
# 154
{ 
# 155
typedef typename ConcurrentGroup::size_type size_type; 
# 157
size_type tid = ((g.this_exec).index()); 
# 159
if (tid == 0) 
# 160
{ 
# 161
(first[0]) = binary_op(init, first[0]); 
# 162
}  
# 164
T x = (tid < n) ? first[tid] : init; 
# 166
(g.wait()); 
# 168
for (size_type offset = (1); offset < (g.size()); offset += offset) 
# 169
{ 
# 170
if ((tid >= offset) && ((tid - offset) < n)) 
# 171
{ 
# 172
x = binary_op(first[tid - offset], x); 
# 173
}  
# 175
(g.wait()); 
# 177
if (tid < n) 
# 178
{ 
# 179
(first[tid]) = x; 
# 180
}  
# 182
(g.wait()); 
# 183
}  
# 185
T result = first[n - 1]; 
# 187
if (tid < n) 
# 188
{ 
# 189
if (tid == 0) 
# 190
{ 
# 191
x = init; 
# 192
} else 
# 194
{ 
# 195
x = (first[tid - 1]); 
# 196
}  
# 197
}  
# 199
(g.wait()); 
# 201
if (tid < n) 
# 202
{ 
# 203
(first[tid]) = x; 
# 204
}  
# 206
(g.wait()); 
# 208
return result; 
# 209
} 
#endif
# 213 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< class ConcurrentGroup, class RandomAccessIterator, class Size, class T, class BinaryFunction> __attribute__((unused)) T 
# 214
bounded_inplace_exclusive_scan(ConcurrentGroup &g, RandomAccessIterator first, Size n, T init, BinaryFunction binary_op) 
# 215
{int volatile ___ = 1;(void)g;(void)first;(void)n;(void)init;(void)binary_op;
# 219
::exit(___);}
#if 0
# 215
{ 
# 216
return (n == (g.size())) ? inplace_exclusive_scan(g, first, init, binary_op) : small_inplace_exclusive_scan(g, first, n, init, binary_op); 
# 219
} 
#endif
# 222 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< bool inclusive, std::size_t 
# 223
bound, std::size_t groupsize, std::size_t grainsize, class 
# 224
RandomAccessIterator1, class 
# 225
RandomAccessIterator2, class 
# 226
T, class 
# 227
BinaryFunction> __attribute__((unused)) T 
# 235
scan(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 238
g, RandomAccessIterator1 
# 239
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 240
result, T 
# 241
carry_in, BinaryFunction 
# 242
binary_op) 
# 243
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)carry_in;(void)binary_op;
# 313
::exit(___);}
#if 0
# 243
{ 
# 244
typedef typename iterator_value< RandomAccessIterator1> ::type input_type; 
# 250
typedef typename scan_intermediate< RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::type intermediate_type; 
# 255
typedef typename bounded< bound, concurrent_group< agent< grainsize> , groupsize> > ::size_type size_type; 
# 257
size_type tid = ((g.this_exec).index()); 
# 258
size_type n = last - first; 
# 261
input_type local_inputs[grainsize]; 
# 263
size_type local_offset = grainsize * tid; 
# 264
size_type local_size = thrust::max< typename bounded< bound, concurrent_group< agent< grainsize> , groupsize> > ::size_type> (0, thrust::min< typename bounded< bound, concurrent_group< agent< grainsize> , groupsize> > ::size_type> (grainsize, n - (grainsize * tid))); 
# 266
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), first + local_offset, local_size, local_inputs); 
# 269
intermediate_type x; 
# 271
if (local_size) 
# 272
{ 
# 273
x = ((local_inputs)[0]); 
# 274
x = bulk_::accumulate(bulk_::bound< grainsize - (1)> ((g.this_exec)), (local_inputs) + 1, local_inputs + local_size, x, binary_op); 
# 275
}  
# 277
(g.wait()); 
# 279
if (local_size) 
# 280
{ 
# 281
(result[tid]) = x; 
# 282
}  
# 284
(g.wait()); 
# 287
const size_type spine_n = (n >= ((g.size()) * ((g.this_exec).grainsize()))) ? (g.size()) : (((n + ((g.this_exec).grainsize())) - 1) / ((g.this_exec).grainsize())); 
# 292
carry_in = bounded_inplace_exclusive_scan(g, result, spine_n, carry_in, binary_op); 
# 294
if (local_size) 
# 295
{ 
# 296
x = (result[tid]); 
# 297
}  
# 299
(g.wait()); 
# 301
if (inclusive) 
# 302
{ 
# 303
bulk_::inclusive_scan(bulk_::bound< grainsize> ((g.this_exec)), local_inputs, local_inputs + local_size, result + local_offset, x, binary_op); 
# 304
} else 
# 306
{ 
# 307
bulk_::exclusive_scan(bulk_::bound< grainsize> ((g.this_exec)), local_inputs, local_inputs + local_size, result + local_offset, x, binary_op); 
# 308
}  
# 310
(g.wait()); 
# 312
return carry_in; 
# 313
} 
#endif
# 316 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class BinaryFunction> 
# 317
struct scan_buffer { 
# 319
typedef typename iterator_value< RandomAccessIterator1> ::type input_type; 
# 325
typedef typename scan_intermediate< RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::type intermediate_type; 
# 328
union { 
# 329
uninitialized_array< typename iterator_value< RandomAccessIterator1> ::type, groupsize * grainsize>  inputs; 
# 330
uninitialized_array< typename scan_intermediate< RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::type, groupsize * grainsize>  results; 
# 331
}; 
# 332
}; 
# 335
template< bool inclusive, std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class T, class BinaryFunction> __attribute__((unused)) void 
# 336
scan_with_buffer(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator1 
# 337
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 338
result, T 
# 339
carry_in, BinaryFunction 
# 340
binary_op, scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction>  &
# 341
buffer) 
# 342
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)carry_in;(void)binary_op;(void)buffer;
# 386
::exit(___);}
#if 0
# 342
{ 
# 349
typedef scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction>  buffer_type; 
# 351
typedef typename scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::input_type input_type; 
# 352
typedef typename scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::intermediate_type intermediate_type; 
# 357
union { 
# 358
input_type *inputs; 
# 359
intermediate_type *results; 
# 360
} stage; 
# 362
(stage.inputs) = ((buffer.inputs).data()); 
# 364
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 366
size_type tid = ((g.this_exec).index()); 
# 368
const size_type elements_per_group = (groupsize * grainsize); 
# 370
for (; first < last; (first += elements_per_group), (result += elements_per_group)) 
# 371
{ 
# 372
size_type partition_size = thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (elements_per_group, last - first); 
# 375
bulk_::copy_n(g, first, partition_size, stage.inputs); 
# 377
carry_in = scan< inclusive> (bulk_::bound< elements_per_group> (g), stage.inputs, (stage.inputs) + partition_size, stage.results, carry_in, binary_op); 
# 384
bulk_::copy_n(g, stage.results, partition_size, result); 
# 385
}  
# 386
} 
#endif
# 389 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
}
# 390
}
# 393
template< std::size_t bound, std::size_t 
# 394
groupsize, std::size_t 
# 395
grainsize, class 
# 396
RandomAccessIterator1, class 
# 397
RandomAccessIterator2, class 
# 398
T, class 
# 399
BinaryFunction> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize), RandomAccessIterator2> ::type 
# 405
inclusive_scan(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 408
g, RandomAccessIterator1 
# 409
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 410
result, T 
# 411
carry_in, BinaryFunction 
# 412
binary_op) 
# 413
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)carry_in;(void)binary_op;
# 416
::exit(___);}
#if 0
# 413
{ 
# 414
detail::scan_detail::scan< true> (g, first, last, result, carry_in, binary_op); 
# 415
return result + (last - first); 
# 416
} 
#endif
# 419 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t bound, std::size_t 
# 420
groupsize, std::size_t 
# 421
grainsize, class 
# 422
RandomAccessIterator1, class 
# 423
RandomAccessIterator2, class 
# 424
BinaryFunction> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize), RandomAccessIterator2> ::type 
# 430
inclusive_scan(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 433
g, RandomAccessIterator1 
# 434
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 435
result, BinaryFunction 
# 436
binary_op) 
# 437
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)binary_op;
# 454
::exit(___);}
#if 0
# 437
{ 
# 438
if ((bound > (0)) && (first < last)) 
# 439
{ 
# 440
typename iterator_value< RandomAccessIterator1> ::type init = *first; 
# 443
(g.wait()); 
# 445
if (((g.this_exec).index()) == 0) 
# 446
{ 
# 447
(*result) = init; 
# 448
}  
# 450
detail::scan_detail::scan< true> (g, first + 1, last, result + 1, init, binary_op); 
# 451
}  
# 453
return result + (last - first); 
# 454
} 
#endif
# 457 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t groupsize, std::size_t 
# 458
grainsize, class 
# 459
RandomAccessIterator1, class 
# 460
RandomAccessIterator2, class 
# 461
T, class 
# 462
BinaryFunction> __attribute__((unused)) void 
# 463
inclusive_scan(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator1 
# 464
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 465
result, T 
# 466
init, BinaryFunction 
# 467
binary_op) 
# 468
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 488
::exit(___);}
#if 0
# 468
{ 
# 469
typedef detail::scan_detail::scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction>  buffer_type; 
# 485
__attribute__((unused)) static uninitialized< detail::scan_detail::scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> >  buffer; 
# 486
detail::scan_detail::scan_with_buffer< true> (g, first, last, result, init, binary_op, (buffer.get())); 
# 488
} 
#endif
# 491 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t size, std::size_t 
# 492
grainsize, class 
# 493
RandomAccessIterator1, class 
# 494
RandomAccessIterator2, class 
# 495
BinaryFunction> __attribute__((unused)) RandomAccessIterator2 
# 498
inclusive_scan(concurrent_group< agent< grainsize> , size>  &this_group, RandomAccessIterator1 
# 499
first, RandomAccessIterator1 
# 500
last, RandomAccessIterator2 
# 501
result, BinaryFunction 
# 502
binary_op) 
# 503
{int volatile ___ = 1;(void)this_group;(void)first;(void)last;(void)result;(void)binary_op;
# 528
::exit(___);}
#if 0
# 503
{ 
# 504
if (first < last) 
# 505
{ 
# 514
typename detail::scan_detail::scan_intermediate< RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> ::type init = *first; 
# 517
(this_group.wait()); 
# 519
if (((this_group.this_exec).index()) == 0) 
# 520
{ 
# 521
(*result) = init; 
# 522
}  
# 524
bulk_::inclusive_scan(this_group, first + 1, last, result + 1, init, binary_op); 
# 525
}  
# 527
return result + (last - first); 
# 528
} 
#endif
# 531 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class 
# 532
RandomAccessIterator1, class 
# 533
RandomAccessIterator2, class 
# 534
T, class 
# 535
BinaryFunction> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize), RandomAccessIterator2> ::type 
# 541
exclusive_scan(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 544
g, RandomAccessIterator1 
# 545
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 546
result, T 
# 547
carry_in, BinaryFunction 
# 548
binary_op) 
# 549
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)carry_in;(void)binary_op;
# 552
::exit(___);}
#if 0
# 549
{ 
# 550
detail::scan_detail::scan< true> (g, first, last, result, carry_in, binary_op); 
# 551
return result + (last - first); 
# 552
} 
#endif
# 555 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
template< std::size_t groupsize, std::size_t 
# 556
grainsize, class 
# 557
RandomAccessIterator1, class 
# 558
RandomAccessIterator2, class 
# 559
T, class 
# 560
BinaryFunction> __attribute__((unused)) typename thrust::detail::enable_if< (groupsize > (0)), RandomAccessIterator2> ::type 
# 566
exclusive_scan(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator1 
# 567
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 568
result, T 
# 569
init, BinaryFunction 
# 570
binary_op) 
# 571
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 593
::exit(___);}
#if 0
# 571
{ 
# 572
typedef detail::scan_detail::scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction>  buffer_type; 
# 588
__attribute__((unused)) static uninitialized< detail::scan_detail::scan_buffer< groupsize, grainsize, RandomAccessIterator1, RandomAccessIterator2, BinaryFunction> >  buffer; 
# 589
detail::scan_detail::scan_with_buffer< false> (g, first, last, result, init, binary_op, (buffer.get())); 
# 592
return result + (last - first); 
# 593
} 
#endif
# 596 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scan.hpp"
}
# 597
}}}}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/permutation_iterator_base.h"
namespace thrust { 
# 27
template< class , class > class permutation_iterator; 
# 30
namespace detail { 
# 33
template< class ElementIterator, class 
# 34
IndexIterator> 
# 35
struct permutation_iterator_base { 
# 37
typedef typename iterator_system< ElementIterator> ::type System1; 
# 38
typedef typename iterator_system< IndexIterator> ::type System2; 
# 47
typedef iterator_adaptor< permutation_iterator< ElementIterator, IndexIterator> , IndexIterator, typename iterator_value< ElementIterator> ::type, typename minimum_system< typename iterator_system< ElementIterator> ::type, typename iterator_system< IndexIterator> ::type> ::type, use_default, typename iterator_reference< ElementIterator> ::type>  type; 
# 48
}; 
# 50
}
# 52
}
# 40 "/usr/local/cuda/include/thrust/iterator/permutation_iterator.h"
namespace thrust { 
# 118
template< class ElementIterator, class 
# 119
IndexIterator> 
# 120
class permutation_iterator : public detail::permutation_iterator_base< ElementIterator, IndexIterator> ::type { 
# 129
typedef typename ::thrust::detail::permutation_iterator_base< ElementIterator, IndexIterator> ::type super_t; 
# 131
friend class iterator_core_access; 
# 140
public: permutation_iterator() : m_element_iterator() 
# 141
{ } 
# 151
explicit permutation_iterator(ElementIterator x, IndexIterator y) : super_t(y), m_element_iterator(x) 
# 152
{ } 
# 157
template< class OtherElementIterator, class OtherIndexIterator> 
# 159
permutation_iterator(const ::thrust::permutation_iterator< OtherElementIterator, OtherIndexIterator>  &r, typename ::thrust::detail::enable_if_convertible< OtherElementIterator, ElementIterator> ::type * = 0, typename ::thrust::detail::enable_if_convertible< OtherIndexIterator, IndexIterator> ::type * = 0) : super_t((r.base())), m_element_iterator((r.m_element_iterator)) 
# 165
{ } 
# 172
private: typename ::thrust::detail::permutation_iterator_base< ElementIterator, IndexIterator> ::type::reference dereference() const 
# 173
{ 
# 174
return *((m_element_iterator) + (*(this->base()))); 
# 175
} 
# 178
template< class , class > friend class permutation_iterator; 
# 180
ElementIterator m_element_iterator; 
# 183
}; 
# 196
template< class ElementIterator, class IndexIterator> permutation_iterator< ElementIterator, IndexIterator>  
# 198
make_permutation_iterator(ElementIterator e, IndexIterator i) 
# 199
{ 
# 200
return permutation_iterator< ElementIterator, IndexIterator> (e, i); 
# 201
} 
# 209
}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 26
namespace bulk_ { 
# 31
template< std::size_t bound, std::size_t 
# 32
grainsize, class 
# 33
RandomAccessIterator1, class 
# 34
RandomAccessIterator2, class 
# 35
RandomAccessIterator3> 
# 36
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator3 
# 37
gather(const bounded< bound, agent< grainsize> >  &, RandomAccessIterator1 
# 38
map_first, RandomAccessIterator1 
# 39
map_last, RandomAccessIterator2 
# 40
input_first, RandomAccessIterator3 
# 41
result) 
# 42
{int volatile ___ = 1;(void)map_first;(void)map_last;(void)input_first;(void)result;
# 66
::exit(___);}
#if 0
# 42
{ 
# 43
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 45
size_type n = map_last - map_first; 
# 47
if (bound <= n) 
# 48
{ 
# 49
for (size_type i = (0); i < bound; ++i) 
# 50
{ 
# 51
(result[i]) = (input_first[map_first[i]]); 
# 52
}  
# 53
} else 
# 55
{ 
# 56
for (size_type i = (0); i < bound; ++i) 
# 57
{ 
# 58
if (i < n) 
# 59
{ 
# 60
(result[i]) = (input_first[map_first[i]]); 
# 61
}  
# 62
}  
# 63
}  
# 65
return result + n; 
# 66
} 
#endif
# 69 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp"
template< class ExecutionGroup, class RandomAccessIterator1, class RandomAccessIterator2, class RandomAccessIterator3> 
# 70
__attribute((always_inline)) __attribute__((unused)) inline RandomAccessIterator3 
# 71
gather(ExecutionGroup &g, RandomAccessIterator1 
# 72
map_first, RandomAccessIterator1 
# 73
map_last, RandomAccessIterator2 
# 74
input_first, RandomAccessIterator3 
# 75
result) 
# 76
{int volatile ___ = 1;(void)g;(void)map_first;(void)map_last;(void)input_first;(void)result;
# 81
::exit(___);}
#if 0
# 76
{ 
# 77
return bulk_::copy_n(g, thrust::make_permutation_iterator(input_first, map_first), map_last - map_first, result); 
# 81
} 
#endif
# 84 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/gather.hpp"
}
# 85
}}}}
# 158 "/usr/include/c++/5/limits" 3
namespace std __attribute((__visibility__("default"))) { 
# 167
enum float_round_style { 
# 169
round_indeterminate = (-1), 
# 170
round_toward_zero = 0, 
# 171
round_to_nearest, 
# 172
round_toward_infinity, 
# 173
round_toward_neg_infinity
# 174
}; 
# 182
enum float_denorm_style { 
# 185
denorm_indeterminate = (-1), 
# 187
denorm_absent = 0, 
# 189
denorm_present
# 190
}; 
# 202
struct __numeric_limits_base { 
# 206
static const bool is_specialized = false; 
# 211
static const int digits = 0; 
# 214
static const int digits10 = 0; 
# 223
static const bool is_signed = false; 
# 226
static const bool is_integer = false; 
# 231
static const bool is_exact = false; 
# 235
static const int radix = 0; 
# 239
static const int min_exponent = 0; 
# 243
static const int min_exponent10 = 0; 
# 248
static const int max_exponent = 0; 
# 252
static const int max_exponent10 = 0; 
# 255
static const bool has_infinity = false; 
# 259
static const bool has_quiet_NaN = false; 
# 263
static const bool has_signaling_NaN = false; 
# 266
static const float_denorm_style has_denorm = denorm_absent; 
# 270
static const bool has_denorm_loss = false; 
# 274
static const bool is_iec559 = false; 
# 279
static const bool is_bounded = false; 
# 288
static const bool is_modulo = false; 
# 291
static const bool traps = false; 
# 294
static const bool tinyness_before = false; 
# 299
static const float_round_style round_style = round_toward_zero; 
# 301
}; 
# 314
template< class _Tp> 
# 315
struct numeric_limits : public __numeric_limits_base { 
# 320
static _Tp min() throw() { return _Tp(); } 
# 324
static _Tp max() throw() { return _Tp(); } 
# 336
static _Tp epsilon() throw() { return _Tp(); } 
# 340
static _Tp round_error() throw() { return _Tp(); } 
# 344
static _Tp infinity() throw() { return _Tp(); } 
# 349
static _Tp quiet_NaN() throw() { return _Tp(); } 
# 354
static _Tp signaling_NaN() throw() { return _Tp(); } 
# 360
static _Tp denorm_min() throw() { return _Tp(); } 
# 361
}; 
# 382
template<> struct numeric_limits< bool>  { 
# 384
static const bool is_specialized = true; 
# 387
static bool min() throw() { return false; } 
# 390
static bool max() throw() { return true; } 
# 396
static const int digits = 1; 
# 397
static const int digits10 = 0; 
# 401
static const bool is_signed = false; 
# 402
static const bool is_integer = true; 
# 403
static const bool is_exact = true; 
# 404
static const int radix = 2; 
# 407
static bool epsilon() throw() { return false; } 
# 410
static bool round_error() throw() { return false; } 
# 412
static const int min_exponent = 0; 
# 413
static const int min_exponent10 = 0; 
# 414
static const int max_exponent = 0; 
# 415
static const int max_exponent10 = 0; 
# 417
static const bool has_infinity = false; 
# 418
static const bool has_quiet_NaN = false; 
# 419
static const bool has_signaling_NaN = false; 
# 420
static const float_denorm_style has_denorm = denorm_absent; 
# 422
static const bool has_denorm_loss = false; 
# 425
static bool infinity() throw() { return false; } 
# 428
static bool quiet_NaN() throw() { return false; } 
# 431
static bool signaling_NaN() throw() { return false; } 
# 434
static bool denorm_min() throw() { return false; } 
# 436
static const bool is_iec559 = false; 
# 437
static const bool is_bounded = true; 
# 438
static const bool is_modulo = false; 
# 443
static const bool traps = true; 
# 444
static const bool tinyness_before = false; 
# 445
static const float_round_style round_style = round_toward_zero; 
# 447
}; 
# 451
template<> struct numeric_limits< char>  { 
# 453
static const bool is_specialized = true; 
# 456
static char min() throw() { return (((char)(-1)) < 0) ? (-((((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0)))) - 1 : ((char)0); } 
# 459
static char max() throw() { return (((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0)); } 
# 466
static const int digits = ((sizeof(char) * (8)) - (((char)(-1)) < 0)); 
# 467
static const int digits10 = ((((sizeof(char) * (8)) - (((char)(-1)) < 0)) * (643L)) / (2136)); 
# 471
static const bool is_signed = (((char)(-1)) < 0); 
# 472
static const bool is_integer = true; 
# 473
static const bool is_exact = true; 
# 474
static const int radix = 2; 
# 477
static char epsilon() throw() { return 0; } 
# 480
static char round_error() throw() { return 0; } 
# 482
static const int min_exponent = 0; 
# 483
static const int min_exponent10 = 0; 
# 484
static const int max_exponent = 0; 
# 485
static const int max_exponent10 = 0; 
# 487
static const bool has_infinity = false; 
# 488
static const bool has_quiet_NaN = false; 
# 489
static const bool has_signaling_NaN = false; 
# 490
static const float_denorm_style has_denorm = denorm_absent; 
# 492
static const bool has_denorm_loss = false; 
# 495
static char infinity() throw() { return ((char)0); } 
# 498
static char quiet_NaN() throw() { return ((char)0); } 
# 501
static char signaling_NaN() throw() { return ((char)0); } 
# 504
static char denorm_min() throw() { return static_cast< char>(0); } 
# 506
static const bool is_iec559 = false; 
# 507
static const bool is_bounded = true; 
# 508
static const bool is_modulo = (!is_signed); 
# 510
static const bool traps = true; 
# 511
static const bool tinyness_before = false; 
# 512
static const float_round_style round_style = round_toward_zero; 
# 514
}; 
# 518
template<> struct numeric_limits< signed char>  { 
# 520
static const bool is_specialized = true; 
# 523
static signed char min() throw() { return (-127) - 1; } 
# 526
static signed char max() throw() { return 127; } 
# 533
static const int digits = ((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)); 
# 534
static const int digits10 = ((((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)) * (643L)) / (2136)); 
# 539
static const bool is_signed = true; 
# 540
static const bool is_integer = true; 
# 541
static const bool is_exact = true; 
# 542
static const int radix = 2; 
# 545
static signed char epsilon() throw() { return 0; } 
# 548
static signed char round_error() throw() { return 0; } 
# 550
static const int min_exponent = 0; 
# 551
static const int min_exponent10 = 0; 
# 552
static const int max_exponent = 0; 
# 553
static const int max_exponent10 = 0; 
# 555
static const bool has_infinity = false; 
# 556
static const bool has_quiet_NaN = false; 
# 557
static const bool has_signaling_NaN = false; 
# 558
static const float_denorm_style has_denorm = denorm_absent; 
# 560
static const bool has_denorm_loss = false; 
# 563
static signed char infinity() throw() { return static_cast< signed char>(0); } 
# 566
static signed char quiet_NaN() throw() { return static_cast< signed char>(0); } 
# 569
static signed char signaling_NaN() throw() 
# 570
{ return static_cast< signed char>(0); } 
# 573
static signed char denorm_min() throw() 
# 574
{ return static_cast< signed char>(0); } 
# 576
static const bool is_iec559 = false; 
# 577
static const bool is_bounded = true; 
# 578
static const bool is_modulo = false; 
# 580
static const bool traps = true; 
# 581
static const bool tinyness_before = false; 
# 582
static const float_round_style round_style = round_toward_zero; 
# 584
}; 
# 588
template<> struct numeric_limits< unsigned char>  { 
# 590
static const bool is_specialized = true; 
# 593
static unsigned char min() throw() { return 0; } 
# 596
static unsigned char max() throw() { return ((127) * 2U) + (1); } 
# 603
static const int digits = ((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)); 
# 605
static const int digits10 = ((((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)) * (643L)) / (2136)); 
# 610
static const bool is_signed = false; 
# 611
static const bool is_integer = true; 
# 612
static const bool is_exact = true; 
# 613
static const int radix = 2; 
# 616
static unsigned char epsilon() throw() { return 0; } 
# 619
static unsigned char round_error() throw() { return 0; } 
# 621
static const int min_exponent = 0; 
# 622
static const int min_exponent10 = 0; 
# 623
static const int max_exponent = 0; 
# 624
static const int max_exponent10 = 0; 
# 626
static const bool has_infinity = false; 
# 627
static const bool has_quiet_NaN = false; 
# 628
static const bool has_signaling_NaN = false; 
# 629
static const float_denorm_style has_denorm = denorm_absent; 
# 631
static const bool has_denorm_loss = false; 
# 634
static unsigned char infinity() throw() 
# 635
{ return static_cast< unsigned char>(0); } 
# 638
static unsigned char quiet_NaN() throw() 
# 639
{ return static_cast< unsigned char>(0); } 
# 642
static unsigned char signaling_NaN() throw() 
# 643
{ return static_cast< unsigned char>(0); } 
# 646
static unsigned char denorm_min() throw() 
# 647
{ return static_cast< unsigned char>(0); } 
# 649
static const bool is_iec559 = false; 
# 650
static const bool is_bounded = true; 
# 651
static const bool is_modulo = true; 
# 653
static const bool traps = true; 
# 654
static const bool tinyness_before = false; 
# 655
static const float_round_style round_style = round_toward_zero; 
# 657
}; 
# 661
template<> struct numeric_limits< wchar_t>  { 
# 663
static const bool is_specialized = true; 
# 666
static wchar_t min() throw() { return (((wchar_t)(-1)) < 0) ? (-((((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0)))) - 1 : ((wchar_t)0); } 
# 669
static wchar_t max() throw() { return (((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0)); } 
# 676
static const int digits = ((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)); 
# 677
static const int digits10 = ((((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) * (643L)) / (2136)); 
# 682
static const bool is_signed = (((wchar_t)(-1)) < 0); 
# 683
static const bool is_integer = true; 
# 684
static const bool is_exact = true; 
# 685
static const int radix = 2; 
# 688
static wchar_t epsilon() throw() { return 0; } 
# 691
static wchar_t round_error() throw() { return 0; } 
# 693
static const int min_exponent = 0; 
# 694
static const int min_exponent10 = 0; 
# 695
static const int max_exponent = 0; 
# 696
static const int max_exponent10 = 0; 
# 698
static const bool has_infinity = false; 
# 699
static const bool has_quiet_NaN = false; 
# 700
static const bool has_signaling_NaN = false; 
# 701
static const float_denorm_style has_denorm = denorm_absent; 
# 703
static const bool has_denorm_loss = false; 
# 706
static wchar_t infinity() throw() { return ((wchar_t)0); } 
# 709
static wchar_t quiet_NaN() throw() { return ((wchar_t)0); } 
# 712
static wchar_t signaling_NaN() throw() { return ((wchar_t)0); } 
# 715
static wchar_t denorm_min() throw() { return ((wchar_t)0); } 
# 717
static const bool is_iec559 = false; 
# 718
static const bool is_bounded = true; 
# 719
static const bool is_modulo = (!is_signed); 
# 721
static const bool traps = true; 
# 722
static const bool tinyness_before = false; 
# 723
static const float_round_style round_style = round_toward_zero; 
# 725
}; 
# 853
template<> struct numeric_limits< short>  { 
# 855
static const bool is_specialized = true; 
# 858
static short min() throw() { return (-32767) - 1; } 
# 861
static short max() throw() { return 32767; } 
# 868
static const int digits = ((sizeof(short) * (8)) - (((short)(-1)) < 0)); 
# 869
static const int digits10 = ((((sizeof(short) * (8)) - (((short)(-1)) < 0)) * (643L)) / (2136)); 
# 873
static const bool is_signed = true; 
# 874
static const bool is_integer = true; 
# 875
static const bool is_exact = true; 
# 876
static const int radix = 2; 
# 879
static short epsilon() throw() { return 0; } 
# 882
static short round_error() throw() { return 0; } 
# 884
static const int min_exponent = 0; 
# 885
static const int min_exponent10 = 0; 
# 886
static const int max_exponent = 0; 
# 887
static const int max_exponent10 = 0; 
# 889
static const bool has_infinity = false; 
# 890
static const bool has_quiet_NaN = false; 
# 891
static const bool has_signaling_NaN = false; 
# 892
static const float_denorm_style has_denorm = denorm_absent; 
# 894
static const bool has_denorm_loss = false; 
# 897
static short infinity() throw() { return ((short)0); } 
# 900
static short quiet_NaN() throw() { return ((short)0); } 
# 903
static short signaling_NaN() throw() { return ((short)0); } 
# 906
static short denorm_min() throw() { return ((short)0); } 
# 908
static const bool is_iec559 = false; 
# 909
static const bool is_bounded = true; 
# 910
static const bool is_modulo = false; 
# 912
static const bool traps = true; 
# 913
static const bool tinyness_before = false; 
# 914
static const float_round_style round_style = round_toward_zero; 
# 916
}; 
# 920
template<> struct numeric_limits< unsigned short>  { 
# 922
static const bool is_specialized = true; 
# 925
static unsigned short min() throw() { return 0; } 
# 928
static unsigned short max() throw() { return ((32767) * 2U) + (1); } 
# 935
static const int digits = ((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)); 
# 937
static const int digits10 = ((((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)) * (643L)) / (2136)); 
# 942
static const bool is_signed = false; 
# 943
static const bool is_integer = true; 
# 944
static const bool is_exact = true; 
# 945
static const int radix = 2; 
# 948
static unsigned short epsilon() throw() { return 0; } 
# 951
static unsigned short round_error() throw() { return 0; } 
# 953
static const int min_exponent = 0; 
# 954
static const int min_exponent10 = 0; 
# 955
static const int max_exponent = 0; 
# 956
static const int max_exponent10 = 0; 
# 958
static const bool has_infinity = false; 
# 959
static const bool has_quiet_NaN = false; 
# 960
static const bool has_signaling_NaN = false; 
# 961
static const float_denorm_style has_denorm = denorm_absent; 
# 963
static const bool has_denorm_loss = false; 
# 966
static unsigned short infinity() throw() 
# 967
{ return static_cast< unsigned short>(0); } 
# 970
static unsigned short quiet_NaN() throw() 
# 971
{ return static_cast< unsigned short>(0); } 
# 974
static unsigned short signaling_NaN() throw() 
# 975
{ return static_cast< unsigned short>(0); } 
# 978
static unsigned short denorm_min() throw() 
# 979
{ return static_cast< unsigned short>(0); } 
# 981
static const bool is_iec559 = false; 
# 982
static const bool is_bounded = true; 
# 983
static const bool is_modulo = true; 
# 985
static const bool traps = true; 
# 986
static const bool tinyness_before = false; 
# 987
static const float_round_style round_style = round_toward_zero; 
# 989
}; 
# 993
template<> struct numeric_limits< int>  { 
# 995
static const bool is_specialized = true; 
# 998
static int min() throw() { return (-2147483647) - 1; } 
# 1001
static int max() throw() { return 2147483647; } 
# 1008
static const int digits = ((sizeof(int) * (8)) - (((int)(-1)) < 0)); 
# 1009
static const int digits10 = ((((sizeof(int) * (8)) - (((int)(-1)) < 0)) * (643L)) / (2136)); 
# 1013
static const bool is_signed = true; 
# 1014
static const bool is_integer = true; 
# 1015
static const bool is_exact = true; 
# 1016
static const int radix = 2; 
# 1019
static int epsilon() throw() { return 0; } 
# 1022
static int round_error() throw() { return 0; } 
# 1024
static const int min_exponent = 0; 
# 1025
static const int min_exponent10 = 0; 
# 1026
static const int max_exponent = 0; 
# 1027
static const int max_exponent10 = 0; 
# 1029
static const bool has_infinity = false; 
# 1030
static const bool has_quiet_NaN = false; 
# 1031
static const bool has_signaling_NaN = false; 
# 1032
static const float_denorm_style has_denorm = denorm_absent; 
# 1034
static const bool has_denorm_loss = false; 
# 1037
static int infinity() throw() { return static_cast< int>(0); } 
# 1040
static int quiet_NaN() throw() { return static_cast< int>(0); } 
# 1043
static int signaling_NaN() throw() { return static_cast< int>(0); } 
# 1046
static int denorm_min() throw() { return static_cast< int>(0); } 
# 1048
static const bool is_iec559 = false; 
# 1049
static const bool is_bounded = true; 
# 1050
static const bool is_modulo = false; 
# 1052
static const bool traps = true; 
# 1053
static const bool tinyness_before = false; 
# 1054
static const float_round_style round_style = round_toward_zero; 
# 1056
}; 
# 1060
template<> struct numeric_limits< unsigned>  { 
# 1062
static const bool is_specialized = true; 
# 1065
static unsigned min() throw() { return 0; } 
# 1068
static unsigned max() throw() { return ((2147483647) * 2U) + (1); } 
# 1075
static const int digits = ((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))); 
# 1077
static const int digits10 = ((((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))) * (643L)) / (2136)); 
# 1082
static const bool is_signed = false; 
# 1083
static const bool is_integer = true; 
# 1084
static const bool is_exact = true; 
# 1085
static const int radix = 2; 
# 1088
static unsigned epsilon() throw() { return 0; } 
# 1091
static unsigned round_error() throw() { return 0; } 
# 1093
static const int min_exponent = 0; 
# 1094
static const int min_exponent10 = 0; 
# 1095
static const int max_exponent = 0; 
# 1096
static const int max_exponent10 = 0; 
# 1098
static const bool has_infinity = false; 
# 1099
static const bool has_quiet_NaN = false; 
# 1100
static const bool has_signaling_NaN = false; 
# 1101
static const float_denorm_style has_denorm = denorm_absent; 
# 1103
static const bool has_denorm_loss = false; 
# 1106
static unsigned infinity() throw() { return static_cast< unsigned>(0); } 
# 1109
static unsigned quiet_NaN() throw() 
# 1110
{ return static_cast< unsigned>(0); } 
# 1113
static unsigned signaling_NaN() throw() 
# 1114
{ return static_cast< unsigned>(0); } 
# 1117
static unsigned denorm_min() throw() 
# 1118
{ return static_cast< unsigned>(0); } 
# 1120
static const bool is_iec559 = false; 
# 1121
static const bool is_bounded = true; 
# 1122
static const bool is_modulo = true; 
# 1124
static const bool traps = true; 
# 1125
static const bool tinyness_before = false; 
# 1126
static const float_round_style round_style = round_toward_zero; 
# 1128
}; 
# 1132
template<> struct numeric_limits< long>  { 
# 1134
static const bool is_specialized = true; 
# 1137
static long min() throw() { return (-9223372036854775807L) - (1); } 
# 1140
static long max() throw() { return 9223372036854775807L; } 
# 1147
static const int digits = ((sizeof(long) * (8)) - (((long)(-1)) < (0))); 
# 1148
static const int digits10 = ((((sizeof(long) * (8)) - (((long)(-1)) < (0))) * (643L)) / (2136)); 
# 1152
static const bool is_signed = true; 
# 1153
static const bool is_integer = true; 
# 1154
static const bool is_exact = true; 
# 1155
static const int radix = 2; 
# 1158
static long epsilon() throw() { return 0; } 
# 1161
static long round_error() throw() { return 0; } 
# 1163
static const int min_exponent = 0; 
# 1164
static const int min_exponent10 = 0; 
# 1165
static const int max_exponent = 0; 
# 1166
static const int max_exponent10 = 0; 
# 1168
static const bool has_infinity = false; 
# 1169
static const bool has_quiet_NaN = false; 
# 1170
static const bool has_signaling_NaN = false; 
# 1171
static const float_denorm_style has_denorm = denorm_absent; 
# 1173
static const bool has_denorm_loss = false; 
# 1176
static long infinity() throw() { return static_cast< long>(0); } 
# 1179
static long quiet_NaN() throw() { return static_cast< long>(0); } 
# 1182
static long signaling_NaN() throw() { return static_cast< long>(0); } 
# 1185
static long denorm_min() throw() { return static_cast< long>(0); } 
# 1187
static const bool is_iec559 = false; 
# 1188
static const bool is_bounded = true; 
# 1189
static const bool is_modulo = false; 
# 1191
static const bool traps = true; 
# 1192
static const bool tinyness_before = false; 
# 1193
static const float_round_style round_style = round_toward_zero; 
# 1195
}; 
# 1199
template<> struct numeric_limits< unsigned long>  { 
# 1201
static const bool is_specialized = true; 
# 1204
static unsigned long min() throw() { return 0; } 
# 1207
static unsigned long max() throw() { return ((9223372036854775807L) * 2UL) + (1); } 
# 1214
static const int digits = ((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))); 
# 1216
static const int digits10 = ((((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))) * (643L)) / (2136)); 
# 1221
static const bool is_signed = false; 
# 1222
static const bool is_integer = true; 
# 1223
static const bool is_exact = true; 
# 1224
static const int radix = 2; 
# 1227
static unsigned long epsilon() throw() { return 0; } 
# 1230
static unsigned long round_error() throw() { return 0; } 
# 1232
static const int min_exponent = 0; 
# 1233
static const int min_exponent10 = 0; 
# 1234
static const int max_exponent = 0; 
# 1235
static const int max_exponent10 = 0; 
# 1237
static const bool has_infinity = false; 
# 1238
static const bool has_quiet_NaN = false; 
# 1239
static const bool has_signaling_NaN = false; 
# 1240
static const float_denorm_style has_denorm = denorm_absent; 
# 1242
static const bool has_denorm_loss = false; 
# 1245
static unsigned long infinity() throw() 
# 1246
{ return static_cast< unsigned long>(0); } 
# 1249
static unsigned long quiet_NaN() throw() 
# 1250
{ return static_cast< unsigned long>(0); } 
# 1253
static unsigned long signaling_NaN() throw() 
# 1254
{ return static_cast< unsigned long>(0); } 
# 1257
static unsigned long denorm_min() throw() 
# 1258
{ return static_cast< unsigned long>(0); } 
# 1260
static const bool is_iec559 = false; 
# 1261
static const bool is_bounded = true; 
# 1262
static const bool is_modulo = true; 
# 1264
static const bool traps = true; 
# 1265
static const bool tinyness_before = false; 
# 1266
static const float_round_style round_style = round_toward_zero; 
# 1268
}; 
# 1272
template<> struct numeric_limits< long long>  { 
# 1274
static const bool is_specialized = true; 
# 1277
static long long min() throw() { return (-9223372036854775807LL) - (1); } 
# 1280
static long long max() throw() { return 9223372036854775807LL; } 
# 1287
static const int digits = ((sizeof(long long) * (8)) - (((long long)(-1)) < (0))); 
# 1289
static const int digits10 = ((((sizeof(long long) * (8)) - (((long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1294
static const bool is_signed = true; 
# 1295
static const bool is_integer = true; 
# 1296
static const bool is_exact = true; 
# 1297
static const int radix = 2; 
# 1300
static long long epsilon() throw() { return 0; } 
# 1303
static long long round_error() throw() { return 0; } 
# 1305
static const int min_exponent = 0; 
# 1306
static const int min_exponent10 = 0; 
# 1307
static const int max_exponent = 0; 
# 1308
static const int max_exponent10 = 0; 
# 1310
static const bool has_infinity = false; 
# 1311
static const bool has_quiet_NaN = false; 
# 1312
static const bool has_signaling_NaN = false; 
# 1313
static const float_denorm_style has_denorm = denorm_absent; 
# 1315
static const bool has_denorm_loss = false; 
# 1318
static long long infinity() throw() { return static_cast< long long>(0); } 
# 1321
static long long quiet_NaN() throw() { return static_cast< long long>(0); } 
# 1324
static long long signaling_NaN() throw() 
# 1325
{ return static_cast< long long>(0); } 
# 1328
static long long denorm_min() throw() { return static_cast< long long>(0); } 
# 1330
static const bool is_iec559 = false; 
# 1331
static const bool is_bounded = true; 
# 1332
static const bool is_modulo = false; 
# 1334
static const bool traps = true; 
# 1335
static const bool tinyness_before = false; 
# 1336
static const float_round_style round_style = round_toward_zero; 
# 1338
}; 
# 1342
template<> struct numeric_limits< unsigned long long>  { 
# 1344
static const bool is_specialized = true; 
# 1347
static unsigned long long min() throw() { return 0; } 
# 1350
static unsigned long long max() throw() { return ((9223372036854775807LL) * 2ULL) + (1); } 
# 1357
static const int digits = ((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))); 
# 1359
static const int digits10 = ((((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1364
static const bool is_signed = false; 
# 1365
static const bool is_integer = true; 
# 1366
static const bool is_exact = true; 
# 1367
static const int radix = 2; 
# 1370
static unsigned long long epsilon() throw() { return 0; } 
# 1373
static unsigned long long round_error() throw() { return 0; } 
# 1375
static const int min_exponent = 0; 
# 1376
static const int min_exponent10 = 0; 
# 1377
static const int max_exponent = 0; 
# 1378
static const int max_exponent10 = 0; 
# 1380
static const bool has_infinity = false; 
# 1381
static const bool has_quiet_NaN = false; 
# 1382
static const bool has_signaling_NaN = false; 
# 1383
static const float_denorm_style has_denorm = denorm_absent; 
# 1385
static const bool has_denorm_loss = false; 
# 1388
static unsigned long long infinity() throw() 
# 1389
{ return static_cast< unsigned long long>(0); } 
# 1392
static unsigned long long quiet_NaN() throw() 
# 1393
{ return static_cast< unsigned long long>(0); } 
# 1396
static unsigned long long signaling_NaN() throw() 
# 1397
{ return static_cast< unsigned long long>(0); } 
# 1400
static unsigned long long denorm_min() throw() 
# 1401
{ return static_cast< unsigned long long>(0); } 
# 1403
static const bool is_iec559 = false; 
# 1404
static const bool is_bounded = true; 
# 1405
static const bool is_modulo = true; 
# 1407
static const bool traps = true; 
# 1408
static const bool tinyness_before = false; 
# 1409
static const float_round_style round_style = round_toward_zero; 
# 1411
}; 
# 1569
template<> struct numeric_limits< __int128_t>  { static const bool is_specialized = true; static __int128_t min() throw() { return (((__int128_t)(-1)) < (0)) ? (-((((__int128_t)(-1)) < (0)) ? (((((__int128_t)1) << ((128 - (((__int128_t)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((__int128_t)0)))) - (1) : ((__int128_t)0); } static __int128_t max() throw() { return (((__int128_t)(-1)) < (0)) ? (((((__int128_t)1) << ((128 - (((__int128_t)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((__int128_t)0)); } static const int digits = (128 - 1); static const int digits10 = (((128 - 1) * 643L) / (2136)); static const bool is_signed = true; static const bool is_integer = true; static const bool is_exact = true; static const int radix = 2; static __int128_t epsilon() throw() { return 0; } static __int128_t round_error() throw() { return 0; } static const int min_exponent = 0; static const int min_exponent10 = 0; static const int max_exponent = 0; static const int max_exponent10 = 0; static const bool has_infinity = false; static const bool has_quiet_NaN = false; static const bool has_signaling_NaN = false; static const float_denorm_style has_denorm = denorm_absent; static const bool has_denorm_loss = false; static __int128_t infinity() throw() { return static_cast< __int128_t>(0); } static __int128_t quiet_NaN() throw() { return static_cast< __int128_t>(0); } static __int128_t signaling_NaN() throw() { return static_cast< __int128_t>(0); } static __int128_t denorm_min() throw() { return static_cast< __int128_t>(0); } static const bool is_iec559 = false; static const bool is_bounded = true; static const bool is_modulo = false; static const bool traps = true; static const bool tinyness_before = false; static const float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits< __uint128_t>  { static const bool is_specialized = true; static __uint128_t min() throw() { return 0; } static __uint128_t max() throw() { return (((__uint128_t)(-1)) < (0)) ? (((((__uint128_t)1) << ((128 - (((__uint128_t)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((__uint128_t)0)); } static const int digits = 128; static const int digits10 = (((128) * 643L) / (2136)); static const bool is_signed = false; static const bool is_integer = true; static const bool is_exact = true; static const int radix = 2; static __uint128_t epsilon() throw() { return 0; } static __uint128_t round_error() throw() { return 0; } static const int min_exponent = 0; static const int min_exponent10 = 0; static const int max_exponent = 0; static const int max_exponent10 = 0; static const bool has_infinity = false; static const bool has_quiet_NaN = false; static const bool has_signaling_NaN = false; static const float_denorm_style has_denorm = denorm_absent; static const bool has_denorm_loss = false; static __uint128_t infinity() throw() { return static_cast< __uint128_t>(0); } static __uint128_t quiet_NaN() throw() { return static_cast< __uint128_t>(0); } static __uint128_t signaling_NaN() throw() { return static_cast< __uint128_t>(0); } static __uint128_t denorm_min() throw() { return static_cast< __uint128_t>(0); } static const bool is_iec559 = false; static const bool is_bounded = true; static const bool is_modulo = true; static const bool traps = true; static const bool tinyness_before = false; static const float_round_style round_style = round_toward_zero; }; 
# 1593
template<> struct numeric_limits< float>  { 
# 1595
static const bool is_specialized = true; 
# 1598
static float min() throw() { return (1.175494351e-38F); } 
# 1601
static float max() throw() { return (3.402823466e+38F); } 
# 1608
static const int digits = 24; 
# 1609
static const int digits10 = 6; 
# 1614
static const bool is_signed = true; 
# 1615
static const bool is_integer = false; 
# 1616
static const bool is_exact = false; 
# 1617
static const int radix = 2; 
# 1620
static float epsilon() throw() { return (1.192092896e-07F); } 
# 1623
static float round_error() throw() { return (0.5F); } 
# 1625
static const int min_exponent = (-125); 
# 1626
static const int min_exponent10 = (-37); 
# 1627
static const int max_exponent = 128; 
# 1628
static const int max_exponent10 = 38; 
# 1630
static const bool has_infinity = (1); 
# 1631
static const bool has_quiet_NaN = (1); 
# 1632
static const bool has_signaling_NaN = has_quiet_NaN; 
# 1633
static const float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1635
static const bool has_denorm_loss = false; 
# 1639
static float infinity() throw() { return __builtin_huge_valf(); } 
# 1642
static float quiet_NaN() throw() { return __builtin_nanf(""); } 
# 1645
static float signaling_NaN() throw() { return __builtin_nansf(""); } 
# 1648
static float denorm_min() throw() { return (1.401298464e-45F); } 
# 1650
static const bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1652
static const bool is_bounded = true; 
# 1653
static const bool is_modulo = false; 
# 1655
static const bool traps = false; 
# 1656
static const bool tinyness_before = false; 
# 1658
static const float_round_style round_style = round_to_nearest; 
# 1660
}; 
# 1668
template<> struct numeric_limits< double>  { 
# 1670
static const bool is_specialized = true; 
# 1673
static double min() throw() { return (double)(2.225073858507201383e-308L); } 
# 1676
static double max() throw() { return (double)(1.797693134862315708e+308L); } 
# 1683
static const int digits = 53; 
# 1684
static const int digits10 = 15; 
# 1689
static const bool is_signed = true; 
# 1690
static const bool is_integer = false; 
# 1691
static const bool is_exact = false; 
# 1692
static const int radix = 2; 
# 1695
static double epsilon() throw() { return (double)(2.220446049250313081e-16L); } 
# 1698
static double round_error() throw() { return (0.5); } 
# 1700
static const int min_exponent = (-1021); 
# 1701
static const int min_exponent10 = (-307); 
# 1702
static const int max_exponent = 1024; 
# 1703
static const int max_exponent10 = 308; 
# 1705
static const bool has_infinity = (1); 
# 1706
static const bool has_quiet_NaN = (1); 
# 1707
static const bool has_signaling_NaN = has_quiet_NaN; 
# 1708
static const float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1710
static const bool has_denorm_loss = false; 
# 1714
static double infinity() throw() { return __builtin_huge_val(); } 
# 1717
static double quiet_NaN() throw() { return __builtin_nan(""); } 
# 1720
static double signaling_NaN() throw() { return __builtin_nans(""); } 
# 1723
static double denorm_min() throw() { return (double)(4.940656458412465442e-324L); } 
# 1725
static const bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1727
static const bool is_bounded = true; 
# 1728
static const bool is_modulo = false; 
# 1730
static const bool traps = false; 
# 1731
static const bool tinyness_before = false; 
# 1733
static const float_round_style round_style = round_to_nearest; 
# 1735
}; 
# 1743
template<> struct numeric_limits< long double>  { 
# 1745
static const bool is_specialized = true; 
# 1748
static long double min() throw() { return (0.0L); } 
# 1751
static long double max() throw() { return ((__builtin_huge_vall())); } 
# 1758
static const int digits = 64; 
# 1759
static const int digits10 = 18; 
# 1764
static const bool is_signed = true; 
# 1765
static const bool is_integer = false; 
# 1766
static const bool is_exact = false; 
# 1767
static const int radix = 2; 
# 1770
static long double epsilon() throw() { return (1.084202172485504434e-19L); } 
# 1773
static long double round_error() throw() { return (0.5L); } 
# 1775
static const int min_exponent = (-16381); 
# 1776
static const int min_exponent10 = (-4931); 
# 1777
static const int max_exponent = 16384; 
# 1778
static const int max_exponent10 = 4932; 
# 1780
static const bool has_infinity = (1); 
# 1781
static const bool has_quiet_NaN = (1); 
# 1782
static const bool has_signaling_NaN = has_quiet_NaN; 
# 1783
static const float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1785
static const bool has_denorm_loss = false; 
# 1789
static long double infinity() throw() { return __builtin_huge_vall(); } 
# 1792
static long double quiet_NaN() throw() { return __builtin_nanl(""); } 
# 1795
static long double signaling_NaN() throw() { return __builtin_nansl(""); } 
# 1798
static long double denorm_min() throw() { return (0.0L); } 
# 1800
static const bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1802
static const bool is_bounded = true; 
# 1803
static const bool is_modulo = false; 
# 1805
static const bool traps = false; 
# 1806
static const bool tinyness_before = false; 
# 1808
static const float_round_style round_style = round_to_nearest; 
# 1810
}; 
# 1817
}
# 24 "/usr/local/cuda/include/thrust/detail/numeric_traits.h"
namespace thrust { 
# 27
namespace detail { 
# 31
typedef long long intmax_t; 
# 33
template< class Number> 
# 34
struct is_signed : public integral_constant< bool, std::numeric_limits< Number> ::is_signed>  { 
# 36
}; 
# 39
template< class T> 
# 40
struct num_digits : public eval_if< std::numeric_limits< T> ::is_specialized, integral_constant< int, std::numeric_limits< T> ::digits> , integral_constant< int, (sizeof(T) * std::numeric_limits< unsigned char> ::digits) - ((is_signed< T> ::value) ? 1 : 0)> > ::type { 
# 52
}; 
# 55
template< class Integer> 
# 56
struct integer_difference { 
# 75
private: 
# 74
template< bool x, bool y> 
# 75
struct and_ { 
# 77
static const bool value = false; 
# 78
}; 
# 80
template< bool y> 
# 81
struct and_< true, y>  { 
# 83
static const bool value = y; 
# 84
}; 
# 104
public: typedef typename eval_if< and_< std::numeric_limits< Integer> ::is_signed, (!std::numeric_limits< Integer> ::is_bounded) || ((((int)std::numeric_limits< Integer> ::digits) + 1) >= integral_constant< int, 63> ::value)> ::value, identity_< Integer> , eval_if< (((int)std::numeric_limits< Integer> ::digits) + 1) < integral_constant< int, 31> ::value, identity_< signed int> , eval_if< (((int)std::numeric_limits< Integer> ::digits) + 1) < integral_constant< int, 63> ::value, identity_< signed long> , identity_< long long> > > > ::type type; 
# 105
}; 
# 108
template< class Number> 
# 109
struct numeric_difference : public eval_if< is_integral< Number> ::value, integer_difference< Number> , identity_< Number> >  { 
# 115
}; 
# 118
template< class Number> typename numeric_difference< Number> ::type 
# 121
numeric_distance(Number x, Number y) 
# 122
{ 
# 123
typedef typename numeric_difference< Number> ::type difference_type; 
# 124
return ((difference_type)y) - ((difference_type)x); 
# 125
} 
# 127
}
# 129
}
# 25 "/usr/local/cuda/include/thrust/iterator/detail/counting_iterator.inl"
namespace thrust { 
# 29
template< class Incrementable, class System, class Traversal, class Difference> class counting_iterator; 
# 32
namespace detail { 
# 35
template< class Incrementable, class System, class Traversal, class Difference> 
# 36
struct counting_iterator_base { 
# 43
typedef typename eval_if< is_same< System, use_default> ::value, identity_< any_system_tag> , identity_< System> > ::type system; 
# 52
typedef typename ia_dflt_help< Traversal, eval_if< is_numeric< Incrementable> ::value, identity_< random_access_traversal_tag> , iterator_traversal< Incrementable> > > ::type traversal; 
# 67
typedef typename ia_dflt_help< Difference, eval_if< is_numeric< Incrementable> ::value, eval_if< is_integral< Incrementable> ::value, numeric_difference< Incrementable> , identity_< signed long> > , iterator_difference< Incrementable> > > ::type difference; 
# 81
typedef iterator_adaptor< counting_iterator< Incrementable, System, Traversal, Difference> , Incrementable, Incrementable, typename eval_if< is_same< System, use_default> ::value, identity_< any_system_tag> , identity_< System> > ::type, typename ia_dflt_help< Traversal, eval_if< is_numeric< Incrementable> ::value, identity_< random_access_traversal_tag> , iterator_traversal< Incrementable> > > ::type, Incrementable, typename ia_dflt_help< Difference, eval_if< is_numeric< Incrementable> ::value, eval_if< is_integral< Incrementable> ::value, numeric_difference< Incrementable> , identity_< signed long> > , iterator_difference< Incrementable> > > ::type>  type; 
# 82
}; 
# 85
template< class Difference, class Incrementable1, class Incrementable2> 
# 86
struct iterator_distance { 
# 89
static Difference distance(Incrementable1 x, Incrementable2 y) 
# 90
{ 
# 91
return y - x; 
# 92
} 
# 93
}; 
# 96
template< class Difference, class Incrementable1, class Incrementable2> 
# 97
struct number_distance { 
# 100
static Difference distance(Incrementable1 x, Incrementable2 y) 
# 101
{ 
# 102
return static_cast< Difference>(numeric_distance(x, y)); 
# 103
} 
# 104
}; 
# 107
template< class Difference, class Incrementable1, class Incrementable2, class Enable = void> 
# 108
struct counting_iterator_equal { 
# 111
static bool equal(Incrementable1 x, Incrementable2 y) 
# 112
{ 
# 113
return x == y; 
# 114
} 
# 115
}; 
# 119
template< class Difference, class Incrementable1, class Incrementable2> 
# 120
struct counting_iterator_equal< Difference, Incrementable1, Incrementable2, typename enable_if< is_floating_point< Incrementable1> ::value || is_floating_point< Incrementable2> ::value> ::type>  { 
# 131
static bool equal(Incrementable1 x, Incrementable2 y) 
# 132
{ 
# 133
typedef number_distance< Difference, Incrementable1, Incrementable2>  d; 
# 134
return d::distance(x, y) == 0; 
# 135
} 
# 136
}; 
# 139
}
# 140
}
# 42 "/usr/local/cuda/include/thrust/iterator/counting_iterator.h"
namespace thrust { 
# 128
template< class Incrementable, class 
# 129
System = use_default, class 
# 130
Traversal = use_default, class 
# 131
Difference = use_default> 
# 132
class counting_iterator : public detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type { 
# 137
typedef typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type super_t; 
# 139
friend class iterator_core_access; 
# 142
public: typedef typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type::reference reference; 
# 143
typedef typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type::difference_type difference_type; 
# 152
counting_iterator() { } 
# 160
counting_iterator(const counting_iterator &rhs) : super_t((rhs.base())) { } 
# 167
template< class OtherSystem> 
# 169
counting_iterator(const ::thrust::counting_iterator< Incrementable, OtherSystem, Traversal, Difference>  &rhs, typename ::thrust::detail::enable_if_convertible< typename iterator_system< ::thrust::counting_iterator< Incrementable, OtherSystem, Traversal, Difference> > ::type, typename iterator_system< typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type> ::type> ::type * = 0) : super_t((rhs.base())) 
# 174
{ } 
# 183
explicit counting_iterator(Incrementable x) : super_t(x) { } 
# 189
private: reference dereference() const 
# 190
{ 
# 191
return (this->base_reference()); 
# 192
} 
# 195
template< class OtherIncrementable, class OtherSystem, class OtherTraversal, class OtherDifference> bool 
# 197
equal(const ::thrust::counting_iterator< OtherIncrementable, OtherSystem, OtherTraversal, OtherDifference>  &y) const 
# 198
{ 
# 199
typedef ::thrust::detail::counting_iterator_equal< typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type::difference_type, Incrementable, OtherIncrementable>  e; 
# 200
return e::equal((this->base()), (y.base())); 
# 201
} 
# 203
template< class OtherIncrementable> difference_type 
# 206
distance_to(const ::thrust::counting_iterator< OtherIncrementable, System, Traversal, Difference>  &y) const 
# 207
{ 
# 213
typedef typename ::thrust::detail::eval_if< ::thrust::detail::is_numeric< Incrementable> ::value, ::thrust::detail::identity_< ::thrust::detail::number_distance< typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type::difference_type, Incrementable, OtherIncrementable> > , ::thrust::detail::identity_< ::thrust::detail::iterator_distance< typename ::thrust::detail::counting_iterator_base< Incrementable, System, Traversal, Difference> ::type::difference_type, Incrementable, OtherIncrementable> > > ::type d; 
# 215
return d::distance((this->base()), (y.base())); 
# 216
} 
# 220
}; 
# 229
template< class Incrementable> inline counting_iterator< Incrementable>  
# 231
make_counting_iterator(Incrementable x) 
# 232
{ 
# 233
return ((counting_iterator< Incrementable> )(x)); 
# 234
} 
# 242
}
# 26 "/usr/local/cuda/include/thrust/iterator/detail/join_iterator.h"
namespace thrust { 
# 28
namespace detail { 
# 32
template< class RandomAccessIterator1, class 
# 33
RandomAccessIterator2, class 
# 34
Difference, class 
# 35
Reference> class join_iterator; 
# 39
namespace join_iterator_detail { 
# 43
template< class RandomAccessIterator1, class 
# 44
RandomAccessIterator2, class 
# 45
Difference, class 
# 46
Reference> 
# 47
struct join_iterator_base { 
# 49
typedef typename remove_reference< Reference> ::type value_type; 
# 51
typedef typename iterator_system< RandomAccessIterator1> ::type system1; 
# 52
typedef typename iterator_system< RandomAccessIterator2> ::type system2; 
# 53
typedef typename minimum_system< typename iterator_system< RandomAccessIterator1> ::type, typename iterator_system< RandomAccessIterator2> ::type> ::type system; 
# 63
typedef iterator_adaptor< join_iterator< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> , counting_iterator< Difference> , typename remove_reference< Reference> ::type, typename minimum_system< typename iterator_system< RandomAccessIterator1> ::type, typename iterator_system< RandomAccessIterator2> ::type> ::type, random_access_traversal_tag, Reference, Difference>  type; 
# 64
}; 
# 67
}
# 70
template< class RandomAccessIterator1, class 
# 71
RandomAccessIterator2, class 
# 72
Difference = typename iterator_difference< RandomAccessIterator1> ::type, class 
# 73
Reference = typename iterator_value< RandomAccessIterator1> ::type> 
# 74
class join_iterator : public join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type { 
# 78
typedef typename ::thrust::detail::join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type super_t; 
# 79
typedef typename ::thrust::detail::join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type::difference_type size_type; 
# 83
public: join_iterator(RandomAccessIterator1 first1, size_type n, RandomAccessIterator2 first2) : super_t(((counting_iterator< typename ::thrust::detail::join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type::difference_type> )(0))), m_n1(n), m_iter1(first1), m_iter2(first2 - (m_n1)) 
# 88
{ } 
# 92
join_iterator(const join_iterator &other) : super_t(other), m_n1(other.m_n1), m_iter1(other.m_iter1), m_iter2(other.m_iter2) 
# 97
{ } 
# 101
friend class ::thrust::iterator_core_access; 
# 105
private: typename ::thrust::detail::join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type::reference dereference() const 
# 106
{ 
# 107
size_type i = *super_t::base(); 
# 108
return (i < (m_n1)) ? (m_iter1)[i] : (static_cast< typename ::thrust::detail::join_iterator_detail::join_iterator_base< RandomAccessIterator1, RandomAccessIterator2, Difference, Reference> ::type::reference>((m_iter2)[i])); 
# 109
} 
# 112
size_type m_n1; 
# 113
RandomAccessIterator1 m_iter1; 
# 114
RandomAccessIterator2 m_iter2; 
# 115
}; 
# 118
template< class RandomAccessIterator1, class Size, class RandomAccessIterator2> join_iterator< RandomAccessIterator1, RandomAccessIterator2, Size>  
# 120
make_join_iterator(RandomAccessIterator1 first1, Size n1, RandomAccessIterator2 first2) 
# 121
{ 
# 122
return join_iterator< RandomAccessIterator1, RandomAccessIterator2, Size> (first1, n1, first2); 
# 123
} 
# 126
}
# 127
}
# 30 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 31
namespace bulk_ { 
# 35
template< class RandomAccessIterator1, class Size, class RandomAccessIterator2, class Compare> __attribute__((unused)) Size 
# 37
merge_path(RandomAccessIterator1 first1, Size n1, RandomAccessIterator2 
# 38
first2, Size n2, Size 
# 39
diag, Compare 
# 40
comp) 
# 41
{int volatile ___ = 1;(void)first1;(void)n1;(void)first2;(void)n2;(void)diag;(void)comp;
# 60
::exit(___);}
#if 0
# 41
{ 
# 42
Size begin = thrust::max< Size> ((Size)0, diag - n2); 
# 43
Size end = thrust::min< Size> (diag, n1); 
# 45
while (begin < end) 
# 46
{ 
# 47
Size mid = (begin + end) >> 1; 
# 49
if (comp(first2[(diag - 1) - mid], first1[mid])) 
# 50
{ 
# 51
end = mid; 
# 52
} else 
# 54
{ 
# 55
begin = (mid + 1); 
# 56
}  
# 57
}  
# 59
return begin; 
# 60
} 
#endif
# 63 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
template< std::size_t bound, std::size_t 
# 64
grainsize, class 
# 65
InputIterator1, class 
# 66
InputIterator2, class 
# 67
OutputIterator, class 
# 68
Compare> __attribute__((unused)) OutputIterator 
# 70
merge(const bounded< bound, agent< grainsize> >  &e, InputIterator1 
# 71
first1, InputIterator1 last1, InputIterator2 
# 72
first2, InputIterator2 last2, OutputIterator 
# 73
result, Compare 
# 74
comp) 
# 75
{int volatile ___ = 1;(void)e;(void)first1;(void)last1;(void)first2;(void)last2;(void)result;(void)comp;
# 170
::exit(___);}
#if 0
# 75
{ 
# 76
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 78
typedef typename iterator_value< InputIterator1> ::type value_type1; 
# 79
typedef typename iterator_value< InputIterator2> ::type value_type2; 
# 81
size_type n = (last1 - first1) + (last2 - first2); 
# 85
value_type1 key_a; 
# 86
size_type n1 = last1 - first1; 
# 87
size_type idx1 = (0); 
# 89
if (n1 > 0) 
# 90
{ 
# 92
key_a = (first1[idx1]); 
# 93
}  
# 96
value_type2 key_b; 
# 97
size_type n2 = last2 - first2; 
# 98
size_type idx2 = (0); 
# 100
if (n2 > 0) 
# 101
{ 
# 103
key_b = (first2[idx2]); 
# 104
}  
# 107
if (bound <= n) 
# 108
{ 
# 109
for (size_type i = (0); i < grainsize; ++i) 
# 110
{ 
# 111
bool p = (idx2 >= n2) || ((idx1 < n1) && (!comp(key_b, key_a))); 
# 113
(result[i]) = (p ? key_a : key_b); 
# 115
if (p) 
# 116
{ 
# 117
++idx1; 
# 120
key_a = (first1[min(idx1, n1 - 1)]); 
# 121
} else 
# 123
{ 
# 124
++idx2; 
# 127
key_b = (first2[min(idx2, n2 - 1)]); 
# 128
}  
# 129
}  
# 130
} else 
# 132
{ 
# 133
for (size_type i = (0); i < grainsize; ++i) 
# 134
{ 
# 135
if (i < n) 
# 136
{ 
# 137
bool p = (idx2 >= n2) || ((idx1 < n1) && (!comp(key_b, key_a))); 
# 139
(result[i]) = (p ? key_a : key_b); 
# 141
if (p) 
# 142
{ 
# 143
++idx1; 
# 146
key_a = (first1[min(idx1, n1 - 1)]); 
# 147
} else 
# 149
{ 
# 150
++idx2; 
# 153
key_b = (first2[min(idx2, n2 - 1)]); 
# 154
}  
# 155
}  
# 156
}  
# 157
}  
# 169
return result + n; 
# 170
} 
#endif
# 173 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
template< std::size_t bound, std::size_t grainsize, class 
# 174
RandomAccessIterator1, class 
# 175
RandomAccessIterator2, class 
# 176
RandomAccessIterator3, class 
# 177
RandomAccessIterator4, class 
# 178
RandomAccessIterator5, class 
# 179
RandomAccessIterator6, class 
# 180
Compare> __attribute__((unused)) pair< RandomAccessIterator5, RandomAccessIterator6>  
# 183
merge_by_key(const bounded< bound, agent< grainsize> >  &, RandomAccessIterator1 
# 184
keys_first1, RandomAccessIterator1 keys_last1, RandomAccessIterator2 
# 185
keys_first2, RandomAccessIterator2 keys_last2, RandomAccessIterator3 
# 186
values_first1, RandomAccessIterator4 
# 187
values_first2, RandomAccessIterator5 
# 188
keys_result, RandomAccessIterator6 
# 189
values_result, Compare 
# 190
comp) 
# 191
{int volatile ___ = 1;(void)keys_first1;(void)keys_last1;(void)keys_first2;(void)keys_last2;(void)values_first1;(void)values_first2;(void)keys_result;(void)values_result;(void)comp;
# 305
::exit(___);}
#if 0
# 191
{ 
# 192
typedef typename bounded< bound, agent< grainsize> > ::size_type size_type; 
# 194
typedef typename iterator_value< RandomAccessIterator1> ::type key_type1; 
# 195
typedef typename iterator_value< RandomAccessIterator2> ::type key_type2; 
# 197
typedef typename iterator_value< RandomAccessIterator3> ::type value_type1; 
# 198
typedef typename iterator_value< RandomAccessIterator4> ::type value_type2; 
# 200
size_type n = (keys_last1 - keys_first1) + (keys_last2 - keys_first2); 
# 205
key_type1 key_a; 
# 206
value_type1 val_a; 
# 207
size_type n1 = keys_last1 - keys_first1; 
# 208
size_type idx1 = (0); 
# 210
if (n1 > 0) 
# 211
{ 
# 214
key_a = (keys_first1[idx1]); 
# 215
val_a = (values_first1[idx1]); 
# 216
}  
# 220
key_type2 key_b; 
# 221
value_type2 val_b; 
# 222
size_type n2 = keys_last2 - keys_first2; 
# 223
size_type idx2 = (0); 
# 225
if (n2 > 0) 
# 226
{ 
# 229
key_b = (keys_first2[idx2]); 
# 230
val_b = (values_first2[idx2]); 
# 231
}  
# 234
if (bound <= n) 
# 235
{ 
# 236
for (size_type i = (0); i < grainsize; ++i) 
# 237
{ 
# 238
bool p = (idx2 >= n2) || ((idx1 < n1) && (!comp(key_b, key_a))); 
# 240
(keys_result[i]) = (p ? key_a : key_b); 
# 241
(values_result[i]) = (p ? val_a : val_b); 
# 243
if (p) 
# 244
{ 
# 245
++idx1; 
# 248
key_a = (keys_first1[min(idx1, n1 - 1)]); 
# 249
val_a = (values_first1[min(idx1, n1 - 1)]); 
# 250
} else 
# 252
{ 
# 253
++idx2; 
# 256
key_b = (keys_first2[min(idx2, n2 - 1)]); 
# 257
val_b = (values_first2[min(idx2, n2 - 1)]); 
# 258
}  
# 259
}  
# 260
} else 
# 262
{ 
# 263
for (size_type i = (0); i < grainsize; ++i) 
# 264
{ 
# 265
if (i < n) 
# 266
{ 
# 267
bool p = (idx2 >= n2) || ((idx1 < n1) && (!comp(key_b, key_a))); 
# 269
(keys_result[i]) = (p ? key_a : key_b); 
# 270
(values_result[i]) = (p ? val_a : val_b); 
# 272
if (p) 
# 273
{ 
# 274
++idx1; 
# 277
key_a = (keys_first1[min(idx1, n1 - 1)]); 
# 278
val_a = (values_first1[min(idx1, n1 - 1)]); 
# 279
} else 
# 281
{ 
# 282
++idx2; 
# 285
key_b = (keys_first2[min(idx2, n2 - 1)]); 
# 286
val_b = (values_first2[min(idx2, n2 - 1)]); 
# 287
}  
# 288
}  
# 289
}  
# 290
}  
# 304
return thrust::make_pair(keys_result + n, values_result + n); 
# 305
} 
#endif
# 308 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator, class Compare> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize)> ::type 
# 313
inplace_merge(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 319
g, RandomAccessIterator 
# 320
first, RandomAccessIterator middle, RandomAccessIterator last, Compare 
# 321
comp) 
# 322
{int volatile ___ = 1;(void)g;(void)first;(void)middle;(void)last;(void)comp;
# 353
::exit(___);}
#if 0
# 322
{ 
# 323
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 325
size_type n1 = middle - first; 
# 326
size_type n2 = last - middle; 
# 329
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 331
size_type mp = bulk_::merge_path(first, n1, middle, n2, local_offset, comp); 
# 334
size_type local_offset1 = mp; 
# 335
size_type local_offset2 = (n1 + local_offset) - mp; 
# 337
typedef typename iterator_value< RandomAccessIterator> ::type value_type; 
# 338
value_type local_result[grainsize]; 
# 339
bulk_::merge(bulk_::bound< grainsize> ((g.this_exec)), first + local_offset1, middle, first + local_offset2, last, local_result, comp); 
# 345
(g.wait()); 
# 349
size_type local_size = thrust::max< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (0, thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (grainsize, (n1 + n2) - local_offset)); 
# 350
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_result, local_size, first + local_offset); 
# 352
(g.wait()); 
# 353
} 
#endif
# 356 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class 
# 357
RandomAccessIterator1, class 
# 358
RandomAccessIterator2, class 
# 359
RandomAccessIterator3, class 
# 360
Compare> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize), RandomAccessIterator3> ::type 
# 366
merge(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 372
g, RandomAccessIterator1 
# 373
first1, RandomAccessIterator1 last1, RandomAccessIterator2 
# 374
first2, RandomAccessIterator2 last2, RandomAccessIterator3 
# 375
result, Compare 
# 376
comp) 
# 377
{int volatile ___ = 1;(void)g;(void)first1;(void)last1;(void)first2;(void)last2;(void)result;(void)comp;
# 408
::exit(___);}
#if 0
# 377
{ 
# 378
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 380
size_type n1 = last1 - first1; 
# 381
size_type n2 = last2 - first2; 
# 384
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 386
size_type mp = bulk_::merge_path(first1, n1, first2, n2, local_offset, comp); 
# 389
size_type local_offset1 = mp; 
# 390
size_type local_offset2 = local_offset - mp; 
# 392
typedef typename iterator_value< RandomAccessIterator3> ::type value_type; 
# 393
value_type local_result[grainsize]; 
# 394
bulk_::merge(bulk_::bound< grainsize> ((g.this_exec)), first1 + local_offset1, last1, first2 + local_offset2, last2, local_result, comp); 
# 402
size_type local_size = thrust::max< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (0, thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (grainsize, (n1 + n2) - local_offset)); 
# 403
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_result, local_size, result + local_offset); 
# 405
(g.wait()); 
# 407
return result + thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (groupsize * grainsize, n1 + n2); 
# 408
} 
#endif
# 411 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
namespace detail { 
# 413
namespace merge_detail { 
# 418
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class RandomAccessIterator3, class RandomAccessIterator4, class Compare> __attribute__((unused)) RandomAccessIterator4 
# 421
bounded_merge_with_buffer(concurrent_group< agent< grainsize> , groupsize>  &exec, RandomAccessIterator1 
# 422
first1, RandomAccessIterator1 last1, RandomAccessIterator2 
# 423
first2, RandomAccessIterator2 last2, RandomAccessIterator3 
# 424
buffer, RandomAccessIterator4 
# 425
result, Compare 
# 426
comp) 
# 427
{int volatile ___ = 1;(void)exec;(void)first1;(void)last1;(void)first2;(void)last2;(void)buffer;(void)result;(void)comp;
# 447
::exit(___);}
#if 0
# 427
{ 
# 428
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 430
size_type n1 = last1 - first1; 
# 431
size_type n2 = last2 - first2; 
# 434
bulk_::copy_n(bulk_::bound< groupsize * grainsize> (exec), thrust::detail::make_join_iterator(first1, n1, first2), n1 + n2, buffer); 
# 440
bulk_::inplace_merge(bulk_::bound< groupsize * grainsize> (exec), buffer, buffer + n1, (buffer + n1) + n2, comp); 
# 446
return bulk_::copy_n(exec, buffer, n1 + n2, result); 
# 447
} 
#endif
# 450 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
}
# 451
}
# 454
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class RandomAccessIterator2, class RandomAccessIterator3, class Compare> __attribute__((unused)) RandomAccessIterator3 
# 456
merge(concurrent_group< agent< grainsize> , groupsize>  &exec, RandomAccessIterator1 
# 457
first1, RandomAccessIterator1 last1, RandomAccessIterator2 
# 458
first2, RandomAccessIterator2 last2, RandomAccessIterator3 
# 459
result, Compare 
# 460
comp) 
# 461
{int volatile ___ = 1;(void)exec;(void)first1;(void)last1;(void)first2;(void)last2;(void)result;(void)comp;
# 504
::exit(___);}
#if 0
# 461
{ 
# 462
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 464
typedef typename iterator_value< RandomAccessIterator3> ::type value_type; 
# 466
value_type *buffer = reinterpret_cast< value_type *>(bulk_::malloc(exec, ((exec.size()) * (exec.grainsize())) * sizeof(value_type))); 
# 468
size_type chunk_size = (exec.size()) * ((exec.this_exec).grainsize()); 
# 470
size_type n1 = last1 - first1; 
# 471
size_type n2 = last2 - first2; 
# 474
if ((n1 + n2) <= chunk_size) 
# 475
{ 
# 476
result = detail::merge_detail::bounded_merge_with_buffer(exec, first1, last1, first2, last2, buffer, result, comp); 
# 477
} else 
# 479
{ 
# 480
while ((first1 < last1) || (first2 < last2)) 
# 481
{ 
# 482
size_type n1 = last1 - first1; 
# 483
size_type n2 = last2 - first2; 
# 485
size_type diag = thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (chunk_size, n1 + n2); 
# 487
size_type mp = bulk_::merge_path(first1, n1, first2, n2, diag, comp); 
# 489
result = detail::merge_detail::bounded_merge_with_buffer(exec, first1, first1 + mp, first2, (first2 + diag) - mp, buffer, result, comp); 
# 496
first1 += mp; 
# 497
first2 += (diag - mp); 
# 498
}  
# 499
}  
# 501
bulk_::free(exec, buffer); 
# 503
return result; 
# 504
} 
#endif
# 507 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
template< std::size_t groupsize, std::size_t grainsize, class 
# 508
RandomAccessIterator1, class 
# 509
RandomAccessIterator2, class 
# 510
RandomAccessIterator3, class 
# 511
RandomAccessIterator4, class 
# 512
RandomAccessIterator5, class 
# 513
RandomAccessIterator6, class 
# 514
Compare> __attribute__((unused)) pair< RandomAccessIterator5, RandomAccessIterator6>  
# 517
merge_by_key(bounded< groupsize * grainsize, concurrent_group< agent< grainsize> , groupsize> >  &
# 520
g, RandomAccessIterator1 
# 521
keys_first1, RandomAccessIterator1 keys_last1, RandomAccessIterator2 
# 522
keys_first2, RandomAccessIterator2 keys_last2, RandomAccessIterator3 
# 523
values_first1, RandomAccessIterator4 
# 524
values_first2, RandomAccessIterator5 
# 525
keys_result, RandomAccessIterator6 
# 526
values_result, Compare 
# 527
comp) 
# 528
{int volatile ___ = 1;(void)g;(void)keys_first1;(void)keys_last1;(void)keys_first2;(void)keys_last2;(void)values_first1;(void)values_first2;(void)keys_result;(void)values_result;(void)comp;
# 607
::exit(___);}
#if 0
# 528
{ 
# 529
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 531
typedef typename iterator_value< RandomAccessIterator5> ::type key_type; 
# 546
__attribute__((unused)) static 
# 543
union { 
# 544
key_type keys[groupsize * grainsize]; 
# 545
size_type indices[groupsize * grainsize]; 
# 546
} stage; 
# 549
size_type n1 = keys_last1 - keys_first1; 
# 550
size_type n2 = keys_last2 - keys_first2; 
# 551
size_type n = n1 + n2; 
# 554
bulk_::copy_n(g, thrust::detail::make_join_iterator(keys_first1, n1, keys_first2), n, stage.keys); 
# 560
size_type diag = thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (n1 + n2, grainsize * ((g.this_exec).index())); 
# 561
size_type mp = bulk_::merge_path(stage.keys, n1, (stage.keys) + n1, n2, diag, comp); 
# 564
size_type start1 = mp; 
# 565
size_type start2 = (n1 + diag) - mp; 
# 567
size_type end1 = n1; 
# 568
size_type end2 = n1 + n2; 
# 571
key_type results[grainsize]; 
# 572
size_type indices[grainsize]; 
# 573
bulk_::merge_by_key(bulk_::bound< grainsize> ((g.this_exec)), (stage.keys) + start1, (stage.keys) + end1, (stage.keys) + start2, (stage.keys) + end2, thrust::make_counting_iterator< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (start1), thrust::make_counting_iterator< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (start2), results, indices, comp); 
# 581
(g.wait()); 
# 584
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 585
size_type local_size = thrust::max< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (0, thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (grainsize, n - local_offset)); 
# 586
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), results, local_size, (stage.keys) + local_offset); 
# 587
(g.wait()); 
# 590
keys_result = bulk_::copy_n(g, stage.keys, n, keys_result); 
# 593
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), indices, local_size, (stage.indices) + local_offset); 
# 594
(g.wait()); 
# 597
values_result = bulk_::gather(g, stage.indices, (stage.indices) + n, thrust::detail::make_join_iterator(values_first1, n1, values_first2), values_result); 
# 606
return thrust::make_pair(keys_result, values_result); 
# 607
} 
#endif
# 610 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/merge.hpp"
}
# 611
}}}}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 23
namespace bulk_ { 
# 27
template< std::size_t bound, std::size_t 
# 28
grainsize, class 
# 29
RandomAccessIterator1, class 
# 30
RandomAccessIterator2, class 
# 31
RandomAccessIterator3, class 
# 32
RandomAccessIterator4> 
# 33
__attribute((always_inline)) __attribute__((unused)) inline void 
# 34
scatter_if(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator1 
# 35
first, RandomAccessIterator1 
# 36
last, RandomAccessIterator2 
# 37
map, RandomAccessIterator3 
# 38
stencil, RandomAccessIterator4 
# 39
result) 
# 40
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)map;(void)stencil;(void)result;
# 52
::exit(___);}
#if 0
# 40
{ 
# 41
typedef int size_type; 
# 43
size_type n = last - first; 
# 45
for (size_type i = 0; i < bound; ++i) 
# 46
{ 
# 47
if ((i < n) && (stencil[i])) 
# 48
{ 
# 49
(result[map[i]]) = (first[i]); 
# 50
}  
# 51
}  
# 52
} 
#endif
# 55 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp"
template< std::size_t bound, std::size_t 
# 56
groupsize, std::size_t 
# 57
grainsize, class 
# 58
RandomAccessIterator1, class 
# 59
RandomAccessIterator2, class 
# 60
RandomAccessIterator3, class 
# 61
RandomAccessIterator4> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize)> ::type 
# 66
scatter_if(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &
# 69
g, RandomAccessIterator1 
# 70
first, RandomAccessIterator1 
# 71
last, RandomAccessIterator2 
# 72
map, RandomAccessIterator3 
# 73
stencil, RandomAccessIterator4 
# 74
result) 
# 75
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)map;(void)stencil;(void)result;
# 112
::exit(___);}
#if 0
# 75
{ 
# 79
typedef typename bounded< bound, concurrent_group< agent< grainsize> , groupsize> > ::size_type size_type; 
# 81
size_type n = last - first; 
# 83
size_type tid = ((g.this_exec).index()); 
# 86
if (n == bound) 
# 87
{ 
# 88
for (size_type i = (0); i < ((g.this_exec).grainsize()); ++i) 
# 89
{ 
# 90
size_type idx = ((g.size()) * i) + tid; 
# 92
if (stencil[idx]) 
# 93
{ 
# 94
(result[map[idx]]) = (first[idx]); 
# 95
}  
# 96
}  
# 97
} else { 
# 98
if (n < bound) 
# 99
{ 
# 100
for (size_type i = (0); i < ((g.this_exec).grainsize()); ++i) 
# 101
{ 
# 102
size_type idx = ((g.size()) * i) + tid; 
# 104
if ((idx < (last - first)) && (stencil[idx])) 
# 105
{ 
# 106
(result[map[idx]]) = (first[idx]); 
# 107
}  
# 108
}  
# 109
}  }  
# 111
(g.wait()); 
# 112
} 
#endif
# 115 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp"
template< std::size_t groupsize, std::size_t 
# 116
grainsize, class 
# 117
RandomAccessIterator1, class 
# 118
RandomAccessIterator2, class 
# 119
RandomAccessIterator3, class 
# 120
RandomAccessIterator4> __attribute__((unused)) void 
# 122
scatter_if(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator1 
# 123
first, RandomAccessIterator1 
# 124
last, RandomAccessIterator2 
# 125
map, RandomAccessIterator3 
# 126
stencil, RandomAccessIterator4 
# 127
result) 
# 128
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)map;(void)stencil;(void)result;
# 197
::exit(___);}
#if 0
# 128
{ 
# 129
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 131
size_type chunk_size = (g.size()) * grainsize; 
# 133
size_type n = last - first; 
# 135
size_type tid = ((g.this_exec).index()); 
# 138
if (chunk_size == n) 
# 139
{ 
# 140
for (size_type i = (0); i < grainsize; ++i) 
# 141
{ 
# 142
size_type idx = ((g.size()) * i) + tid; 
# 144
if (stencil[idx]) 
# 145
{ 
# 146
(result[map[idx]]) = (first[idx]); 
# 147
}  
# 148
}  
# 149
} else { 
# 150
if (n < chunk_size) 
# 151
{ 
# 152
for (size_type i = (0); i < grainsize; ++i) 
# 153
{ 
# 154
size_type idx = ((g.size()) * i) + tid; 
# 156
if ((idx < (last - first)) && (stencil[idx])) 
# 157
{ 
# 158
(result[map[idx]]) = (first[idx]); 
# 159
}  
# 160
}  
# 161
} else 
# 163
{ 
# 164
for (; first < last; ((first += chunk_size), (map += chunk_size)), (stencil += chunk_size)) 
# 167
{ 
# 168
if ((last - first) >= chunk_size) 
# 169
{ 
# 171
for (size_type i = (0); i < grainsize; ++i) 
# 172
{ 
# 173
size_type idx = ((g.size()) * i) + tid; 
# 175
if (stencil[idx]) 
# 176
{ 
# 177
(result[map[idx]]) = (first[idx]); 
# 178
}  
# 179
}  
# 180
} else 
# 182
{ 
# 183
for (size_type i = (0); i < grainsize; ++i) 
# 184
{ 
# 185
size_type idx = ((g.size()) * i) + tid; 
# 187
if ((idx < (last - first)) && (stencil[idx])) 
# 188
{ 
# 189
(result[map[idx]]) = (first[idx]); 
# 190
}  
# 191
}  
# 192
}  
# 193
}  
# 194
}  }  
# 196
(g.wait()); 
# 197
} 
#endif
# 200 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/scatter.hpp"
}
# 201
}}}}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 23
namespace bulk_ { 
# 27
template< std::size_t grainsize, class 
# 28
RandomAccessIterator1, class 
# 29
RandomAccessIterator2, class 
# 30
T, class 
# 31
BinaryOperation> __attribute__((unused)) RandomAccessIterator2 
# 33
adjacent_difference(agent< grainsize>  &exec, RandomAccessIterator1 
# 34
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 35
result, T 
# 36
init, BinaryOperation 
# 37
binary_op) 
# 38
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 47
::exit(___);}
#if 0
# 38
{ 
# 39
for (; first != last; (++first), (++result)) 
# 40
{ 
# 41
T temp = *first; 
# 42
(*result) = binary_op(temp, init); 
# 43
init = temp; 
# 44
}  
# 46
return result; 
# 47
} 
#endif
# 50 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp"
template< std::size_t groupsize, std::size_t 
# 51
grainsize_, class 
# 52
RandomAccessIterator1, class 
# 53
RandomAccessIterator2, class 
# 54
T, class 
# 55
BinaryOperation> __attribute__((unused)) RandomAccessIterator2 
# 57
adjacent_difference(concurrent_group< agent< grainsize_> , groupsize>  &g, RandomAccessIterator1 
# 58
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 59
result, T 
# 60
init, BinaryOperation 
# 61
binary_op) 
# 62
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 107
::exit(___);}
#if 0
# 62
{ 
# 67
typedef typename concurrent_group< agent< grainsize_> , groupsize> ::size_type size_type; 
# 69
RandomAccessIterator2 return_me = result + (last - first); 
# 71
const size_type grainsize = ((g.this_exec).grainsize()); 
# 72
const size_type tile_size = (g.size()) * grainsize; 
# 75
RandomAccessIterator1 first_init = (first + (grainsize * ((g.this_exec).index()))) - 1; 
# 76
if ((first <= first_init) && (first_init < last)) 
# 77
{ 
# 78
init = (*first_init); 
# 79
}  
# 81
(g.wait()); 
# 83
for (; first < last; (first += tile_size), (result += tile_size)) 
# 84
{ 
# 85
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 86
size_type local_size = thrust::max(0, thrust::min< typename concurrent_group< agent< grainsize_> , groupsize> ::size_type> (grainsize, last - (first + local_offset))); 
# 89
T next_init = ((((first + local_offset) + tile_size) - 1) < last) ? first[tile_size - 1] : init; 
# 91
(g.wait()); 
# 94
bulk_::adjacent_difference((g.this_exec), first + local_offset, (first + local_offset) + local_size, result + local_offset, init, binary_op); 
# 101
init = next_init; 
# 102
}  
# 104
(g.wait()); 
# 106
return return_me; 
# 107
} 
#endif
# 110 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp"
template< std::size_t groupsize, std::size_t 
# 111
grainsize, class 
# 112
RandomAccessIterator1, class 
# 113
RandomAccessIterator2, class 
# 114
BinaryOperation> __attribute__((unused)) RandomAccessIterator2 
# 116
adjacent_difference(concurrent_group< agent< grainsize> , groupsize>  &g, RandomAccessIterator1 
# 117
first, RandomAccessIterator1 last, RandomAccessIterator2 
# 118
result, BinaryOperation 
# 119
binary_op) 
# 120
{int volatile ___ = 1;(void)g;(void)first;(void)last;(void)result;(void)binary_op;
# 137
::exit(___);}
#if 0
# 120
{ 
# 121
if (first < last) 
# 122
{ 
# 123
typename iterator_value< RandomAccessIterator1> ::type init = *first; 
# 126
(g.wait()); 
# 128
if (((g.this_exec).index()) == 0) 
# 129
{ 
# 130
(*result) = init; 
# 131
}  
# 133
result = bulk_::adjacent_difference(g, first + 1, last, result + 1, init, binary_op); 
# 134
}  
# 136
return result; 
# 137
} 
#endif
# 140 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/adjacent_difference.hpp"
}
# 141
}}}}
# 23 "/usr/local/cuda/include/thrust/iterator/detail/transform_iterator.inl"
namespace thrust { 
# 26
template< class UnaryFunction, class Iterator, class Reference, class Value> class transform_iterator; 
# 29
namespace detail { 
# 33
template< class UnaryFunc, class Iterator, class Reference, class Value> 
# 34
struct transform_iterator_base { 
# 41
private: typedef typename ia_dflt_help< Reference, result_of_adaptable_function< UnaryFunc (typename iterator_value< Iterator> ::type)> > ::type reference; 
# 51
typedef typename ia_dflt_help< Value, remove_reference< typename ia_dflt_help< Reference, result_of_adaptable_function< UnaryFunc (typename iterator_value< Iterator> ::type)> > ::type> > ::type cv_value_type; 
# 66
public: typedef iterator_adaptor< transform_iterator< UnaryFunc, Iterator, Reference, Value> , Iterator, typename ia_dflt_help< Value, remove_reference< typename ia_dflt_help< Reference, result_of_adaptable_function< UnaryFunc (typename iterator_value< Iterator> ::type)> > ::type> > ::type, use_default, typename iterator_traits< Iterator> ::iterator_category, typename ia_dflt_help< Reference, result_of_adaptable_function< UnaryFunc (typename iterator_value< Iterator> ::type)> > ::type>  type; 
# 67
}; 
# 70
}
# 71
}
# 43 "/usr/local/cuda/include/thrust/iterator/transform_iterator.h"
namespace thrust { 
# 189
template< class AdaptableUnaryFunction, class Iterator, class Reference = use_default, class Value = use_default> 
# 190
class transform_iterator : public detail::transform_iterator_base< AdaptableUnaryFunction, Iterator, Reference, Value> ::type { 
# 198
public: typedef typename ::thrust::detail::transform_iterator_base< AdaptableUnaryFunction, Iterator, Reference, Value> ::type super_t; 
# 200
friend class iterator_core_access; 
# 208
transform_iterator() { } 
# 217
transform_iterator(const Iterator &x, AdaptableUnaryFunction f) : super_t(x), m_f(f) 
# 218
{ 
# 219
} 
# 227
explicit transform_iterator(const Iterator &x) : super_t(x) 
# 228
{ } 
# 235
template< class OtherAdaptableUnaryFunction, class 
# 236
OtherIterator, class 
# 237
OtherReference, class 
# 238
OtherValue> 
# 240
transform_iterator(const ::thrust::transform_iterator< OtherAdaptableUnaryFunction, OtherIterator, OtherReference, OtherValue>  &other, typename ::thrust::detail::enable_if_convertible< OtherIterator, Iterator> ::type * = 0, typename ::thrust::detail::enable_if_convertible< OtherAdaptableUnaryFunction, AdaptableUnaryFunction> ::type * = 0) : super_t((other.base())), m_f((other.functor())) 
# 243
{ } 
# 256
transform_iterator &operator=(const transform_iterator &other) 
# 257
{ 
# 258
return do_assign(other, typename ::thrust::detail::is_copy_assignable< AdaptableUnaryFunction> ::type()); 
# 266
} 
# 272
AdaptableUnaryFunction functor() const 
# 273
{ return m_f; } 
# 279
private: transform_iterator &do_assign(const transform_iterator &other, ::thrust::detail::true_type) 
# 280
{ 
# 281
::thrust::detail::transform_iterator_base< AdaptableUnaryFunction, Iterator, Reference, Value> ::type::operator=(other); 
# 284
(m_f) = other.functor(); 
# 286
return *this; 
# 287
} 
# 290
transform_iterator &do_assign(const transform_iterator &other, ::thrust::detail::false_type) 
# 291
{ 
# 292
::thrust::detail::transform_iterator_base< AdaptableUnaryFunction, Iterator, Reference, Value> ::type::operator=(other); 
# 296
return *this; 
# 297
} 
# 301
typename ::thrust::detail::transform_iterator_base< AdaptableUnaryFunction, Iterator, Reference, Value> ::type::reference dereference() const 
# 302
{ 
# 305
typename iterator_value< Iterator> ::type x = *(this->base()); 
# 306
return (m_f)(x); 
# 307
} 
# 311
mutable AdaptableUnaryFunction m_f; 
# 315
}; 
# 329
template< class AdaptableUnaryFunction, class Iterator> inline transform_iterator< AdaptableUnaryFunction, Iterator>  
# 332
make_transform_iterator(Iterator it, AdaptableUnaryFunction fun) 
# 333
{ 
# 334
return transform_iterator< AdaptableUnaryFunction, Iterator> (it, fun); 
# 335
} 
# 343
}
# 21 "/usr/local/cuda/include/thrust/iterator/detail/minimum_category.h"
namespace thrust { 
# 24
namespace detail { 
# 27
template< class T1, class 
# 28
T2 = minimum_type_detail::any_conversion, class 
# 29
T3 = minimum_type_detail::any_conversion, class 
# 30
T4 = minimum_type_detail::any_conversion, class 
# 31
T5 = minimum_type_detail::any_conversion, class 
# 32
T6 = minimum_type_detail::any_conversion, class 
# 33
T7 = minimum_type_detail::any_conversion, class 
# 34
T8 = minimum_type_detail::any_conversion, class 
# 35
T9 = minimum_type_detail::any_conversion, class 
# 36
T10 = minimum_type_detail::any_conversion, class 
# 37
T11 = minimum_type_detail::any_conversion, class 
# 38
T12 = minimum_type_detail::any_conversion, class 
# 39
T13 = minimum_type_detail::any_conversion, class 
# 40
T14 = minimum_type_detail::any_conversion, class 
# 41
T15 = minimum_type_detail::any_conversion, class 
# 42
T16 = minimum_type_detail::any_conversion> 
# 43
struct minimum_category : public minimum_type< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>  { 
# 46
}; 
# 48
}
# 50
}
# 21 "/usr/local/cuda/include/thrust/detail/tuple_meta_transform.h"
namespace thrust { 
# 24
namespace detail { 
# 27
template< class Tuple, 
# 28
template< class >  class UnaryMetaFunction, unsigned 
# 29
sz = tuple_size< Tuple> ::value> struct tuple_meta_transform; 
# 32
template< class Tuple, 
# 33
template< class >  class UnaryMetaFunction> 
# 34
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 0>  { 
# 36
typedef null_type type; 
# 37
}; 
# 39
template< class Tuple, 
# 40
template< class >  class UnaryMetaFunction> 
# 41
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 1>  { 
# 45
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 46
}; 
# 48
template< class Tuple, 
# 49
template< class >  class UnaryMetaFunction> 
# 50
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 2>  { 
# 55
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 56
}; 
# 58
template< class Tuple, 
# 59
template< class >  class UnaryMetaFunction> 
# 60
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 3>  { 
# 66
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 67
}; 
# 69
template< class Tuple, 
# 70
template< class >  class UnaryMetaFunction> 
# 71
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 4>  { 
# 78
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type, null_type>  type; 
# 79
}; 
# 81
template< class Tuple, 
# 82
template< class >  class UnaryMetaFunction> 
# 83
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 5>  { 
# 91
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, null_type, null_type, null_type, null_type, null_type>  type; 
# 92
}; 
# 94
template< class Tuple, 
# 95
template< class >  class UnaryMetaFunction> 
# 96
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 6>  { 
# 105
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, null_type, null_type, null_type, null_type>  type; 
# 106
}; 
# 108
template< class Tuple, 
# 109
template< class >  class UnaryMetaFunction> 
# 110
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 7>  { 
# 120
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, null_type, null_type, null_type>  type; 
# 121
}; 
# 123
template< class Tuple, 
# 124
template< class >  class UnaryMetaFunction> 
# 125
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 8>  { 
# 136
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, null_type, null_type>  type; 
# 137
}; 
# 139
template< class Tuple, 
# 140
template< class >  class UnaryMetaFunction> 
# 141
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 9>  { 
# 153
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 8, Tuple> ::type> ::type, null_type>  type; 
# 154
}; 
# 156
template< class Tuple, 
# 157
template< class >  class UnaryMetaFunction> 
# 158
struct tuple_meta_transform< Tuple, UnaryMetaFunction, 10>  { 
# 171
typedef tuple< typename UnaryMetaFunction< typename tuple_element< 0, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 1, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 2, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 3, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 4, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 5, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 6, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 7, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 8, Tuple> ::type> ::type, typename UnaryMetaFunction< typename tuple_element< 9, Tuple> ::type> ::type>  type; 
# 172
}; 
# 174
}
# 176
}
# 22 "/usr/local/cuda/include/thrust/detail/tuple_transform.h"
namespace thrust { 
# 25
namespace detail { 
# 28
template< class Tuple, 
# 29
template< class >  class UnaryMetaFunction, class 
# 30
UnaryFunction, unsigned 
# 31
sz = tuple_size< Tuple> ::value> struct tuple_transform_functor; 
# 35
template< class Tuple, 
# 36
template< class >  class UnaryMetaFunction, class 
# 37
UnaryFunction> 
# 38
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 0>  { 
# 42
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 43
{ 
# 44
return null_type(); 
# 45
} 
# 49
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 50
{ 
# 51
return null_type(); 
# 52
} 
# 53
}; 
# 56
template< class Tuple, 
# 57
template< class >  class UnaryMetaFunction, class 
# 58
UnaryFunction> 
# 59
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 1>  { 
# 63
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 64
{ 
# 65
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 67
return (XfrmTuple)f(thrust::get< 0> (t)); 
# 68
} 
# 72
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 73
{ 
# 74
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 76
return (XfrmTuple)f(thrust::get< 0> (t)); 
# 77
} 
# 78
}; 
# 81
template< class Tuple, 
# 82
template< class >  class UnaryMetaFunction, class 
# 83
UnaryFunction> 
# 84
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 2>  { 
# 88
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 89
{ 
# 90
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 92
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t))); 
# 94
} 
# 98
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 99
{ 
# 100
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 102
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t))); 
# 104
} 
# 105
}; 
# 108
template< class Tuple, 
# 109
template< class >  class UnaryMetaFunction, class 
# 110
UnaryFunction> 
# 111
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 3>  { 
# 115
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 116
{ 
# 117
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 119
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t))); 
# 122
} 
# 126
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 127
{ 
# 128
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 130
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t))); 
# 133
} 
# 134
}; 
# 137
template< class Tuple, 
# 138
template< class >  class UnaryMetaFunction, class 
# 139
UnaryFunction> 
# 140
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 4>  { 
# 144
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 145
{ 
# 146
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 148
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t))); 
# 152
} 
# 156
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 157
{ 
# 158
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 160
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t))); 
# 164
} 
# 165
}; 
# 168
template< class Tuple, 
# 169
template< class >  class UnaryMetaFunction, class 
# 170
UnaryFunction> 
# 171
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 5>  { 
# 175
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 176
{ 
# 177
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 179
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t))); 
# 184
} 
# 188
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 189
{ 
# 190
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 192
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t))); 
# 197
} 
# 198
}; 
# 201
template< class Tuple, 
# 202
template< class >  class UnaryMetaFunction, class 
# 203
UnaryFunction> 
# 204
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 6>  { 
# 208
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 209
{ 
# 210
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 212
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t))); 
# 218
} 
# 222
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 223
{ 
# 224
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 226
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t))); 
# 232
} 
# 233
}; 
# 236
template< class Tuple, 
# 237
template< class >  class UnaryMetaFunction, class 
# 238
UnaryFunction> 
# 239
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 7>  { 
# 243
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 244
{ 
# 245
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 247
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t))); 
# 254
} 
# 258
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 259
{ 
# 260
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 262
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t))); 
# 269
} 
# 270
}; 
# 273
template< class Tuple, 
# 274
template< class >  class UnaryMetaFunction, class 
# 275
UnaryFunction> 
# 276
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 8>  { 
# 280
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 281
{ 
# 282
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 284
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t))); 
# 292
} 
# 296
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 297
{ 
# 298
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 300
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t))); 
# 308
} 
# 309
}; 
# 312
template< class Tuple, 
# 313
template< class >  class UnaryMetaFunction, class 
# 314
UnaryFunction> 
# 315
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 9>  { 
# 319
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 320
{ 
# 321
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 323
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t))); 
# 332
} 
# 336
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 337
{ 
# 338
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 340
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t))); 
# 349
} 
# 350
}; 
# 353
template< class Tuple, 
# 354
template< class >  class UnaryMetaFunction, class 
# 355
UnaryFunction> 
# 356
struct tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction, 10>  { 
# 360
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host(const Tuple &t, UnaryFunction f) 
# 361
{ 
# 362
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 364
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t)), f(thrust::get< 9> (t))); 
# 374
} 
# 378
static typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type do_it_on_the_host_or_device(const Tuple &t, UnaryFunction f) 
# 379
{ 
# 380
typedef typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type XfrmTuple; 
# 382
return XfrmTuple(f(thrust::get< 0> (t)), f(thrust::get< 1> (t)), f(thrust::get< 2> (t)), f(thrust::get< 3> (t)), f(thrust::get< 4> (t)), f(thrust::get< 5> (t)), f(thrust::get< 6> (t)), f(thrust::get< 7> (t)), f(thrust::get< 8> (t)), f(thrust::get< 9> (t))); 
# 392
} 
# 393
}; 
# 396
template< template< class >  class UnaryMetaFunction, class 
# 397
Tuple, class 
# 398
UnaryFunction> typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type 
# 400
tuple_host_transform(const Tuple &t, UnaryFunction f) 
# 401
{ 
# 402
return tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction> ::do_it_on_the_host(t, f); 
# 403
} 
# 405
template< template< class >  class UnaryMetaFunction, class 
# 406
Tuple, class 
# 407
UnaryFunction> typename tuple_meta_transform< Tuple, UnaryMetaFunction> ::type 
# 410
tuple_host_device_transform(const Tuple &t, UnaryFunction f) 
# 411
{ 
# 412
return tuple_transform_functor< Tuple, UnaryMetaFunction, UnaryFunction> ::do_it_on_the_host_or_device(t, f); 
# 413
} 
# 415
}
# 417
}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/tuple_of_iterator_references.h"
namespace thrust { 
# 26
namespace detail { 
# 30
template< class 
# 31
T0, class T1, class T2, class 
# 32
T3, class T4, class T5, class 
# 33
T6, class T7, class T8, class 
# 34
T9> 
# 36
class tuple_of_iterator_references : public tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  { 
# 40
typedef ::thrust::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  super_t; 
# 45
public: tuple_of_iterator_references(const super_t &other) : super_t(other) 
# 47
{ } 
# 51
template< class U1, class U2> tuple_of_iterator_references &
# 53
operator=(const cons< U1, U2>  &other) 
# 54
{ 
# 55
::thrust::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::operator=(other); 
# 56
return *this; 
# 57
} 
# 61
template< class U1, class U2> tuple_of_iterator_references &
# 63
operator=(const pair< U1, U2>  &other) 
# 64
{ 
# 65
::thrust::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::operator=(other); 
# 66
return *this; 
# 67
} 
# 72
template< class U0, class U1, class U2, class 
# 73
U3, class U4, class U5, class 
# 74
U6, class U7, class U8, class 
# 75
U9, class 
# 76
Pointer, class Derived> tuple_of_iterator_references &
# 87
operator=(const reference< ::thrust::tuple< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9> , Pointer, Derived>  &other) 
# 88
{ 
# 89
typedef ::thrust::tuple< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9>  tuple_type; 
# 92
tuple_type other_tuple = other; 
# 93
::thrust::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ::operator=(other_tuple); 
# 94
return *this; 
# 95
} 
# 100
tuple_of_iterator_references() { } 
# 103
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0) : super_t(t0, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 114
{ } 
# 117
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 118
t1) : super_t(t0, t1, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 128
{ } 
# 131
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 132
t1, typename access_traits< T2> ::parameter_type 
# 133
t2) : super_t(t0, t1, t2, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 142
{ } 
# 145
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 146
t1, typename access_traits< T2> ::parameter_type 
# 147
t2, typename access_traits< T3> ::parameter_type 
# 148
t3) : super_t(t0, t1, t2, t3, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 156
{ } 
# 159
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 160
t1, typename access_traits< T2> ::parameter_type 
# 161
t2, typename access_traits< T3> ::parameter_type 
# 162
t3, typename access_traits< T4> ::parameter_type 
# 163
t4) : super_t(t0, t1, t2, t3, t4, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 170
{ } 
# 173
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 174
t1, typename access_traits< T2> ::parameter_type 
# 175
t2, typename access_traits< T3> ::parameter_type 
# 176
t3, typename access_traits< T4> ::parameter_type 
# 177
t4, typename access_traits< T5> ::parameter_type 
# 178
t5) : super_t(t0, t1, t2, t3, t4, t5, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 184
{ } 
# 187
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 188
t1, typename access_traits< T2> ::parameter_type 
# 189
t2, typename access_traits< T3> ::parameter_type 
# 190
t3, typename access_traits< T4> ::parameter_type 
# 191
t4, typename access_traits< T5> ::parameter_type 
# 192
t5, typename access_traits< T6> ::parameter_type 
# 193
t6) : super_t(t0, t1, t2, t3, t4, t5, t6, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 198
{ } 
# 201
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 202
t1, typename access_traits< T2> ::parameter_type 
# 203
t2, typename access_traits< T3> ::parameter_type 
# 204
t3, typename access_traits< T4> ::parameter_type 
# 205
t4, typename access_traits< T5> ::parameter_type 
# 206
t5, typename access_traits< T6> ::parameter_type 
# 207
t6, typename access_traits< T7> ::parameter_type 
# 208
t7) : super_t(t0, t1, t2, t3, t4, t5, t6, t7, static_cast< const ::thrust::null_type &>(::thrust::null_type()), static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 212
{ } 
# 215
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 216
t1, typename access_traits< T2> ::parameter_type 
# 217
t2, typename access_traits< T3> ::parameter_type 
# 218
t3, typename access_traits< T4> ::parameter_type 
# 219
t4, typename access_traits< T5> ::parameter_type 
# 220
t5, typename access_traits< T6> ::parameter_type 
# 221
t6, typename access_traits< T7> ::parameter_type 
# 222
t7, typename access_traits< T8> ::parameter_type 
# 223
t8) : super_t(t0, t1, t2, t3, t4, t5, t6, t7, t8, static_cast< const ::thrust::null_type &>(::thrust::null_type())) 
# 226
{ } 
# 229
tuple_of_iterator_references(typename access_traits< T0> ::parameter_type t0, typename access_traits< T1> ::parameter_type 
# 230
t1, typename access_traits< T2> ::parameter_type 
# 231
t2, typename access_traits< T3> ::parameter_type 
# 232
t3, typename access_traits< T4> ::parameter_type 
# 233
t4, typename access_traits< T5> ::parameter_type 
# 234
t5, typename access_traits< T6> ::parameter_type 
# 235
t6, typename access_traits< T7> ::parameter_type 
# 236
t7, typename access_traits< T8> ::parameter_type 
# 237
t8, typename access_traits< T9> ::parameter_type 
# 238
t9) : super_t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) 
# 240
{ } 
# 241
}; 
# 244
}
# 245
}
# 30 "/usr/local/cuda/include/thrust/iterator/detail/zip_iterator_base.h"
namespace thrust { 
# 34
template< class IteratorTuple> class zip_iterator; 
# 36
namespace detail { 
# 42
template< class DiffType> 
# 43
class advance_iterator { 
# 47
public: advance_iterator(DiffType step) : m_step(step) { } 
# 50
template< class Iterator> void 
# 52
operator()(Iterator &it) const 
# 53
{ it += (m_step); } 
# 56
private: DiffType m_step; 
# 57
}; 
# 60
struct increment_iterator { 
# 63
template< class Iterator> void 
# 65
operator()(Iterator &it) 
# 66
{ ++it; } 
# 67
}; 
# 70
struct decrement_iterator { 
# 73
template< class Iterator> void 
# 75
operator()(Iterator &it) 
# 76
{ --it; } 
# 77
}; 
# 80
struct dereference_iterator { 
# 82
template< class Iterator> 
# 83
struct apply { 
# 87
typedef typename iterator_traits< Iterator> ::reference type; 
# 88
}; 
# 92
template< class Iterator> typename apply< Iterator> ::type 
# 94
operator()(const Iterator &it) 
# 95
{ 
# 96
return *it; 
# 97
} 
# 98
}; 
# 103
namespace tuple_impl_specific { 
# 107
template< class UnaryMetaFunctionClass, class Arg> 
# 108
struct apply1 : public UnaryMetaFunctionClass::template apply< Arg>  { 
# 111
}; 
# 115
template< class UnaryMetaFunctionClass, class Arg1, class Arg2> 
# 116
struct apply2 : public UnaryMetaFunctionClass::template apply< Arg1, Arg2>  { 
# 119
}; 
# 126
template< class Tuple, class BinaryMetaFun, class StartType> struct tuple_meta_accumulate; 
# 129
template< class 
# 130
Tuple, class 
# 131
BinaryMetaFun, class 
# 132
StartType> 
# 134
struct tuple_meta_accumulate_impl { 
# 144
typedef typename apply2< BinaryMetaFun, typename Tuple::head_type, typename tuple_meta_accumulate< typename Tuple::tail_type, BinaryMetaFun, StartType> ::type> ::type type; 
# 145
}; 
# 148
template< class 
# 149
Tuple, class 
# 150
BinaryMetaFun, class 
# 151
StartType> 
# 153
struct tuple_meta_accumulate : public eval_if< is_same< Tuple, null_type> ::value, identity_< StartType> , tuple_meta_accumulate_impl< Tuple, BinaryMetaFun, StartType> >  { 
# 164
}; 
# 187
template< class Fun> inline Fun 
# 189
tuple_for_each(null_type, Fun f) 
# 190
{ 
# 191
return f; 
# 192
} 
# 195
template< class Tuple, class Fun> inline Fun 
# 197
tuple_for_each(Tuple &t, Fun f) 
# 198
{ 
# 199
f((t.get_head())); 
# 200
return tuple_for_each((t.get_tail()), f); 
# 201
} 
# 210
inline bool tuple_equal(null_type, null_type) 
# 211
{ return true; } 
# 214
template< class Tuple1, class Tuple2> bool 
# 216
tuple_equal(const Tuple1 &t1, const Tuple2 &t2) 
# 217
{ 
# 218
return ((t1.get_head()) == (t2.get_head())) && tuple_equal((t1.get_tail()), (t2.get_tail())); 
# 220
} 
# 222
}
# 228
template< class IteratorTuple> 
# 229
struct tuple_of_value_types : public tuple_meta_transform< IteratorTuple, iterator_value>  { 
# 235
}; 
# 238
struct minimum_category_lambda { 
# 240
template< class T1, class T2> 
# 241
struct apply : public minimum_category< T1, T2>  { 
# 242
}; 
# 243
}; 
# 250
template< class IteratorTuple> 
# 251
struct minimum_traversal_category_in_iterator_tuple { 
# 256
typedef typename tuple_meta_transform< IteratorTuple, iterator_traversal> ::type tuple_of_traversal_tags; 
# 262
typedef typename tuple_impl_specific::tuple_meta_accumulate< typename tuple_meta_transform< IteratorTuple, iterator_traversal> ::type, minimum_category_lambda, random_access_traversal_tag> ::type type; 
# 263
}; 
# 266
struct minimum_system_lambda { 
# 268
template< class T1, class T2> 
# 269
struct apply : public minimum_system< T1, T2>  { 
# 270
}; 
# 271
}; 
# 277
template< class IteratorTuple> 
# 278
struct minimum_system_in_iterator_tuple { 
# 283
typedef typename tuple_meta_transform< IteratorTuple, iterator_system> ::type tuple_of_system_tags; 
# 289
typedef typename tuple_impl_specific::tuple_meta_accumulate< typename tuple_meta_transform< IteratorTuple, iterator_system> ::type, minimum_system_lambda, any_system_tag> ::type type; 
# 290
}; 
# 292
namespace zip_iterator_base_ns { 
# 296
template< int i, class Tuple> 
# 297
struct tuple_elements_helper : public eval_if< i < tuple_size< Tuple> ::value, tuple_element< i, Tuple> , identity_< null_type> >  { 
# 303
}; 
# 306
template< class Tuple> 
# 307
struct tuple_elements { 
# 309
typedef typename tuple_elements_helper< 0, Tuple> ::type T0; 
# 310
typedef typename tuple_elements_helper< 1, Tuple> ::type T1; 
# 311
typedef typename tuple_elements_helper< 2, Tuple> ::type T2; 
# 312
typedef typename tuple_elements_helper< 3, Tuple> ::type T3; 
# 313
typedef typename tuple_elements_helper< 4, Tuple> ::type T4; 
# 314
typedef typename tuple_elements_helper< 5, Tuple> ::type T5; 
# 315
typedef typename tuple_elements_helper< 6, Tuple> ::type T6; 
# 316
typedef typename tuple_elements_helper< 7, Tuple> ::type T7; 
# 317
typedef typename tuple_elements_helper< 8, Tuple> ::type T8; 
# 318
typedef typename tuple_elements_helper< 9, Tuple> ::type T9; 
# 319
}; 
# 322
template< class IteratorTuple> 
# 323
struct tuple_of_iterator_references { 
# 329
typedef typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type tuple_of_references; 
# 332
typedef tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type>  elements; 
# 346
typedef detail::tuple_of_iterator_references< typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T0, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T1, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T2, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T3, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T4, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T5, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T6, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T7, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T8, typename tuple_elements< typename tuple_meta_transform< IteratorTuple, iterator_reference> ::type> ::T9>  type; 
# 347
}; 
# 350
}
# 359
template< class IteratorTuple> 
# 360
struct zip_iterator_base { 
# 365
typedef typename zip_iterator_base_ns::tuple_of_iterator_references< IteratorTuple> ::type reference; 
# 369
typedef typename tuple_of_value_types< IteratorTuple> ::type value_type; 
# 374
typedef typename iterator_traits< typename tuple_element< 0, IteratorTuple> ::type> ::difference_type difference_type; 
# 379
typedef typename minimum_system_in_iterator_tuple< IteratorTuple> ::type system; 
# 384
typedef typename minimum_traversal_category_in_iterator_tuple< IteratorTuple> ::type traversal_category; 
# 397
typedef iterator_facade< zip_iterator< IteratorTuple> , typename tuple_of_value_types< IteratorTuple> ::type, typename minimum_system_in_iterator_tuple< IteratorTuple> ::type, typename minimum_traversal_category_in_iterator_tuple< IteratorTuple> ::type, typename zip_iterator_base_ns::tuple_of_iterator_references< IteratorTuple> ::type, typename iterator_traits< typename tuple_element< 0, IteratorTuple> ::type> ::difference_type>  type; 
# 398
}; 
# 400
}
# 402
}
# 39 "/usr/local/cuda/include/thrust/iterator/zip_iterator.h"
namespace thrust { 
# 139
template< class IteratorTuple> 
# 140
class zip_iterator : public detail::zip_iterator_base< IteratorTuple> ::type { 
# 147
public: inline zip_iterator(); 
# 155
inline zip_iterator(IteratorTuple iterator_tuple); 
# 162
template< class OtherIteratorTuple> inline zip_iterator(const ::thrust::zip_iterator< OtherIteratorTuple>  & other, typename ::thrust::detail::enable_if_convertible< OtherIteratorTuple, IteratorTuple> ::type * = 0); 
# 177
inline const IteratorTuple &get_iterator_tuple() const; 
# 183
private: typedef typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type super_t; 
# 185
friend class iterator_core_access; 
# 190
typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type::reference dereference() const; 
# 195
template< class OtherIteratorTuple> inline bool equal(const ::thrust::zip_iterator< OtherIteratorTuple>  & other) const; 
# 201
inline void advance(typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type::difference_type n); 
# 205
inline void increment(); 
# 209
inline void decrement(); 
# 212
template< class OtherIteratorTuple> inline typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type::difference_type distance_to(const ::thrust::zip_iterator< OtherIteratorTuple>  & other) const; 
# 218
IteratorTuple m_iterator_tuple; 
# 222
}; 
# 232
template< class IteratorTuple> inline zip_iterator< IteratorTuple>  make_zip_iterator(IteratorTuple t); 
# 242
}
# 22 "/usr/local/cuda/include/thrust/iterator/detail/zip_iterator.inl"
namespace thrust { 
# 26
template< class IteratorTuple> inline 
# 29
zip_iterator< IteratorTuple> ::zip_iterator() 
# 30
{ 
# 31
} 
# 34
template< class IteratorTuple> inline 
# 37
zip_iterator< IteratorTuple> ::zip_iterator(IteratorTuple iterator_tuple) : m_iterator_tuple(iterator_tuple) 
# 39
{ 
# 40
} 
# 43
template< class IteratorTuple> 
# 44
template< class OtherIteratorTuple> inline 
# 47
zip_iterator< IteratorTuple> ::zip_iterator(const ::thrust::zip_iterator< OtherIteratorTuple>  &other, typename ::thrust::detail::enable_if_convertible< OtherIteratorTuple, IteratorTuple> ::type *) : m_iterator_tuple((other.get_iterator_tuple())) 
# 53
{ 
# 54
} 
# 57
template< class IteratorTuple> inline const IteratorTuple &
# 60
zip_iterator< IteratorTuple> ::get_iterator_tuple() const 
# 61
{ 
# 62
return m_iterator_tuple; 
# 63
} 
# 66
template< class IteratorTuple> typename detail::zip_iterator_base< IteratorTuple> ::type::reference 
# 70
zip_iterator< IteratorTuple> ::dereference() const 
# 71
{ 
# 72
using namespace ::thrust::detail::tuple_impl_specific;
# 74
return ::thrust::detail::tuple_host_device_transform< ::thrust::detail::dereference_iterator::template apply> (get_iterator_tuple(), ::thrust::detail::dereference_iterator()); 
# 75
} 
# 79
template< class IteratorTuple> 
# 80
template< class OtherIteratorTuple> inline bool 
# 83
zip_iterator< IteratorTuple> ::equal(const ::thrust::zip_iterator< OtherIteratorTuple>  &other) const 
# 84
{ 
# 85
return get< 0> (get_iterator_tuple()) == get< 0> ((other.get_iterator_tuple())); 
# 86
} 
# 89
template< class IteratorTuple> inline void 
# 92
zip_iterator< IteratorTuple> ::advance(typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type::difference_type n) 
# 93
{ 
# 94
using namespace ::thrust::detail::tuple_impl_specific;
# 95
tuple_for_each(m_iterator_tuple, ((::thrust::detail::advance_iterator< typename ::thrust::detail::zip_iterator_base< IteratorTuple> ::type::difference_type> )(n))); 
# 97
} 
# 100
template< class IteratorTuple> inline void 
# 103
zip_iterator< IteratorTuple> ::increment() 
# 104
{ 
# 105
using namespace ::thrust::detail::tuple_impl_specific;
# 106
tuple_for_each(m_iterator_tuple, ::thrust::detail::increment_iterator()); 
# 107
} 
# 110
template< class IteratorTuple> inline void 
# 113
zip_iterator< IteratorTuple> ::decrement() 
# 114
{ 
# 115
using namespace ::thrust::detail::tuple_impl_specific;
# 116
tuple_for_each(m_iterator_tuple, ::thrust::detail::decrement_iterator()); 
# 117
} 
# 121
template< class IteratorTuple> 
# 122
template< class OtherIteratorTuple> inline typename detail::zip_iterator_base< IteratorTuple> ::type::difference_type 
# 126
zip_iterator< IteratorTuple> ::distance_to(const ::thrust::zip_iterator< OtherIteratorTuple>  &other) const 
# 127
{ 
# 128
return get< 0> ((other.get_iterator_tuple())) - get< 0> (get_iterator_tuple()); 
# 129
} 
# 132
template< class IteratorTuple> inline zip_iterator< IteratorTuple>  
# 134
make_zip_iterator(IteratorTuple t) 
# 135
{ 
# 136
return ((zip_iterator< IteratorTuple> )(t)); 
# 137
} 
# 140
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/head_flags.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 28
namespace bulk_ { 
# 30
namespace detail { 
# 34
template< class RandomAccessIterator, class 
# 35
BinaryPredicate = equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 36
ValueType = bool, class 
# 37
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 38
class head_flags_with_init { 
# 40
typedef typename iterator_value< RandomAccessIterator> ::type init_type; 
# 45
public: struct head_flag_functor { 
# 47
BinaryPredicate binary_pred; 
# 48
init_type init; 
# 49
IndexType n; 
# 51
typedef ValueType result_type; 
# 54
head_flag_functor(init_type init, IndexType n) : binary_pred(), init(init), n(n) 
# 56
{ } 
# 59
head_flag_functor(init_type init, IndexType n, BinaryPredicate binary_pred) : binary_pred(binary_pred), init(init), n(n) 
# 61
{ } 
# 63
template< class Tuple> 
# 64
__attribute((always_inline)) result_type 
# 65
operator()(const Tuple &t) 
# 66
{ 
# 67
const IndexType i = thrust::get< 0> (t); 
# 69
if (i == 0) 
# 70
{ 
# 71
return !(binary_pred)(init, thrust::get< 1> (t)); 
# 72
}  
# 74
return !(binary_pred)(thrust::get< 1> (t), thrust::get< 2> (t)); 
# 75
} 
# 76
}; 
# 78
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 84
typedef transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > >  iterator; 
# 88
head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(init, last - first))), m_end((m_begin) + (last - first)) 
# 92
{ } 
# 95
head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(init, last - first, binary_pred))), m_end((m_begin) + (last - first)) 
# 99
{ } 
# 102
iterator begin() const 
# 103
{ 
# 104
return m_begin; 
# 105
} 
# 108
iterator end() const 
# 109
{ 
# 110
return m_end; 
# 111
} 
# 113
template< class OtherIndex> typename transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > > ::reference 
# 115
operator[](OtherIndex i) 
# 116
{ 
# 117
return *(begin() + i); 
# 118
} 
# 121
private: iterator m_begin, m_end; 
# 122
}; 
# 126
template< class RandomAccessIterator, class 
# 127
BinaryPredicate = equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 128
ValueType = bool, class 
# 129
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 131
class head_flags_ { 
# 136
public: struct head_flag_functor { 
# 138
BinaryPredicate binary_pred; 
# 139
IndexType n; 
# 141
typedef ValueType result_type; 
# 144
head_flag_functor(IndexType n) : binary_pred(), n(n) 
# 146
{ } 
# 149
head_flag_functor(IndexType n, BinaryPredicate binary_pred) : binary_pred(binary_pred), n(n) 
# 151
{ } 
# 153
template< class Tuple> 
# 154
__attribute((always_inline)) result_type 
# 155
operator()(const Tuple &t) 
# 156
{ 
# 157
const IndexType i = thrust::get< 0> (t); 
# 161
return (i == 0) || (!(binary_pred)(thrust::get< 1> (t), thrust::get< 2> (t))); 
# 162
} 
# 163
}; 
# 165
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 171
typedef transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > >  iterator; 
# 175
head_flags_(RandomAccessIterator first, RandomAccessIterator last) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), (head_flag_functor)(last - first))), m_end((m_begin) + (last - first)) 
# 179
{ } 
# 183
head_flags_(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(last - first, binary_pred))), m_end((m_begin) + (last - first)) 
# 187
{ } 
# 190
iterator begin() const 
# 191
{ 
# 192
return m_begin; 
# 193
} 
# 196
iterator end() const 
# 197
{ 
# 198
return m_end; 
# 199
} 
# 201
template< class OtherIndex> typename transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > > ::reference 
# 203
operator[](OtherIndex i) 
# 204
{ 
# 205
return *(begin() + i); 
# 206
} 
# 209
private: iterator m_begin, m_end; 
# 210
}; 
# 213
template< class RandomAccessIterator, class BinaryPredicate> head_flags_< RandomAccessIterator, BinaryPredicate>  
# 217
make_head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) 
# 218
{ 
# 220
return head_flags_< RandomAccessIterator, BinaryPredicate> (first, last, binary_pred); 
# 221
} 
# 224
template< class RandomAccessIterator> head_flags_< RandomAccessIterator>  
# 228
make_head_flags(RandomAccessIterator first, RandomAccessIterator last) 
# 229
{ 
# 231
return head_flags_< RandomAccessIterator> (first, last); 
# 232
} 
# 235
}
# 236
}
# 237
}}}}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/detail/tail_flags.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 28
namespace bulk_ { 
# 30
namespace detail { 
# 34
template< class RandomAccessIterator, class 
# 35
BinaryPredicate = equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 36
ValueType = bool, class 
# 37
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 38
class tail_flags_ { 
# 43
public: struct tail_flag_functor { 
# 45
BinaryPredicate binary_pred; 
# 46
RandomAccessIterator iter; 
# 47
IndexType n; 
# 49
typedef ValueType result_type; 
# 52
tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last) : binary_pred(), iter(first), n(last - first) 
# 54
{ } 
# 57
tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : binary_pred(binary_pred), iter(first), n(last - first) 
# 59
{ } 
# 61
__attribute((always_inline)) result_type 
# 62
operator()(const IndexType &i) 
# 63
{ 
# 64
return (i == ((n) - 1)) || (!(binary_pred)((iter)[i], (iter)[i + 1])); 
# 65
} 
# 66
}; 
# 68
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 74
typedef transform_iterator< tail_flag_functor, thrust::counting_iterator< IndexType> >  iterator; 
# 78
tail_flags_(RandomAccessIterator first, RandomAccessIterator last) : m_begin(thrust::make_transform_iterator(((thrust::counting_iterator< IndexType> )(0)), tail_flag_functor(first, last))), m_end((m_begin) + (last - first)) 
# 82
{ } 
# 86
tail_flags_(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(((thrust::counting_iterator< IndexType> )(0)), tail_flag_functor(first, last, binary_pred))), m_end((m_begin) + (last - first)) 
# 90
{ } 
# 93
iterator begin() const 
# 94
{ 
# 95
return m_begin; 
# 96
} 
# 99
iterator end() const 
# 100
{ 
# 101
return m_end; 
# 102
} 
# 104
template< class OtherIndex> typename transform_iterator< tail_flag_functor, thrust::counting_iterator< IndexType> > ::reference 
# 106
operator[](OtherIndex i) 
# 107
{ 
# 108
return *(begin() + i); 
# 109
} 
# 112
private: iterator m_begin, m_end; 
# 113
}; 
# 116
template< class RandomAccessIterator, class BinaryPredicate> tail_flags_< RandomAccessIterator, BinaryPredicate>  
# 120
make_tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) 
# 121
{ 
# 123
return tail_flags_< RandomAccessIterator, BinaryPredicate> (first, last, binary_pred); 
# 124
} 
# 127
template< class RandomAccessIterator> tail_flags_< RandomAccessIterator>  
# 131
make_tail_flags(RandomAccessIterator first, RandomAccessIterator last) 
# 132
{ 
# 134
return tail_flags_< RandomAccessIterator> (first, last); 
# 135
} 
# 138
}
# 139
}
# 140
}}}}
# 32 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 33
namespace bulk_ { 
# 35
namespace detail { 
# 37
namespace reduce_by_key_detail { 
# 41
template< class FlagType, class ValueType, class BinaryFunction> 
# 42
struct scan_head_flags_functor { 
# 44
BinaryFunction binary_op; 
# 46
typedef tuple< FlagType, ValueType, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  result_type; 
# 47
typedef result_type first_argument_type; 
# 48
typedef result_type second_argument_type; 
# 51
scan_head_flags_functor(BinaryFunction binary_op) : binary_op(binary_op) 
# 53
{ } 
# 56
result_type operator()(const first_argument_type &a, const second_argument_type &b) 
# 57
{ 
# 58
ValueType val = (thrust::get< 0> (b)) ? thrust::get< 1> (b) : (binary_op)(thrust::get< 1> (a), thrust::get< 1> (b)); 
# 59
FlagType flag = thrust::get< 0> (a) + thrust::get< 0> (b); 
# 60
return result_type(flag, val); 
# 61
} 
# 62
}; 
# 65
template< class ConcurrentGroup, class 
# 66
InputIterator1, class 
# 67
Size, class 
# 68
InputIterator2, class 
# 69
InputIterator3, class 
# 70
OutputIterator1, class 
# 71
OutputIterator2> __attribute__((unused)) void 
# 73
scatter_tails_n(ConcurrentGroup &group, InputIterator1 
# 74
flags_first, Size 
# 75
n, InputIterator2 
# 76
keys_first, InputIterator3 
# 77
values_first, OutputIterator1 
# 78
keys_result, OutputIterator2 
# 79
values_result) 
# 80
{int volatile ___ = 1;(void)group;(void)flags_first;(void)n;(void)keys_first;(void)values_first;(void)keys_result;(void)values_result;
# 108
::exit(___);}
#if 0
# 80
{ 
# 94
bulk_::scatter_if(group, values_first, (values_first + n) - 1, thrust::make_transform_iterator(flags_first, (thrust::placeholders::_1 - (1))), (detail::make_tail_flags(flags_first, flags_first + n).begin()), values_result); 
# 101
bulk_::scatter_if(group, keys_first, (keys_first + n) - 1, thrust::make_transform_iterator(flags_first, (thrust::placeholders::_1 - (1))), (detail::make_tail_flags(flags_first, flags_first + n).begin()), keys_result); 
# 108
} 
#endif
# 111 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp"
}
# 112
}
# 115
template< std::size_t groupsize, std::size_t 
# 116
grainsize, class 
# 117
InputIterator1, class 
# 118
InputIterator2, class 
# 119
OutputIterator1, class 
# 120
OutputIterator2, class 
# 121
T1, class 
# 122
T2, class 
# 123
BinaryPredicate, class 
# 124
BinaryFunction> __attribute__((unused)) tuple< OutputIterator1, OutputIterator2, typename iterator_value< InputIterator1> ::type, typename iterator_value< OutputIterator2> ::type, null_type, null_type, null_type, null_type, null_type, null_type>  
# 132
reduce_by_key(concurrent_group< agent< grainsize> , groupsize>  &g, InputIterator1 
# 133
keys_first, InputIterator1 keys_last, InputIterator2 
# 134
values_first, OutputIterator1 
# 135
keys_result, OutputIterator2 
# 136
values_result, T1 
# 137
init_key, T2 
# 138
init_value, BinaryPredicate 
# 139
pred, BinaryFunction 
# 140
binary_op) 
# 141
{int volatile ___ = 1;(void)g;(void)keys_first;(void)keys_last;(void)values_first;(void)keys_result;(void)values_result;(void)init_key;(void)init_value;(void)pred;(void)binary_op;
# 216
::exit(___);}
#if 0
# 141
{ 
# 142
typedef typename iterator_value< InputIterator2> ::type value_type; 
# 144
typedef typename concurrent_group< agent< grainsize> , groupsize> ::size_type size_type; 
# 146
const size_type interval_size = (groupsize * grainsize); 
# 152
__attribute__((unused)) static uninitialized_array< typename concurrent_group< agent< grainsize> , groupsize> ::size_type, interval_size>  s_flags_impl; 
# 153
size_type *s_flags = (s_flags_impl.data()); 
# 155
__attribute__((unused)) static uninitialized_array< typename iterator_value< InputIterator2> ::type, interval_size>  s_values_impl; 
# 156
value_type *s_values = (s_values_impl.data()); 
# 159
for (; keys_first < keys_last; (keys_first += interval_size), (values_first += interval_size)) 
# 160
{ 
# 162
size_type n = thrust::min< typename concurrent_group< agent< grainsize> , groupsize> ::size_type> (interval_size, keys_last - keys_first); 
# 168
detail::head_flags_with_init< InputIterator1, BinaryPredicate, typename concurrent_group< agent< grainsize> , groupsize> ::size_type>  flags(keys_first, keys_first + n, init_key, pred); 
# 170
detail::reduce_by_key_detail::scan_head_flags_functor< typename concurrent_group< agent< grainsize> , groupsize> ::size_type, typename iterator_value< InputIterator2> ::type, BinaryFunction>  f(binary_op); 
# 173
bulk_::copy_n(bulk_::bound< interval_size> (g), thrust::make_zip_iterator(thrust::make_tuple((flags.begin()), values_first)), n, thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values))); 
# 179
bulk_::inclusive_scan(bulk_::bound< interval_size> (g), thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values)), thrust::make_zip_iterator(thrust::make_tuple(s_flags + n, s_values)), thrust::make_zip_iterator(thrust::make_tuple(s_flags, s_values)), thrust::make_tuple(1, init_value), f); 
# 187
detail::reduce_by_key_detail::scatter_tails_n(bulk_::bound< interval_size> (g), s_flags, n, keys_first, s_values, keys_result, values_result); 
# 194
if ((((g.this_exec).index()) == 0) && ((s_flags[0]) > 1)) 
# 195
{ 
# 196
(keys_result[0]) = init_key; 
# 197
(values_result[0]) = init_value; 
# 198
}  
# 200
size_type result_size = (s_flags[n - 1]) - 1; 
# 202
keys_result += result_size; 
# 203
values_result += result_size; 
# 204
init_key = (keys_first[n - 1]); 
# 205
init_value = (s_values[n - 1]); 
# 207
(g.wait()); 
# 208
}  
# 215
return thrust::make_tuple(keys_result, values_result, init_key, init_value); 
# 216
} 
#endif
# 219 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/reduce_by_key.hpp"
}
# 220
}}}}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 29
namespace bulk_ { 
# 34
template< std::size_t bound, std::size_t 
# 35
grainsize, class 
# 36
RandomAccessIterator1, class 
# 37
RandomAccessIterator2, class 
# 38
Compare> 
# 39
__attribute((always_inline)) __attribute__((unused)) inline void 
# 34
stable_sort_by_key(const bounded< bound, agent< grainsize> >  & exec, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, Compare comp); 
# 46
namespace detail { 
# 48
namespace stable_merge_sort_detail { 
# 52
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class KeyType, class ValType, class Compare> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize)> ::type 
# 57
inplace_merge_adjacent_partitions(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &g, KeyType 
# 58
local_keys[], ValType local_values[], void *stage_ptr, int count, int local_size, Compare comp) 
# 59
{int volatile ___ = 1;(void)g;(void)local_keys;(void)local_values;(void)stage_ptr;(void)count;(void)local_size;(void)comp;
# 119
::exit(___);}
#if 0
# 59
{ 
# 60
union stage_t { 
# 62
KeyType *keys; 
# 63
ValType *vals; 
# 64
}; 
# 66
stage_t stage; 
# 67
(stage.keys) = (reinterpret_cast< KeyType *>(stage_ptr)); 
# 69
typedef typename agent< grainsize> ::size_type size_type; 
# 71
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 75
for (size_type num_agents_per_merge = (2); num_agents_per_merge <= groupsize; num_agents_per_merge *= 2) 
# 76
{ 
# 78
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_keys, local_size, (stage.keys) + local_offset); 
# 80
(g.wait()); 
# 83
size_type list = (~(num_agents_per_merge - 1)) & ((g.this_exec).index()); 
# 84
size_type diag = thrust::min< typename agent< grainsize> ::size_type> (count, grainsize * ((num_agents_per_merge - 1) & ((g.this_exec).index()))); 
# 85
size_type start = grainsize * list; 
# 88
size_type input_size = grainsize * (num_agents_per_merge / 2); 
# 90
size_type partition_first1 = thrust::min< typename agent< grainsize> ::size_type> (count, start); 
# 91
size_type partition_first2 = thrust::min< typename agent< grainsize> ::size_type> (count, partition_first1 + input_size); 
# 92
size_type partition_last2 = thrust::min< typename agent< grainsize> ::size_type> (count, partition_first2 + input_size); 
# 94
size_type n1 = partition_first2 - partition_first1; 
# 95
size_type n2 = partition_last2 - partition_first2; 
# 97
size_type mp = bulk_::merge_path((stage.keys) + partition_first1, n1, (stage.keys) + partition_first2, n2, diag, comp); 
# 101
size_type gather_indices[grainsize]; 
# 102
bulk_::merge_by_key(bulk_::bound< grainsize> ((g.this_exec)), ((stage.keys) + partition_first1) + mp, (stage.keys) + partition_first2, (((stage.keys) + partition_first2) + diag) - mp, (stage.keys) + partition_last2, thrust::make_counting_iterator< typename agent< grainsize> ::size_type> (partition_first1 + mp), thrust::make_counting_iterator< typename agent< grainsize> ::size_type> ((partition_first2 + diag) - mp), local_keys, gather_indices, comp); 
# 112
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_values, local_size, (stage.vals) + local_offset); 
# 115
bulk_::gather(bulk_::bound< grainsize> ((g.this_exec)), gather_indices, (gather_indices) + local_size, stage.vals, local_values); 
# 117
(g.wait()); 
# 118
}  
# 119
} 
#endif
# 122 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
}
# 125
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class 
# 126
RandomAccessIterator1, class 
# 127
RandomAccessIterator2, class 
# 128
Compare> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize)> ::type 
# 133
stable_merge_sort_by_key(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &g, RandomAccessIterator1 
# 134
keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 
# 135
values_first, Compare 
# 136
comp) 
# 137
{int volatile ___ = 1;(void)g;(void)keys_first;(void)keys_last;(void)values_first;(void)comp;
# 206
::exit(___);}
#if 0
# 137
{ 
# 138
typedef typename iterator_value< RandomAccessIterator1> ::type key_type; 
# 139
typedef typename iterator_value< RandomAccessIterator2> ::type value_type; 
# 141
typedef typename agent< grainsize> ::size_type size_type; 
# 143
size_type n = keys_last - keys_first; 
# 144
const size_type tile_size = (groupsize * grainsize); 
# 146
size_type local_offset = grainsize * ((g.this_exec).index()); 
# 147
size_type local_size = thrust::max< typename agent< grainsize> ::size_type> (0, thrust::min< typename agent< grainsize> ::size_type> (grainsize, n - local_offset)); 
# 162
__attribute__((unused)) static 
# 159
union { 
# 160
key_type keys[tile_size]; 
# 161
value_type values[tile_size]; 
# 162
} stage; 
# 166
bulk_::copy_n(bulk_::bound< tile_size> (g), keys_first, n, stage.keys); 
# 168
key_type local_keys[grainsize]; 
# 169
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), (stage.keys) + local_offset, local_size, local_keys); 
# 172
bulk_::copy_n(bulk_::bound< tile_size> (g), values_first, n, stage.values); 
# 174
value_type local_values[grainsize]; 
# 175
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), (stage.values) + local_offset, local_size, local_values); 
# 178
bulk_::stable_sort_by_key(bulk_::bound< grainsize> ((g.this_exec)), local_keys, local_keys + local_size, local_values, comp); 
# 182
if (n == tile_size) 
# 183
{ 
# 184
stable_merge_sort_detail::inplace_merge_adjacent_partitions(g, local_keys, local_values, stage.keys, tile_size, grainsize, comp); 
# 185
} else 
# 187
{ 
# 188
stable_merge_sort_detail::inplace_merge_adjacent_partitions(g, local_keys, local_values, stage.keys, n, local_size, comp); 
# 189
}  
# 192
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_keys, local_size, (stage.keys) + local_offset); 
# 193
(g.wait()); 
# 195
bulk_::copy_n(bulk_::bound< tile_size> (g), stage.keys, n, keys_first); 
# 198
bulk_::copy_n(bulk_::bound< grainsize> ((g.this_exec)), local_values, local_size, (stage.values) + local_offset); 
# 199
(g.wait()); 
# 201
bulk_::copy_n(bulk_::bound< tile_size> (g), stage.values, n, values_first); 
# 206
} 
#endif
# 209 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/detail/stable_merge_sort.hpp"
}
# 210
}
# 211
}}}}
# 24 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
namespace thrust { namespace system { namespace cuda { namespace detail { 
# 25
namespace bulk_ { 
# 27
namespace detail { 
# 29
namespace sort_detail { 
# 33
template< int i, int bound> 
# 34
struct stable_odd_even_transpose_sort_by_key_impl { 
# 36
template< class RandomAccessIterator1, class RandomAccessIterator2, class Compare> static void 
# 38
sort(RandomAccessIterator1 keys, RandomAccessIterator2 values, int n, Compare comp) 
# 39
{int volatile ___ = 1;(void)keys;(void)values;(void)n;(void)comp;
# 52
::exit(___);}
#if 0
# 39
{ 
# 40
for (int j = (1 & i); j < (bound - 1); j += 2) 
# 41
{ 
# 42
if (((j + 1) < n) && comp(keys[j + 1], keys[j])) 
# 43
{ 
# 44
using thrust::swap;
# 46
swap(keys[j], keys[j + 1]); 
# 47
swap(values[j], values[j + 1]); 
# 48
}  
# 49
}  
# 51
stable_odd_even_transpose_sort_by_key_impl< i + 1, bound> ::sort(keys, values, n, comp); 
# 52
} 
#endif
# 53 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}; 
# 56
template< int i> struct stable_odd_even_transpose_sort_by_key_impl< i, i>  { 
# 58
template< class RandomAccessIterator1, class RandomAccessIterator2, class Compare> static void 
# 59
sort(RandomAccessIterator1, RandomAccessIterator2, int, Compare) {int volatile ___ = 1;::exit(___);}
#if 0
# 59
{ } 
#endif
# 60 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}; 
# 63
template< std::size_t bound, std::size_t 
# 64
grainsize, class 
# 65
RandomAccessIterator1, class 
# 66
RandomAccessIterator2, class 
# 67
Compare> 
# 68
__attribute((always_inline)) __attribute__((unused)) inline void 
# 69
stable_odd_even_transpose_sort_by_key(const bounded< bound, agent< grainsize> >  &, RandomAccessIterator1 
# 70
keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 
# 71
values_first, Compare 
# 72
comp) 
# 73
{int volatile ___ = 1;(void)keys_first;(void)keys_last;(void)values_first;(void)comp;
# 75
::exit(___);}
#if 0
# 73
{ 
# 74
stable_odd_even_transpose_sort_by_key_impl< 0, bound> ::sort(keys_first, values_first, keys_last - keys_first, comp); 
# 75
} 
#endif
# 78 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
template< int i, int bound> 
# 79
struct stable_odd_even_transpose_sort_impl { 
# 81
template< class RandomAccessIterator, class Compare> static void 
# 83
sort(RandomAccessIterator keys, int n, Compare comp) 
# 84
{int volatile ___ = 1;(void)keys;(void)n;(void)comp;
# 96
::exit(___);}
#if 0
# 84
{ 
# 85
for (int j = (1 & i); j < (bound - 1); j += 2) 
# 86
{ 
# 87
if (((j + 1) < n) && comp(keys[j + 1], keys[j])) 
# 88
{ 
# 89
using thrust::swap;
# 91
swap(keys[j], keys[j + 1]); 
# 92
}  
# 93
}  
# 95
stable_odd_even_transpose_sort_impl< i + 1, bound> ::sort(keys, n, comp); 
# 96
} 
#endif
# 97 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}; 
# 100
template< int i> struct stable_odd_even_transpose_sort_impl< i, i>  { 
# 102
template< class RandomAccessIterator, class Compare> static void 
# 103
sort(RandomAccessIterator, int, Compare) {int volatile ___ = 1;::exit(___);}
#if 0
# 103
{ } 
#endif
# 104 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}; 
# 107
template< std::size_t bound, std::size_t 
# 108
grainsize, class 
# 109
RandomAccessIterator, class 
# 110
Compare> 
# 111
__attribute((always_inline)) __attribute__((unused)) inline void 
# 112
stable_odd_even_transpose_sort(const bounded< bound, agent< grainsize> >  &, RandomAccessIterator 
# 113
first, RandomAccessIterator last, Compare 
# 114
comp) 
# 115
{int volatile ___ = 1;(void)first;(void)last;(void)comp;
# 117
::exit(___);}
#if 0
# 115
{ 
# 116
stable_odd_even_transpose_sort_impl< 0, bound> ::sort(first, last - first, comp); 
# 117
} 
#endif
# 120 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}
# 121
}
# 124
template< std::size_t bound, std::size_t 
# 125
grainsize, class 
# 126
RandomAccessIterator1, class 
# 127
RandomAccessIterator2, class 
# 128
Compare> 
# 129
__attribute((always_inline)) __attribute__((unused)) inline void 
# 130
stable_sort_by_key(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator1 
# 131
keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 
# 132
values_first, Compare 
# 133
comp) 
# 134
{int volatile ___ = 1;(void)exec;(void)keys_first;(void)keys_last;(void)values_first;(void)comp;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
detail::sort_detail::stable_odd_even_transpose_sort_by_key(exec, keys_first, keys_last, values_first, comp); 
# 136
} 
#endif
# 139 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
template< std::size_t bound, std::size_t 
# 140
grainsize, class 
# 141
RandomAccessIterator, class 
# 142
Compare> 
# 143
__attribute((always_inline)) __attribute__((unused)) inline void 
# 144
stable_sort(const bounded< bound, agent< grainsize> >  &exec, RandomAccessIterator 
# 145
first, RandomAccessIterator last, Compare 
# 146
comp) 
# 147
{int volatile ___ = 1;(void)exec;(void)first;(void)last;(void)comp;
# 149
::exit(___);}
#if 0
# 147
{ 
# 148
detail::sort_detail::stable_odd_even_transpose_sort(exec, first, last, comp); 
# 149
} 
#endif
# 152 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
template< std::size_t bound, std::size_t groupsize, std::size_t grainsize, class 
# 153
RandomAccessIterator1, class 
# 154
RandomAccessIterator2, class 
# 155
Compare> __attribute__((unused)) typename thrust::detail::enable_if< bound <= (groupsize * grainsize)> ::type 
# 160
stable_sort_by_key(bounded< bound, concurrent_group< agent< grainsize> , groupsize> >  &g, RandomAccessIterator1 
# 161
keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 
# 162
values_first, Compare 
# 163
comp) 
# 164
{int volatile ___ = 1;(void)g;(void)keys_first;(void)keys_last;(void)values_first;(void)comp;
# 166
::exit(___);}
#if 0
# 164
{ 
# 165
detail::stable_merge_sort_by_key(g, keys_first, keys_last, values_first, comp); 
# 166
} 
#endif
# 169 "/usr/local/cuda/include/thrust/system/cuda/detail/bulk/algorithm/sort.hpp"
}
# 170
}}}}
# 24 "/usr/local/cuda/include/thrust/system/cuda/detail/throw_on_error.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace cuda { 
# 30
namespace detail { 
# 35
inline void throw_on_error(cudaError_t error, const char *message) 
# 36
{ 
# 37
thrust::system::cuda::detail::bulk_::detail::throw_on_error(error, message); 
# 38
} 
# 41
}
# 42
}
# 43
}
# 44
}
# 26 "/usr/local/cuda/include/thrust/detail/malloc_and_free.h"
namespace thrust { 
# 30
template< class DerivedPolicy> pointer< void, DerivedPolicy, use_default, use_default>  
# 32
malloc(const detail::execution_policy_base< DerivedPolicy>  &exec, std::size_t n) 
# 33
{ 
# 34
using system::detail::generic::malloc;
# 37
void *raw_ptr = static_cast< void *>(thrust::raw_pointer_cast(malloc(detail::derived_cast(detail::strip_const(exec)), n))); 
# 39
return ((pointer< void, DerivedPolicy, use_default, use_default> )(raw_ptr)); 
# 40
} 
# 43
template< class T, class DerivedPolicy> pointer< T, DerivedPolicy, use_default, use_default>  
# 45
malloc(const detail::execution_policy_base< DerivedPolicy>  &exec, std::size_t n) 
# 46
{ 
# 47
using system::detail::generic::malloc;
# 49
T *raw_ptr = static_cast< T *>(thrust::raw_pointer_cast(malloc< T> (detail::derived_cast(detail::strip_const(exec)), n))); 
# 51
return ((pointer< T, DerivedPolicy, use_default, use_default> )(raw_ptr)); 
# 52
} 
# 72
template< class DerivedPolicy, class Pointer> void 
# 74
free(const detail::execution_policy_base< DerivedPolicy>  &exec, Pointer ptr) 
# 75
{ 
# 76
using system::detail::generic::free;
# 78
free(detail::derived_cast(detail::strip_const(exec)), ptr); 
# 79
} 
# 84
}
# 25 "/usr/local/cuda/include/thrust/detail/allocator/allocator_traits.h"
namespace thrust { 
# 27
namespace detail { 
# 32
template< class Alloc> struct allocator_system; 
# 35
namespace allocator_traits_detail { 
# 38
template< class T> struct has_value_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::value_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 39
template< class T> struct has_pointer { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::pointer *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 40
template< class T> struct has_const_pointer { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::const_pointer *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 41
template< class T> struct has_reference { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::reference *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 42
template< class T> struct has_const_reference { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::const_reference *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 43
template< class T> struct has_void_pointer { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::void_pointer *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 44
template< class T> struct has_const_void_pointer { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::const_void_pointer *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 45
template< class T> struct has_difference_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::difference_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 46
template< class T> struct has_size_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::size_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 47
template< class T> struct has_propagate_on_container_copy_assignment { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::propagate_on_container_copy_assignment *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 48
template< class T> struct has_propagate_on_container_move_assignment { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::propagate_on_container_move_assignment *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 49
template< class T> struct has_propagate_on_container_swap { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::propagate_on_container_swap *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 50
template< class T> struct has_system_type { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::system_type *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 51
template< class T, class Signature> class has_member_system_impl; template< class T, class Result> class has_member_system_impl< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::system>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_system_impl< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::system>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_system_impl< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::system>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_system_impl< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::system>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_system_impl< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result system(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::system>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; 
# 54
template< class T> 
# 55
struct nested_pointer { 
# 57
typedef typename T::pointer type; 
# 58
}; 
# 60
template< class T> 
# 61
struct nested_const_pointer { 
# 63
typedef typename T::const_pointer type; 
# 64
}; 
# 66
template< class T> 
# 67
struct nested_reference { 
# 69
typedef typename T::reference type; 
# 70
}; 
# 72
template< class T> 
# 73
struct nested_const_reference { 
# 75
typedef typename T::const_reference type; 
# 76
}; 
# 78
template< class T> 
# 79
struct nested_void_pointer { 
# 81
typedef typename T::void_pointer type; 
# 82
}; 
# 84
template< class T> 
# 85
struct nested_const_void_pointer { 
# 87
typedef typename T::const_void_pointer type; 
# 88
}; 
# 90
template< class T> 
# 91
struct nested_difference_type { 
# 93
typedef typename T::difference_type type; 
# 94
}; 
# 96
template< class T> 
# 97
struct nested_size_type { 
# 99
typedef typename T::size_type type; 
# 100
}; 
# 102
template< class T> 
# 103
struct nested_propagate_on_container_copy_assignment { 
# 105
typedef typename T::propagate_on_container_copy_assignment type; 
# 106
}; 
# 108
template< class T> 
# 109
struct nested_propagate_on_container_move_assignment { 
# 111
typedef typename T::propagate_on_container_move_assignment type; 
# 112
}; 
# 114
template< class T> 
# 115
struct nested_propagate_on_container_swap { 
# 117
typedef typename T::propagate_on_container_swap type; 
# 118
}; 
# 120
template< class T> 
# 121
struct nested_system_type { 
# 123
typedef typename T::system_type type; 
# 124
}; 
# 126
template< class Alloc> 
# 127
class has_member_system { 
# 129
typedef typename allocator_system< Alloc> ::type system_type; 
# 132
public: typedef typename has_member_system_impl< Alloc, typename allocator_system< Alloc> ::type &(void)> ::type type; 
# 133
static const bool value = (type::value); 
# 134
}; 
# 137
}
# 140
template< class Alloc> 
# 141
struct allocator_traits { 
# 143
typedef Alloc allocator_type; 
# 145
typedef typename Alloc::value_type value_type; 
# 151
typedef typename eval_if< allocator_traits_detail::has_pointer< Alloc> ::value, allocator_traits_detail::nested_pointer< Alloc> , identity_< typename Alloc::value_type *> > ::type pointer; 
# 155
private: 
# 154
template< class T> 
# 155
struct rebind_pointer { 
# 157
typedef typename pointer_traits< typename eval_if< allocator_traits_detail::has_pointer< Alloc> ::value, allocator_traits_detail::nested_pointer< Alloc> , identity_< typename Alloc::value_type *> > ::type> ::template rebind< T> ::other type; 
# 158
}; 
# 166
public: typedef typename eval_if< allocator_traits_detail::has_const_pointer< Alloc> ::value, allocator_traits_detail::nested_const_pointer< Alloc> , rebind_pointer< const typename Alloc::value_type> > ::type const_pointer; 
# 172
typedef typename eval_if< allocator_traits_detail::has_void_pointer< Alloc> ::value, allocator_traits_detail::nested_void_pointer< Alloc> , rebind_pointer< void> > ::type void_pointer; 
# 178
typedef typename eval_if< allocator_traits_detail::has_const_void_pointer< Alloc> ::value, allocator_traits_detail::nested_const_void_pointer< Alloc> , rebind_pointer< const void> > ::type const_void_pointer; 
# 184
typedef typename eval_if< allocator_traits_detail::has_difference_type< Alloc> ::value, allocator_traits_detail::nested_difference_type< Alloc> , pointer_difference< typename eval_if< allocator_traits_detail::has_pointer< Alloc> ::value, allocator_traits_detail::nested_pointer< Alloc> , identity_< typename Alloc::value_type *> > ::type> > ::type difference_type; 
# 190
typedef typename eval_if< allocator_traits_detail::has_size_type< Alloc> ::value, allocator_traits_detail::nested_size_type< Alloc> , make_unsigned< typename eval_if< allocator_traits_detail::has_difference_type< Alloc> ::value, allocator_traits_detail::nested_difference_type< Alloc> , pointer_difference< typename eval_if< allocator_traits_detail::has_pointer< Alloc> ::value, allocator_traits_detail::nested_pointer< Alloc> , identity_< typename Alloc::value_type *> > ::type> > ::type> > ::type size_type; 
# 196
typedef typename eval_if< allocator_traits_detail::has_propagate_on_container_copy_assignment< Alloc> ::value, allocator_traits_detail::nested_propagate_on_container_copy_assignment< Alloc> , identity_< integral_constant< bool, false> > > ::type propagate_on_container_copy_assignment; 
# 202
typedef typename eval_if< allocator_traits_detail::has_propagate_on_container_move_assignment< Alloc> ::value, allocator_traits_detail::nested_propagate_on_container_move_assignment< Alloc> , identity_< integral_constant< bool, false> > > ::type propagate_on_container_move_assignment; 
# 208
typedef typename eval_if< allocator_traits_detail::has_propagate_on_container_swap< Alloc> ::value, allocator_traits_detail::nested_propagate_on_container_swap< Alloc> , identity_< integral_constant< bool, false> > > ::type propagate_on_container_swap; 
# 214
typedef typename eval_if< allocator_traits_detail::has_system_type< Alloc> ::value, allocator_traits_detail::nested_system_type< Alloc> , iterator_system< typename eval_if< allocator_traits_detail::has_pointer< Alloc> ::value, allocator_traits_detail::nested_pointer< Alloc> , identity_< typename Alloc::value_type *> > ::type> > ::type system_type; 
# 220
static inline pointer allocate(allocator_type & a, size_type n); 
# 223
static inline pointer allocate(allocator_type & a, size_type n, const_void_pointer hint); 
# 226
static inline void deallocate(allocator_type & a, pointer p, size_type n); 
# 230
template< class T> static inline void construct(allocator_type & a, T * p); 
# 233
template< class T, class Arg1> static inline void construct(allocator_type & a, T * p, const Arg1 & arg1); 
# 236
template< class T> static inline void destroy(allocator_type & a, T * p); 
# 240
static inline size_type max_size(const allocator_type & a); 
# 241
}; 
# 247
template< class T> 
# 248
struct is_allocator : public allocator_traits_detail::has_value_type< T>  { 
# 250
}; 
# 254
template< class Alloc> 
# 255
struct allocator_system { 
# 264
typedef typename eval_if< allocator_traits_detail::has_system_type< Alloc> ::value, allocator_traits_detail::nested_system_type< Alloc> , iterator_system< typename allocator_traits< Alloc> ::pointer> > ::type type; 
# 271
typedef typename eval_if< allocator_traits_detail::has_member_system< Alloc> ::value, add_reference< typename eval_if< allocator_traits_detail::has_system_type< Alloc> ::value, allocator_traits_detail::nested_system_type< Alloc> , iterator_system< typename allocator_traits< Alloc> ::pointer> > ::type> , identity_< typename eval_if< allocator_traits_detail::has_system_type< Alloc> ::value, allocator_traits_detail::nested_system_type< Alloc> , iterator_system< typename allocator_traits< Alloc> ::pointer> > ::type> > ::type get_result_type; 
# 274
static inline get_result_type get(Alloc & a); 
# 275
}; 
# 278
}
# 279
}
# 25 "/usr/local/cuda/include/thrust/detail/type_traits/is_call_possible.h"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace is_call_possible_detail { 
# 32
template< class T> class void_exp_result { }; 
# 34
template< class T, class U> const U &operator,(const U &, void_exp_result< T> ); 
# 37
template< class T, class U> U &operator,(U &, void_exp_result< T> ); 
# 40
template< class src_type, class dest_type> 
# 41
struct clone_constness { 
# 43
typedef dest_type type; 
# 44
}; 
# 46
template< class src_type, class dest_type> 
# 47
struct clone_constness< const src_type, dest_type>  { 
# 49
typedef const dest_type type; 
# 50
}; 
# 52
}
# 53
}
# 54
}
# 23 "/usr/local/cuda/include/thrust/detail/integer_traits.h"
namespace thrust { 
# 26
namespace detail { 
# 29
template< class T> 
# 30
class integer_traits { 
# 33
public: static const bool is_integral = false; 
# 34
}; 
# 36
template< class T, T min_val, T max_val> 
# 37
class integer_traits_base { 
# 40
public: static const bool is_integral = true; 
# 41
static const T const_min = min_val; 
# 42
static const T const_max = max_val; 
# 43
}; 
# 47
template<> class integer_traits< bool>  : public std::numeric_limits< bool> , public integer_traits_base< bool, false, true>  { 
# 50
}; 
# 54
template<> class integer_traits< char>  : public std::numeric_limits< char> , public integer_traits_base< char, '\200', '\177'>  { 
# 57
}; 
# 61
template<> class integer_traits< signed char>  : public std::numeric_limits< signed char> , public integer_traits_base< signed char, (signed char)'\200', (signed char)'\177'>  { 
# 64
}; 
# 68
template<> class integer_traits< unsigned char>  : public std::numeric_limits< unsigned char> , public integer_traits_base< unsigned char, (unsigned char)'\000', (unsigned char)'\377'>  { 
# 71
}; 
# 75
template<> class integer_traits< short>  : public std::numeric_limits< short> , public integer_traits_base< short, (short)(-32767-1), (short)32767>  { 
# 78
}; 
# 82
template<> class integer_traits< unsigned short>  : public std::numeric_limits< unsigned short> , public integer_traits_base< unsigned short, (unsigned short)0U, (unsigned short)65535U>  { 
# 85
}; 
# 89
template<> class integer_traits< int>  : public std::numeric_limits< int> , public integer_traits_base< int, -2147483647-1, 2147483647>  { 
# 92
}; 
# 96
template<> class integer_traits< unsigned>  : public std::numeric_limits< unsigned> , public integer_traits_base< unsigned, 0U, 4294967295U>  { 
# 99
}; 
# 103
template<> class integer_traits< long>  : public std::numeric_limits< long> , public integer_traits_base< long, -9223372036854775807L-1, 9223372036854775807L>  { 
# 106
}; 
# 110
template<> class integer_traits< unsigned long>  : public std::numeric_limits< unsigned long> , public integer_traits_base< unsigned long, 0UL, 18446744073709551615UL>  { 
# 113
}; 
# 117
template<> class integer_traits< long long>  : public std::numeric_limits< long long> , public integer_traits_base< long long, -9223372036854775807LL-1, 9223372036854775807LL>  { 
# 120
}; 
# 124
template<> class integer_traits< unsigned long long>  : public std::numeric_limits< unsigned long long> , public integer_traits_base< unsigned long long, 0ULL, 18446744073709551615ULL>  { 
# 127
}; 
# 129
}
# 131
}
# 23 "/usr/local/cuda/include/thrust/detail/allocator/allocator_traits.inl"
namespace thrust { 
# 25
namespace detail { 
# 27
namespace allocator_traits_detail { 
# 30
template< class T, class Signature> class has_member_allocate_with_hint_impl_has_member; template< class T, class Result> class has_member_allocate_with_hint_impl_has_member< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::allocate>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_allocate_with_hint_impl_has_member< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::allocate>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_allocate_with_hint_impl_has_member< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::allocate>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_allocate_with_hint_impl_has_member< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::allocate>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_allocate_with_hint_impl_has_member< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result allocate(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::allocate>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Signature> struct has_member_allocate_with_hint_impl { private: struct yes { }; struct no { yes m[2]; }; struct derived : public T { using T::allocate;typename ::thrust::detail::allocator_traits_detail::has_member_allocate_with_hint_impl< T, Signature> ::no allocate(...) const; }; typedef typename is_call_possible_detail::clone_constness< T, derived> ::type derived_type; template< class U, class Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(is_call_possible_detail::void_exp_result< T> ); }; template< class U> struct return_value_check< U, void>  { static yes deduce(...); static no deduce(no); }; template< bool has_the_member_of_interest, class F> struct impl { static const bool value = false; }; template< class Result, class Arg> struct impl< true, Result (Arg)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg> ::type arg; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.allocate(arg)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2> struct impl< true, Result (Arg1, Arg2)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.allocate(arg1, arg2)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3> struct impl< true, Result (Arg1, Arg2, Arg3)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.allocate(arg1, arg2, arg3)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3, class Arg4> struct impl< true, Result (Arg1, Arg2, Arg3, Arg4)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static typename add_reference< Arg4> ::type arg4; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.allocate(arg1, arg2, arg3, arg4)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; public: static const bool value = (impl< has_member_allocate_with_hint_impl_has_member< T, Signature> ::value, Signature> ::value); typedef integral_constant< bool, value>  type; }; 
# 32
template< class Alloc> 
# 33
class has_member_allocate_with_hint { 
# 35
typedef typename allocator_traits< Alloc> ::pointer pointer; 
# 36
typedef typename allocator_traits< Alloc> ::size_type size_type; 
# 37
typedef typename allocator_traits< Alloc> ::const_void_pointer const_void_pointer; 
# 40
public: typedef typename has_member_allocate_with_hint_impl< Alloc, typename allocator_traits< Alloc> ::pointer (typename allocator_traits< Alloc> ::size_type, typename allocator_traits< Alloc> ::const_void_pointer)> ::type type; 
# 41
static const bool value = (type::value); 
# 42
}; 
# 44
template< class Alloc> typename enable_if< has_member_allocate_with_hint< Alloc> ::value, typename allocator_traits< Alloc> ::pointer> ::type 
# 50
allocate(Alloc &a, typename allocator_traits< Alloc> ::size_type n, typename allocator_traits< Alloc> ::const_void_pointer hint) 
# 51
{ 
# 52
return (a.allocate(n, hint)); 
# 53
} 
# 55
template< class Alloc> typename disable_if< has_member_allocate_with_hint< Alloc> ::value, typename allocator_traits< Alloc> ::pointer> ::type 
# 61
allocate(Alloc &a, typename allocator_traits< Alloc> ::size_type n, typename allocator_traits< Alloc> ::const_void_pointer) 
# 62
{ 
# 63
return (a.allocate(n)); 
# 64
} 
# 67
template< class T, class Signature> class has_member_construct1_impl_has_member; template< class T, class Result> class has_member_construct1_impl_has_member< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_construct1_impl_has_member< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_construct1_impl_has_member< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_construct1_impl_has_member< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_construct1_impl_has_member< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Signature> struct has_member_construct1_impl { private: struct yes { }; struct no { yes m[2]; }; struct derived : public T { using T::construct;typename ::thrust::detail::allocator_traits_detail::has_member_construct1_impl< T, Signature> ::no construct(...) const; }; typedef typename is_call_possible_detail::clone_constness< T, derived> ::type derived_type; template< class U, class Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(is_call_possible_detail::void_exp_result< T> ); }; template< class U> struct return_value_check< U, void>  { static yes deduce(...); static no deduce(no); }; template< bool has_the_member_of_interest, class F> struct impl { static const bool value = false; }; template< class Result, class Arg> struct impl< true, Result (Arg)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg> ::type arg; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2> struct impl< true, Result (Arg1, Arg2)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3> struct impl< true, Result (Arg1, Arg2, Arg3)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2, arg3)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3, class Arg4> struct impl< true, Result (Arg1, Arg2, Arg3, Arg4)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static typename add_reference< Arg4> ::type arg4; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2, arg3, arg4)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; public: static const bool value = (impl< has_member_construct1_impl_has_member< T, Signature> ::value, Signature> ::value); typedef integral_constant< bool, value>  type; }; 
# 69
template< class Alloc, class T> 
# 70
struct has_member_construct1 : public has_member_construct1_impl< Alloc, void (T *)>  { 
# 72
}; 
# 75
template< class Alloc, class T> inline typename enable_if< has_member_construct1< Alloc, T> ::value> ::type 
# 80
construct(Alloc &a, T *p) 
# 81
{ 
# 82
(a.construct(p)); 
# 83
} 
# 85
template< class Alloc, class T> inline typename disable_if< has_member_construct1< Alloc, T> ::value> ::type 
# 90
construct(Alloc &a, T *p) 
# 91
{ 
# 92
::new (static_cast< void *>(p)) (T)(); 
# 93
} 
# 96
template< class T, class Signature> class has_member_construct2_impl_has_member; template< class T, class Result> class has_member_construct2_impl_has_member< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_construct2_impl_has_member< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_construct2_impl_has_member< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_construct2_impl_has_member< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_construct2_impl_has_member< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result construct(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::construct>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Signature> struct has_member_construct2_impl { private: struct yes { }; struct no { yes m[2]; }; struct derived : public T { using T::construct;typename ::thrust::detail::allocator_traits_detail::has_member_construct2_impl< T, Signature> ::no construct(...) const; }; typedef typename is_call_possible_detail::clone_constness< T, derived> ::type derived_type; template< class U, class Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(is_call_possible_detail::void_exp_result< T> ); }; template< class U> struct return_value_check< U, void>  { static yes deduce(...); static no deduce(no); }; template< bool has_the_member_of_interest, class F> struct impl { static const bool value = false; }; template< class Result, class Arg> struct impl< true, Result (Arg)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg> ::type arg; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2> struct impl< true, Result (Arg1, Arg2)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3> struct impl< true, Result (Arg1, Arg2, Arg3)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2, arg3)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3, class Arg4> struct impl< true, Result (Arg1, Arg2, Arg3, Arg4)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static typename add_reference< Arg4> ::type arg4; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.construct(arg1, arg2, arg3, arg4)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; public: static const bool value = (impl< has_member_construct2_impl_has_member< T, Signature> ::value, Signature> ::value); typedef integral_constant< bool, value>  type; }; 
# 98
template< class Alloc, class T, class Arg1> 
# 99
struct has_member_construct2 : public has_member_construct2_impl< Alloc, void (T *, const Arg1 &)>  { 
# 101
}; 
# 103
template< class Alloc, class T, class Arg1> inline typename enable_if< has_member_construct2< Alloc, T, Arg1> ::value> ::type 
# 108
construct(Alloc &a, T *p, const Arg1 &arg1) 
# 109
{ 
# 110
(a.construct(p, arg1)); 
# 111
} 
# 113
template< class Alloc, class T, class Arg1> inline typename disable_if< has_member_construct2< Alloc, T, Arg1> ::value> ::type 
# 118
construct(Alloc &, T *p, const Arg1 &arg1) 
# 119
{ 
# 120
::new (static_cast< void *>(p)) (T)(arg1); 
# 121
} 
# 124
template< class T, class Signature> class has_member_destroy_impl_has_member; template< class T, class Result> class has_member_destroy_impl_has_member< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::destroy>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_destroy_impl_has_member< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::destroy>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_destroy_impl_has_member< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::destroy>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_destroy_impl_has_member< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::destroy>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_destroy_impl_has_member< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result destroy(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::destroy>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Signature> struct has_member_destroy_impl { private: struct yes { }; struct no { yes m[2]; }; struct derived : public T { using T::destroy;typename ::thrust::detail::allocator_traits_detail::has_member_destroy_impl< T, Signature> ::no destroy(...) const; }; typedef typename is_call_possible_detail::clone_constness< T, derived> ::type derived_type; template< class U, class Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(is_call_possible_detail::void_exp_result< T> ); }; template< class U> struct return_value_check< U, void>  { static yes deduce(...); static no deduce(no); }; template< bool has_the_member_of_interest, class F> struct impl { static const bool value = false; }; template< class Result, class Arg> struct impl< true, Result (Arg)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg> ::type arg; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.destroy(arg)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2> struct impl< true, Result (Arg1, Arg2)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.destroy(arg1, arg2)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3> struct impl< true, Result (Arg1, Arg2, Arg3)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.destroy(arg1, arg2, arg3)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3, class Arg4> struct impl< true, Result (Arg1, Arg2, Arg3, Arg4)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static typename add_reference< Arg4> ::type arg4; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.destroy(arg1, arg2, arg3, arg4)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; public: static const bool value = (impl< has_member_destroy_impl_has_member< T, Signature> ::value, Signature> ::value); typedef integral_constant< bool, value>  type; }; 
# 126
template< class Alloc, class T> 
# 127
struct has_member_destroy : public has_member_destroy_impl< Alloc, void (T *)>  { 
# 129
}; 
# 131
template< class Alloc, class T> inline typename enable_if< has_member_destroy< Alloc, T> ::value> ::type 
# 136
destroy(Alloc &a, T *p) 
# 137
{ 
# 138
(a.destroy(p)); 
# 139
} 
# 141
template< class Alloc, class T> inline typename disable_if< has_member_destroy< Alloc, T> ::value> ::type 
# 146
destroy(Alloc &, T *p) 
# 147
{ 
# 148
(p->~T()); 
# 149
} 
# 152
template< class T, class Signature> class has_member_max_size_impl_has_member; template< class T, class Result> class has_member_max_size_impl_has_member< T, Result (void)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(void), &U::max_size>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg> class has_member_max_size_impl_has_member< T, Result (Arg)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg), &U::max_size>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2> class has_member_max_size_impl_has_member< T, Result (Arg1, Arg2)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1, Arg2); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2), &U::max_size>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3> class has_member_max_size_impl_has_member< T, Result (Arg1, Arg2, Arg3)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1, Arg2, Arg3); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3), &U::max_size>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Result, class Arg1, class Arg2, class Arg3, class Arg4> class has_member_max_size_impl_has_member< T, Result (Arg1, Arg2, Arg3, Arg4)>  { class yes { char m; }; class no { yes m[2]; }; struct base_mixin { Result max_size(Arg1, Arg2, Arg3, Arg4); }; struct base : public T, public base_mixin { }; template< class U, U t> class helper { }; template< class U> static no deduce(U *, helper< Result (base_mixin::*)(Arg1, Arg2, Arg3, Arg4), &U::max_size>  * = 0); static yes deduce(...); public: static const bool value = (sizeof(yes) == sizeof(deduce(static_cast< base *>(0)))); typedef integral_constant< bool, value>  type; }; template< class T, class Signature> struct has_member_max_size_impl { private: struct yes { }; struct no { yes m[2]; }; struct derived : public T { using T::max_size;typename ::thrust::detail::allocator_traits_detail::has_member_max_size_impl< T, Signature> ::no max_size(...) const; }; typedef typename is_call_possible_detail::clone_constness< T, derived> ::type derived_type; template< class U, class Result> struct return_value_check { static yes deduce(Result); static no deduce(...); static no deduce(no); static no deduce(is_call_possible_detail::void_exp_result< T> ); }; template< class U> struct return_value_check< U, void>  { static yes deduce(...); static no deduce(no); }; template< bool has_the_member_of_interest, class F> struct impl { static const bool value = false; }; template< class Result, class Arg> struct impl< true, Result (Arg)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg> ::type arg; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.max_size(arg)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2> struct impl< true, Result (Arg1, Arg2)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.max_size(arg1, arg2)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3> struct impl< true, Result (Arg1, Arg2, Arg3)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.max_size(arg1, arg2, arg3)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; template< class Result, class Arg1, class Arg2, class Arg3, class Arg4> struct impl< true, Result (Arg1, Arg2, Arg3, Arg4)>  { static typename add_reference< typename is_call_possible_detail::clone_constness< T, derived> ::type> ::type test_me; static typename add_reference< Arg1> ::type arg1; static typename add_reference< Arg2> ::type arg2; static typename add_reference< Arg3> ::type arg3; static typename add_reference< Arg4> ::type arg4; static const bool value = (sizeof(return_value_check< T, Result> ::deduce(((test_me.max_size(arg1, arg2, arg3, arg4)), (is_call_possible_detail::void_exp_result< T> ())))) == sizeof(yes)); }; public: static const bool value = (impl< has_member_max_size_impl_has_member< T, Signature> ::value, Signature> ::value); typedef integral_constant< bool, value>  type; }; 
# 154
template< class Alloc> 
# 155
class has_member_max_size { 
# 157
typedef typename allocator_traits< Alloc> ::size_type size_type; 
# 160
public: typedef typename has_member_max_size_impl< Alloc, typename allocator_traits< Alloc> ::size_type (void)> ::type type; 
# 161
static const bool value = (type::value); 
# 162
}; 
# 164
template< class Alloc> typename enable_if< has_member_max_size< Alloc> ::value, typename allocator_traits< Alloc> ::size_type> ::type 
# 170
max_size(const Alloc &a) 
# 171
{ 
# 172
return (a.max_size()); 
# 173
} 
# 175
template< class Alloc> typename disable_if< has_member_max_size< Alloc> ::value, typename allocator_traits< Alloc> ::size_type> ::type 
# 181
max_size(const Alloc &) 
# 182
{ 
# 183
typedef typename allocator_traits< Alloc> ::size_type size_type; 
# 184
return thrust::detail::integer_traits< typename allocator_traits< Alloc> ::size_type> ::const_max; 
# 185
} 
# 187
template< class Alloc> typename enable_if< has_member_system< Alloc> ::value, typename allocator_system< Alloc> ::type &> ::type 
# 193
system(Alloc &a) 
# 194
{ 
# 196
return (a.system()); 
# 197
} 
# 199
template< class Alloc> typename disable_if< has_member_system< Alloc> ::value, typename allocator_system< Alloc> ::type> ::type 
# 205
system(Alloc &) 
# 206
{ 
# 208
typename allocator_system< Alloc> ::type result; 
# 209
return result; 
# 210
} 
# 213
}
# 216
template< class Alloc> inline typename allocator_traits< Alloc> ::pointer 
# 220
allocator_traits< Alloc> ::allocate(Alloc &a, size_type n) 
# 221
{ 
# 222
struct workaround_warnings { 
# 227
static pointer allocate(Alloc &a, size_type n) 
# 228
{ 
# 229
return (a.allocate(n)); 
# 230
} 
# 231
}; 
# 233
return (workaround_warnings::allocate)(a, n); 
# 234
} 
# 236
template< class Alloc> inline typename allocator_traits< Alloc> ::pointer 
# 240
allocator_traits< Alloc> ::allocate(Alloc &a, size_type n, const_void_pointer hint) 
# 241
{ 
# 242
return allocator_traits_detail::allocate(a, n, hint); 
# 243
} 
# 245
template< class Alloc> inline void 
# 248
allocator_traits< Alloc> ::deallocate(Alloc &a, pointer p, size_type n) 
# 249
{ 
# 250
struct workaround_warnings { 
# 254
static void deallocate(Alloc &a, pointer p, size_type n) 
# 255
{ 
# 256
return (a.deallocate(p, n)); 
# 257
} 
# 258
}; 
# 260
return (workaround_warnings::deallocate)(a, p, n); 
# 261
} 
# 263
template< class Alloc> 
# 264
template< class T> inline void 
# 267
allocator_traits< Alloc> ::construct(allocator_type &a, T *p) 
# 268
{ 
# 269
return allocator_traits_detail::construct(a, p); 
# 270
} 
# 272
template< class Alloc> 
# 273
template< class T, class Arg1> inline void 
# 276
allocator_traits< Alloc> ::construct(allocator_type &a, T *p, const Arg1 &arg1) 
# 277
{ 
# 278
return allocator_traits_detail::construct(a, p, arg1); 
# 279
} 
# 281
template< class Alloc> 
# 282
template< class T> inline void 
# 285
allocator_traits< Alloc> ::destroy(allocator_type &a, T *p) 
# 286
{ 
# 287
return allocator_traits_detail::destroy(a, p); 
# 288
} 
# 290
template< class Alloc> inline typename allocator_traits< Alloc> ::size_type 
# 294
allocator_traits< Alloc> ::max_size(const allocator_type &a) 
# 295
{ 
# 296
return allocator_traits_detail::max_size(a); 
# 297
} 
# 299
template< class Alloc> inline typename allocator_system< Alloc> ::get_result_type 
# 303
allocator_system< Alloc> ::get(Alloc &a) 
# 304
{ 
# 305
return allocator_traits_detail::system(a); 
# 306
} 
# 309
}
# 310
}
# 26 "/usr/local/cuda/include/thrust/detail/execute_with_allocator.h"
namespace thrust { 
# 28
namespace detail { 
# 31
template< class ToPointer, class FromPointer> ToPointer 
# 33
reinterpret_pointer_cast(FromPointer ptr) 
# 34
{ 
# 35
typedef typename pointer_element< ToPointer> ::type to_element; 
# 36
return (ToPointer)(reinterpret_cast< to_element *>(thrust::raw_pointer_cast(ptr))); 
# 37
} 
# 40
template< class Allocator, template< class >  class BaseSystem> 
# 41
struct execute_with_allocator : public BaseSystem< execute_with_allocator< Allocator, BaseSystem> >  { 
# 46
typedef BaseSystem< ::thrust::detail::execute_with_allocator< Allocator, BaseSystem> >  super_t; 
# 48
Allocator &m_alloc; 
# 51
execute_with_allocator(const super_t &super, Allocator &alloc) : super_t(super), m_alloc(alloc) 
# 54
{ } 
# 57
execute_with_allocator(Allocator &alloc) : m_alloc(alloc) 
# 59
{ } 
# 61
template< class T> friend inline pair< T *, long>  
# 64
get_temporary_buffer(execute_with_allocator &system, ::std::ptrdiff_t n) 
# 65
{ 
# 66
typedef allocator_traits< Allocator>  alloc_traits; 
# 67
typedef typename allocator_traits< Allocator> ::void_pointer void_pointer; 
# 68
typedef typename allocator_traits< Allocator> ::size_type size_type; 
# 69
typedef typename allocator_traits< Allocator> ::value_type value_type; 
# 72
size_type num_elements = thrust::detail::util::divide_ri(sizeof(T) * n, sizeof(value_type)); 
# 75
void_pointer ptr = alloc_traits::allocate(system.m_alloc, num_elements); 
# 78
return ::thrust::make_pair(detail::reinterpret_pointer_cast< T *> (ptr), n); 
# 79
} 
# 81
template< class Pointer> friend inline void 
# 82
return_temporary_buffer(execute_with_allocator &system, Pointer p) 
# 83
{ 
# 84
typedef allocator_traits< Allocator>  alloc_traits; 
# 85
typedef typename allocator_traits< Allocator> ::pointer pointer; 
# 88
pointer to_ptr = detail::reinterpret_pointer_cast< typename allocator_traits< Allocator> ::pointer> (p); 
# 89
alloc_traits::deallocate(system.m_alloc, to_ptr, 0); 
# 90
} 
# 91
}; 
# 94
}
# 95
}
# 24 "/usr/local/cuda/include/thrust/detail/seq.h"
namespace thrust { 
# 26
namespace detail { 
# 30
struct seq_t : public system::detail::sequential::execution_policy< seq_t>  { 
# 33
seq_t() : system::detail::sequential::execution_policy< seq_t> () { } 
# 36
template< class DerivedPolicy> 
# 38
seq_t(const thrust::execution_policy< DerivedPolicy>  &) : system::detail::sequential::execution_policy< seq_t> () 
# 40
{ } 
# 42
template< class Allocator> execute_with_allocator< Allocator, system::detail::sequential::execution_policy>  
# 44
operator()(Allocator &alloc) const 
# 45
{ 
# 46
return ((execute_with_allocator< Allocator, system::detail::sequential::execution_policy> )(alloc)); 
# 47
} 
# 48
}; 
# 51
}
# 57
static const detail::seq_t seq; 
# 61
}
# 31 "/usr/local/cuda/include/thrust/system/cuda/detail/malloc_and_free.h"
namespace thrust { 
# 33
namespace system { 
# 35
namespace cuda { 
# 37
namespace detail { 
# 43
template< class DerivedPolicy> void *
# 45
malloc(execution_policy< DerivedPolicy>  &, std::size_t n) 
# 46
{ 
# 47
void *result = (0); 
# 51
cudaError_t error = cudaMalloc(reinterpret_cast< void **>(&result), n); 
# 53
if (error) 
# 54
{ 
# 55
throw ((system::detail::bad_alloc)((thrust::cuda_category().message(error)).c_str())); 
# 56
}  
# 61
return result; 
# 62
} 
# 65
template< class DerivedPolicy, class Pointer> void 
# 67
free(execution_policy< DerivedPolicy>  &, Pointer ptr) 
# 68
{ 
# 71
throw_on_error(cudaFree(thrust::raw_pointer_cast(ptr)), "cudaFree in free"); 
# 75
} 
# 78
}
# 79
}
# 80
}
# 81
}
# 43 "/usr/local/cuda/include/thrust/detail/static_assert.h"
namespace thrust { 
# 46
namespace detail { 
# 50
template< bool x> struct STATIC_ASSERTION_FAILURE; 
# 52
template<> struct STATIC_ASSERTION_FAILURE< true>  { enum { value = 1}; }; 
# 55
template< int x> struct static_assert_test { }; 
# 57
template< class , bool x> 
# 58
struct depend_on_instantiation { 
# 60
static const bool value = x; 
# 61
}; 
# 63
}
# 65
}
# 25 "/usr/local/cuda/include/thrust/system/detail/generic/memory.inl"
namespace thrust { 
# 27
namespace system { 
# 29
namespace detail { 
# 31
namespace generic { 
# 35
template< class DerivedPolicy, class Size> void 
# 37
malloc(execution_policy< DerivedPolicy>  &, Size) 
# 38
{ 
# 40
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< Size, false> ::value)> )>  thrust_static_assert_typedef_40 __attribute((unused)); 
# 41
} 
# 44
template< class T, class DerivedPolicy> pointer< T, DerivedPolicy, use_default, use_default>  
# 47
malloc(execution_policy< DerivedPolicy>  &exec, std::size_t n) 
# 48
{ 
# 49
pointer< void, DerivedPolicy, use_default, use_default>  void_ptr = thrust::malloc(exec, sizeof(T) * n); 
# 51
return ((pointer< T, DerivedPolicy, use_default, use_default> )(static_cast< T *>((void_ptr.get())))); 
# 52
} 
# 55
template< class DerivedPolicy, class Pointer> void 
# 57
free(execution_policy< DerivedPolicy>  &, Pointer) 
# 58
{ 
# 60
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< Pointer, false> ::value)> )>  thrust_static_assert_typedef_60 __attribute((unused)); 
# 61
} 
# 64
template< class DerivedPolicy, class Pointer1, class Pointer2> void 
# 66
assign_value(execution_policy< DerivedPolicy>  &, Pointer1, Pointer2) 
# 67
{ 
# 69
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< Pointer1, false> ::value)> )>  thrust_static_assert_typedef_69 __attribute((unused)); 
# 70
} 
# 73
template< class DerivedPolicy, class Pointer> void 
# 75
get_value(execution_policy< DerivedPolicy>  &, Pointer) 
# 76
{ 
# 78
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< Pointer, false> ::value)> )>  thrust_static_assert_typedef_78 __attribute((unused)); 
# 79
} 
# 82
template< class Pointer1, class Pointer2> void 
# 84
iter_swap(tag, Pointer1, Pointer2) 
# 85
{ 
# 87
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< Pointer1, false> ::value)> )>  thrust_static_assert_typedef_87 __attribute((unused)); 
# 88
} 
# 91
}
# 92
}
# 93
}
# 94
}
# 23 "/usr/local/cuda/include/thrust/system/detail/sequential/get_value.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace sequential { 
# 33
template< class DerivedPolicy, class Pointer> typename iterator_value< Pointer> ::type 
# 36
get_value(execution_policy< DerivedPolicy>  &, Pointer ptr) 
# 37
{ 
# 38
return *thrust::raw_pointer_cast(ptr); 
# 39
} 
# 42
}
# 43
}
# 44
}
# 45
}
# 22 "/usr/local/cuda/include/thrust/detail/copy.h"
namespace thrust { 
# 25
template< class System, class 
# 26
InputIterator, class 
# 27
OutputIterator> OutputIterator 
# 25
copy(const detail::execution_policy_base< System>  & system, InputIterator first, InputIterator last, OutputIterator result); 
# 34
template< class System, class 
# 35
InputIterator, class 
# 36
Size, class 
# 37
OutputIterator> OutputIterator 
# 34
copy_n(const detail::execution_policy_base< System>  & system, InputIterator first, Size n, OutputIterator result); 
# 44
template< class InputIterator, class 
# 45
OutputIterator> OutputIterator 
# 44
copy(InputIterator first, InputIterator last, OutputIterator result); 
# 50
template< class InputIterator, class 
# 51
Size, class 
# 52
OutputIterator> OutputIterator 
# 50
copy_n(InputIterator first, Size n, OutputIterator result); 
# 58
namespace detail { 
# 62
template< class FromSystem, class 
# 63
ToSystem, class 
# 64
InputIterator, class 
# 65
OutputIterator> OutputIterator 
# 62
two_system_copy(const execution_policy< FromSystem>  & from_system, const execution_policy< ToSystem>  & two_system, InputIterator first, InputIterator last, OutputIterator result); 
# 74
template< class FromSystem, class 
# 75
ToSystem, class 
# 76
InputIterator, class 
# 77
Size, class 
# 78
OutputIterator> OutputIterator 
# 74
two_system_copy_n(const execution_policy< FromSystem>  & from_system, const execution_policy< ToSystem>  & two_system, InputIterator first, Size n, OutputIterator result); 
# 87
}
# 88
}
# 22 "/usr/local/cuda/include/thrust/system/detail/generic/copy.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace generic { 
# 32
template< class DerivedPolicy, class 
# 33
InputIterator, class 
# 34
OutputIterator> OutputIterator 
# 32
copy(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 42
template< class DerivedPolicy, class 
# 43
InputIterator, class 
# 44
Size, class 
# 45
OutputIterator> OutputIterator 
# 42
copy_n(execution_policy< DerivedPolicy>  & exec, InputIterator first, Size n, OutputIterator result); 
# 53
}
# 54
}
# 55
}
# 56
}
# 32 "/usr/local/cuda/include/thrust/detail/raw_reference_cast.h"
namespace thrust { 
# 34
namespace detail { 
# 38
template< class T> struct is_wrapped_reference { typedef char yes_type; typedef int no_type; template< class S> static yes_type test(typename S::wrapped_reference_hint *); template< class S> static no_type test(...); static const bool value = (sizeof(test< T> (0)) == sizeof(yes_type)); typedef integral_constant< bool, value>  type; }; 
# 43
template< class T> 
# 44
struct is_unwrappable : public is_wrapped_reference< T>  { 
# 46
}; 
# 51
template< class 
# 52
T0, class T1, class T2, class 
# 53
T3, class T4, class T5, class 
# 54
T6, class T7, class T8, class 
# 55
T9> 
# 57
struct is_unwrappable< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  : public or_< is_unwrappable< T0> , is_unwrappable< T1> , is_unwrappable< T2> , is_unwrappable< T3> , is_unwrappable< T4> , is_unwrappable< T5> , is_unwrappable< T6> , is_unwrappable< T7> , is_unwrappable< T8> , is_unwrappable< T9> >  { 
# 72
}; 
# 77
template< class 
# 78
T0, class T1, class T2, class 
# 79
T3, class T4, class T5, class 
# 80
T6, class T7, class T8, class 
# 81
T9> 
# 83
struct is_unwrappable< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  : public or_< is_unwrappable< T0> , is_unwrappable< T1> , is_unwrappable< T2> , is_unwrappable< T3> , is_unwrappable< T4> , is_unwrappable< T5> , is_unwrappable< T6> , is_unwrappable< T7> , is_unwrappable< T8> , is_unwrappable< T9> >  { 
# 98
}; 
# 101
template< class T, class Result = void> 
# 102
struct enable_if_unwrappable : public enable_if< is_unwrappable< T> ::value, Result>  { 
# 107
}; 
# 110
namespace raw_reference_detail { 
# 114
template< class T, class Enable = void> 
# 115
struct raw_reference_impl : public add_reference< T>  { 
# 117
}; 
# 120
template< class T> 
# 121
struct raw_reference_impl< T, typename enable_if< is_wrapped_reference< typename remove_cv< T> ::type> ::value> ::type>  { 
# 132
typedef typename add_reference< typename pointer_element< typename T::pointer> ::type> ::type type; 
# 133
}; 
# 136
}
# 139
template< class T> 
# 140
struct raw_reference : public raw_reference_detail::raw_reference_impl< T>  { 
# 142
}; 
# 145
namespace raw_reference_detail { 
# 162
template< class T> 
# 163
struct raw_reference_tuple_helper : public eval_if< is_unwrappable< typename remove_cv< T> ::type> ::value, raw_reference< T> , identity_< T> >  { 
# 171
}; 
# 175
template< class 
# 176
T0, class T1, class T2, class 
# 177
T3, class T4, class T5, class 
# 178
T6, class T7, class T8, class 
# 179
T9> 
# 181
struct raw_reference_tuple_helper< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  { 
# 196
typedef tuple< typename raw_reference_detail::raw_reference_tuple_helper< T0> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T1> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T2> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T3> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T4> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T5> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T6> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T7> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T8> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T9> ::type>  type; 
# 197
}; 
# 200
template< class 
# 201
T0, class T1, class T2, class 
# 202
T3, class T4, class T5, class 
# 203
T6, class T7, class T8, class 
# 204
T9> 
# 206
struct raw_reference_tuple_helper< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  { 
# 221
typedef tuple_of_iterator_references< typename raw_reference_detail::raw_reference_tuple_helper< T0> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T1> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T2> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T3> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T4> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T5> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T6> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T7> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T8> ::type, typename raw_reference_detail::raw_reference_tuple_helper< T9> ::type>  type; 
# 222
}; 
# 225
}
# 234
template< class 
# 235
T0, class T1, class T2, class 
# 236
T3, class T4, class T5, class 
# 237
T6, class T7, class T8, class 
# 238
T9> 
# 240
struct raw_reference< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  { 
# 245
private: typedef tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  tuple_type; 
# 252
public: typedef typename eval_if< is_unwrappable< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::value, raw_reference_detail::raw_reference_tuple_helper< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > , add_reference< tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > > ::type type; 
# 253
}; 
# 256
template< class 
# 257
T0, class T1, class T2, class 
# 258
T3, class T4, class T5, class 
# 259
T6, class T7, class T8, class 
# 260
T9> 
# 262
struct raw_reference< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> >  { 
# 267
private: typedef tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  tuple_type; 
# 270
public: typedef typename raw_reference_detail::raw_reference_tuple_helper< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::type type; 
# 278
}; 
# 281
}
# 285
template< class T> inline typename detail::raw_reference< T> ::type raw_reference_cast(T & ref); 
# 291
template< class T> inline typename detail::raw_reference< const T> ::type raw_reference_cast(const T & ref); 
# 297
template< class 
# 298
T0, class T1, class T2, class 
# 299
T3, class T4, class T5, class 
# 300
T6, class T7, class T8, class 
# 301
T9> typename detail::enable_if_unwrappable< detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> , typename detail::raw_reference< detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::type> ::type 
# 297
raw_reference_cast(detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  t); 
# 313
namespace detail { 
# 317
struct raw_reference_caster { 
# 319
template< class T> typename raw_reference< T> ::type 
# 321
operator()(T &ref) 
# 322
{ 
# 323
return thrust::raw_reference_cast(ref); 
# 324
} 
# 326
template< class T> typename raw_reference< const T> ::type 
# 328
operator()(const T &ref) 
# 329
{ 
# 330
return thrust::raw_reference_cast(ref); 
# 331
} 
# 333
template< class 
# 334
T0, class T1, class T2, class 
# 335
T3, class T4, class T5, class 
# 336
T6, class T7, class T8, class 
# 337
T9> typename raw_reference< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::type 
# 343
operator()(tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  t, typename enable_if< is_unwrappable< tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::value> ::type * = 0) 
# 347
{ 
# 348
return thrust::raw_reference_cast(t); 
# 349
} 
# 350
}; 
# 353
}
# 356
template< class T> inline typename detail::raw_reference< T> ::type 
# 359
raw_reference_cast(T &ref) 
# 360
{ 
# 361
return *thrust::raw_pointer_cast(&ref); 
# 362
} 
# 365
template< class T> inline typename detail::raw_reference< const T> ::type 
# 368
raw_reference_cast(const T &ref) 
# 369
{ 
# 370
return *thrust::raw_pointer_cast(&ref); 
# 371
} 
# 374
template< class 
# 375
T0, class T1, class T2, class 
# 376
T3, class T4, class T5, class 
# 377
T6, class T7, class T8, class 
# 378
T9> typename detail::enable_if_unwrappable< detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> , typename detail::raw_reference< detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> > ::type> ::type 
# 387
raw_reference_cast(detail::tuple_of_iterator_references< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>  t) 
# 388
{ 
# 389
detail::raw_reference_caster f; 
# 393
return detail::tuple_host_device_transform< detail::raw_reference_detail::raw_reference_tuple_helper> (t, f); 
# 394
} 
# 397
}
# 63 "/usr/include/c++/5/bits/stl_construct.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 77
template< class _T1, class _T2> inline void 
# 79
_Construct(_T1 *__p, const _T2 &__value) 
# 80
{ 
# 83
::new (static_cast< void *>(__p)) (_T1)(__value); 
# 84
} 
# 90
template< class _Tp> inline void 
# 92
_Destroy(_Tp *__pointer) 
# 93
{ (__pointer->~_Tp()); } 
# 95
template< bool > 
# 96
struct _Destroy_aux { 
# 98
template< class _ForwardIterator> static void 
# 100
__destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 101
{ 
# 102
for (; __first != __last; ++__first) { 
# 103
std::_Destroy(std::__addressof(*__first)); }  
# 104
} 
# 105
}; 
# 108
template<> struct _Destroy_aux< true>  { 
# 110
template< class _ForwardIterator> static void 
# 112
__destroy(_ForwardIterator, _ForwardIterator) { } 
# 113
}; 
# 120
template< class _ForwardIterator> inline void 
# 122
_Destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 123
{ 
# 125
typedef typename iterator_traits< _ForwardIterator> ::value_type _Value_type; 
# 126
std::_Destroy_aux< __has_trivial_destructor(typename iterator_traits< _ForwardIterator> ::value_type)> ::__destroy(__first, __last); 
# 128
} 
# 136
template< class _ForwardIterator, class _Allocator> void 
# 138
_Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &
# 139
__alloc) 
# 140
{ 
# 141
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 142
for (; __first != __last; ++__first) { 
# 143
__traits::destroy(__alloc, std::__addressof(*__first)); }  
# 144
} 
# 146
template< class _ForwardIterator, class _Tp> inline void 
# 148
_Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp>  &) 
# 150
{ 
# 151
_Destroy(__first, __last); 
# 152
} 
# 155
}
# 59 "/usr/include/c++/5/bits/stl_uninitialized.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< bool _TrivialValueTypes> 
# 64
struct __uninitialized_copy { 
# 66
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 68
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 69
__result) 
# 70
{ 
# 71
_ForwardIterator __cur = __result; 
# 72
try 
# 73
{ 
# 74
for (; __first != __last; (++__first), (++__cur)) { 
# 75
std::_Construct(std::__addressof(*__cur), *__first); }  
# 76
return __cur; 
# 77
} 
# 78
catch (...) 
# 79
{ 
# 80
std::_Destroy(__result, __cur); 
# 81
throw; 
# 82
}  
# 83
} 
# 84
}; 
# 87
template<> struct __uninitialized_copy< true>  { 
# 89
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 91
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 92
__result) 
# 93
{ return std::copy(__first, __last, __result); } 
# 94
}; 
# 105
template< class _InputIterator, class _ForwardIterator> inline _ForwardIterator 
# 107
uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 108
__result) 
# 109
{ 
# 111
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType1; 
# 113
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType2; 
# 115
const bool __assignable = true; 
# 123
return std::__uninitialized_copy< __is_trivial(typename iterator_traits< _InputIterator> ::value_type) && __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && true> ::__uninit_copy(__first, __last, __result); 
# 127
} 
# 130
template< bool _TrivialValueType> 
# 131
struct __uninitialized_fill { 
# 133
template< class _ForwardIterator, class _Tp> static void 
# 135
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 136
__x) 
# 137
{ 
# 138
_ForwardIterator __cur = __first; 
# 139
try 
# 140
{ 
# 141
for (; __cur != __last; ++__cur) { 
# 142
std::_Construct(std::__addressof(*__cur), __x); }  
# 143
} 
# 144
catch (...) 
# 145
{ 
# 146
std::_Destroy(__first, __cur); 
# 147
throw; 
# 148
}  
# 149
} 
# 150
}; 
# 153
template<> struct __uninitialized_fill< true>  { 
# 155
template< class _ForwardIterator, class _Tp> static void 
# 157
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 158
__x) 
# 159
{ std::fill(__first, __last, __x); } 
# 160
}; 
# 171
template< class _ForwardIterator, class _Tp> inline void 
# 173
uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 174
__x) 
# 175
{ 
# 177
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 179
const bool __assignable = true; 
# 185
std::__uninitialized_fill< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && true> ::__uninit_fill(__first, __last, __x); 
# 187
} 
# 190
template< bool _TrivialValueType> 
# 191
struct __uninitialized_fill_n { 
# 193
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 195
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 196
__x) 
# 197
{ 
# 198
_ForwardIterator __cur = __first; 
# 199
try 
# 200
{ 
# 201
for (; __n > 0; (--__n), (++__cur)) { 
# 202
std::_Construct(std::__addressof(*__cur), __x); }  
# 203
return __cur; 
# 204
} 
# 205
catch (...) 
# 206
{ 
# 207
std::_Destroy(__first, __cur); 
# 208
throw; 
# 209
}  
# 210
} 
# 211
}; 
# 214
template<> struct __uninitialized_fill_n< true>  { 
# 216
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 218
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 219
__x) 
# 220
{ return std::fill_n(__first, __n, __x); } 
# 221
}; 
# 234
template< class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator 
# 236
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) 
# 237
{ 
# 239
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 241
const bool __assignable = true; 
# 246
return __uninitialized_fill_n< __is_trivial(typename iterator_traits< _ForwardIterator> ::value_type) && true> ::__uninit_fill_n(__first, __n, __x); 
# 248
} 
# 256
template< class _InputIterator, class _ForwardIterator, class 
# 257
_Allocator> _ForwardIterator 
# 259
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 260
__result, _Allocator &__alloc) 
# 261
{ 
# 262
_ForwardIterator __cur = __result; 
# 263
try 
# 264
{ 
# 265
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 266
for (; __first != __last; (++__first), (++__cur)) { 
# 267
__traits::construct(__alloc, std::__addressof(*__cur), *__first); }  
# 268
return __cur; 
# 269
} 
# 270
catch (...) 
# 271
{ 
# 272
std::_Destroy(__result, __cur, __alloc); 
# 273
throw; 
# 274
}  
# 275
} 
# 277
template< class _InputIterator, class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 279
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 280
__result, allocator< _Tp>  &) 
# 281
{ return std::uninitialized_copy(__first, __last, __result); } 
# 283
template< class _InputIterator, class _ForwardIterator, class 
# 284
_Allocator> inline _ForwardIterator 
# 286
__uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 287
__result, _Allocator &__alloc) 
# 288
{ 
# 289
return std::__uninitialized_copy_a(__first, __last, __result, __alloc); 
# 292
} 
# 294
template< class _InputIterator, class _ForwardIterator, class 
# 295
_Allocator> inline _ForwardIterator 
# 297
__uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator 
# 298
__last, _ForwardIterator 
# 299
__result, _Allocator &
# 300
__alloc) 
# 301
{ 
# 302
return std::__uninitialized_copy_a(__first, __last, __result, __alloc); 
# 305
} 
# 307
template< class _ForwardIterator, class _Tp, class _Allocator> void 
# 309
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 310
__x, _Allocator &__alloc) 
# 311
{ 
# 312
_ForwardIterator __cur = __first; 
# 313
try 
# 314
{ 
# 315
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 316
for (; __cur != __last; ++__cur) { 
# 317
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 318
} 
# 319
catch (...) 
# 320
{ 
# 321
std::_Destroy(__first, __cur, __alloc); 
# 322
throw; 
# 323
}  
# 324
} 
# 326
template< class _ForwardIterator, class _Tp, class _Tp2> inline void 
# 328
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 329
__x, allocator< _Tp2>  &) 
# 330
{ std::uninitialized_fill(__first, __last, __x); } 
# 332
template< class _ForwardIterator, class _Size, class _Tp, class 
# 333
_Allocator> _ForwardIterator 
# 335
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 336
__x, _Allocator &__alloc) 
# 337
{ 
# 338
_ForwardIterator __cur = __first; 
# 339
try 
# 340
{ 
# 341
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 342
for (; __n > 0; (--__n), (++__cur)) { 
# 343
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 344
return __cur; 
# 345
} 
# 346
catch (...) 
# 347
{ 
# 348
std::_Destroy(__first, __cur, __alloc); 
# 349
throw; 
# 350
}  
# 351
} 
# 353
template< class _ForwardIterator, class _Size, class _Tp, class 
# 354
_Tp2> inline _ForwardIterator 
# 356
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 357
__x, allocator< _Tp2>  &) 
# 358
{ return std::uninitialized_fill_n(__first, __n, __x); } 
# 370
template< class _InputIterator1, class _InputIterator2, class 
# 371
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 373
__uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 
# 374
__last1, _InputIterator2 
# 375
__first2, _InputIterator2 
# 376
__last2, _ForwardIterator 
# 377
__result, _Allocator &
# 378
__alloc) 
# 379
{ 
# 380
_ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc); 
# 383
try 
# 384
{ 
# 385
return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc); 
# 386
} 
# 387
catch (...) 
# 388
{ 
# 389
std::_Destroy(__result, __mid, __alloc); 
# 390
throw; 
# 391
}  
# 392
} 
# 398
template< class _InputIterator1, class _InputIterator2, class 
# 399
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 401
__uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 
# 402
__last1, _InputIterator2 
# 403
__first2, _InputIterator2 
# 404
__last2, _ForwardIterator 
# 405
__result, _Allocator &
# 406
__alloc) 
# 407
{ 
# 408
_ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc); 
# 411
try 
# 412
{ 
# 413
return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc); 
# 414
} 
# 415
catch (...) 
# 416
{ 
# 417
std::_Destroy(__result, __mid, __alloc); 
# 418
throw; 
# 419
}  
# 420
} 
# 425
template< class _ForwardIterator, class _Tp, class _InputIterator, class 
# 426
_Allocator> inline _ForwardIterator 
# 428
__uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &
# 429
__x, _InputIterator __first, _InputIterator 
# 430
__last, _Allocator &__alloc) 
# 431
{ 
# 432
std::__uninitialized_fill_a(__result, __mid, __x, __alloc); 
# 433
try 
# 434
{ 
# 435
return std::__uninitialized_move_a(__first, __last, __mid, __alloc); 
# 436
} 
# 437
catch (...) 
# 438
{ 
# 439
std::_Destroy(__result, __mid, __alloc); 
# 440
throw; 
# 441
}  
# 442
} 
# 447
template< class _InputIterator, class _ForwardIterator, class _Tp, class 
# 448
_Allocator> inline void 
# 450
__uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 451
__first2, _ForwardIterator 
# 452
__last2, const _Tp &__x, _Allocator &
# 453
__alloc) 
# 454
{ 
# 455
_ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc); 
# 458
try 
# 459
{ 
# 460
std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc); 
# 461
} 
# 462
catch (...) 
# 463
{ 
# 464
std::_Destroy(__first2, __mid2, __alloc); 
# 465
throw; 
# 466
}  
# 467
} 
# 686
}
# 62 "/usr/include/c++/5/bits/stl_tempbuf.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 83
template< class _Tp> pair< _Tp *, long>  
# 85
get_temporary_buffer(ptrdiff_t __len) 
# 86
{ 
# 87
const ptrdiff_t __max = (__gnu_cxx::__numeric_traits_integer< long> ::__max / sizeof(_Tp)); 
# 89
if (__len > __max) { 
# 90
__len = __max; }  
# 92
while (__len > (0)) 
# 93
{ 
# 94
_Tp *__tmp = static_cast< _Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow)); 
# 96
if (__tmp != 0) { 
# 97
return pair< _Tp *, long> (__tmp, __len); }  
# 98
__len /= (2); 
# 99
}  
# 100
return pair< _Tp *, long> (static_cast< _Tp *>(0), 0); 
# 101
} 
# 110
template< class _Tp> inline void 
# 112
return_temporary_buffer(_Tp *__p) 
# 113
{ ::operator delete(__p, std::nothrow); } 
# 121
template< class _ForwardIterator, class _Tp> 
# 122
class _Temporary_buffer { 
# 128
public: typedef _Tp value_type; 
# 129
typedef value_type *pointer; 
# 130
typedef pointer iterator; 
# 131
typedef ptrdiff_t size_type; 
# 134
protected: size_type _M_original_len; 
# 135
size_type _M_len; 
# 136
pointer _M_buffer; 
# 141
public: size_type size() const 
# 142
{ return _M_len; } 
# 146
size_type requested_size() const 
# 147
{ return _M_original_len; } 
# 151
iterator begin() 
# 152
{ return _M_buffer; } 
# 156
iterator end() 
# 157
{ return (_M_buffer) + (_M_len); } 
# 163
_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last); 
# 165
~_Temporary_buffer() 
# 166
{ 
# 167
std::_Destroy(_M_buffer, (_M_buffer) + (_M_len)); 
# 168
std::return_temporary_buffer(_M_buffer); 
# 169
} 
# 173
private: _Temporary_buffer(const _Temporary_buffer &); 
# 176
void operator=(const _Temporary_buffer &); 
# 177
}; 
# 180
template< bool > 
# 181
struct __uninitialized_construct_buf_dispatch { 
# 183
template< class _Pointer, class _ForwardIterator> static void 
# 185
__ucr(_Pointer __first, _Pointer __last, _ForwardIterator 
# 186
__seed) 
# 187
{ 
# 188
if (__first == __last) { 
# 189
return; }  
# 191
_Pointer __cur = __first; 
# 192
try 
# 193
{ 
# 194
std::_Construct(std::__addressof(*__first), *__seed); 
# 196
_Pointer __prev = __cur; 
# 197
++__cur; 
# 198
for (; __cur != __last; (++__cur), (++__prev)) { 
# 199
std::_Construct(std::__addressof(*__cur), *__prev); }  
# 201
(*__seed) = (*__prev); 
# 202
} 
# 203
catch (...) 
# 204
{ 
# 205
std::_Destroy(__first, __cur); 
# 206
throw; 
# 207
}  
# 208
} 
# 209
}; 
# 212
template<> struct __uninitialized_construct_buf_dispatch< true>  { 
# 214
template< class _Pointer, class _ForwardIterator> static void 
# 216
__ucr(_Pointer, _Pointer, _ForwardIterator) { } 
# 217
}; 
# 229
template< class _Pointer, class _ForwardIterator> inline void 
# 231
__uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator 
# 232
__seed) 
# 233
{ 
# 235
typedef typename iterator_traits< _Pointer> ::value_type _ValueType; 
# 237
std::__uninitialized_construct_buf_dispatch< __has_trivial_constructor(typename iterator_traits< _Pointer> ::value_type)> ::__ucr(__first, __last, __seed); 
# 240
} 
# 242
template< class _ForwardIterator, class _Tp> 
# 244
_Temporary_buffer< _ForwardIterator, _Tp> ::_Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) : _M_original_len(std::distance(__first, __last)), _M_len((0)), _M_buffer((0)) 
# 247
{ 
# 248
try 
# 249
{ 
# 250
pair< _Tp *, long>  __p(std::get_temporary_buffer< value_type> (_M_original_len)); 
# 252
(_M_buffer) = (__p.first); 
# 253
(_M_len) = (__p.second); 
# 254
if (_M_buffer) { 
# 255
std::__uninitialized_construct_buf(_M_buffer, (_M_buffer) + (_M_len), __first); }  
# 257
} 
# 258
catch (...) 
# 259
{ 
# 260
std::return_temporary_buffer(_M_buffer); 
# 261
(_M_buffer) = 0; 
# 262
(_M_len) = (0); 
# 263
throw; 
# 264
}  
# 265
} 
# 268
}
# 59 "/usr/include/c++/5/bits/stl_raw_storage_iter.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 67
template< class _OutputIterator, class _Tp> 
# 68
class raw_storage_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 72
protected: _OutputIterator _M_iter; 
# 76
public: explicit raw_storage_iterator(_OutputIterator __x) : _M_iter(__x) 
# 77
{ } 
# 80
raw_storage_iterator &operator*() { return *this; } 
# 83
raw_storage_iterator &operator=(const _Tp &__element) 
# 84
{ 
# 85
std::_Construct(std::__addressof(*(_M_iter)), __element); 
# 86
return *this; 
# 87
} 
# 90
raw_storage_iterator &operator++() 
# 91
{ 
# 92
++(_M_iter); 
# 93
return *this; 
# 94
} 
# 97
raw_storage_iterator operator++(int) 
# 98
{ 
# 99
raw_storage_iterator __tmp = *this; 
# 100
++(_M_iter); 
# 101
return __tmp; 
# 102
} 
# 103
}; 
# 106
}
# 36 "/usr/include/c++/5/backward/auto_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
template< class _Tp1> 
# 48
struct auto_ptr_ref { 
# 50
_Tp1 *_M_ptr; 
# 53
explicit auto_ptr_ref(_Tp1 *__p) : _M_ptr(__p) { } 
# 54
}; 
# 86
template< class _Tp> 
# 87
class auto_ptr { 
# 90
_Tp *_M_ptr; 
# 94
public: typedef _Tp element_type; 
# 103
explicit auto_ptr(element_type *__p = 0) throw() : _M_ptr(__p) { } 
# 112
auto_ptr(auto_ptr &__a) throw() : _M_ptr(__a.release()) { } 
# 124
template< class _Tp1> 
# 125
auto_ptr(std::auto_ptr< _Tp1>  &__a) throw() : _M_ptr((__a.release())) { } 
# 136
auto_ptr &operator=(auto_ptr &__a) throw() 
# 137
{ 
# 138
reset(__a.release()); 
# 139
return *this; 
# 140
} 
# 152
template< class _Tp1> auto_ptr &
# 154
operator=(std::auto_ptr< _Tp1>  &__a) throw() 
# 155
{ 
# 156
reset((__a.release())); 
# 157
return *this; 
# 158
} 
# 170
~auto_ptr() { delete (_M_ptr); } 
# 181
element_type &operator*() const throw() 
# 182
{ 
# 183
; 
# 184
return *(_M_ptr); 
# 185
} 
# 194
element_type *operator->() const throw() 
# 195
{ 
# 196
; 
# 197
return _M_ptr; 
# 198
} 
# 211
element_type *get() const throw() { return _M_ptr; } 
# 225
element_type *release() throw() 
# 226
{ 
# 227
element_type *__tmp = _M_ptr; 
# 228
(_M_ptr) = 0; 
# 229
return __tmp; 
# 230
} 
# 240
void reset(element_type *__p = 0) throw() 
# 241
{ 
# 242
if (__p != (_M_ptr)) 
# 243
{ 
# 244
delete (_M_ptr); 
# 245
(_M_ptr) = __p; 
# 246
}  
# 247
} 
# 260
auto_ptr(auto_ptr_ref< _Tp>  __ref) throw() : _M_ptr(((__ref._M_ptr))) 
# 261
{ } 
# 264
auto_ptr &operator=(auto_ptr_ref< _Tp>  __ref) throw() 
# 265
{ 
# 266
if ((__ref._M_ptr) != this->get()) 
# 267
{ 
# 268
delete (_M_ptr); 
# 269
(_M_ptr) = (__ref._M_ptr); 
# 270
}  
# 271
return *this; 
# 272
} 
# 274
template< class _Tp1> 
# 275
operator auto_ptr_ref< _Tp1> () throw() 
# 276
{ return ((auto_ptr_ref< _Tp1> )(this->release())); } 
# 278
template< class _Tp1> 
# 279
operator std::auto_ptr< _Tp1> () throw() 
# 280
{ return ((std::auto_ptr< _Tp1> )(this->release())); } 
# 281
}; 
# 286
template<> class auto_ptr< void>  { 
# 289
public: typedef void element_type; 
# 290
}; 
# 327
}
# 31 "/usr/local/cuda/include/thrust/detail/internal_functional.h"
namespace thrust { 
# 33
namespace detail { 
# 37
template< class Predicate> 
# 38
struct unary_negate { 
# 40
typedef bool result_type; 
# 42
Predicate pred; 
# 45
explicit unary_negate(const Predicate &pred) : pred(pred) { } 
# 47
template< class T> bool 
# 49
operator()(const T &x) 
# 50
{ 
# 51
return !((bool)(pred)(x)); 
# 52
} 
# 53
}; 
# 56
template< class Predicate> 
# 57
struct binary_negate { 
# 59
typedef bool result_type; 
# 61
Predicate pred; 
# 64
explicit binary_negate(const Predicate &pred) : pred(pred) { } 
# 66
template< class T1, class T2> bool 
# 68
operator()(const T1 &x, const T2 &y) 
# 69
{ 
# 70
return !((bool)(pred)(x, y)); 
# 71
} 
# 72
}; 
# 74
template< class Predicate> unary_negate< Predicate>  
# 76
not1(const Predicate &pred) 
# 77
{ 
# 78
return ((unary_negate< Predicate> )(pred)); 
# 79
} 
# 81
template< class Predicate> binary_negate< Predicate>  
# 83
not2(const Predicate &pred) 
# 84
{ 
# 85
return ((binary_negate< Predicate> )(pred)); 
# 86
} 
# 90
template< class Predicate, class IntegralType> 
# 91
struct predicate_to_integral { 
# 93
Predicate pred; 
# 96
explicit predicate_to_integral(const Predicate &pred) : pred(pred) { } 
# 98
template< class T> bool 
# 100
operator()(const T &x) 
# 101
{ 
# 102
return ((pred)(x)) ? (IntegralType)1 : ((IntegralType)0); 
# 103
} 
# 104
}; 
# 108
template< class T1> 
# 109
struct equal_to { 
# 111
typedef bool result_type; 
# 113
template< class T2> bool 
# 115
operator()(const T1 &lhs, const T2 &rhs) const 
# 116
{ 
# 117
return lhs == rhs; 
# 118
} 
# 119
}; 
# 122
template< class T2> 
# 123
struct equal_to_value { 
# 125
T2 rhs; 
# 128
equal_to_value(const T2 &rhs) : rhs(rhs) { } 
# 130
template< class T1> bool 
# 132
operator()(const T1 &lhs) const 
# 133
{ 
# 134
return lhs == (rhs); 
# 135
} 
# 136
}; 
# 138
template< class Predicate> 
# 139
struct tuple_binary_predicate { 
# 141
typedef bool result_type; 
# 144
tuple_binary_predicate(const Predicate &p) : pred(p) { } 
# 146
template< class Tuple> bool 
# 148
operator()(const Tuple &t) const 
# 149
{ 
# 150
return (pred)(thrust::get< 0> (t), thrust::get< 1> (t)); 
# 151
} 
# 153
mutable Predicate pred; 
# 154
}; 
# 156
template< class Predicate> 
# 157
struct tuple_not_binary_predicate { 
# 159
typedef bool result_type; 
# 162
tuple_not_binary_predicate(const Predicate &p) : pred(p) { } 
# 164
template< class Tuple> bool 
# 166
operator()(const Tuple &t) const 
# 167
{ 
# 168
return !(pred)(thrust::get< 0> (t), thrust::get< 1> (t)); 
# 169
} 
# 171
mutable Predicate pred; 
# 172
}; 
# 174
template< class Generator> 
# 175
struct host_generate_functor { 
# 177
typedef void result_type; 
# 180
host_generate_functor(Generator g) : gen(g) 
# 181
{ } 
# 193
template< class T> void 
# 195
operator()(const T &x) 
# 196
{ 
# 198
T &lvalue = const_cast< T &>(x); 
# 201
lvalue = (gen)(); 
# 202
} 
# 204
Generator gen; 
# 205
}; 
# 207
template< class Generator> 
# 208
struct device_generate_functor { 
# 210
typedef void result_type; 
# 213
device_generate_functor(Generator g) : gen(g) 
# 214
{ } 
# 226
template< class T> void 
# 228
operator()(const T &x) 
# 229
{ 
# 231
T &lvalue = const_cast< T &>(x); 
# 234
lvalue = (gen)(); 
# 235
} 
# 237
Generator gen; 
# 238
}; 
# 240
template< class System, class Generator> 
# 241
struct generate_functor : public eval_if< is_convertible< System, system::cpp::detail::tag> ::value, identity_< host_generate_functor< Generator> > , identity_< device_generate_functor< Generator> > >  { 
# 247
}; 
# 250
template< class ResultType, class BinaryFunction> 
# 251
struct zipped_binary_op { 
# 253
typedef ResultType result_type; 
# 256
zipped_binary_op(BinaryFunction binary_op) : m_binary_op(binary_op) 
# 257
{ } 
# 259
template< class Tuple> result_type 
# 261
operator()(Tuple t) 
# 262
{ 
# 263
return (m_binary_op)(thrust::get< 0> (t), thrust::get< 1> (t)); 
# 264
} 
# 266
BinaryFunction m_binary_op; 
# 267
}; 
# 270
template< class T> 
# 271
struct is_non_const_reference : public and_< not_< is_const< T> > , is_reference< T> >  { 
# 276
}; 
# 278
template< class T> struct is_tuple_of_iterator_references : public false_type { }; 
# 280
template< class T1, class T2, class T3, class 
# 281
T4, class T5, class T6, class 
# 282
T7, class T8, class T9, class 
# 283
T10> 
# 284
struct is_tuple_of_iterator_references< tuple_of_iterator_references< T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> >  : public true_type { 
# 290
}; 
# 294
template< class T> 
# 295
struct enable_if_non_const_reference_or_tuple_of_iterator_references : public enable_if< is_non_const_reference< T> ::value || is_tuple_of_iterator_references< T> ::value>  { 
# 299
}; 
# 302
template< class UnaryFunction> 
# 303
struct unary_transform_functor { 
# 305
typedef void result_type; 
# 307
UnaryFunction f; 
# 310
unary_transform_functor(UnaryFunction f) : f(f) 
# 312
{ } 
# 315
template< class Tuple> typename enable_if_non_const_reference_or_tuple_of_iterator_references< typename tuple_element< 1, Tuple> ::type> ::type 
# 320
operator()(Tuple t) 
# 321
{ 
# 322
thrust::get< 1> (t) = (f)(thrust::get< 0> (t)); 
# 323
} 
# 324
}; 
# 327
template< class BinaryFunction> 
# 328
struct binary_transform_functor { 
# 330
BinaryFunction f; 
# 333
binary_transform_functor(BinaryFunction f) : f(f) 
# 335
{ } 
# 338
template< class Tuple> typename enable_if_non_const_reference_or_tuple_of_iterator_references< typename tuple_element< 2, Tuple> ::type> ::type 
# 343
operator()(Tuple t) 
# 344
{ 
# 345
thrust::get< 2> (t) = (f)(thrust::get< 0> (t), thrust::get< 1> (t)); 
# 346
} 
# 347
}; 
# 350
template< class UnaryFunction, class Predicate> 
# 351
struct unary_transform_if_functor { 
# 353
UnaryFunction unary_op; 
# 354
Predicate pred; 
# 357
unary_transform_if_functor(UnaryFunction unary_op, Predicate pred) : unary_op(unary_op), pred(pred) 
# 359
{ } 
# 362
template< class Tuple> typename enable_if_non_const_reference_or_tuple_of_iterator_references< typename tuple_element< 1, Tuple> ::type> ::type 
# 367
operator()(Tuple t) 
# 368
{ 
# 369
if ((pred)(thrust::get< 0> (t))) 
# 370
{ 
# 371
thrust::get< 1> (t) = (unary_op)(thrust::get< 0> (t)); 
# 372
}  
# 373
} 
# 374
}; 
# 377
template< class UnaryFunction, class Predicate> 
# 378
struct unary_transform_if_with_stencil_functor { 
# 380
UnaryFunction unary_op; 
# 381
Predicate pred; 
# 384
unary_transform_if_with_stencil_functor(UnaryFunction unary_op, Predicate pred) : unary_op(unary_op), pred(pred) 
# 386
{ } 
# 389
template< class Tuple> typename enable_if_non_const_reference_or_tuple_of_iterator_references< typename tuple_element< 2, Tuple> ::type> ::type 
# 394
operator()(Tuple t) 
# 395
{ 
# 396
if ((pred)(thrust::get< 1> (t))) { 
# 397
thrust::get< 2> (t) = (unary_op)(thrust::get< 0> (t)); }  
# 398
} 
# 399
}; 
# 402
template< class BinaryFunction, class Predicate> 
# 403
struct binary_transform_if_functor { 
# 405
BinaryFunction binary_op; 
# 406
Predicate pred; 
# 409
binary_transform_if_functor(BinaryFunction binary_op, Predicate pred) : binary_op(binary_op), pred(pred) 
# 410
{ } 
# 413
template< class Tuple> typename enable_if_non_const_reference_or_tuple_of_iterator_references< typename tuple_element< 3, Tuple> ::type> ::type 
# 418
operator()(Tuple t) 
# 419
{ 
# 420
if ((pred)(thrust::get< 2> (t))) { 
# 421
thrust::get< 3> (t) = (binary_op)(thrust::get< 0> (t), thrust::get< 1> (t)); }  
# 422
} 
# 423
}; 
# 426
template< class T> 
# 427
struct host_destroy_functor { 
# 430
void operator()(T &x) const 
# 431
{ 
# 432
(x.~T()); 
# 433
} 
# 434
}; 
# 437
template< class T> 
# 438
struct device_destroy_functor { 
# 442
void operator()(T &x) const 
# 443
{ 
# 444
(x.~T()); 
# 445
} 
# 446
}; 
# 449
template< class System, class T> 
# 450
struct destroy_functor : public eval_if< is_convertible< System, system::cpp::detail::tag> ::value, identity_< host_destroy_functor< T> > , identity_< device_destroy_functor< T> > >  { 
# 456
}; 
# 459
template< class T> 
# 460
struct fill_functor { 
# 462
T exemplar; 
# 465
fill_functor(const T &_exemplar) : exemplar(_exemplar) 
# 466
{ } 
# 469
T operator()() const 
# 470
{ 
# 471
return exemplar; 
# 472
} 
# 473
}; 
# 476
template< class T> 
# 477
struct uninitialized_fill_functor { 
# 479
T exemplar; 
# 482
uninitialized_fill_functor(T x) : exemplar(x) { } 
# 485
void operator()(T &x) 
# 486
{ 
# 487
::new (static_cast< void *>(&x)) (T)(exemplar); 
# 488
} 
# 489
}; 
# 496
template< class Compare> 
# 497
struct compare_first_less_second { 
# 499
compare_first_less_second(Compare c) : comp(c) 
# 500
{ } 
# 502
template< class T1, class T2> bool 
# 504
operator()(T1 lhs, T2 rhs) 
# 505
{ 
# 506
return (comp)(thrust::get< 0> (lhs), thrust::get< 0> (rhs)) || ((!(comp)(thrust::get< 0> (rhs), thrust::get< 0> (lhs))) && (thrust::get< 1> (lhs) < thrust::get< 1> (rhs))); 
# 507
} 
# 509
Compare comp; 
# 510
}; 
# 513
template< class Compare> 
# 514
struct compare_first { 
# 516
Compare comp; 
# 519
compare_first(Compare comp) : comp(comp) 
# 521
{ } 
# 523
template< class Tuple1, class Tuple2> bool 
# 525
operator()(const Tuple1 &x, const Tuple2 &y) 
# 526
{ 
# 527
return (comp)(thrust::raw_reference_cast(thrust::get< 0> (x)), thrust::raw_reference_cast(thrust::get< 0> (y))); 
# 528
} 
# 529
}; 
# 532
}
# 533
}
# 27 "/usr/local/cuda/include/thrust/transform.h"
namespace thrust { 
# 87
template< class DerivedPolicy, class 
# 88
InputIterator, class 
# 89
OutputIterator, class 
# 90
UnaryFunction> OutputIterator 
# 87
transform(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op); 
# 138
template< class InputIterator, class 
# 139
OutputIterator, class 
# 140
UnaryFunction> OutputIterator 
# 138
transform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op); 
# 201
template< class DerivedPolicy, class 
# 202
InputIterator1, class 
# 203
InputIterator2, class 
# 204
OutputIterator, class 
# 205
BinaryFunction> OutputIterator 
# 201
transform(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op); 
# 262
template< class InputIterator1, class 
# 263
InputIterator2, class 
# 264
OutputIterator, class 
# 265
BinaryFunction> OutputIterator 
# 262
transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op); 
# 338
template< class DerivedPolicy, class 
# 339
InputIterator, class 
# 340
ForwardIterator, class 
# 341
UnaryFunction, class 
# 342
Predicate> ForwardIterator 
# 338
transform_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred); 
# 410
template< class InputIterator, class 
# 411
ForwardIterator, class 
# 412
UnaryFunction, class 
# 413
Predicate> ForwardIterator 
# 410
transform_if(InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred); 
# 481
template< class DerivedPolicy, class 
# 482
InputIterator1, class 
# 483
InputIterator2, class 
# 484
ForwardIterator, class 
# 485
UnaryFunction, class 
# 486
Predicate> ForwardIterator 
# 481
transform_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred); 
# 550
template< class InputIterator1, class 
# 551
InputIterator2, class 
# 552
ForwardIterator, class 
# 553
UnaryFunction, class 
# 554
Predicate> ForwardIterator 
# 550
transform_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred); 
# 628
template< class DerivedPolicy, class 
# 629
InputIterator1, class 
# 630
InputIterator2, class 
# 631
InputIterator3, class 
# 632
ForwardIterator, class 
# 633
BinaryFunction, class 
# 634
Predicate> ForwardIterator 
# 628
transform_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred); 
# 704
template< class InputIterator1, class 
# 705
InputIterator2, class 
# 706
InputIterator3, class 
# 707
ForwardIterator, class 
# 708
BinaryFunction, class 
# 709
Predicate> ForwardIterator 
# 704
transform_if(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred); 
# 722
}
# 22 "/usr/local/cuda/include/thrust/system/detail/generic/transform.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace generic { 
# 31
template< class DerivedPolicy, class 
# 32
InputIterator, class 
# 33
OutputIterator, class 
# 34
UnaryFunction> OutputIterator 
# 31
transform(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op); 
# 42
template< class DerivedPolicy, class 
# 43
InputIterator1, class 
# 44
InputIterator2, class 
# 45
OutputIterator, class 
# 46
BinaryFunction> OutputIterator 
# 42
transform(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op); 
# 55
template< class DerivedPolicy, class 
# 56
InputIterator, class 
# 57
ForwardIterator, class 
# 58
UnaryFunction, class 
# 59
Predicate> ForwardIterator 
# 55
transform_if(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction unary_op, Predicate pred); 
# 68
template< class DerivedPolicy, class 
# 69
InputIterator1, class 
# 70
InputIterator2, class 
# 71
ForwardIterator, class 
# 72
UnaryFunction, class 
# 73
Predicate> ForwardIterator 
# 68
transform_if(execution_policy< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction unary_op, Predicate pred); 
# 83
template< class DerivedPolicy, class 
# 84
InputIterator1, class 
# 85
InputIterator2, class 
# 86
InputIterator3, class 
# 87
ForwardIterator, class 
# 88
BinaryFunction, class 
# 89
Predicate> ForwardIterator 
# 83
transform_if(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred); 
# 100
}
# 101
}
# 102
}
# 103
}
# 27 "/usr/local/cuda/include/thrust/for_each.h"
namespace thrust { 
# 91
template< class DerivedPolicy, class 
# 92
InputIterator, class 
# 93
UnaryFunction> InputIterator 
# 91
for_each(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, UnaryFunction f); 
# 154
template< class DerivedPolicy, class 
# 155
InputIterator, class 
# 156
Size, class 
# 157
UnaryFunction> InputIterator 
# 154
for_each_n(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, Size n, UnaryFunction f); 
# 212
template< class InputIterator, class 
# 213
UnaryFunction> InputIterator 
# 212
for_each(InputIterator first, InputIterator last, UnaryFunction f); 
# 267
template< class InputIterator, class 
# 268
Size, class 
# 269
UnaryFunction> InputIterator 
# 267
for_each_n(InputIterator first, Size n, UnaryFunction f); 
# 277
}
# 29 "/usr/local/cuda/include/thrust/system/detail/generic/for_each.h"
namespace thrust { 
# 31
namespace system { 
# 33
namespace detail { 
# 35
namespace generic { 
# 39
template< class DerivedPolicy, class 
# 40
InputIterator, class 
# 41
UnaryFunction> InputIterator 
# 43
for_each(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 44
first, InputIterator 
# 45
last, UnaryFunction 
# 46
f) 
# 47
{ 
# 49
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, false> ::value)> )>  thrust_static_assert_typedef_49 __attribute((unused)); 
# 50
return first; 
# 51
} 
# 54
template< class DerivedPolicy, class 
# 55
InputIterator, class 
# 56
Size, class 
# 57
UnaryFunction> InputIterator 
# 59
for_each_n(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 60
first, Size 
# 61
n, UnaryFunction 
# 62
f) 
# 63
{ 
# 65
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, false> ::value)> )>  thrust_static_assert_typedef_65 __attribute((unused)); 
# 66
return first; 
# 67
} 
# 70
}
# 71
}
# 72
}
# 73
}
# 22 "/usr/local/cuda/include/thrust/detail/function.h"
namespace thrust { 
# 24
namespace detail { 
# 28
template< class Function, class Result> 
# 29
struct wrapped_function { 
# 32
mutable Function m_f; 
# 35
wrapped_function() : m_f() 
# 37
{ } 
# 40
wrapped_function(const Function &f) : m_f(f) 
# 42
{ } 
# 45
template< class Argument> Result 
# 47
operator()(Argument &x) const 
# 48
{ 
# 51
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x))); 
# 52
} 
# 55
template< class Argument> Result 
# 56
operator()(const Argument &x) const 
# 57
{ 
# 60
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x))); 
# 61
} 
# 64
template< class Argument1, class Argument2> Result 
# 65
operator()(Argument1 &x, Argument2 &y) const 
# 66
{ 
# 69
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y))); 
# 70
} 
# 73
template< class Argument1, class Argument2> Result 
# 74
operator()(const Argument1 &x, Argument2 &y) const 
# 75
{ 
# 78
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y))); 
# 79
} 
# 82
template< class Argument1, class Argument2> Result 
# 83
operator()(const Argument1 &x, const Argument2 &y) const 
# 84
{ 
# 87
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y))); 
# 88
} 
# 91
template< class Argument1, class Argument2> Result 
# 92
operator()(Argument1 &x, const Argument2 &y) const 
# 93
{ 
# 96
return static_cast< Result>((m_f)(thrust::raw_reference_cast(x), thrust::raw_reference_cast(y))); 
# 97
} 
# 98
}; 
# 101
}
# 102
}
# 28 "/usr/local/cuda/include/thrust/system/detail/sequential/for_each.h"
namespace thrust { 
# 30
namespace system { 
# 32
namespace detail { 
# 34
namespace sequential { 
# 39
template< class DerivedPolicy, class 
# 40
InputIterator, class 
# 41
UnaryFunction> InputIterator 
# 43
for_each(execution_policy< DerivedPolicy>  &, InputIterator 
# 44
first, InputIterator 
# 45
last, UnaryFunction 
# 46
f) 
# 47
{ 
# 52
thrust::detail::wrapped_function< UnaryFunction, void>  wrapped_f(f); 
# 54
for (; first != last; ++first) 
# 55
{ 
# 56
wrapped_f(*first); 
# 57
}  
# 59
return first; 
# 60
} 
# 63
template< class DerivedPolicy, class 
# 64
InputIterator, class 
# 65
Size, class 
# 66
UnaryFunction> InputIterator 
# 68
for_each_n(execution_policy< DerivedPolicy>  &, InputIterator 
# 69
first, Size 
# 70
n, UnaryFunction 
# 71
f) 
# 72
{ 
# 77
thrust::detail::wrapped_function< UnaryFunction, void>  wrapped_f(f); 
# 79
for (Size i = (0); i != n; i++) 
# 80
{ 
# 83
wrapped_f(*first); 
# 84
++first; 
# 85
}  
# 87
return first; 
# 88
} 
# 91
}
# 92
}
# 93
}
# 94
}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/for_each.h"
namespace thrust { 
# 30
namespace system { 
# 32
namespace cuda { 
# 34
namespace detail { 
# 38
template< class DerivedPolicy, class 
# 39
RandomAccessIterator, class 
# 40
UnaryFunction> RandomAccessIterator 
# 38
for_each(execution_policy< DerivedPolicy>  & s, RandomAccessIterator first, RandomAccessIterator last, UnaryFunction f); 
# 48
template< class DerivedPolicy, class 
# 49
RandomAccessIterator, class 
# 50
Size, class 
# 51
UnaryFunction> RandomAccessIterator 
# 48
for_each_n(execution_policy< DerivedPolicy>  & s, RandomAccessIterator first, Size n, UnaryFunction f); 
# 59
}
# 60
}
# 61
}
# 62
}
# 27 "/usr/local/cuda/include/thrust/distance.h"
namespace thrust { 
# 66
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type distance(InputIterator first, InputIterator last); 
# 74
}
# 26 "/usr/local/cuda/include/thrust/advance.h"
namespace thrust { 
# 64
template< class InputIterator, class Distance> void advance(InputIterator & i, Distance n); 
# 71
}
# 22 "/usr/local/cuda/include/thrust/system/detail/generic/advance.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace generic { 
# 31
template< class InputIterator, class Distance> void advance(InputIterator & i, Distance n); 
# 35
}
# 36
}
# 37
}
# 38
}
# 21 "/usr/local/cuda/include/thrust/system/detail/generic/advance.inl"
namespace thrust { 
# 23
namespace system { 
# 25
namespace detail { 
# 27
namespace generic { 
# 29
namespace detail { 
# 33
template< class InputIterator, class Distance> void 
# 35
advance(InputIterator &i, Distance n, incrementable_traversal_tag) 
# 36
{ 
# 37
while (n) 
# 38
{ 
# 39
++i; 
# 40
--n; 
# 41
}  
# 42
} 
# 45
template< class InputIterator, class Distance> void 
# 47
advance(InputIterator &i, Distance n, random_access_traversal_tag) 
# 48
{ 
# 49
i += n; 
# 50
} 
# 52
}
# 54
template< class InputIterator, class Distance> void 
# 56
advance(InputIterator &i, Distance n) 
# 57
{ 
# 59
detail::advance(i, n, typename iterator_traversal< InputIterator> ::type()); 
# 61
} 
# 63
}
# 64
}
# 65
}
# 66
}
# 26 "/usr/local/cuda/include/thrust/detail/advance.inl"
namespace thrust { 
# 30
template< class InputIterator, class Distance> void 
# 32
advance(InputIterator &i, Distance n) 
# 33
{ 
# 34
system::detail::generic::advance(i, n); 
# 35
} 
# 38
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/distance.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 32
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type distance(InputIterator first, InputIterator last); 
# 37
}
# 38
}
# 39
}
# 40
}
# 21 "/usr/local/cuda/include/thrust/system/detail/generic/distance.inl"
namespace thrust { 
# 23
namespace system { 
# 25
namespace detail { 
# 27
namespace generic { 
# 29
namespace detail { 
# 34
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type 
# 37
distance(InputIterator first, InputIterator last, incrementable_traversal_tag) 
# 38
{ 
# 39
typename iterator_traits< InputIterator> ::difference_type result(0); 
# 41
while (first != last) 
# 42
{ 
# 43
++first; 
# 44
++result; 
# 45
}  
# 47
return result; 
# 48
} 
# 52
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type 
# 55
distance(InputIterator first, InputIterator last, random_access_traversal_tag) 
# 56
{ 
# 57
return last - first; 
# 58
} 
# 61
}
# 64
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type 
# 67
distance(InputIterator first, InputIterator last) 
# 68
{ 
# 70
return detail::distance(first, last, typename iterator_traversal< InputIterator> ::type()); 
# 72
} 
# 75
}
# 76
}
# 77
}
# 78
}
# 26 "/usr/local/cuda/include/thrust/detail/distance.inl"
namespace thrust { 
# 30
template< class InputIterator> inline typename iterator_traits< InputIterator> ::difference_type 
# 33
distance(InputIterator first, InputIterator last) 
# 34
{ 
# 35
return system::detail::generic::distance(first, last); 
# 36
} 
# 39
}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/execute_on_stream.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace cuda { 
# 29
namespace detail { 
# 34
inline cudaStream_t legacy_stream() 
# 35
{ 
# 39
return (cudaStream_t)1; 
# 41
} 
# 45
inline cudaStream_t default_stream() 
# 46
{ 
# 48
return legacy_stream(); 
# 49
} 
# 53
template< class DerivedPolicy> inline cudaStream_t 
# 55
stream(const execution_policy< DerivedPolicy>  &exec) 
# 56
{ 
# 57
return default_stream(); 
# 58
} 
# 62
template< class DerivedPolicy> 
# 63
class execute_on_stream_base : public execution_policy< DerivedPolicy>  { 
# 68
public: execute_on_stream_base() : m_stream(default_stream()) 
# 70
{ } 
# 73
execute_on_stream_base(::cudaStream_t stream) : m_stream(stream) 
# 75
{ } 
# 78
DerivedPolicy on(const ::cudaStream_t &s) const 
# 79
{ 
# 82
DerivedPolicy result = ::thrust::detail::derived_cast(*this); 
# 85
(result.set_stream(s)); 
# 87
return result; 
# 88
} 
# 93
friend inline ::cudaStream_t stream(const execute_on_stream_base &exec) 
# 94
{ 
# 95
return exec.m_stream; 
# 96
} 
# 99
private: void set_stream(const ::cudaStream_t &s) 
# 100
{ 
# 101
(m_stream) = s; 
# 102
} 
# 104
::cudaStream_t m_stream; 
# 105
}; 
# 109
class execute_on_stream : public execute_on_stream_base< execute_on_stream>  { 
# 112
typedef cuda::detail::execute_on_stream_base< execute_on_stream>  super_t; 
# 116
public: execute_on_stream(cudaStream_t stream) : super_t(stream) 
# 118
{ } 
# 119
}; 
# 122
}
# 123
}
# 124
}
# 125
}
# 31 "/usr/local/cuda/include/thrust/system/cuda/detail/for_each.inl"
namespace thrust { 
# 33
namespace system { 
# 35
namespace cuda { 
# 37
namespace detail { 
# 39
namespace for_each_n_detail { 
# 43
struct for_each_kernel { 
# 45
template< class Iterator, class Function, class Size> void 
# 47
operator()(bulk_::parallel_group< bulk_::concurrent_group<> >  &grid, Iterator first, Function f, Size n) 
# 48
{ 
# 49
Size grid_size = grid.size() * (grid.this_exec).size(); 
# 51
Size i = ((grid.this_exec).index() * (grid.this_exec).size()) + ((grid.this_exec).this_exec).index(); 
# 53
first += i; 
# 55
while (i < n) 
# 56
{ 
# 57
f(*first); 
# 58
i += grid_size; 
# 59
first += grid_size; 
# 60
}  
# 61
} 
# 62
}; 
# 65
template< class Size> bool 
# 67
use_wide_counter(Size n, unsigned narrow_grid_size) 
# 68
{ 
# 72
Size threshold = (static_cast< Size>(((2147483647) * 2U) + 1U)); 
# 74
bool result = (sizeof(Size) > sizeof(unsigned)) && (n > threshold); 
# 76
if (!result) 
# 77
{ 
# 79
unsigned narrow_n = static_cast< unsigned>(n); 
# 81
if (((narrow_n - 1U) + narrow_grid_size) < narrow_n) 
# 82
{ 
# 83
result = true; 
# 84
}  
# 85
}  
# 87
return result; 
# 88
} 
# 91
}
# 94
template< class DerivedPolicy, class 
# 95
RandomAccessIterator, class 
# 96
Size, class 
# 97
UnaryFunction> RandomAccessIterator 
# 99
for_each_n(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator 
# 100
first, Size 
# 101
n, UnaryFunction 
# 102
f) 
# 103
{ 
# 109
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< RandomAccessIterator, true> ::value)> )>  thrust_static_assert_typedef_109 __attribute((unused)); 
# 111
struct workaround { 
# 114
static RandomAccessIterator parallel_path(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator first, Size n, UnaryFunction f) 
# 115
{ 
# 116
thrust::detail::wrapped_function< UnaryFunction, void>  wrapped_f(f); 
# 120
unsigned narrow_n = static_cast< unsigned>(n); 
# 121
unsigned narrow_num_groups = (0); 
# 122
unsigned narrow_group_size = (0); 
# 125
thrust::tie(narrow_num_groups, narrow_group_size) = bulk_::choose_sizes(bulk_::grid(), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, narrow_n); 
# 128
if (for_each_n_detail::use_wide_counter(n, narrow_num_groups * narrow_group_size)) 
# 129
{ 
# 130
Size num_groups = (0); 
# 131
Size group_size = (0); 
# 132
thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, n); 
# 134
num_groups = thrust::min< Size> (num_groups, thrust::detail::util::divide_ri(n, group_size)); 
# 136
bulk_::async(bulk_::grid(num_groups, group_size, 0, stream(thrust::detail::derived_cast(exec))), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, n); 
# 137
} else 
# 139
{ 
# 141
narrow_num_groups = thrust::min< unsigned> (narrow_num_groups, thrust::detail::util::divide_ri(narrow_n, narrow_group_size)); 
# 143
bulk_::async(bulk_::grid(narrow_num_groups, narrow_group_size, 0, stream(thrust::detail::derived_cast(exec))), for_each_n_detail::for_each_kernel(), bulk_::root, first, wrapped_f, narrow_n); 
# 144
}  
# 146
return first + n; 
# 147
} 
# 150
static RandomAccessIterator sequential_path(execution_policy< DerivedPolicy>  &, RandomAccessIterator first, Size n, UnaryFunction f) 
# 151
{ 
# 152
return thrust::for_each_n(thrust::seq, first, n, f); 
# 153
} 
# 154
}; 
# 157
return (workaround::parallel_path)(exec, first, n, f); 
# 161
} 
# 164
template< class DerivedPolicy, class 
# 165
InputIterator, class 
# 166
UnaryFunction> InputIterator 
# 168
for_each(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 169
first, InputIterator 
# 170
last, UnaryFunction 
# 171
f) 
# 172
{ 
# 173
return cuda::detail::for_each_n(exec, first, thrust::distance(first, last), f); 
# 174
} 
# 177
}
# 178
}
# 179
}
# 180
}
# 29 "/usr/local/cuda/include/thrust/detail/for_each.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator, class 
# 35
UnaryFunction> InputIterator 
# 37
for_each(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 38
first, InputIterator 
# 39
last, UnaryFunction 
# 40
f) 
# 41
{ 
# 42
using system::detail::generic::for_each;
# 44
return for_each(detail::derived_cast(detail::strip_const(exec)), first, last, f); 
# 45
} 
# 48
template< class InputIterator, class 
# 49
UnaryFunction> InputIterator 
# 50
for_each(InputIterator first, InputIterator 
# 51
last, UnaryFunction 
# 52
f) 
# 53
{ 
# 54
using thrust::system::detail::generic::select_system;
# 55
typedef typename iterator_system< InputIterator> ::type System; 
# 57
System system; 
# 58
return thrust::for_each(select_system(system), first, last, f); 
# 59
} 
# 62
template< class DerivedPolicy, class InputIterator, class Size, class UnaryFunction> InputIterator 
# 64
for_each_n(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 65
first, Size 
# 66
n, UnaryFunction 
# 67
f) 
# 68
{ 
# 69
using system::detail::generic::for_each_n;
# 71
return for_each_n(detail::derived_cast(detail::strip_const(exec)), first, n, f); 
# 72
} 
# 75
template< class InputIterator, class 
# 76
Size, class 
# 77
UnaryFunction> InputIterator 
# 78
for_each_n(InputIterator first, Size 
# 79
n, UnaryFunction 
# 80
f) 
# 81
{ 
# 82
using thrust::system::detail::generic::select_system;
# 84
typedef typename iterator_system< InputIterator> ::type System; 
# 86
System system; 
# 87
return thrust::for_each_n(select_system(system), first, n, f); 
# 88
} 
# 91
}
# 26 "/usr/local/cuda/include/thrust/system/detail/generic/transform.inl"
namespace thrust { 
# 28
namespace system { 
# 30
namespace detail { 
# 32
namespace generic { 
# 36
template< class DerivedPolicy, class 
# 37
InputIterator, class 
# 38
OutputIterator, class 
# 39
UnaryFunction> OutputIterator 
# 41
transform(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 42
first, InputIterator 
# 43
last, OutputIterator 
# 44
result, UnaryFunction 
# 45
op) 
# 46
{ 
# 47
typedef thrust::detail::unary_transform_functor< UnaryFunction>  UnaryTransformFunctor; 
# 50
typedef tuple< InputIterator, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 51
typedef zip_iterator< tuple< InputIterator, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 53
ZipIterator zipped_result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first, result)), thrust::make_zip_iterator(thrust::make_tuple(last, result)), ((UnaryTransformFunctor)(op))); 
# 59
return thrust::get< 1> ((zipped_result.get_iterator_tuple())); 
# 60
} 
# 63
template< class DerivedPolicy, class 
# 64
InputIterator1, class 
# 65
InputIterator2, class 
# 66
OutputIterator, class 
# 67
BinaryFunction> OutputIterator 
# 69
transform(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 70
first1, InputIterator1 
# 71
last1, InputIterator2 
# 72
first2, OutputIterator 
# 73
result, BinaryFunction 
# 74
op) 
# 75
{ 
# 77
typedef thrust::detail::binary_transform_functor< BinaryFunction>  BinaryTransformFunctor; 
# 80
typedef tuple< InputIterator1, InputIterator2, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 81
typedef zip_iterator< tuple< InputIterator1, InputIterator2, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 83
ZipIterator zipped_result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first1, first2, result)), thrust::make_zip_iterator(thrust::make_tuple(last1, first2, result)), ((BinaryTransformFunctor)(op))); 
# 89
return thrust::get< 2> ((zipped_result.get_iterator_tuple())); 
# 90
} 
# 93
template< class DerivedPolicy, class 
# 94
InputIterator, class 
# 95
ForwardIterator, class 
# 96
UnaryFunction, class 
# 97
Predicate> ForwardIterator 
# 99
transform_if(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 100
first, InputIterator 
# 101
last, ForwardIterator 
# 102
result, UnaryFunction 
# 103
unary_op, Predicate 
# 104
pred) 
# 105
{ 
# 106
typedef thrust::detail::unary_transform_if_functor< UnaryFunction, Predicate>  UnaryTransformIfFunctor; 
# 109
typedef tuple< InputIterator, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 110
typedef zip_iterator< tuple< InputIterator, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 112
ZipIterator zipped_result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first, result)), thrust::make_zip_iterator(thrust::make_tuple(last, result)), UnaryTransformIfFunctor(unary_op, pred)); 
# 118
return thrust::get< 1> ((zipped_result.get_iterator_tuple())); 
# 119
} 
# 122
template< class DerivedPolicy, class 
# 123
InputIterator1, class 
# 124
InputIterator2, class 
# 125
ForwardIterator, class 
# 126
UnaryFunction, class 
# 127
Predicate> ForwardIterator 
# 129
transform_if(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 130
first, InputIterator1 
# 131
last, InputIterator2 
# 132
stencil, ForwardIterator 
# 133
result, UnaryFunction 
# 134
unary_op, Predicate 
# 135
pred) 
# 136
{ 
# 137
typedef thrust::detail::unary_transform_if_with_stencil_functor< UnaryFunction, Predicate>  UnaryTransformIfFunctor; 
# 140
typedef tuple< InputIterator1, InputIterator2, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 141
typedef zip_iterator< tuple< InputIterator1, InputIterator2, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 143
ZipIterator zipped_result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first, stencil, result)), thrust::make_zip_iterator(thrust::make_tuple(last, stencil, result)), UnaryTransformIfFunctor(unary_op, pred)); 
# 149
return thrust::get< 2> ((zipped_result.get_iterator_tuple())); 
# 150
} 
# 153
template< class DerivedPolicy, class 
# 154
InputIterator1, class 
# 155
InputIterator2, class 
# 156
InputIterator3, class 
# 157
ForwardIterator, class 
# 158
BinaryFunction, class 
# 159
Predicate> ForwardIterator 
# 161
transform_if(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 162
first1, InputIterator1 
# 163
last1, InputIterator2 
# 164
first2, InputIterator3 
# 165
stencil, ForwardIterator 
# 166
result, BinaryFunction 
# 167
binary_op, Predicate 
# 168
pred) 
# 169
{ 
# 170
typedef thrust::detail::binary_transform_if_functor< BinaryFunction, Predicate>  BinaryTransformIfFunctor; 
# 173
typedef tuple< InputIterator1, InputIterator2, InputIterator3, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 174
typedef zip_iterator< tuple< InputIterator1, InputIterator2, InputIterator3, ForwardIterator, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 176
ZipIterator zipped_result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first1, first2, stencil, result)), thrust::make_zip_iterator(thrust::make_tuple(last1, first2, stencil, result)), BinaryTransformIfFunctor(binary_op, pred)); 
# 182
return thrust::get< 3> ((zipped_result.get_iterator_tuple())); 
# 183
} 
# 186
}
# 187
}
# 188
}
# 189
}
# 28 "/usr/local/cuda/include/thrust/detail/transform.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator, class 
# 35
OutputIterator, class 
# 36
UnaryFunction> OutputIterator 
# 38
transform(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 39
first, InputIterator last, OutputIterator 
# 40
result, UnaryFunction 
# 41
op) 
# 42
{ 
# 43
using system::detail::generic::transform;
# 44
return transform(detail::derived_cast(detail::strip_const(exec)), first, last, result, op); 
# 45
} 
# 49
template< class DerivedPolicy, class 
# 50
InputIterator1, class 
# 51
InputIterator2, class 
# 52
OutputIterator, class 
# 53
BinaryFunction> OutputIterator 
# 55
transform(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 56
first1, InputIterator1 last1, InputIterator2 
# 57
first2, OutputIterator 
# 58
result, BinaryFunction 
# 59
op) 
# 60
{ 
# 61
using system::detail::generic::transform;
# 62
return transform(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, op); 
# 63
} 
# 67
template< class DerivedPolicy, class 
# 68
InputIterator, class 
# 69
ForwardIterator, class 
# 70
UnaryFunction, class 
# 71
Predicate> ForwardIterator 
# 73
transform_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 74
first, InputIterator last, ForwardIterator 
# 75
result, UnaryFunction 
# 76
op, Predicate 
# 77
pred) 
# 78
{ 
# 79
using system::detail::generic::transform_if;
# 80
return transform_if(detail::derived_cast(detail::strip_const(exec)), first, last, result, op, pred); 
# 81
} 
# 85
template< class DerivedPolicy, class 
# 86
InputIterator1, class 
# 87
InputIterator2, class 
# 88
ForwardIterator, class 
# 89
UnaryFunction, class 
# 90
Predicate> ForwardIterator 
# 92
transform_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 93
first, InputIterator1 last, InputIterator2 
# 94
stencil, ForwardIterator 
# 95
result, UnaryFunction 
# 96
op, Predicate 
# 97
pred) 
# 98
{ 
# 99
using system::detail::generic::transform_if;
# 100
return transform_if(detail::derived_cast(detail::strip_const(exec)), first, last, stencil, result, op, pred); 
# 101
} 
# 105
template< class DerivedPolicy, class 
# 106
InputIterator1, class 
# 107
InputIterator2, class 
# 108
InputIterator3, class 
# 109
ForwardIterator, class 
# 110
BinaryFunction, class 
# 111
Predicate> ForwardIterator 
# 113
transform_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 114
first1, InputIterator1 last1, InputIterator2 
# 115
first2, InputIterator3 
# 116
stencil, ForwardIterator 
# 117
result, BinaryFunction 
# 118
binary_op, Predicate 
# 119
pred) 
# 120
{ 
# 121
using system::detail::generic::transform_if;
# 122
return transform_if(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, stencil, result, binary_op, pred); 
# 123
} 
# 126
template< class InputIterator, class 
# 127
OutputIterator, class 
# 128
UnaryFunction> OutputIterator 
# 129
transform(InputIterator first, InputIterator 
# 130
last, OutputIterator 
# 131
result, UnaryFunction 
# 132
op) 
# 133
{ 
# 134
using system::detail::generic::select_system;
# 136
typedef typename iterator_system< InputIterator> ::type System1; 
# 137
typedef typename iterator_system< OutputIterator> ::type System2; 
# 139
System1 system1; 
# 140
System2 system2; 
# 142
return thrust::transform(select_system(system1, system2), first, last, result, op); 
# 143
} 
# 146
template< class InputIterator1, class 
# 147
InputIterator2, class 
# 148
OutputIterator, class 
# 149
BinaryFunction> OutputIterator 
# 150
transform(InputIterator1 first1, InputIterator1 
# 151
last1, InputIterator2 
# 152
first2, OutputIterator 
# 153
result, BinaryFunction 
# 154
op) 
# 155
{ 
# 156
using system::detail::generic::select_system;
# 158
typedef typename iterator_system< InputIterator1> ::type System1; 
# 159
typedef typename iterator_system< InputIterator2> ::type System2; 
# 160
typedef typename iterator_system< OutputIterator> ::type System3; 
# 162
System1 system1; 
# 163
System2 system2; 
# 164
System3 system3; 
# 166
return thrust::transform(select_system(system1, system2, system3), first1, last1, first2, result, op); 
# 167
} 
# 170
template< class InputIterator, class 
# 171
ForwardIterator, class 
# 172
UnaryFunction, class 
# 173
Predicate> ForwardIterator 
# 174
transform_if(InputIterator first, InputIterator 
# 175
last, ForwardIterator 
# 176
result, UnaryFunction 
# 177
unary_op, Predicate 
# 178
pred) 
# 179
{ 
# 180
using system::detail::generic::select_system;
# 182
typedef typename iterator_system< InputIterator> ::type System1; 
# 183
typedef typename iterator_system< ForwardIterator> ::type System2; 
# 185
System1 system1; 
# 186
System2 system2; 
# 188
return thrust::transform_if(select_system(system1, system2), first, last, result, unary_op, pred); 
# 189
} 
# 192
template< class InputIterator1, class 
# 193
InputIterator2, class 
# 194
ForwardIterator, class 
# 195
UnaryFunction, class 
# 196
Predicate> ForwardIterator 
# 197
transform_if(InputIterator1 first, InputIterator1 
# 198
last, InputIterator2 
# 199
stencil, ForwardIterator 
# 200
result, UnaryFunction 
# 201
unary_op, Predicate 
# 202
pred) 
# 203
{ 
# 204
using system::detail::generic::select_system;
# 206
typedef typename iterator_system< InputIterator1> ::type System1; 
# 207
typedef typename iterator_system< InputIterator2> ::type System2; 
# 208
typedef typename iterator_system< ForwardIterator> ::type System3; 
# 210
System1 system1; 
# 211
System2 system2; 
# 212
System3 system3; 
# 214
return thrust::transform_if(select_system(system1, system2, system3), first, last, stencil, result, unary_op, pred); 
# 215
} 
# 218
template< class InputIterator1, class 
# 219
InputIterator2, class 
# 220
InputIterator3, class 
# 221
ForwardIterator, class 
# 222
BinaryFunction, class 
# 223
Predicate> ForwardIterator 
# 224
transform_if(InputIterator1 first1, InputIterator1 
# 225
last1, InputIterator2 
# 226
first2, InputIterator3 
# 227
stencil, ForwardIterator 
# 228
result, BinaryFunction 
# 229
binary_op, Predicate 
# 230
pred) 
# 231
{ 
# 232
using system::detail::generic::select_system;
# 234
typedef typename iterator_system< InputIterator1> ::type System1; 
# 235
typedef typename iterator_system< InputIterator2> ::type System2; 
# 236
typedef typename iterator_system< InputIterator3> ::type System3; 
# 237
typedef typename iterator_system< ForwardIterator> ::type System4; 
# 239
System1 system1; 
# 240
System2 system2; 
# 241
System3 system3; 
# 242
System4 system4; 
# 244
return thrust::transform_if(select_system(system1, system2, system3, system4), first1, last1, first2, stencil, result, binary_op, pred); 
# 245
} 
# 248
}
# 29 "/usr/local/cuda/include/thrust/system/detail/generic/copy.inl"
namespace thrust { 
# 31
namespace system { 
# 33
namespace detail { 
# 35
namespace generic { 
# 39
template< class DerivedPolicy, class 
# 40
InputIterator, class 
# 41
OutputIterator> OutputIterator 
# 43
copy(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 44
first, InputIterator 
# 45
last, OutputIterator 
# 46
result) 
# 47
{ 
# 48
typedef typename iterator_value< InputIterator> ::type T; 
# 49
return thrust::transform(exec, first, last, result, identity< typename iterator_value< InputIterator> ::type> ()); 
# 50
} 
# 53
template< class DerivedPolicy, class 
# 54
InputIterator, class 
# 55
Size, class 
# 56
OutputIterator> OutputIterator 
# 58
copy_n(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 59
first, Size 
# 60
n, OutputIterator 
# 61
result) 
# 62
{ 
# 63
typedef typename iterator_value< InputIterator> ::type value_type; 
# 64
typedef identity< typename iterator_value< InputIterator> ::type>  xfrm_type; 
# 66
typedef thrust::detail::unary_transform_functor< identity< typename iterator_value< InputIterator> ::type> >  functor_type; 
# 68
typedef tuple< InputIterator, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  iterator_tuple; 
# 69
typedef zip_iterator< tuple< InputIterator, OutputIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  zip_iter; 
# 71
zip_iter zipped = thrust::make_zip_iterator(thrust::make_tuple(first, result)); 
# 73
return thrust::get< 1> ((thrust::for_each_n(exec, zipped, n, ((functor_type)(xfrm_type()))).get_iterator_tuple())); 
# 74
} 
# 77
}
# 78
}
# 79
}
# 80
}
# 26 "/usr/local/cuda/include/thrust/system/detail/sequential/copy.h"
namespace thrust { 
# 28
namespace system { 
# 30
namespace detail { 
# 32
namespace sequential { 
# 36
template< class DerivedPolicy, class 
# 37
InputIterator, class 
# 38
OutputIterator> OutputIterator 
# 36
copy(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 46
template< class DerivedPolicy, class 
# 47
InputIterator, class 
# 48
Size, class 
# 49
OutputIterator> OutputIterator 
# 46
copy_n(execution_policy< DerivedPolicy>  & exec, InputIterator first, Size n, OutputIterator result); 
# 57
}
# 58
}
# 59
}
# 60
}
# 28 "/usr/local/cuda/include/thrust/detail/dispatch/is_trivial_copy.h"
namespace thrust { 
# 31
namespace detail { 
# 34
namespace dispatch { 
# 41
template< class FromIterator, class ToIterator> 
# 42
struct is_trivial_copy : public integral_constant< bool, is_same< typename iterator_value< FromIterator> ::type, typename iterator_value< ToIterator> ::type> ::value && is_trivial_iterator< FromIterator> ::value && is_trivial_iterator< ToIterator> ::value && has_trivial_assign< typename iterator_value< ToIterator> ::type> ::value>  { 
# 52
}; 
# 54
}
# 56
}
# 58
}
# 27 "/usr/local/cuda/include/thrust/system/detail/sequential/general_copy.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace detail { 
# 33
namespace sequential { 
# 35
namespace general_copy_detail { 
# 39
template< class T1, class T2> 
# 40
struct lazy_is_assignable : public thrust::detail::is_assignable< typename T1::type, typename T2::type>  { 
# 45
}; 
# 50
template< class InputIterator, class OutputIterator> 
# 51
struct reference_is_assignable : public thrust::detail::eval_if< thrust::detail::is_same< typename iterator_reference< OutputIterator> ::type, void> ::value, thrust::detail::integral_constant< bool, true> , lazy_is_assignable< iterator_reference< OutputIterator> , iterator_reference< InputIterator> > > ::type { 
# 62
}; 
# 69
template< class OutputIterator, class InputIterator> inline typename thrust::detail::enable_if< reference_is_assignable< InputIterator, OutputIterator> ::value> ::type 
# 74
iter_assign(OutputIterator dst, InputIterator src) 
# 75
{ 
# 76
(*dst) = (*src); 
# 77
} 
# 81
template< class OutputIterator, class InputIterator> inline typename thrust::detail::disable_if< reference_is_assignable< InputIterator, OutputIterator> ::value> ::type 
# 86
iter_assign(OutputIterator dst, InputIterator src) 
# 87
{ 
# 88
typedef typename iterator_value< InputIterator> ::type value_type; 
# 91
(*dst) = (static_cast< value_type>(*src)); 
# 92
} 
# 95
}
# 99
template< class InputIterator, class 
# 100
OutputIterator> OutputIterator 
# 102
general_copy(InputIterator first, InputIterator 
# 103
last, OutputIterator 
# 104
result) 
# 105
{ 
# 106
for (; first != last; (++first), (++result)) 
# 107
{ 
# 112
general_copy_detail::iter_assign(result, first); 
# 114
}  
# 116
return result; 
# 117
} 
# 121
template< class InputIterator, class 
# 122
Size, class 
# 123
OutputIterator> OutputIterator 
# 125
general_copy_n(InputIterator first, Size 
# 126
n, OutputIterator 
# 127
result) 
# 128
{ 
# 129
for (; n > ((Size)0); ((++first), (++result)), (--n)) 
# 130
{ 
# 135
general_copy_detail::iter_assign(result, first); 
# 137
}  
# 139
return result; 
# 140
} 
# 143
}
# 144
}
# 145
}
# 146
}
# 27 "/usr/local/cuda/include/thrust/system/detail/sequential/trivial_copy.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace detail { 
# 33
namespace sequential { 
# 37
template< class T> T *
# 39
trivial_copy_n(const T *first, std::ptrdiff_t 
# 40
n, T *
# 41
result) 
# 42
{ 
# 44
std::memmove(result, first, n * sizeof(T)); 
# 45
return result + n; 
# 49
} 
# 52
}
# 53
}
# 54
}
# 55
}
# 26 "/usr/local/cuda/include/thrust/system/detail/sequential/copy.inl"
namespace thrust { 
# 28
namespace system { 
# 30
namespace detail { 
# 32
namespace sequential { 
# 34
namespace copy_detail { 
# 39
template< class Pointer> typename thrust::detail::pointer_traits< Pointer> ::raw_pointer 
# 42
get(Pointer ptr) 
# 43
{ 
# 44
return thrust::detail::pointer_traits< Pointer> ::get(ptr); 
# 45
} 
# 49
template< class InputIterator, class 
# 50
OutputIterator> OutputIterator 
# 52
copy(InputIterator first, InputIterator 
# 53
last, OutputIterator 
# 54
result, thrust::detail::true_type) 
# 56
{ 
# 57
typedef typename iterator_difference< InputIterator> ::type Size; 
# 59
const Size n = last - first; 
# 60
sequential::trivial_copy_n(get(&(*first)), n, get(&(*result))); 
# 61
return result + n; 
# 62
} 
# 66
template< class InputIterator, class 
# 67
OutputIterator> OutputIterator 
# 69
copy(InputIterator first, InputIterator 
# 70
last, OutputIterator 
# 71
result, thrust::detail::false_type) 
# 73
{ 
# 74
return sequential::general_copy(first, last, result); 
# 75
} 
# 79
template< class InputIterator, class 
# 80
Size, class 
# 81
OutputIterator> OutputIterator 
# 83
copy_n(InputIterator first, Size 
# 84
n, OutputIterator 
# 85
result, thrust::detail::true_type) 
# 87
{ 
# 88
sequential::trivial_copy_n(get(&(*first)), n, get(&(*result))); 
# 89
return result + n; 
# 90
} 
# 93
template< class InputIterator, class 
# 94
Size, class 
# 95
OutputIterator> OutputIterator 
# 97
copy_n(InputIterator first, Size 
# 98
n, OutputIterator 
# 99
result, thrust::detail::false_type) 
# 101
{ 
# 102
return sequential::general_copy_n(first, n, result); 
# 103
} 
# 106
}
# 110
template< class DerivedPolicy, class 
# 111
InputIterator, class 
# 112
OutputIterator> OutputIterator 
# 114
copy(execution_policy< DerivedPolicy>  &, InputIterator 
# 115
first, InputIterator 
# 116
last, OutputIterator 
# 117
result) 
# 118
{ 
# 119
return copy_detail::copy(first, last, result, typename thrust::detail::dispatch::is_trivial_copy< InputIterator, OutputIterator> ::type()); 
# 121
} 
# 124
template< class DerivedPolicy, class 
# 125
InputIterator, class 
# 126
Size, class 
# 127
OutputIterator> OutputIterator 
# 129
copy_n(execution_policy< DerivedPolicy>  &, InputIterator 
# 130
first, Size 
# 131
n, OutputIterator 
# 132
result) 
# 133
{ 
# 134
return copy_detail::copy_n(first, n, result, typename thrust::detail::dispatch::is_trivial_copy< InputIterator, OutputIterator> ::type()); 
# 136
} 
# 139
}
# 140
}
# 141
}
# 142
}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/copy.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace cuda { 
# 29
namespace detail { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator, class 
# 35
OutputIterator> OutputIterator 
# 33
copy(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 43
template< class System1, class 
# 44
System2, class 
# 45
InputIterator, class 
# 46
OutputIterator> OutputIterator 
# 43
copy(cross_system< System1, System2>  exec, InputIterator first, InputIterator last, OutputIterator result); 
# 53
template< class DerivedPolicy, class 
# 54
InputIterator, class 
# 55
Size, class 
# 56
OutputIterator> OutputIterator 
# 53
copy_n(execution_policy< DerivedPolicy>  & exec, InputIterator first, Size n, OutputIterator result); 
# 64
template< class System1, class 
# 65
System2, class 
# 66
InputIterator, class 
# 67
Size, class 
# 68
OutputIterator> OutputIterator 
# 64
copy_n(cross_system< System1, System2>  exec, InputIterator first, Size n, OutputIterator result); 
# 75
}
# 76
}
# 77
}
# 78
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/copy_device_to_device.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace cuda { 
# 33
namespace detail { 
# 37
template< class DerivedPolicy, class 
# 38
InputIterator, class 
# 39
OutputIterator> OutputIterator 
# 37
copy_device_to_device(execution_policy< DerivedPolicy>  & exec, InputIterator begin, InputIterator end, OutputIterator result); 
# 46
}
# 47
}
# 48
}
# 49
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/copy_cross_system.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 32
template< class System1, class 
# 33
System2, class 
# 34
InputIterator, class 
# 35
OutputIterator> OutputIterator 
# 32
copy_cross_system(cross_system< System1, System2>  systems, InputIterator begin, InputIterator end, OutputIterator result); 
# 42
template< class System1, class 
# 43
System2, class 
# 44
InputIterator, class 
# 45
Size, class 
# 46
OutputIterator> OutputIterator 
# 42
copy_cross_system_n(cross_system< System1, System2>  systems, InputIterator begin, Size n, OutputIterator result); 
# 53
}
# 54
}
# 55
}
# 56
}
# 24 "/usr/local/cuda/include/thrust/iterator/detail/tagged_iterator.h"
namespace thrust { 
# 26
namespace detail { 
# 29
template< class , class > class tagged_iterator; 
# 31
template< class Iterator, class Tag> 
# 32
struct tagged_iterator_base { 
# 42
typedef iterator_adaptor< tagged_iterator< Iterator, Tag> , Iterator, typename iterator_value< Iterator> ::type, Tag, typename iterator_traversal< Iterator> ::type, typename iterator_reference< Iterator> ::type, typename iterator_difference< Iterator> ::type>  type; 
# 43
}; 
# 45
template< class Iterator, class Tag> 
# 46
class tagged_iterator : public tagged_iterator_base< Iterator, Tag> ::type { 
# 50
typedef typename tagged_iterator_base< Iterator, Tag> ::type super_t; 
# 54
public: tagged_iterator() { } 
# 57
explicit tagged_iterator(Iterator x) : super_t(x) 
# 58
{ } 
# 59
}; 
# 63
template< class > struct is_trivial_iterator; 
# 66
template< class BaseIterator, class Tag> 
# 67
struct is_trivial_iterator< tagged_iterator< BaseIterator, Tag> >  : public is_trivial_iterator< BaseIterator>  { 
# 69
}; 
# 72
}
# 73
}
# 29 "/usr/local/cuda/include/thrust/iterator/detail/normal_iterator.h"
namespace thrust { 
# 31
namespace detail { 
# 35
template< class Pointer> 
# 36
class normal_iterator : public iterator_adaptor< normal_iterator< Pointer> , Pointer>  { 
# 42
typedef ::thrust::iterator_adaptor< ::thrust::detail::normal_iterator< Pointer> , Pointer>  super_t; 
# 46
public: normal_iterator() { } 
# 49
normal_iterator(Pointer p) : super_t(p) 
# 50
{ } 
# 52
template< class OtherPointer> 
# 54
normal_iterator(const ::thrust::detail::normal_iterator< OtherPointer>  &other, typename enable_if_convertible< OtherPointer, Pointer> ::type * = 0) : super_t((other.base())) 
# 59
{ } 
# 61
}; 
# 64
template< class Pointer> inline normal_iterator< Pointer>  
# 65
make_normal_iterator(Pointer ptr) 
# 66
{ 
# 67
return ((normal_iterator< Pointer> )(ptr)); 
# 68
} 
# 71
template< class T> struct is_trivial_iterator< normal_iterator< T> >  : public true_type { }; 
# 74
}
# 75
}
# 23 "/usr/local/cuda/include/thrust/detail/contiguous_storage.h"
namespace thrust { 
# 26
namespace detail { 
# 30
template< class T, class Alloc> 
# 31
class contiguous_storage { 
# 34
typedef allocator_traits< Alloc>  alloc_traits; 
# 37
public: typedef Alloc allocator_type; 
# 38
typedef T value_type; 
# 39
typedef typename allocator_traits< Alloc> ::pointer pointer; 
# 40
typedef typename allocator_traits< Alloc> ::const_pointer const_pointer; 
# 41
typedef typename allocator_traits< Alloc> ::size_type size_type; 
# 42
typedef typename allocator_traits< Alloc> ::difference_type difference_type; 
# 49
typedef typename Alloc::reference reference; 
# 50
typedef typename Alloc::const_reference const_reference; 
# 52
typedef normal_iterator< typename allocator_traits< Alloc> ::pointer>  iterator; 
# 53
typedef normal_iterator< typename allocator_traits< Alloc> ::const_pointer>  const_iterator; 
# 57
explicit contiguous_storage(const allocator_type & alloc = allocator_type()); 
# 61
explicit contiguous_storage(size_type n, const allocator_type & alloc = allocator_type()); 
# 65
~contiguous_storage(); 
# 68
size_type size() const; 
# 71
size_type max_size() const; 
# 74
iterator begin(); 
# 77
const_iterator begin() const; 
# 80
iterator end(); 
# 83
const_iterator end() const; 
# 86
reference operator[](size_type n); 
# 89
const_reference operator[](size_type n) const; 
# 92
allocator_type get_allocator() const; 
# 96
void allocate(size_type n); 
# 99
void deallocate(); 
# 102
void swap(contiguous_storage & x); 
# 105
void default_construct_n(iterator first, size_type n); 
# 108
void uninitialized_fill_n(iterator first, size_type n, const value_type & value); 
# 110
template< class InputIterator> iterator uninitialized_copy(InputIterator first, InputIterator last, iterator result); 
# 114
template< class System, class InputIterator> iterator uninitialized_copy(execution_policy< System>  & from_system, InputIterator first, InputIterator last, iterator result); 
# 121
template< class InputIterator, class Size> iterator uninitialized_copy_n(InputIterator first, Size n, iterator result); 
# 125
template< class System, class InputIterator, class Size> iterator uninitialized_copy_n(execution_policy< System>  & from_system, InputIterator first, Size n, iterator result); 
# 133
void destroy(iterator first, iterator last); 
# 137
private: allocator_type m_allocator; 
# 139
iterator m_begin; 
# 141
size_type m_size; 
# 144
contiguous_storage &operator=(const contiguous_storage & x); 
# 145
}; 
# 147
}
# 149
template< class T, class Alloc> void swap(detail::contiguous_storage< T, Alloc>  & lhs, detail::contiguous_storage< T, Alloc>  & rhs); 
# 153
}
# 22 "/usr/local/cuda/include/thrust/detail/allocator/copy_construct_range.h"
namespace thrust { 
# 24
namespace detail { 
# 27
template< class System, class Allocator, class InputIterator, class Pointer> Pointer copy_construct_range(execution_policy< System>  & from_system, Allocator & a, InputIterator first, InputIterator last, Pointer result); 
# 35
template< class System, class Allocator, class InputIterator, class Size, class Pointer> Pointer copy_construct_range_n(execution_policy< System>  & from_system, Allocator & a, InputIterator first, Size n, Pointer result); 
# 43
}
# 44
}
# 29 "/usr/local/cuda/include/thrust/detail/allocator/copy_construct_range.inl"
namespace thrust { 
# 31
namespace detail { 
# 33
namespace allocator_traits_detail { 
# 37
template< class Allocator, class InputType, class OutputType> 
# 38
struct copy_construct_with_allocator { 
# 40
Allocator &a; 
# 43
copy_construct_with_allocator(Allocator &a) : a(a) 
# 45
{ } 
# 47
template< class Tuple> void 
# 49
operator()(Tuple t) 
# 50
{ 
# 51
const InputType &in = thrust::get< 0> (t); 
# 52
OutputType &out = thrust::get< 1> (t); 
# 54
allocator_traits< Allocator> ::construct(a, &out, in); 
# 55
} 
# 56
}; 
# 63
template< class Allocator, class T> 
# 64
struct needs_copy_construct_via_allocator : public integral_constant< bool, has_member_construct2< Allocator, T, T> ::value || (!has_trivial_copy_constructor< T> ::value)>  { 
# 69
}; 
# 74
template< class U, class T> 
# 75
struct needs_copy_construct_via_allocator< std::allocator< U> , T>  : public integral_constant< bool, !has_trivial_copy_constructor< T> ::value>  { 
# 80
}; 
# 87
template< class Allocator, class FromSystem, class ToSystem, class InputIterator, class Pointer> typename enable_if_convertible< FromSystem, ToSystem, Pointer> ::type 
# 94
uninitialized_copy_with_allocator(Allocator &a, const execution_policy< FromSystem>  &
# 95
from_system, const execution_policy< ToSystem>  &
# 96
to_system, InputIterator 
# 97
first, InputIterator 
# 98
last, Pointer 
# 99
result) 
# 100
{ 
# 102
typedef tuple< InputIterator, Pointer, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 103
typedef zip_iterator< tuple< InputIterator, Pointer, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 105
ZipIterator begin = thrust::make_zip_iterator(thrust::make_tuple(first, result)); 
# 106
ZipIterator end = begin; 
# 109
const typename iterator_difference< InputIterator> ::type n = thrust::distance(first, last); 
# 110
thrust::advance(end, n); 
# 113
typedef typename iterator_traits< InputIterator> ::value_type InputType; 
# 114
typedef typename iterator_traits< Pointer> ::value_type OutputType; 
# 118
thrust::for_each(to_system, begin, end, ((copy_construct_with_allocator< Allocator, typename iterator_traits< InputIterator> ::value_type, typename iterator_traits< Pointer> ::value_type> )(a))); 
# 121
return thrust::get< 1> ((end.get_iterator_tuple())); 
# 122
} 
# 129
template< class Allocator, class FromSystem, class ToSystem, class InputIterator, class Size, class Pointer> typename enable_if_convertible< FromSystem, ToSystem, Pointer> ::type 
# 136
uninitialized_copy_with_allocator_n(Allocator &a, const execution_policy< FromSystem>  &
# 137
from_system, const execution_policy< ToSystem>  &
# 138
to_system, InputIterator 
# 139
first, Size 
# 140
n, Pointer 
# 141
result) 
# 142
{ 
# 144
typedef tuple< InputIterator, Pointer, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 145
typedef zip_iterator< tuple< InputIterator, Pointer, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 147
ZipIterator begin = thrust::make_zip_iterator(thrust::make_tuple(first, result)); 
# 150
typedef typename iterator_traits< InputIterator> ::value_type InputType; 
# 151
typedef typename iterator_traits< Pointer> ::value_type OutputType; 
# 155
ZipIterator end = thrust::for_each_n(to_system, begin, n, ((copy_construct_with_allocator< Allocator, typename iterator_traits< InputIterator> ::value_type, typename iterator_traits< Pointer> ::value_type> )(a))); 
# 158
return thrust::get< 1> ((end.get_iterator_tuple())); 
# 159
} 
# 162
template< class Allocator, class FromSystem, class ToSystem, class InputIterator, class Pointer> typename disable_if_convertible< FromSystem, ToSystem, Pointer> ::type 
# 169
uninitialized_copy_with_allocator(Allocator &, const execution_policy< FromSystem>  &
# 170
from_system, const execution_policy< ToSystem>  &
# 171
to_system, InputIterator 
# 172
first, InputIterator 
# 173
last, Pointer 
# 174
result) 
# 175
{ 
# 178
return detail::two_system_copy(from_system, to_system, first, last, result); 
# 179
} 
# 182
template< class Allocator, class FromSystem, class ToSystem, class InputIterator, class Size, class Pointer> typename disable_if_convertible< FromSystem, ToSystem, Pointer> ::type 
# 189
uninitialized_copy_with_allocator_n(Allocator &, const execution_policy< FromSystem>  &
# 190
from_system, const execution_policy< ToSystem>  &
# 191
to_system, InputIterator 
# 192
first, Size 
# 193
n, Pointer 
# 194
result) 
# 195
{ 
# 198
return detail::two_system_copy_n(from_system, to_system, first, n, result); 
# 199
} 
# 202
template< class FromSystem, class Allocator, class InputIterator, class Pointer> typename disable_if< needs_copy_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value, Pointer> ::type 
# 211
copy_construct_range(execution_policy< FromSystem>  &from_system, Allocator &
# 212
a, InputIterator 
# 213
first, InputIterator 
# 214
last, Pointer 
# 215
result) 
# 216
{ 
# 218
return detail::two_system_copy(from_system, allocator_system< Allocator> ::get(a), first, last, result); 
# 219
} 
# 222
template< class FromSystem, class Allocator, class InputIterator, class Size, class Pointer> typename disable_if< needs_copy_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value, Pointer> ::type 
# 231
copy_construct_range_n(execution_policy< FromSystem>  &from_system, Allocator &
# 232
a, InputIterator 
# 233
first, Size 
# 234
n, Pointer 
# 235
result) 
# 236
{ 
# 238
return detail::two_system_copy_n(from_system, allocator_system< Allocator> ::get(a), first, n, result); 
# 239
} 
# 242
template< class FromSystem, class Allocator, class InputIterator, class Pointer> typename enable_if< needs_copy_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value, Pointer> ::type 
# 251
copy_construct_range(execution_policy< FromSystem>  &from_system, Allocator &
# 252
a, InputIterator 
# 253
first, InputIterator 
# 254
last, Pointer 
# 255
result) 
# 256
{ 
# 257
return uninitialized_copy_with_allocator(a, from_system, allocator_system< Allocator> ::get(a), first, last, result); 
# 258
} 
# 261
template< class FromSystem, class Allocator, class InputIterator, class Size, class Pointer> typename enable_if< needs_copy_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value, Pointer> ::type 
# 270
copy_construct_range_n(execution_policy< FromSystem>  &from_system, Allocator &
# 271
a, InputIterator 
# 272
first, Size 
# 273
n, Pointer 
# 274
result) 
# 275
{ 
# 276
return uninitialized_copy_with_allocator_n(a, from_system, allocator_system< Allocator> ::get(a), first, n, result); 
# 277
} 
# 280
}
# 283
template< class System, class Allocator, class InputIterator, class Pointer> Pointer 
# 285
copy_construct_range(execution_policy< System>  &from_system, Allocator &
# 286
a, InputIterator 
# 287
first, InputIterator 
# 288
last, Pointer 
# 289
result) 
# 290
{ 
# 291
return allocator_traits_detail::copy_construct_range(from_system, a, first, last, result); 
# 292
} 
# 295
template< class System, class Allocator, class InputIterator, class Size, class Pointer> Pointer 
# 297
copy_construct_range_n(execution_policy< System>  &from_system, Allocator &
# 298
a, InputIterator 
# 299
first, Size 
# 300
n, Pointer 
# 301
result) 
# 302
{ 
# 303
return allocator_traits_detail::copy_construct_range_n(from_system, a, first, n, result); 
# 304
} 
# 307
}
# 308
}
# 21 "/usr/local/cuda/include/thrust/detail/allocator/default_construct_range.h"
namespace thrust { 
# 23
namespace detail { 
# 27
template< class Allocator, class Pointer, class Size> inline void default_construct_range(Allocator & a, Pointer p, Size n); 
# 32
}
# 33
}
# 27 "/usr/local/cuda/include/thrust/uninitialized_fill.h"
namespace thrust { 
# 90
template< class DerivedPolicy, class ForwardIterator, class T> void uninitialized_fill(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, const T & x); 
# 146
template< class ForwardIterator, class T> void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T & x); 
# 206
template< class DerivedPolicy, class ForwardIterator, class Size, class T> ForwardIterator uninitialized_fill_n(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, Size n, const T & x); 
# 263
template< class ForwardIterator, class Size, class T> ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T & x); 
# 272
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/uninitialized_fill.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 32
template< class DerivedPolicy, class 
# 33
ForwardIterator, class 
# 34
T> void 
# 32
uninitialized_fill(execution_policy< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, const T & x); 
# 41
template< class DerivedPolicy, class 
# 42
ForwardIterator, class 
# 43
Size, class 
# 44
T> ForwardIterator 
# 41
uninitialized_fill_n(execution_policy< DerivedPolicy>  & exec, ForwardIterator first, Size n, const T & x); 
# 51
}
# 52
}
# 53
}
# 54
}
# 27 "/usr/local/cuda/include/thrust/fill.h"
namespace thrust { 
# 74
template< class DerivedPolicy, class ForwardIterator, class T> void fill(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, const T & value); 
# 113
template< class ForwardIterator, class T> void fill(ForwardIterator first, ForwardIterator last, const T & value); 
# 156
template< class DerivedPolicy, class OutputIterator, class Size, class T> OutputIterator fill_n(const detail::execution_policy_base< DerivedPolicy>  & exec, OutputIterator first, Size n, const T & value); 
# 195
template< class OutputIterator, class Size, class T> OutputIterator fill_n(OutputIterator first, Size n, const T & value); 
# 206
}
# 27 "/usr/local/cuda/include/thrust/generate.h"
namespace thrust { 
# 72
template< class DerivedPolicy, class 
# 73
ForwardIterator, class 
# 74
Generator> void 
# 72
generate(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, Generator gen); 
# 114
template< class ForwardIterator, class 
# 115
Generator> void 
# 114
generate(ForwardIterator first, ForwardIterator last, Generator gen); 
# 157
template< class DerivedPolicy, class 
# 158
OutputIterator, class 
# 159
Size, class 
# 160
Generator> OutputIterator 
# 157
generate_n(const detail::execution_policy_base< DerivedPolicy>  & exec, OutputIterator first, Size n, Generator gen); 
# 199
template< class OutputIterator, class 
# 200
Size, class 
# 201
Generator> OutputIterator 
# 199
generate_n(OutputIterator first, Size n, Generator gen); 
# 210
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/generate.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 32
template< class ExecutionPolicy, class 
# 33
ForwardIterator, class 
# 34
Generator> void 
# 32
generate(execution_policy< ExecutionPolicy>  & exec, ForwardIterator first, ForwardIterator last, Generator gen); 
# 41
template< class ExecutionPolicy, class 
# 42
OutputIterator, class 
# 43
Size, class 
# 44
Generator> OutputIterator 
# 41
generate_n(execution_policy< ExecutionPolicy>  & exec, OutputIterator first, Size n, Generator gen); 
# 51
}
# 52
}
# 53
}
# 54
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/generate.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 32
template< class ExecutionPolicy, class 
# 33
ForwardIterator, class 
# 34
Generator> void 
# 36
generate(execution_policy< ExecutionPolicy>  &exec, ForwardIterator 
# 37
first, ForwardIterator 
# 38
last, Generator 
# 39
gen) 
# 40
{ 
# 41
thrust::for_each(exec, first, last, (typename thrust::detail::generate_functor< ExecutionPolicy, Generator> ::type)gen); 
# 42
} 
# 44
template< class ExecutionPolicy, class 
# 45
OutputIterator, class 
# 46
Size, class 
# 47
Generator> OutputIterator 
# 49
generate_n(execution_policy< ExecutionPolicy>  &exec, OutputIterator 
# 50
first, Size 
# 51
n, Generator 
# 52
gen) 
# 53
{ 
# 54
return thrust::for_each_n(exec, first, n, (typename thrust::detail::generate_functor< ExecutionPolicy, Generator> ::type)gen); 
# 55
} 
# 57
}
# 58
}
# 59
}
# 60
}
# 29 "/usr/local/cuda/include/thrust/detail/generate.inl"
namespace thrust { 
# 34
template< class DerivedPolicy, class 
# 35
ForwardIterator, class 
# 36
Generator> void 
# 38
generate(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 39
first, ForwardIterator 
# 40
last, Generator 
# 41
gen) 
# 42
{ 
# 43
using system::detail::generic::generate;
# 44
return generate(detail::derived_cast(detail::strip_const(exec)), first, last, gen); 
# 45
} 
# 49
template< class DerivedPolicy, class 
# 50
OutputIterator, class 
# 51
Size, class 
# 52
Generator> OutputIterator 
# 54
generate_n(const detail::execution_policy_base< DerivedPolicy>  &exec, OutputIterator 
# 55
first, Size 
# 56
n, Generator 
# 57
gen) 
# 58
{ 
# 59
using system::detail::generic::generate_n;
# 60
return generate_n(detail::derived_cast(detail::strip_const(exec)), first, n, gen); 
# 61
} 
# 64
template< class ForwardIterator, class 
# 65
Generator> void 
# 66
generate(ForwardIterator first, ForwardIterator 
# 67
last, Generator 
# 68
gen) 
# 69
{ 
# 70
using thrust::system::detail::generic::select_system;
# 72
typedef typename iterator_system< ForwardIterator> ::type System; 
# 74
System system; 
# 76
return thrust::generate(select_system(system), first, last, gen); 
# 77
} 
# 80
template< class OutputIterator, class 
# 81
Size, class 
# 82
Generator> OutputIterator 
# 83
generate_n(OutputIterator first, Size 
# 84
n, Generator 
# 85
gen) 
# 86
{ 
# 87
using thrust::system::detail::generic::select_system;
# 89
typedef typename iterator_system< OutputIterator> ::type System; 
# 91
System system; 
# 93
return thrust::generate_n(select_system(system), first, n, gen); 
# 94
} 
# 97
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/fill.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class OutputIterator, class Size, class T> OutputIterator 
# 35
fill_n(execution_policy< DerivedPolicy>  &exec, OutputIterator 
# 36
first, Size 
# 37
n, const T &
# 38
value) 
# 39
{ 
# 41
return thrust::generate_n(exec, first, n, ((thrust::detail::fill_functor< T> )(value))); 
# 42
} 
# 44
template< class DerivedPolicy, class ForwardIterator, class T> void 
# 46
fill(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 47
first, ForwardIterator 
# 48
last, const T &
# 49
value) 
# 50
{ 
# 52
thrust::generate(exec, first, last, ((thrust::detail::fill_functor< T> )(value))); 
# 53
} 
# 56
}
# 57
}
# 58
}
# 59
}
# 28 "/usr/local/cuda/include/thrust/detail/fill.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class ForwardIterator, class T> void 
# 35
fill(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 36
first, ForwardIterator 
# 37
last, const T &
# 38
value) 
# 39
{ 
# 40
using system::detail::generic::fill;
# 41
return fill(detail::derived_cast(detail::strip_const(exec)), first, last, value); 
# 42
} 
# 46
template< class DerivedPolicy, class OutputIterator, class Size, class T> OutputIterator 
# 48
fill_n(const detail::execution_policy_base< DerivedPolicy>  &exec, OutputIterator 
# 49
first, Size 
# 50
n, const T &
# 51
value) 
# 52
{ 
# 53
using system::detail::generic::fill_n;
# 54
return fill_n(detail::derived_cast(detail::strip_const(exec)), first, n, value); 
# 55
} 
# 58
template< class ForwardIterator, class T> void 
# 60
fill(ForwardIterator first, ForwardIterator 
# 61
last, const T &
# 62
value) 
# 63
{ 
# 64
using thrust::system::detail::generic::select_system;
# 66
typedef typename iterator_system< ForwardIterator> ::type System; 
# 68
System system; 
# 70
thrust::fill(select_system(system), first, last, value); 
# 71
} 
# 74
template< class OutputIterator, class Size, class T> OutputIterator 
# 76
fill_n(OutputIterator first, Size 
# 77
n, const T &
# 78
value) 
# 79
{ 
# 80
using thrust::system::detail::generic::select_system;
# 82
typedef typename iterator_system< OutputIterator> ::type System; 
# 84
System system; 
# 86
return thrust::fill_n(select_system(system), first, n, value); 
# 87
} 
# 90
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/uninitialized_fill.inl"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 32
namespace detail { 
# 35
template< class DerivedPolicy, class 
# 36
ForwardIterator, class 
# 37
T> void 
# 39
uninitialized_fill(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 40
first, ForwardIterator 
# 41
last, const T &
# 42
x, thrust::detail::true_type) 
# 44
{ 
# 45
thrust::fill(exec, first, last, x); 
# 46
} 
# 48
template< class DerivedPolicy, class 
# 49
ForwardIterator, class 
# 50
T> void 
# 52
uninitialized_fill(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 53
first, ForwardIterator 
# 54
last, const T &
# 55
x, thrust::detail::false_type) 
# 57
{ 
# 58
typedef typename iterator_traits< ForwardIterator> ::value_type ValueType; 
# 60
thrust::for_each(exec, first, last, ((thrust::detail::uninitialized_fill_functor< typename iterator_traits< ForwardIterator> ::value_type> )(x))); 
# 61
} 
# 63
template< class DerivedPolicy, class 
# 64
ForwardIterator, class 
# 65
Size, class 
# 66
T> ForwardIterator 
# 68
uninitialized_fill_n(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 69
first, Size 
# 70
n, const T &
# 71
x, thrust::detail::true_type) 
# 73
{ 
# 74
return thrust::fill_n(exec, first, n, x); 
# 75
} 
# 77
template< class DerivedPolicy, class 
# 78
ForwardIterator, class 
# 79
Size, class 
# 80
T> ForwardIterator 
# 82
uninitialized_fill_n(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 83
first, Size 
# 84
n, const T &
# 85
x, thrust::detail::false_type) 
# 87
{ 
# 88
typedef typename iterator_traits< ForwardIterator> ::value_type ValueType; 
# 90
return thrust::for_each_n(exec, first, n, ((thrust::detail::uninitialized_fill_functor< typename iterator_traits< ForwardIterator> ::value_type> )(x))); 
# 91
} 
# 93
}
# 95
template< class DerivedPolicy, class 
# 96
ForwardIterator, class 
# 97
T> void 
# 99
uninitialized_fill(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 100
first, ForwardIterator 
# 101
last, const T &
# 102
x) 
# 103
{ 
# 104
typedef typename iterator_traits< ForwardIterator> ::value_type ValueType; 
# 106
typedef thrust::detail::has_trivial_copy_constructor< typename iterator_traits< ForwardIterator> ::value_type>  ValueTypeHasTrivialCopyConstructor; 
# 108
detail::uninitialized_fill(exec, first, last, x, ValueTypeHasTrivialCopyConstructor()); 
# 110
} 
# 112
template< class DerivedPolicy, class 
# 113
ForwardIterator, class 
# 114
Size, class 
# 115
T> ForwardIterator 
# 117
uninitialized_fill_n(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 118
first, Size 
# 119
n, const T &
# 120
x) 
# 121
{ 
# 122
typedef typename iterator_traits< ForwardIterator> ::value_type ValueType; 
# 124
typedef thrust::detail::has_trivial_copy_constructor< typename iterator_traits< ForwardIterator> ::value_type>  ValueTypeHasTrivialCopyConstructor; 
# 126
return detail::uninitialized_fill_n(exec, first, n, x, ValueTypeHasTrivialCopyConstructor()); 
# 128
} 
# 130
}
# 131
}
# 132
}
# 133
}
# 28 "/usr/local/cuda/include/thrust/detail/uninitialized_fill.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class ForwardIterator, class T> void 
# 35
uninitialized_fill(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 36
first, ForwardIterator 
# 37
last, const T &
# 38
x) 
# 39
{ 
# 40
using system::detail::generic::uninitialized_fill;
# 41
return uninitialized_fill(detail::derived_cast(detail::strip_const(exec)), first, last, x); 
# 42
} 
# 46
template< class DerivedPolicy, class ForwardIterator, class Size, class T> ForwardIterator 
# 48
uninitialized_fill_n(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 49
first, Size 
# 50
n, const T &
# 51
x) 
# 52
{ 
# 53
using system::detail::generic::uninitialized_fill_n;
# 54
return uninitialized_fill_n(detail::derived_cast(detail::strip_const(exec)), first, n, x); 
# 55
} 
# 58
template< class ForwardIterator, class 
# 59
T> void 
# 60
uninitialized_fill(ForwardIterator first, ForwardIterator 
# 61
last, const T &
# 62
x) 
# 63
{ 
# 64
using thrust::system::detail::generic::select_system;
# 66
typedef typename iterator_system< ForwardIterator> ::type System; 
# 68
System system; 
# 70
thrust::uninitialized_fill(select_system(system), first, last, x); 
# 71
} 
# 74
template< class ForwardIterator, class 
# 75
Size, class 
# 76
T> ForwardIterator 
# 77
uninitialized_fill_n(ForwardIterator first, Size 
# 78
n, const T &
# 79
x) 
# 80
{ 
# 81
using thrust::system::detail::generic::select_system;
# 83
typedef typename iterator_system< ForwardIterator> ::type System; 
# 85
System system; 
# 87
return thrust::uninitialized_fill_n(select_system(system), first, n, x); 
# 88
} 
# 91
}
# 24 "/usr/local/cuda/include/thrust/detail/allocator/default_construct_range.inl"
namespace thrust { 
# 26
namespace detail { 
# 28
namespace allocator_traits_detail { 
# 32
template< class Allocator> 
# 33
struct construct1_via_allocator { 
# 35
Allocator &a; 
# 38
construct1_via_allocator(Allocator &a) : a(a) 
# 40
{ } 
# 42
template< class T> void 
# 44
operator()(T &x) 
# 45
{ 
# 46
allocator_traits< Allocator> ::construct(a, &x); 
# 47
} 
# 48
}; 
# 52
template< class Allocator, class T> 
# 53
struct needs_default_construct_via_allocator : public or_< has_member_construct1< Allocator, T> , not_< has_trivial_constructor< T> > >  { 
# 58
}; 
# 64
template< class U, class T> 
# 65
struct needs_default_construct_via_allocator< std::allocator< U> , T>  : public not_< has_trivial_constructor< T> >  { 
# 67
}; 
# 70
template< class Allocator, class Pointer, class Size> typename enable_if< needs_default_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value> ::type 
# 78
default_construct_range(Allocator &a, Pointer p, Size n) 
# 79
{ 
# 80
thrust::for_each_n(allocator_system< Allocator> ::get(a), p, n, ((construct1_via_allocator< Allocator> )(a))); 
# 81
} 
# 84
template< class Allocator, class Pointer, class Size> typename disable_if< needs_default_construct_via_allocator< Allocator, typename pointer_element< Pointer> ::type> ::value> ::type 
# 92
default_construct_range(Allocator &a, Pointer p, Size n) 
# 93
{ 
# 94
thrust::uninitialized_fill_n(allocator_system< Allocator> ::get(a), p, n, typename pointer_element< Pointer> ::type()); 
# 95
} 
# 98
}
# 101
template< class Allocator, class Pointer, class Size> inline void 
# 103
default_construct_range(Allocator &a, Pointer p, Size n) 
# 104
{ 
# 105
return allocator_traits_detail::default_construct_range(a, p, n); 
# 106
} 
# 109
}
# 110
}
# 21 "/usr/local/cuda/include/thrust/detail/allocator/destroy_range.h"
namespace thrust { 
# 23
namespace detail { 
# 26
template< class Allocator, class Pointer, class Size> inline void destroy_range(Allocator & a, Pointer p, Size n); 
# 30
}
# 31
}
# 23 "/usr/local/cuda/include/thrust/detail/allocator/destroy_range.inl"
namespace thrust { 
# 25
namespace detail { 
# 27
namespace allocator_traits_detail { 
# 38
template< class Allocator, class T> 
# 39
struct has_effectful_member_destroy : public has_member_destroy< Allocator, T>  { 
# 41
}; 
# 44
template< class U, class T> 
# 45
struct has_effectful_member_destroy< std::allocator< U> , T>  : public false_type { 
# 47
}; 
# 50
template< class Allocator, class Pointer> 
# 51
struct enable_if_destroy_range_case1 : public enable_if< has_effectful_member_destroy< Allocator, typename pointer_element< Pointer> ::type> ::value>  { 
# 58
}; 
# 61
template< class Allocator, class Pointer> 
# 62
struct enable_if_destroy_range_case2 : public enable_if< (!has_effectful_member_destroy< Allocator, typename pointer_element< Pointer> ::type> ::value) && (!has_trivial_destructor< typename pointer_element< Pointer> ::type> ::value)>  { 
# 72
}; 
# 75
template< class Allocator, class Pointer> 
# 76
struct enable_if_destroy_range_case3 : public enable_if< (!has_effectful_member_destroy< Allocator, typename pointer_element< Pointer> ::type> ::value) && has_trivial_destructor< typename pointer_element< Pointer> ::type> ::value>  { 
# 86
}; 
# 90
template< class Allocator> 
# 91
struct destroy_via_allocator { 
# 93
Allocator &a; 
# 96
destroy_via_allocator(Allocator &a) : a(a) 
# 98
{ } 
# 100
template< class T> void 
# 102
operator()(T &x) 
# 103
{ 
# 104
allocator_traits< Allocator> ::destroy(a, &x); 
# 105
} 
# 106
}; 
# 110
template< class Allocator, class Pointer, class Size> typename enable_if_destroy_range_case1< Allocator, Pointer> ::type 
# 113
destroy_range(Allocator &a, Pointer p, Size n) 
# 114
{ 
# 115
thrust::for_each_n(allocator_system< Allocator> ::get(a), p, n, ((destroy_via_allocator< Allocator> )(a))); 
# 116
} 
# 120
struct gozer { 
# 123
template< class T> void 
# 125
operator()(T &x) 
# 126
{ 
# 127
(x.~T()); 
# 128
} 
# 129
}; 
# 132
template< class Allocator, class Pointer, class Size> typename enable_if_destroy_range_case2< Allocator, Pointer> ::type 
# 135
destroy_range(Allocator &a, Pointer p, Size n) 
# 136
{ 
# 137
thrust::for_each_n(allocator_system< Allocator> ::get(a), p, n, gozer()); 
# 138
} 
# 142
template< class Allocator, class Pointer, class Size> typename enable_if_destroy_range_case3< Allocator, Pointer> ::type 
# 145
destroy_range(Allocator &, Pointer, Size) 
# 146
{ 
# 148
} 
# 151
}
# 154
template< class Allocator, class Pointer, class Size> inline void 
# 156
destroy_range(Allocator &a, Pointer p, Size n) 
# 157
{ 
# 158
return allocator_traits_detail::destroy_range(a, p, n); 
# 159
} 
# 162
}
# 163
}
# 21 "/usr/local/cuda/include/thrust/detail/allocator/fill_construct_range.h"
namespace thrust { 
# 23
namespace detail { 
# 27
template< class Allocator, class Pointer, class Size, class T> inline void fill_construct_range(Allocator & a, Pointer p, Size n, const T & value); 
# 32
}
# 33
}
# 25 "/usr/local/cuda/include/thrust/detail/allocator/fill_construct_range.inl"
namespace thrust { 
# 27
namespace detail { 
# 29
namespace allocator_traits_detail { 
# 38
template< class Allocator, class T, class Arg1> 
# 39
struct has_effectful_member_construct2 : public has_member_construct2< Allocator, T, Arg1>  { 
# 41
}; 
# 44
template< class U, class T, class Arg1> 
# 45
struct has_effectful_member_construct2< std::allocator< U> , T, Arg1>  : public false_type { 
# 47
}; 
# 50
template< class Allocator, class Arg1> 
# 51
struct construct2_via_allocator { 
# 53
Allocator &a; 
# 54
Arg1 arg; 
# 57
construct2_via_allocator(Allocator &a, const Arg1 &arg) : a(a), arg(arg) 
# 59
{ } 
# 61
template< class T> void 
# 63
operator()(T &x) 
# 64
{ 
# 65
allocator_traits< Allocator> ::construct(a, &x, arg); 
# 66
} 
# 67
}; 
# 70
template< class Allocator, class Pointer, class Size, class T> typename enable_if< has_effectful_member_construct2< Allocator, typename pointer_element< Pointer> ::type, T> ::value> ::type 
# 79
fill_construct_range(Allocator &a, Pointer p, Size n, const T &value) 
# 80
{ 
# 81
thrust::for_each_n(allocator_system< Allocator> ::get(a), p, n, construct2_via_allocator< Allocator, T> (a, value)); 
# 82
} 
# 85
template< class Allocator, class Pointer, class Size, class T> typename disable_if< has_effectful_member_construct2< Allocator, typename pointer_element< Pointer> ::type, T> ::value> ::type 
# 94
fill_construct_range(Allocator &a, Pointer p, Size n, const T &value) 
# 95
{ 
# 96
thrust::uninitialized_fill_n(allocator_system< Allocator> ::get(a), p, n, value); 
# 97
} 
# 100
}
# 103
template< class Alloc, class Pointer, class Size, class T> inline void 
# 105
fill_construct_range(Alloc &a, Pointer p, Size n, const T &value) 
# 106
{ 
# 107
return allocator_traits_detail::fill_construct_range(a, p, n, value); 
# 108
} 
# 111
}
# 112
}
# 28 "/usr/local/cuda/include/thrust/detail/contiguous_storage.inl"
namespace thrust { 
# 31
namespace detail { 
# 35
template< class T, class Alloc> 
# 38
contiguous_storage< T, Alloc> ::contiguous_storage(const Alloc &alloc) : m_allocator(alloc), m_begin((pointer)(static_cast< T *>(0))), m_size(0) 
# 42
{ 
# 43
; 
# 44
} 
# 47
template< class T, class Alloc> 
# 50
contiguous_storage< T, Alloc> ::contiguous_storage(size_type n, const Alloc &alloc) : m_allocator(alloc), m_begin((pointer)(static_cast< T *>(0))), m_size(0) 
# 54
{ 
# 55
allocate(n); 
# 56
} 
# 59
template< class T, class Alloc> 
# 62
contiguous_storage< T, Alloc> ::~contiguous_storage() 
# 63
{ 
# 64
deallocate(); 
# 65
} 
# 67
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::size_type 
# 71
contiguous_storage< T, Alloc> ::size() const 
# 72
{ 
# 73
return m_size; 
# 74
} 
# 76
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::size_type 
# 80
contiguous_storage< T, Alloc> ::max_size() const 
# 81
{ 
# 82
return alloc_traits::max_size(m_allocator); 
# 83
} 
# 85
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::iterator 
# 89
contiguous_storage< T, Alloc> ::begin() 
# 90
{ 
# 91
return m_begin; 
# 92
} 
# 94
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::const_iterator 
# 98
contiguous_storage< T, Alloc> ::begin() const 
# 99
{ 
# 100
return m_begin; 
# 101
} 
# 103
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::iterator 
# 107
contiguous_storage< T, Alloc> ::end() 
# 108
{ 
# 109
return (m_begin) + size(); 
# 110
} 
# 112
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::const_iterator 
# 116
contiguous_storage< T, Alloc> ::end() const 
# 117
{ 
# 118
return (m_begin) + size(); 
# 119
} 
# 121
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::reference 
# 125
contiguous_storage< T, Alloc> ::operator[](size_type n) 
# 126
{ 
# 127
return (m_begin)[n]; 
# 128
} 
# 130
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::const_reference 
# 134
contiguous_storage< T, Alloc> ::operator[](size_type n) const 
# 135
{ 
# 136
return (m_begin)[n]; 
# 137
} 
# 139
template< class T, class Alloc> typename contiguous_storage< T, Alloc> ::allocator_type 
# 143
contiguous_storage< T, Alloc> ::get_allocator() const 
# 144
{ 
# 145
return m_allocator; 
# 146
} 
# 148
template< class T, class Alloc> void 
# 151
contiguous_storage< T, Alloc> ::allocate(size_type n) 
# 152
{ 
# 153
if (n > 0) 
# 154
{ 
# 155
(m_begin) = ((iterator)(alloc_traits::allocate(m_allocator, n))); 
# 156
(m_size) = n; 
# 157
} else 
# 159
{ 
# 160
(m_begin) = ((iterator)((pointer)(static_cast< T *>(0)))); 
# 161
(m_size) = 0; 
# 162
}  
# 163
} 
# 165
template< class T, class Alloc> void 
# 168
contiguous_storage< T, Alloc> ::deallocate() 
# 169
{ 
# 170
if (size() > 0) 
# 171
{ 
# 172
alloc_traits::deallocate(m_allocator, ((m_begin).base()), size()); 
# 173
(m_begin) = ((iterator)((pointer)(static_cast< T *>(0)))); 
# 174
(m_size) = 0; 
# 175
}  
# 176
} 
# 178
template< class T, class Alloc> void 
# 181
contiguous_storage< T, Alloc> ::swap(contiguous_storage &x) 
# 182
{ 
# 183
thrust::swap(m_begin, x.m_begin); 
# 184
thrust::swap(m_size, x.m_size); 
# 186
thrust::swap(m_allocator, x.m_allocator); 
# 187
} 
# 189
template< class T, class Alloc> void 
# 192
contiguous_storage< T, Alloc> ::default_construct_n(iterator first, size_type n) 
# 193
{ 
# 194
default_construct_range(m_allocator, (first.base()), n); 
# 195
} 
# 197
template< class T, class Alloc> void 
# 200
contiguous_storage< T, Alloc> ::uninitialized_fill_n(iterator first, size_type n, const value_type &x) 
# 201
{ 
# 202
fill_construct_range(m_allocator, (first.base()), n, x); 
# 203
} 
# 205
template< class T, class Alloc> 
# 206
template< class System, class InputIterator> typename contiguous_storage< T, Alloc> ::iterator 
# 210
contiguous_storage< T, Alloc> ::uninitialized_copy(execution_policy< System>  &from_system, InputIterator first, InputIterator last, iterator result) 
# 211
{ 
# 212
return ((iterator)(copy_construct_range(from_system, m_allocator, first, last, (result.base())))); 
# 213
} 
# 215
template< class T, class Alloc> 
# 216
template< class InputIterator> typename contiguous_storage< T, Alloc> ::iterator 
# 220
contiguous_storage< T, Alloc> ::uninitialized_copy(InputIterator first, InputIterator last, iterator result) 
# 221
{ 
# 223
typename iterator_system< InputIterator> ::type from_system; 
# 225
return ((iterator)(copy_construct_range(from_system, m_allocator, first, last, (result.base())))); 
# 226
} 
# 228
template< class T, class Alloc> 
# 229
template< class System, class InputIterator, class Size> typename contiguous_storage< T, Alloc> ::iterator 
# 233
contiguous_storage< T, Alloc> ::uninitialized_copy_n(execution_policy< System>  &from_system, InputIterator first, Size n, iterator result) 
# 234
{ 
# 235
return ((iterator)(copy_construct_range_n(from_system, m_allocator, first, n, (result.base())))); 
# 236
} 
# 238
template< class T, class Alloc> 
# 239
template< class InputIterator, class Size> typename contiguous_storage< T, Alloc> ::iterator 
# 243
contiguous_storage< T, Alloc> ::uninitialized_copy_n(InputIterator first, Size n, iterator result) 
# 244
{ 
# 246
typename iterator_system< InputIterator> ::type from_system; 
# 248
return ((iterator)(copy_construct_range_n(from_system, m_allocator, first, n, (result.base())))); 
# 249
} 
# 251
template< class T, class Alloc> void 
# 254
contiguous_storage< T, Alloc> ::destroy(iterator first, iterator last) 
# 255
{ 
# 256
destroy_range(m_allocator, (first.base()), last - first); 
# 257
} 
# 259
}
# 261
template< class T, class Alloc> void 
# 263
swap(detail::contiguous_storage< T, Alloc>  &lhs, detail::contiguous_storage< T, Alloc>  &rhs) 
# 264
{ 
# 265
(lhs.swap(rhs)); 
# 266
} 
# 268
}
# 23 "/usr/local/cuda/include/thrust/detail/allocator/tagged_allocator.h"
namespace thrust { 
# 25
namespace detail { 
# 28
template< class T, class Tag, class Pointer> class tagged_allocator; 
# 30
template< class Tag, class Pointer> 
# 31
class tagged_allocator< void, Tag, Pointer>  { 
# 34
public: typedef void value_type; 
# 35
typedef typename pointer_traits< Pointer> ::template rebind< void> ::other pointer; 
# 36
typedef typename pointer_traits< Pointer> ::template rebind< const void> ::other const_pointer; 
# 37
typedef std::size_t size_type; 
# 38
typedef typename pointer_traits< Pointer> ::difference_type difference_type; 
# 39
typedef Tag system_type; 
# 41
template< class U> 
# 42
struct rebind { 
# 44
typedef detail::tagged_allocator< U, Tag, Pointer>  other; 
# 45
}; 
# 46
}; 
# 48
template< class T, class Tag, class Pointer> 
# 49
class tagged_allocator { 
# 52
public: typedef T value_type; 
# 53
typedef typename pointer_traits< Pointer> ::template rebind< T> ::other pointer; 
# 54
typedef typename pointer_traits< Pointer> ::template rebind< const T> ::other const_pointer; 
# 55
typedef typename iterator_reference< typename pointer_traits< Pointer> ::template rebind< T> ::other> ::type reference; 
# 56
typedef typename iterator_reference< typename pointer_traits< Pointer> ::template rebind< const T> ::other> ::type const_reference; 
# 57
typedef std::size_t size_type; 
# 58
typedef typename pointer_traits< typename pointer_traits< Pointer> ::template rebind< T> ::other> ::difference_type difference_type; 
# 59
typedef Tag system_type; 
# 61
template< class U> 
# 62
struct rebind { 
# 64
typedef detail::tagged_allocator< U, Tag, Pointer>  other; 
# 65
}; 
# 68
inline tagged_allocator(); 
# 71
inline tagged_allocator(const tagged_allocator &); 
# 73
template< class U, class OtherPointer> inline tagged_allocator(const detail::tagged_allocator< U, Tag, OtherPointer>  &); 
# 78
inline ~tagged_allocator(); 
# 81
pointer address(reference x) const; 
# 84
const_pointer address(const_reference x) const; 
# 86
size_type max_size() const; 
# 87
}; 
# 89
template< class T1, class Pointer1, class T2, class Pointer2, class Tag> bool operator==(const tagged_allocator< T1, Pointer1, Tag>  &, const tagged_allocator< T2, Pointer2, Tag>  &); 
# 93
template< class T1, class Pointer1, class T2, class Pointer2, class Tag> bool operator!=(const tagged_allocator< T1, Pointer1, Tag>  &, const tagged_allocator< T2, Pointer2, Tag>  &); 
# 97
}
# 98
}
# 21 "/usr/local/cuda/include/thrust/detail/allocator/tagged_allocator.inl"
namespace thrust { 
# 23
namespace detail { 
# 27
template< class T, class Tag, class Pointer> inline 
# 29
tagged_allocator< T, Tag, Pointer> ::tagged_allocator() 
# 30
{ } 
# 33
template< class T, class Tag, class Pointer> inline 
# 35
tagged_allocator< T, Tag, Pointer> ::tagged_allocator(const tagged_allocator &) 
# 36
{ } 
# 39
template< class T, class Tag, class Pointer> 
# 40
template< class U, class OtherPointer> inline 
# 42
tagged_allocator< T, Tag, Pointer> ::tagged_allocator(const detail::tagged_allocator< U, Tag, OtherPointer>  &) 
# 43
{ } 
# 46
template< class T, class Tag, class Pointer> inline 
# 48
tagged_allocator< T, Tag, Pointer> ::~tagged_allocator() 
# 49
{ } 
# 52
template< class T, class Tag, class Pointer> typename tagged_allocator< T, Tag, Pointer> ::pointer 
# 55
tagged_allocator< T, Tag, Pointer> ::address(reference x) const 
# 56
{ 
# 57
return &x; 
# 58
} 
# 61
template< class T, class Tag, class Pointer> typename tagged_allocator< T, Tag, Pointer> ::const_pointer 
# 64
tagged_allocator< T, Tag, Pointer> ::address(const_reference x) const 
# 65
{ 
# 66
return &x; 
# 67
} 
# 70
template< class T, class Tag, class Pointer> typename tagged_allocator< T, Tag, Pointer> ::size_type 
# 73
tagged_allocator< T, Tag, Pointer> ::max_size() const 
# 74
{ 
# 75
return std::numeric_limits< unsigned long> ::max() / sizeof(T); 
# 76
} 
# 79
template< class T1, class Pointer1, class T2, class Pointer2, class Tag> bool 
# 81
operator==(const tagged_allocator< T1, Pointer1, Tag>  &, const tagged_allocator< T2, Pointer2, Tag>  &) 
# 82
{ 
# 83
return true; 
# 84
} 
# 87
template< class T1, class Pointer1, class T2, class Pointer2, class Tag> bool 
# 89
operator!=(const tagged_allocator< T1, Pointer1, Tag>  &, const tagged_allocator< T2, Pointer2, Tag>  &) 
# 90
{ 
# 91
return false; 
# 92
} 
# 95
}
# 96
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/temporary_buffer.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 34
template< class T, class DerivedPolicy> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  get_temporary_buffer(execution_policy< DerivedPolicy>  & exec, typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type n); 
# 40
template< class DerivedPolicy, class Pointer> void return_temporary_buffer(execution_policy< DerivedPolicy>  & exec, Pointer p); 
# 45
}
# 46
}
# 47
}
# 48
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/temporary_buffer.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class T, class DerivedPolicy> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  
# 36
get_temporary_buffer(execution_policy< DerivedPolicy>  &exec, typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type n) 
# 37
{ 
# 38
pointer< T, DerivedPolicy, use_default, use_default>  ptr = thrust::malloc< T> (exec, n); 
# 41
if (!(ptr.get())) 
# 42
{ 
# 43
n = 0; 
# 44
}  
# 46
return thrust::make_pair(ptr, n); 
# 47
} 
# 50
template< class DerivedPolicy, class Pointer> void 
# 52
return_temporary_buffer(execution_policy< DerivedPolicy>  &exec, Pointer p) 
# 53
{ 
# 54
thrust::free(exec, p); 
# 55
} 
# 58
}
# 59
}
# 60
}
# 61
}
# 27 "/usr/local/cuda/include/thrust/detail/temporary_buffer.h"
namespace thrust { 
# 29
namespace detail { 
# 31
namespace get_temporary_buffer_detail { 
# 35
template< class T, class DerivedPolicy, class Pair> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  
# 38
down_cast_pair(Pair p) 
# 39
{ 
# 41
pointer< T, DerivedPolicy, use_default, use_default>  ptr = ((pointer< T, DerivedPolicy, use_default, use_default> )(static_cast< T *>(thrust::raw_pointer_cast((p.first))))); 
# 43
typedef pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  result_type; 
# 44
return result_type(ptr, (p.second)); 
# 45
} 
# 48
}
# 49
}
# 53
template< class T, class DerivedPolicy> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  
# 56
get_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  &exec, typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type n) 
# 57
{ 
# 58
using system::detail::generic::get_temporary_buffer;
# 60
return detail::get_temporary_buffer_detail::down_cast_pair< T, DerivedPolicy> (get_temporary_buffer< T> (detail::derived_cast(detail::strip_const(exec)), n)); 
# 61
} 
# 65
template< class DerivedPolicy, class Pointer> void 
# 67
return_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  &exec, Pointer p) 
# 68
{ 
# 69
using system::detail::generic::return_temporary_buffer;
# 71
return return_temporary_buffer(detail::derived_cast(detail::strip_const(exec)), p); 
# 72
} 
# 75
}
# 31 "/usr/local/cuda/include/thrust/memory.h"
namespace thrust { 
# 303
template< class DerivedPolicy> pointer< void, DerivedPolicy, use_default, use_default>  malloc(const detail::execution_policy_base< DerivedPolicy>  & system, std::size_t n); 
# 341
template< class T, class DerivedPolicy> pointer< T, DerivedPolicy, use_default, use_default>  malloc(const detail::execution_policy_base< DerivedPolicy>  & system, std::size_t n); 
# 394
template< class T, class DerivedPolicy> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  get_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  & system, typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type n); 
# 437
template< class DerivedPolicy, class Pointer> void free(const detail::execution_policy_base< DerivedPolicy>  & system, Pointer ptr); 
# 483
template< class DerivedPolicy, class Pointer> void return_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  & system, Pointer p); 
# 499
template< class Pointer> inline typename detail::pointer_traits< Pointer> ::raw_pointer raw_pointer_cast(const Pointer & ptr); 
# 516
template< class T> inline typename detail::raw_reference< T> ::type raw_reference_cast(T & ref); 
# 533
template< class T> inline typename detail::raw_reference< const T> ::type raw_reference_cast(const T & ref); 
# 542
}
# 26 "/usr/local/cuda/include/thrust/detail/allocator/temporary_allocator.h"
namespace thrust { 
# 28
namespace detail { 
# 35
template< class T, class System> 
# 36
class temporary_allocator : public tagged_allocator< T, System, pointer< T, System, use_default, use_default> >  { 
# 44
typedef ::thrust::detail::tagged_allocator< T, System, ::thrust::pointer< T, System, ::thrust::use_default, ::thrust::use_default> >  super_t; 
# 46
System &m_system; 
# 49
public: typedef typename ::thrust::detail::tagged_allocator< T, System, ::thrust::pointer< T, System, ::thrust::use_default, ::thrust::use_default> > ::pointer pointer; 
# 50
typedef typename ::thrust::detail::tagged_allocator< T, System, ::thrust::pointer< T, System, ::thrust::use_default, ::thrust::use_default> > ::size_type size_type; 
# 53
temporary_allocator(const temporary_allocator &other) : super_t(), m_system(other.m_system) 
# 56
{ } 
# 59
explicit temporary_allocator(execution_policy< System>  &system) : super_t(), m_system(::thrust::detail::derived_cast(system)) 
# 62
{ } 
# 65
pointer allocate(size_type cnt); 
# 68
void deallocate(pointer p, size_type n); 
# 71
System &system() 
# 72
{ 
# 73
return m_system; 
# 74
} 
# 77
private: typedef pair< typename ::thrust::detail::tagged_allocator< T, System, ::thrust::pointer< T, System, ::thrust::use_default, ::thrust::use_default> > ::pointer, typename ::thrust::detail::tagged_allocator< T, System, ::thrust::pointer< T, System, ::thrust::use_default, ::thrust::use_default> > ::size_type>  pointer_and_size; 
# 78
}; 
# 81
}
# 82
}
# 66 "/usr/include/assert.h" 3
extern "C" {
# 69
extern void __assert_fail(const char * __assertion, const char * __file, unsigned __line, const char * __function) throw()
# 71
 __attribute((__noreturn__)); 
# 74
extern void __assert_perror_fail(int __errnum, const char * __file, unsigned __line, const char * __function) throw()
# 76
 __attribute((__noreturn__)); 
# 81
extern void __assert(const char * __assertion, const char * __file, int __line) throw()
# 82
 __attribute((__noreturn__)); 
# 85
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/terminate.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 33
__attribute__((unused)) inline void terminate() 
# 34
{int volatile ___ = 1;
# 36
::exit(___);}
#if 0
# 34
{ 
# 35
thrust::system::cuda::detail::bulk_::detail::terminate(); 
# 36
} 
#endif
# 40 "/usr/local/cuda/include/thrust/system/cuda/detail/terminate.h"
inline void terminate_with_message(const char *message) 
# 41
{ 
# 42
thrust::system::cuda::detail::bulk_::detail::terminate_with_message(message); 
# 43
} 
# 46
}
# 47
}
# 48
}
# 49
}
# 27 "/usr/local/cuda/include/thrust/detail/allocator/temporary_allocator.inl"
namespace thrust { 
# 29
namespace detail { 
# 33
template< class T, class System> typename temporary_allocator< T, System> ::pointer 
# 37
temporary_allocator< T, System> ::allocate(size_type cnt) 
# 38
{ 
# 39
pointer_and_size result = ::thrust::get_temporary_buffer< T> (system(), cnt); 
# 42
if ((result.second) < cnt) 
# 43
{ 
# 46
deallocate((result.first), cnt); 
# 49
throw ((::thrust::system::detail::bad_alloc)("temporary_buffer::allocate: get_temporary_buffer failed")); 
# 53
}  
# 55
return result.first; 
# 56
} 
# 59
template< class T, class System> void 
# 62
temporary_allocator< T, System> ::deallocate(pointer p, size_type n) 
# 63
{ 
# 64
return ::thrust::return_temporary_buffer(system(), p); 
# 65
} 
# 68
}
# 69
}
# 21 "/usr/local/cuda/include/thrust/detail/allocator/no_throw_allocator.h"
namespace thrust { 
# 23
namespace detail { 
# 26
template< class BaseAllocator> 
# 27
struct no_throw_allocator : public BaseAllocator { 
# 30
private: typedef BaseAllocator super_t; 
# 34
public: no_throw_allocator(const BaseAllocator &other = BaseAllocator()) : super_t(other) 
# 36
{ } 
# 38
template< class U> 
# 39
struct rebind { 
# 41
typedef ::thrust::detail::no_throw_allocator< typename BaseAllocator::template rebind< U> ::other>  other; 
# 42
}; 
# 45
void deallocate(typename BaseAllocator::pointer p, typename BaseAllocator::size_type n) 
# 46
{ 
# 48
try 
# 49
{ 
# 50
super_t::deallocate(p, n); 
# 51
} 
# 52
catch (...) 
# 53
{ 
# 55
}  
# 59
} 
# 62
bool operator==(const no_throw_allocator &other) { return BaseAllocator::operator==(other); } 
# 65
bool operator!=(const no_throw_allocator &other) { return BaseAllocator::operator!=(other); } 
# 66
}; 
# 68
}
# 69
}
# 31 "/usr/local/cuda/include/thrust/detail/temporary_array.h"
namespace thrust { 
# 33
namespace detail { 
# 37
template< class T, class System> 
# 38
class temporary_array : public contiguous_storage< T, no_throw_allocator< temporary_allocator< T, System> > >  { 
# 52
typedef ::thrust::detail::contiguous_storage< T, no_throw_allocator< temporary_allocator< T, System> > >  super_t; 
# 55
typedef no_throw_allocator< temporary_allocator< T, System> >  alloc_type; 
# 58
public: typedef typename ::thrust::detail::contiguous_storage< T, no_throw_allocator< temporary_allocator< T, System> > > ::size_type size_type; 
# 61
temporary_array(execution_policy< System>  & system); 
# 64
temporary_array(execution_policy< System>  & system, size_type n); 
# 68
temporary_array(int uninit, execution_policy< System>  & system, size_type n); 
# 70
template< class InputIterator> temporary_array(execution_policy< System>  & system, InputIterator first, size_type n); 
# 76
template< class InputIterator, class InputSystem> temporary_array(execution_policy< System>  & system, execution_policy< InputSystem>  & input_system, InputIterator first, size_type n); 
# 83
template< class InputIterator> temporary_array(execution_policy< System>  & system, InputIterator first, InputIterator last); 
# 89
template< class InputSystem, class InputIterator> temporary_array(execution_policy< System>  & system, execution_policy< InputSystem>  & input_system, InputIterator first, InputIterator last); 
# 97
~temporary_array(); 
# 98
}; 
# 102
template< class Iterator, class System> 
# 103
class tagged_iterator_range { 
# 106
public: typedef tagged_iterator< Iterator, System>  iterator; 
# 108
template< class Ignored1, class Ignored2> 
# 109
tagged_iterator_range(const Ignored1 &, const Ignored2 &, Iterator first, Iterator last) : m_begin(first), m_end(last) 
# 112
{ } 
# 114
iterator begin() const { return m_begin; } 
# 115
iterator end() const { return m_end; } 
# 118
private: iterator m_begin, m_end; 
# 119
}; 
# 125
template< class Iterator, class FromSystem, class ToSystem> 
# 126
struct move_to_system_base : public eval_if< is_convertible< FromSystem, ToSystem> ::value, identity_< tagged_iterator_range< Iterator, ToSystem> > , identity_< temporary_array< typename iterator_value< Iterator> ::type, ToSystem> > >  { 
# 142
}; 
# 145
template< class Iterator, class FromSystem, class ToSystem> 
# 146
class move_to_system : public move_to_system_base< Iterator, FromSystem, ToSystem> ::type { 
# 153
typedef typename move_to_system_base< Iterator, FromSystem, ToSystem> ::type super_t; 
# 156
public: move_to_system(execution_policy< FromSystem>  &from_system, execution_policy< ToSystem>  &
# 157
to_system, Iterator 
# 158
first, Iterator 
# 159
last) : super_t(to_system, from_system, first, last) 
# 160
{ } 
# 161
}; 
# 164
}
# 165
}
# 23 "/usr/local/cuda/include/thrust/detail/temporary_array.inl"
namespace thrust { 
# 26
namespace detail { 
# 28
namespace temporary_array_detail { 
# 32
template< class T> struct avoid_initialization : public has_trivial_copy_constructor< T>  { }; 
# 35
template< class T, class TemporaryArray, class Size> typename enable_if< avoid_initialization< T> ::value> ::type 
# 40
construct_values(TemporaryArray &, Size) 
# 42
{ 
# 44
} 
# 47
template< class T, class TemporaryArray, class Size> typename disable_if< avoid_initialization< T> ::value> ::type 
# 52
construct_values(TemporaryArray &a, Size 
# 53
n) 
# 54
{ 
# 55
(a.default_construct_n((a.begin()), n)); 
# 56
} 
# 59
}
# 62
template< class T, class System> 
# 65
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system) : super_t(((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 67
{ 
# 68
} 
# 71
template< class T, class System> 
# 74
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system, size_type n) : super_t(n, ((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 76
{ 
# 77
::thrust::detail::temporary_array_detail::construct_values< T> (*this, n); 
# 78
} 
# 81
template< class T, class System> 
# 84
temporary_array< T, System> ::temporary_array(int, execution_policy< System>  &system, size_type n) : super_t(n, ((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 86
{ 
# 88
; 
# 89
} 
# 92
template< class T, class System> 
# 93
template< class InputIterator> 
# 96
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system, InputIterator 
# 97
first, size_type 
# 98
n) : super_t(((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 100
{ 
# 101
super_t::allocate(n); 
# 103
super_t::uninitialized_copy_n(system, first, n, super_t::begin()); 
# 104
} 
# 107
template< class T, class System> 
# 108
template< class InputIterator, class InputSystem> 
# 111
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system, execution_policy< InputSystem>  &
# 112
input_system, InputIterator 
# 113
first, size_type 
# 114
n) : super_t(((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 116
{ 
# 117
super_t::allocate(n); 
# 119
super_t::uninitialized_copy_n(input_system, first, n, super_t::begin()); 
# 120
} 
# 123
template< class T, class System> 
# 124
template< class InputIterator> 
# 127
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system, InputIterator 
# 128
first, InputIterator 
# 129
last) : super_t(((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 131
{ 
# 132
super_t::allocate(::thrust::distance(first, last)); 
# 134
super_t::uninitialized_copy(system, first, last, super_t::begin()); 
# 135
} 
# 138
template< class T, class System> 
# 139
template< class InputSystem, class InputIterator> 
# 142
temporary_array< T, System> ::temporary_array(execution_policy< System>  &system, execution_policy< InputSystem>  &
# 143
input_system, InputIterator 
# 144
first, InputIterator 
# 145
last) : super_t(((alloc_type)(((temporary_allocator< T, System> )(system))))) 
# 147
{ 
# 148
super_t::allocate(::thrust::distance(first, last)); 
# 150
super_t::uninitialized_copy(input_system, first, last, super_t::begin()); 
# 151
} 
# 154
template< class T, class System> 
# 157
temporary_array< T, System> ::~temporary_array() 
# 158
{ 
# 160
super_t::destroy(super_t::begin(), super_t::end()); 
# 161
} 
# 163
}
# 165
}
# 20 "/usr/local/cuda/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust { 
# 22
namespace system { 
# 24
namespace cuda { 
# 26
namespace detail { 
# 30
template< class DerivedPolicy, class 
# 31
RandomAccessIterator1, class 
# 32
Size, class 
# 33
RandomAccessIterator2> void 
# 30
trivial_copy_n(execution_policy< DerivedPolicy>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 41
template< class System1, class 
# 42
System2, class 
# 43
RandomAccessIterator1, class 
# 44
Size, class 
# 45
RandomAccessIterator2> void 
# 41
trivial_copy_n(cross_system< System1, System2>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 52
}
# 53
}
# 54
}
# 55
}
# 20 "/usr/local/cuda/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust { 
# 22
namespace system { 
# 24
namespace cuda { 
# 26
namespace detail { 
# 30
template< class DerivedPolicy, class 
# 31
RandomAccessIterator1, class 
# 32
Size, class 
# 33
RandomAccessIterator2> void 
# 30
trivial_copy_n(execution_policy< DerivedPolicy>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 41
template< class System1, class 
# 42
System2, class 
# 43
RandomAccessIterator1, class 
# 44
Size, class 
# 45
RandomAccessIterator2> void 
# 41
trivial_copy_n(cross_system< System1, System2>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 52
}
# 53
}
# 54
}
# 55
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/synchronize.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 33
inline void synchronize(const char * message = ""); 
# 36
inline void synchronize(cudaStream_t stream, const char * message = ""); 
# 40
inline void synchronize_if_enabled(const char * message = ""); 
# 44
}
# 45
}
# 46
}
# 47
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/synchronize.inl"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 33
inline void synchronize(const char *message) 
# 34
{ 
# 35
throw_on_error(cudaDeviceSynchronize(), message); 
# 36
} 
# 40
inline void synchronize(cudaStream_t stream, const char *message) 
# 41
{ 
# 43
throw_on_error(cudaStreamSynchronize(stream), message); 
# 47
} 
# 50
inline void synchronize_if_enabled(const char *message) 
# 51
{ 
# 58
(void)message; 
# 60
} 
# 63
}
# 64
}
# 65
}
# 66
}
# 32 "/usr/local/cuda/include/thrust/system/cuda/detail/trivial_copy.inl"
namespace thrust { 
# 34
namespace system { 
# 36
namespace cuda { 
# 38
namespace detail { 
# 40
namespace trivial_copy_detail { 
# 43
inline void checked_cudaMemcpyAsync(void *dst, const void *src, size_t count, cudaMemcpyKind kind, cudaStream_t stream) 
# 44
{ 
# 45
cudaError_t error = cudaMemcpyAsync(dst, src, count, kind, stream); 
# 46
if (error) 
# 47
{ 
# 48
throw system_error(error, thrust::cuda_category()); 
# 49
}  
# 50
} 
# 53
template< class System1, class 
# 54
System2> cudaMemcpyKind 
# 55
cuda_memcpy_kind(const execution_policy< System1>  &, const cpp::detail::execution_policy< System2>  &) 
# 57
{ 
# 58
return cudaMemcpyDeviceToHost; 
# 59
} 
# 62
template< class System1, class 
# 63
System2> cudaMemcpyKind 
# 64
cuda_memcpy_kind(const cpp::detail::execution_policy< System1>  &, const execution_policy< System2>  &) 
# 66
{ 
# 67
return cudaMemcpyHostToDevice; 
# 68
} 
# 70
template< class System> cudaMemcpyKind 
# 71
cuda_memcpy_kind(const execution_policy< System>  &, const execution_policy< System>  &) 
# 73
{ 
# 81
return cudaMemcpyDefault; 
# 83
} 
# 85
namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { }; using namespace ::thrust::system::cuda::detail::trivial_copy_detail::_GLOBAL__N__20_expected_val_cpp1_ii_71016e90; namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { 
# 92
template< class T> bool 
# 93
is_valid_policy(const T &t) 
# 94
{ 
# 95
volatile size_t value = (reinterpret_cast< size_t>(&t)); 
# 96
if (value) 
# 97
{ 
# 98
if (value == (0)) 
# 99
{ 
# 100
fprintf(stderr, " clang WAR failed. Terminate.\n"); 
# 101
std::terminate(); 
# 102
}  
# 103
return true; 
# 104
}  
# 105
return false; 
# 106
} 
# 107
}
# 109
template< class System1, class 
# 110
System2> cudaStream_t 
# 111
cuda_memcpy_stream(const execution_policy< System1>  &exec, const cpp::detail::execution_policy< System2>  &) 
# 113
{ 
# 114
if (is_valid_policy(exec)) { 
# 115
return stream(derived_cast(exec)); }  
# 116
return legacy_stream(); 
# 117
} 
# 119
template< class System1, class 
# 120
System2> cudaStream_t 
# 121
cuda_memcpy_stream(const cpp::detail::execution_policy< System1>  &, const execution_policy< System2>  &
# 122
exec) 
# 123
{ 
# 124
if (is_valid_policy(exec)) { 
# 125
return stream(derived_cast(exec)); }  
# 126
return legacy_stream(); 
# 127
} 
# 130
template< class System> cudaStream_t 
# 131
cuda_memcpy_stream(const execution_policy< System>  &, const execution_policy< System>  &
# 132
exec) 
# 133
{ 
# 134
if (is_valid_policy(exec)) { 
# 135
return stream(derived_cast(exec)); }  
# 136
return legacy_stream(); 
# 137
} 
# 141
template< class System> cudaStream_t 
# 142
cuda_memcpy_stream(const execute_on_stream &exec, const execution_policy< System>  &) 
# 144
{ 
# 145
if (is_valid_policy(exec)) { 
# 146
return stream(exec); }  
# 147
return legacy_stream(); 
# 148
} 
# 154
}
# 157
template< class DerivedPolicy, class 
# 158
RandomAccessIterator1, class 
# 159
Size, class 
# 160
RandomAccessIterator2> void 
# 162
trivial_copy_n(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator1 
# 163
first, Size 
# 164
n, RandomAccessIterator2 
# 165
result) 
# 166
{ 
# 167
typedef typename iterator_value< RandomAccessIterator1> ::type T; 
# 170
void *dst = thrust::raw_pointer_cast(&(*result)); 
# 171
const void *src = thrust::raw_pointer_cast(&(*first)); 
# 178
cudaMemcpyKind kind = trivial_copy_detail::cuda_memcpy_kind(thrust::detail::derived_cast(exec), thrust::detail::derived_cast(exec)); 
# 179
trivial_copy_detail::checked_cudaMemcpyAsync(dst, src, n * sizeof(T), kind, stream(thrust::detail::derived_cast(exec))); 
# 183
} 
# 186
template< class System1, class 
# 187
System2, class 
# 188
RandomAccessIterator1, class 
# 189
Size, class 
# 190
RandomAccessIterator2> void 
# 191
trivial_copy_n(cross_system< System1, System2>  &systems, RandomAccessIterator1 
# 192
first, Size 
# 193
n, RandomAccessIterator2 
# 194
result) 
# 195
{ 
# 196
typedef typename iterator_value< RandomAccessIterator1> ::type T; 
# 198
void *dst = thrust::raw_pointer_cast(&(*result)); 
# 199
const void *src = thrust::raw_pointer_cast(&(*first)); 
# 201
cudaMemcpyKind kind = trivial_copy_detail::cuda_memcpy_kind(thrust::detail::derived_cast((systems.system1)), thrust::detail::derived_cast((systems.system2))); 
# 205
cudaStream_t s = trivial_copy_detail::cuda_memcpy_stream(derived_cast((systems.system1)), derived_cast((systems.system2))); 
# 206
trivial_copy_detail::checked_cudaMemcpyAsync(dst, src, n * sizeof(T), kind, s); 
# 207
synchronize(s, "failed synchronize in thrust::system::cuda::detail::trivial_copy_n"); 
# 208
} 
# 211
}
# 212
}
# 213
}
# 214
}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/copy_cross_system.inl"
namespace thrust { 
# 27
namespace detail { 
# 31
template< class , class > class temporary_array; 
# 33
}
# 35
namespace system { 
# 37
namespace cuda { 
# 39
namespace detail { 
# 44
template< class System1, class 
# 45
System2, class 
# 46
InputIterator, class 
# 47
RandomAccessIterator> RandomAccessIterator 
# 48
copy_cross_system(cross_system< System1, System2>  systems, InputIterator 
# 49
begin, InputIterator 
# 50
end, RandomAccessIterator 
# 51
result, incrementable_traversal_tag, random_access_traversal_tag) 
# 54
{ 
# 59
typedef typename iterator_value< InputIterator> ::type InputType; 
# 62
thrust::detail::temporary_array< typename iterator_value< InputIterator> ::type, System1>  temp((systems.system1), begin, end); 
# 63
return thrust::copy(systems, (temp.begin()), (temp.end()), result); 
# 64
} 
# 66
template< class System1, class 
# 67
System2, class 
# 68
InputIterator, class 
# 69
Size, class 
# 70
RandomAccessIterator> RandomAccessIterator 
# 71
copy_cross_system_n(cross_system< System1, System2>  systems, InputIterator 
# 72
first, Size 
# 73
n, RandomAccessIterator 
# 74
result, incrementable_traversal_tag, random_access_traversal_tag) 
# 77
{ 
# 78
typedef typename iterator_value< InputIterator> ::type InputType; 
# 81
thrust::detail::temporary_array< typename iterator_value< InputIterator> ::type, System1>  temp((systems.system1), first, n); 
# 84
return copy_cross_system(systems, (temp.begin()), (temp.end()), result); 
# 85
} 
# 89
template< class System1, class 
# 90
System2, class 
# 91
RandomAccessIterator, class 
# 92
OutputIterator> OutputIterator 
# 93
copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator 
# 94
begin, RandomAccessIterator 
# 95
end, OutputIterator 
# 96
result, random_access_traversal_tag, incrementable_traversal_tag) 
# 99
{ 
# 100
typedef typename iterator_value< RandomAccessIterator> ::type InputType; 
# 103
thrust::detail::temporary_array< typename iterator_value< RandomAccessIterator> ::type, System2>  temp((systems.system2), (systems.system1), begin, end); 
# 105
return thrust::copy((systems.system2), (temp.begin()), (temp.end()), result); 
# 106
} 
# 108
template< class System1, class 
# 109
System2, class 
# 110
RandomAccessIterator, class 
# 111
Size, class 
# 112
OutputIterator> OutputIterator 
# 113
copy_cross_system_n(cross_system< System1, System2>  systems, RandomAccessIterator 
# 114
first, Size 
# 115
n, OutputIterator 
# 116
result, random_access_traversal_tag, incrementable_traversal_tag) 
# 119
{ 
# 120
typedef typename iterator_value< RandomAccessIterator> ::type InputType; 
# 123
thrust::detail::temporary_array< typename iterator_value< RandomAccessIterator> ::type, System2>  temp((systems.system2), (systems.system1), first, n); 
# 126
return thrust::copy((systems.system2), (temp.begin()), (temp.end()), result); 
# 127
} 
# 131
template< class System1, class 
# 132
System2, class 
# 133
RandomAccessIterator1, class 
# 134
RandomAccessIterator2> RandomAccessIterator2 
# 135
copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 136
begin, RandomAccessIterator1 
# 137
end, RandomAccessIterator2 
# 138
result, random_access_traversal_tag, random_access_traversal_tag, thrust::detail::true_type) 
# 142
{ 
# 149
typename iterator_traits< RandomAccessIterator1> ::difference_type n = end - begin; 
# 151
cuda::detail::trivial_copy_n(systems, begin, n, result); 
# 153
return result + n; 
# 154
} 
# 157
namespace detail { 
# 161
template< class System1, class 
# 162
System2, class 
# 163
RandomAccessIterator1, class 
# 164
RandomAccessIterator2> RandomAccessIterator2 
# 165
non_trivial_random_access_copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 166
begin, RandomAccessIterator1 
# 167
end, RandomAccessIterator2 
# 168
result, thrust::detail::false_type) 
# 170
{ 
# 172
typedef typename iterator_value< RandomAccessIterator2> ::type OutputType; 
# 175
thrust::detail::temporary_array< typename iterator_value< RandomAccessIterator2> ::type, System1>  temp((systems.system1), begin, end); 
# 178
return copy_cross_system(systems, (temp.begin()), (temp.end()), result); 
# 179
} 
# 181
template< class System1, class 
# 182
System2, class 
# 183
RandomAccessIterator1, class 
# 184
RandomAccessIterator2> RandomAccessIterator2 
# 185
non_trivial_random_access_copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 186
begin, RandomAccessIterator1 
# 187
end, RandomAccessIterator2 
# 188
result, thrust::detail::true_type) 
# 190
{ 
# 191
typename iterator_difference< RandomAccessIterator1> ::type n = thrust::distance(begin, end); 
# 196
typedef typename iterator_value< RandomAccessIterator1> ::type InputType; 
# 197
thrust::detail::temporary_array< typename iterator_value< RandomAccessIterator1> ::type, System2>  temp(0, (systems.system2), n); 
# 204
cuda::detail::trivial_copy_n(systems, begin, n, (temp.begin())); 
# 207
return thrust::copy((systems.system2), (temp.begin()), (temp.end()), result); 
# 208
} 
# 210
}
# 214
template< class System1, class 
# 215
System2, class 
# 216
RandomAccessIterator1, class 
# 217
RandomAccessIterator2> RandomAccessIterator2 
# 218
copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 219
begin, RandomAccessIterator1 
# 220
end, RandomAccessIterator2 
# 221
result, random_access_traversal_tag, random_access_traversal_tag, thrust::detail::false_type) 
# 225
{ 
# 227
return detail::non_trivial_random_access_copy_cross_system(systems, begin, end, result, typename thrust::detail::is_trivial_iterator< RandomAccessIterator1> ::type()); 
# 229
} 
# 232
template< class System1, class 
# 233
System2, class 
# 234
RandomAccessIterator1, class 
# 235
RandomAccessIterator2> RandomAccessIterator2 
# 236
copy_cross_system(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 237
begin, RandomAccessIterator1 
# 238
end, RandomAccessIterator2 
# 239
result, random_access_traversal_tag 
# 240
input_traversal, random_access_traversal_tag 
# 241
output_traversal) 
# 242
{ 
# 244
return copy_cross_system(systems, begin, end, result, input_traversal, output_traversal, typename thrust::detail::dispatch::is_trivial_copy< RandomAccessIterator1, RandomAccessIterator2> ::type()); 
# 246
} 
# 248
template< class System1, class 
# 249
System2, class 
# 250
RandomAccessIterator1, class 
# 251
Size, class 
# 252
RandomAccessIterator2> RandomAccessIterator2 
# 253
copy_cross_system_n(cross_system< System1, System2>  systems, RandomAccessIterator1 
# 254
first, Size 
# 255
n, RandomAccessIterator2 
# 256
result, random_access_traversal_tag 
# 257
input_traversal, random_access_traversal_tag 
# 258
output_traversal) 
# 259
{ 
# 261
return copy_cross_system(systems, first, first + n, result, input_traversal, output_traversal); 
# 262
} 
# 268
template< class System1, class 
# 269
System2, class 
# 270
InputIterator, class 
# 271
OutputIterator> OutputIterator 
# 272
copy_cross_system(cross_system< System1, System2>  systems, InputIterator 
# 273
begin, InputIterator 
# 274
end, OutputIterator 
# 275
result) 
# 276
{ 
# 277
return copy_cross_system(systems, begin, end, result, typename iterator_traversal< InputIterator> ::type(), typename iterator_traversal< OutputIterator> ::type()); 
# 280
} 
# 282
template< class System1, class 
# 283
System2, class 
# 284
InputIterator, class 
# 285
Size, class 
# 286
OutputIterator> OutputIterator 
# 287
copy_cross_system_n(cross_system< System1, System2>  systems, InputIterator 
# 288
begin, Size 
# 289
n, OutputIterator 
# 290
result) 
# 291
{ 
# 292
return copy_cross_system_n(systems, begin, n, result, typename iterator_traversal< InputIterator> ::type(), typename iterator_traversal< OutputIterator> ::type()); 
# 295
} 
# 297
}
# 298
}
# 299
}
# 300
}
# 20 "/usr/local/cuda/include/thrust/system/cuda/detail/trivial_copy.h"
namespace thrust { 
# 22
namespace system { 
# 24
namespace cuda { 
# 26
namespace detail { 
# 30
template< class DerivedPolicy, class 
# 31
RandomAccessIterator1, class 
# 32
Size, class 
# 33
RandomAccessIterator2> void 
# 30
trivial_copy_n(execution_policy< DerivedPolicy>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 41
template< class System1, class 
# 42
System2, class 
# 43
RandomAccessIterator1, class 
# 44
Size, class 
# 45
RandomAccessIterator2> void 
# 41
trivial_copy_n(cross_system< System1, System2>  & exec, RandomAccessIterator1 first, Size n, RandomAccessIterator2 result); 
# 52
}
# 53
}
# 54
}
# 55
}
# 28 "/usr/local/cuda/include/thrust/system/cuda/detail/copy_device_to_device.inl"
namespace thrust { 
# 30
namespace system { 
# 32
namespace cuda { 
# 34
namespace detail { 
# 36
namespace detail { 
# 40
template< class DerivedPolicy, class 
# 41
InputIterator, class 
# 42
OutputIterator> OutputIterator 
# 44
copy_device_to_device(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 45
begin, InputIterator 
# 46
end, OutputIterator 
# 47
result, thrust::detail::false_type) 
# 49
{ 
# 51
typedef typename iterator_traits< InputIterator> ::value_type InputType; 
# 54
return thrust::transform(exec, begin, end, result, identity< typename iterator_traits< InputIterator> ::value_type> ()); 
# 72
} 
# 75
template< class DerivedPolicy, class 
# 76
InputIterator, class 
# 77
OutputIterator> OutputIterator 
# 79
copy_device_to_device(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 80
begin, InputIterator 
# 81
end, OutputIterator 
# 82
result, thrust::detail::true_type) 
# 84
{ 
# 89
typename iterator_traits< OutputIterator> ::difference_type n = end - begin; 
# 91
cuda::detail::trivial_copy_n(exec, begin, n, result); 
# 93
return result + n; 
# 94
} 
# 97
}
# 105
template< class DerivedPolicy, class 
# 106
InputIterator, class 
# 107
OutputIterator> OutputIterator 
# 109
copy_device_to_device(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 110
begin, InputIterator 
# 111
end, OutputIterator 
# 112
result) 
# 113
{ 
# 114
typedef typename iterator_traits< InputIterator> ::value_type InputType; 
# 115
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 117
const bool use_trivial_copy = (thrust::detail::is_same< typename iterator_traits< InputIterator> ::value_type, typename iterator_traits< OutputIterator> ::value_type> ::value && thrust::detail::is_trivial_iterator< InputIterator> ::value && thrust::detail::is_trivial_iterator< OutputIterator> ::value); 
# 123
(void)use_trivial_copy; 
# 125
return detail::copy_device_to_device(exec, begin, end, result, thrust::detail::integral_constant< bool, use_trivial_copy> ()); 
# 127
} 
# 130
}
# 131
}
# 132
}
# 133
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/copy.inl"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 32
template< class System, class 
# 33
InputIterator, class 
# 34
OutputIterator> OutputIterator 
# 36
copy(execution_policy< System>  &system, InputIterator 
# 37
first, InputIterator 
# 38
last, OutputIterator 
# 39
result) 
# 40
{ 
# 41
return cuda::detail::copy_device_to_device(system, first, last, result); 
# 42
} 
# 45
template< class System1, class 
# 46
System2, class 
# 47
InputIterator, class 
# 48
OutputIterator> OutputIterator 
# 49
copy(cross_system< System1, System2>  systems, InputIterator 
# 50
first, InputIterator 
# 51
last, OutputIterator 
# 52
result) 
# 53
{ 
# 54
return cuda::detail::copy_cross_system(systems, first, last, result); 
# 55
} 
# 58
template< class System, class 
# 59
InputIterator, class 
# 60
Size, class 
# 61
OutputIterator> OutputIterator 
# 63
copy_n(execution_policy< System>  &system, InputIterator 
# 64
first, Size 
# 65
n, OutputIterator 
# 66
result) 
# 67
{ 
# 68
return cuda::detail::copy_device_to_device(system, first, first + n, result); 
# 69
} 
# 72
template< class System1, class 
# 73
System2, class 
# 74
InputIterator, class 
# 75
Size, class 
# 76
OutputIterator> OutputIterator 
# 77
copy_n(cross_system< System1, System2>  systems, InputIterator 
# 78
first, Size 
# 79
n, OutputIterator 
# 80
result) 
# 81
{ 
# 82
return cuda::detail::copy_cross_system_n(systems, first, n, result); 
# 83
} 
# 86
}
# 87
}
# 88
}
# 89
}
# 24 "/usr/local/cuda/include/thrust/detail/copy.inl"
namespace thrust { 
# 29
template< class DerivedPolicy, class InputIterator, class OutputIterator> OutputIterator 
# 31
copy(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 32
first, InputIterator 
# 33
last, OutputIterator 
# 34
result) 
# 35
{ 
# 36
using system::detail::generic::copy;
# 37
return copy(detail::derived_cast(detail::strip_const(exec)), first, last, result); 
# 38
} 
# 42
template< class DerivedPolicy, class InputIterator, class Size, class OutputIterator> OutputIterator 
# 44
copy_n(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 45
first, Size 
# 46
n, OutputIterator 
# 47
result) 
# 48
{ 
# 49
using system::detail::generic::copy_n;
# 50
return copy_n(detail::derived_cast(detail::strip_const(exec)), first, n, result); 
# 51
} 
# 54
namespace detail { 
# 59
template< class System1, class 
# 60
System2, class 
# 61
InputIterator, class 
# 62
OutputIterator> OutputIterator 
# 64
two_system_copy(const execution_policy< System1>  &system1, const execution_policy< System2>  &
# 65
system2, InputIterator 
# 66
first, InputIterator 
# 67
last, OutputIterator 
# 68
result) 
# 69
{ 
# 70
using system::detail::generic::select_system;
# 72
return thrust::copy(select_system(detail::derived_cast(detail::strip_const(system1)), detail::derived_cast(detail::strip_const(system2))), first, last, result); 
# 73
} 
# 77
template< class System1, class 
# 78
System2, class 
# 79
InputIterator, class 
# 80
Size, class 
# 81
OutputIterator> OutputIterator 
# 83
two_system_copy_n(const execution_policy< System1>  &system1, const execution_policy< System2>  &
# 84
system2, InputIterator 
# 85
first, Size 
# 86
n, OutputIterator 
# 87
result) 
# 88
{ 
# 89
using system::detail::generic::select_system;
# 91
return thrust::copy_n(select_system(detail::derived_cast(detail::strip_const(system1)), detail::derived_cast(detail::strip_const(system2))), first, n, result); 
# 92
} 
# 95
}
# 98
template< class InputIterator, class 
# 99
OutputIterator> OutputIterator 
# 100
copy(InputIterator first, InputIterator 
# 101
last, OutputIterator 
# 102
result) 
# 103
{ 
# 104
typedef typename iterator_system< InputIterator> ::type System1; 
# 105
typedef typename iterator_system< OutputIterator> ::type System2; 
# 107
System1 system1; 
# 108
System2 system2; 
# 110
return detail::two_system_copy(system1, system2, first, last, result); 
# 111
} 
# 114
template< class InputIterator, class 
# 115
Size, class 
# 116
OutputIterator> OutputIterator 
# 117
copy_n(InputIterator first, Size 
# 118
n, OutputIterator 
# 119
result) 
# 120
{ 
# 121
typedef typename iterator_system< InputIterator> ::type System1; 
# 122
typedef typename iterator_system< OutputIterator> ::type System2; 
# 124
System1 system1; 
# 125
System2 system2; 
# 127
return detail::two_system_copy_n(system1, system2, first, n, result); 
# 128
} 
# 131
}
# 24 "/usr/local/cuda/include/thrust/system/cuda/detail/assign_value.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace cuda { 
# 30
namespace detail { 
# 77
template< class DerivedPolicy, class Pointer1, class Pointer2> inline void 
# 79
assign_value(execution_policy< DerivedPolicy>  &exec, Pointer1 dst, Pointer2 src) 
# 80
{ 
# 82
struct war_nvbugs_881631 { 
# 84
static void host_path(execution_policy< DerivedPolicy>  &exec, Pointer1 dst, Pointer2 src) 
# 85
{ 
# 86
thrust::copy(exec, src, src + 1, dst); 
# 87
} 
# 89
static void device_path(execution_policy< DerivedPolicy>  &, Pointer1 dst, Pointer2 src) 
# 90
{int volatile ___ = 1;(void)dst;(void)src;
# 92
::exit(___);}
#if 0
# 90
{ 
# 91
(*thrust::raw_pointer_cast(dst)) = (*thrust::raw_pointer_cast(src)); 
# 92
} 
#endif
# 93 "/usr/local/cuda/include/thrust/system/cuda/detail/assign_value.h"
}; 
# 96
(war_nvbugs_881631::host_path)(exec, dst, src); 
# 100
} 
# 159
template< class System1, class System2, class Pointer1, class Pointer2> inline void 
# 161
assign_value(cross_system< System1, System2>  &systems, Pointer1 dst, Pointer2 src) 
# 162
{ 
# 164
struct war_nvbugs_881631 { 
# 166
static void host_path(cross_system< System1, System2>  &systems, Pointer1 dst, Pointer2 src) 
# 167
{ 
# 170
cross_system< System2, System1>  rotated_systems = (systems.rotate()); 
# 171
thrust::copy(rotated_systems, src, src + 1, dst); 
# 172
} 
# 174
static void device_path(cross_system< System1, System2>  &systems, Pointer1 dst, Pointer2 src) 
# 175
{int volatile ___ = 1;(void)systems;(void)dst;(void)src;
# 180
::exit(___);}
#if 0
# 175
{ 
# 178
tag cuda_tag; 
# 179
cuda::detail::assign_value(cuda_tag, dst, src); 
# 180
} 
#endif
# 181 "/usr/local/cuda/include/thrust/system/cuda/detail/assign_value.h"
}; 
# 186
(war_nvbugs_881631::host_path)(systems, dst, src); 
# 188
} 
# 194
}
# 195
}
# 196
}
# 197
}
# 25 "/usr/local/cuda/include/thrust/system/cuda/detail/get_value.h"
namespace thrust { 
# 27
namespace system { 
# 29
namespace cuda { 
# 31
namespace detail { 
# 36
namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { }; using namespace ::thrust::system::cuda::detail::_GLOBAL__N__20_expected_val_cpp1_ii_71016e90; namespace _GLOBAL__N__20_expected_val_cpp1_ii_71016e90 { 
# 39
template< class DerivedPolicy, class Pointer> inline typename iterator_value< Pointer> ::type 
# 42
get_value_msvc2005_war(execution_policy< DerivedPolicy>  &exec, Pointer ptr) 
# 43
{ 
# 44
typedef typename iterator_value< Pointer> ::type result_type; 
# 47
struct war_nvbugs_881631 { 
# 49
static result_type host_path(execution_policy< DerivedPolicy>  &exec, Pointer ptr) 
# 50
{ 
# 53
result_type result; 
# 55
host_system_tag host_tag; 
# 56
cross_system< cpp::detail::tag, DerivedPolicy>  systems(host_tag, exec); 
# 57
assign_value(systems, &result, ptr); 
# 59
return result; 
# 60
} 
# 62
static result_type device_path(execution_policy< DerivedPolicy>  &, Pointer ptr) 
# 63
{int volatile ___ = 1;(void)ptr;
# 66
::exit(___);}
#if 0
# 63
{ 
# 65
return *thrust::raw_pointer_cast(ptr); 
# 66
} 
#endif
# 67 "/usr/local/cuda/include/thrust/system/cuda/detail/get_value.h"
}; 
# 70
return (war_nvbugs_881631::host_path)(exec, ptr); 
# 74
} 
# 77
}
# 80
template< class DerivedPolicy, class Pointer> inline typename iterator_value< Pointer> ::type 
# 83
get_value(execution_policy< DerivedPolicy>  &exec, Pointer ptr) 
# 84
{ 
# 85
return get_value_msvc2005_war(exec, ptr); 
# 86
} 
# 89
}
# 90
}
# 91
}
# 92
}
# 23 "/usr/local/cuda/include/thrust/system/detail/sequential/assign_value.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace sequential { 
# 32
template< class DerivedPolicy, class Pointer1, class Pointer2> void 
# 34
assign_value(execution_policy< DerivedPolicy>  &, Pointer1 dst, Pointer2 src) 
# 35
{ 
# 36
(*thrust::raw_pointer_cast(dst)) = (*thrust::raw_pointer_cast(src)); 
# 37
} 
# 39
}
# 40
}
# 41
}
# 42
}
# 24 "/usr/local/cuda/include/thrust/system/detail/sequential/iter_swap.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace sequential { 
# 34
template< class Pointer1, class Pointer2> void 
# 36
iter_swap(tag, Pointer1 a, Pointer2 b) 
# 37
{ 
# 38
using thrust::swap;
# 39
swap(*thrust::raw_pointer_cast(a), *thrust::raw_pointer_cast(b)); 
# 40
} 
# 43
}
# 44
}
# 45
}
# 46
}
# 30 "/usr/local/cuda/include/thrust/swap.h"
namespace thrust { 
# 65
template< class Assignable1, class Assignable2> inline void swap(Assignable1 & a, Assignable2 & b); 
# 127
template< class DerivedPolicy, class 
# 128
ForwardIterator1, class 
# 129
ForwardIterator2> ForwardIterator2 
# 127
swap_ranges(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2); 
# 177
template< class ForwardIterator1, class 
# 178
ForwardIterator2> ForwardIterator2 
# 177
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2); 
# 188
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/swap_ranges.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 32
template< class DerivedPolicy, class 
# 33
ForwardIterator1, class 
# 34
ForwardIterator2> ForwardIterator2 
# 32
swap_ranges(execution_policy< DerivedPolicy>  & exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2); 
# 41
}
# 42
}
# 43
}
# 44
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/swap_ranges.inl"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 32
namespace detail { 
# 38
struct swap_pair_elements { 
# 40
template< class Tuple> void 
# 42
operator()(Tuple t) 
# 43
{ 
# 45
using thrust::swap;
# 46
swap(thrust::get< 0> (t), thrust::get< 1> (t)); 
# 47
} 
# 48
}; 
# 51
}
# 54
template< class DerivedPolicy, class 
# 55
ForwardIterator1, class 
# 56
ForwardIterator2> ForwardIterator2 
# 58
swap_ranges(execution_policy< DerivedPolicy>  &exec, ForwardIterator1 
# 59
first1, ForwardIterator1 
# 60
last1, ForwardIterator2 
# 61
first2) 
# 62
{ 
# 63
typedef tuple< ForwardIterator1, ForwardIterator2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 64
typedef zip_iterator< tuple< ForwardIterator1, ForwardIterator2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 66
ZipIterator result = thrust::for_each(exec, thrust::make_zip_iterator(thrust::make_tuple(first1, first2)), thrust::make_zip_iterator(thrust::make_tuple(last1, first2)), detail::swap_pair_elements()); 
# 70
return thrust::get< 1> ((result.get_iterator_tuple())); 
# 71
} 
# 74
}
# 75
}
# 76
}
# 77
}
# 28 "/usr/local/cuda/include/thrust/detail/swap_ranges.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class 
# 34
ForwardIterator1, class 
# 35
ForwardIterator2> ForwardIterator2 
# 37
swap_ranges(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator1 
# 38
first1, ForwardIterator1 
# 39
last1, ForwardIterator2 
# 40
first2) 
# 41
{ 
# 42
using system::detail::generic::swap_ranges;
# 43
return swap_ranges(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2); 
# 44
} 
# 47
template< class ForwardIterator1, class 
# 48
ForwardIterator2> ForwardIterator2 
# 49
swap_ranges(ForwardIterator1 first1, ForwardIterator1 
# 50
last1, ForwardIterator2 
# 51
first2) 
# 52
{ 
# 53
using system::detail::generic::select_system;
# 55
typedef typename iterator_system< ForwardIterator1> ::type System1; 
# 56
typedef typename iterator_system< ForwardIterator2> ::type System2; 
# 58
System1 system1; 
# 59
System2 system2; 
# 61
return thrust::swap_ranges(select_system(system1, system2), first1, last1, first2); 
# 62
} 
# 65
}
# 23 "/usr/local/cuda/include/thrust/system/cuda/detail/iter_swap.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace cuda { 
# 29
namespace detail { 
# 33
template< class Pointer1, class Pointer2> inline void 
# 35
iter_swap(tag, Pointer1 a, Pointer2 b) 
# 36
{ 
# 38
struct war_nvbugs_881631 { 
# 40
static void host_path(Pointer1 a, Pointer2 b) 
# 41
{ 
# 42
thrust::swap_ranges(a, a + 1, b); 
# 43
} 
# 45
static void device_path(Pointer1 a, Pointer2 b) 
# 46
{int volatile ___ = 1;(void)a;(void)b;
# 50
::exit(___);}
#if 0
# 46
{ 
# 47
using thrust::swap;
# 48
swap(*thrust::raw_pointer_cast(a), *thrust::raw_pointer_cast(b)); 
# 50
} 
#endif
# 51 "/usr/local/cuda/include/thrust/system/cuda/detail/iter_swap.h"
}; 
# 54
return (war_nvbugs_881631::host_path)(a, b); 
# 58
} 
# 61
}
# 62
}
# 63
}
# 64
}
# 28 "/usr/local/cuda/include/thrust/detail/reference.inl"
namespace thrust { 
# 32
template< class Element, class Pointer, class Derived> 
# 33
template< class OtherElement, class OtherPointer, class OtherDerived> 
# 35
reference< Element, Pointer, Derived> ::reference(const thrust::reference< OtherElement, OtherPointer, OtherDerived>  &other, typename detail::enable_if_convertible< typename thrust::reference< OtherElement, OtherPointer, OtherDerived> ::pointer, Pointer> ::type *) : m_ptr((other.m_ptr)) 
# 41
{ } 
# 44
template< class Element, class Pointer, class Derived> 
# 46
reference< Element, Pointer, Derived> ::reference(const pointer &ptr) : m_ptr(ptr) 
# 48
{ } 
# 51
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::pointer 
# 54
reference< Element, Pointer, Derived> ::operator&() const 
# 55
{ 
# 56
return m_ptr; 
# 57
} 
# 60
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 63
reference< Element, Pointer, Derived> ::operator=(const value_type &v) 
# 64
{ 
# 65
assign_from(&v); 
# 66
return static_cast< derived_type &>(*this); 
# 67
} 
# 70
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 73
reference< Element, Pointer, Derived> ::operator=(const reference &other) 
# 74
{ 
# 75
assign_from(&other); 
# 76
return static_cast< derived_type &>(*this); 
# 77
} 
# 80
template< class Element, class Pointer, class Derived> 
# 81
template< class OtherElement, class OtherPointer, class OtherDerived> typename reference< Element, Pointer, Derived> ::derived_type &
# 84
reference< Element, Pointer, Derived> ::operator=(const thrust::reference< OtherElement, OtherPointer, OtherDerived>  &other) 
# 85
{ 
# 86
assign_from(&other); 
# 87
return static_cast< derived_type &>(*this); 
# 88
} 
# 91
template< class Element, class Pointer, class Derived> 
# 92
template< class System> inline typename reference< Element, Pointer, Derived> ::value_type 
# 95
reference< Element, Pointer, Derived> ::convert_to_value_type(System *system) const 
# 96
{ 
# 97
using thrust::system::detail::generic::select_system;
# 98
return strip_const_get_value(select_system(*system)); 
# 99
} 
# 102
template< class Element, class Pointer, class Derived> 
# 104
reference< Element, Pointer, Derived> ::operator typename reference< Element, Pointer, Derived> ::value_type() const 
# 105
{ 
# 106
typedef typename iterator_system< Pointer> ::type System; 
# 112
System *system = (0); 
# 114
return convert_to_value_type(system); 
# 115
} 
# 118
template< class Element, class Pointer, class Derived> 
# 119
template< class System> inline typename reference< Element, Pointer, Derived> ::value_type 
# 122
reference< Element, Pointer, Derived> ::strip_const_get_value(const System &system) const 
# 123
{ 
# 124
System &non_const_system = const_cast< System &>(system); 
# 126
using thrust::system::detail::generic::get_value;
# 128
return get_value(detail::derived_cast(non_const_system), m_ptr); 
# 129
} 
# 132
template< class Element, class Pointer, class Derived> 
# 133
template< class System1, class System2, class OtherPointer> inline void 
# 135
reference< Element, Pointer, Derived> ::assign_from(System1 *system1, System2 *system2, OtherPointer src) 
# 136
{ 
# 137
using system::detail::generic::select_system;
# 139
strip_const_assign_value(select_system(*system1, *system2), src); 
# 140
} 
# 143
template< class Element, class Pointer, class Derived> 
# 144
template< class OtherPointer> inline void 
# 146
reference< Element, Pointer, Derived> ::assign_from(OtherPointer src) 
# 147
{ 
# 148
typedef typename iterator_system< Pointer> ::type System1; 
# 149
typedef typename iterator_system< OtherPointer> ::type System2; 
# 155
System1 *system1 = (0); 
# 156
System2 *system2 = (0); 
# 158
assign_from(system1, system2, src); 
# 159
} 
# 162
template< class Element, class Pointer, class Derived> 
# 163
template< class System, class OtherPointer> inline void 
# 165
reference< Element, Pointer, Derived> ::strip_const_assign_value(const System &system, OtherPointer src) 
# 166
{ 
# 167
System &non_const_system = const_cast< System &>(system); 
# 169
using thrust::system::detail::generic::assign_value;
# 171
assign_value(detail::derived_cast(non_const_system), m_ptr, src); 
# 172
} 
# 175
template< class Element, class Pointer, class Derived> 
# 176
template< class System> inline void 
# 178
reference< Element, Pointer, Derived> ::swap(System *system, derived_type &other) 
# 179
{ 
# 180
using thrust::system::detail::generic::select_system;
# 181
using thrust::system::detail::generic::iter_swap;
# 183
iter_swap(select_system(*system, *system), m_ptr, (other.m_ptr)); 
# 184
} 
# 187
template< class Element, class Pointer, class Derived> void 
# 189
reference< Element, Pointer, Derived> ::swap(derived_type &other) 
# 190
{ 
# 191
typedef typename iterator_system< Pointer> ::type System; 
# 197
System *system = (0); 
# 199
swap(system, other); 
# 200
} 
# 203
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 206
reference< Element, Pointer, Derived> ::operator++() 
# 207
{ 
# 208
value_type temp = *this; 
# 209
++temp; 
# 210
(*this) = temp; 
# 211
return static_cast< derived_type &>(*this); 
# 212
} 
# 215
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::value_type 
# 218
reference< Element, Pointer, Derived> ::operator++(int) 
# 219
{ 
# 220
value_type temp = *this; 
# 221
value_type result = temp++; 
# 222
(*this) = temp; 
# 223
return result; 
# 224
} 
# 227
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 230
reference< Element, Pointer, Derived> ::operator+=(const value_type &rhs) 
# 231
{ 
# 232
value_type temp = *this; 
# 233
temp += rhs; 
# 234
(*this) = temp; 
# 235
return static_cast< derived_type &>(*this); 
# 236
} 
# 238
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 241
reference< Element, Pointer, Derived> ::operator--() 
# 242
{ 
# 243
value_type temp = *this; 
# 244
--temp; 
# 245
(*this) = temp; 
# 246
return static_cast< derived_type &>(*this); 
# 247
} 
# 249
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::value_type 
# 252
reference< Element, Pointer, Derived> ::operator--(int) 
# 253
{ 
# 254
value_type temp = *this; 
# 255
value_type result = temp--; 
# 256
(*this) = temp; 
# 257
return result; 
# 258
} 
# 260
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 263
reference< Element, Pointer, Derived> ::operator-=(const value_type &rhs) 
# 264
{ 
# 265
value_type temp = *this; 
# 266
temp -= rhs; 
# 267
(*this) = temp; 
# 268
return static_cast< derived_type &>(*this); 
# 269
} 
# 271
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 274
reference< Element, Pointer, Derived> ::operator*=(const value_type &rhs) 
# 275
{ 
# 276
value_type temp = *this; 
# 277
temp *= rhs; 
# 278
(*this) = temp; 
# 279
return static_cast< derived_type &>(*this); 
# 280
} 
# 282
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 285
reference< Element, Pointer, Derived> ::operator/=(const value_type &rhs) 
# 286
{ 
# 287
value_type temp = *this; 
# 288
temp /= rhs; 
# 289
(*this) = temp; 
# 290
return static_cast< derived_type &>(*this); 
# 291
} 
# 293
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 296
reference< Element, Pointer, Derived> ::operator%=(const value_type &rhs) 
# 297
{ 
# 298
value_type temp = *this; 
# 299
temp %= rhs; 
# 300
(*this) = temp; 
# 301
return static_cast< derived_type &>(*this); 
# 302
} 
# 304
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 307
reference< Element, Pointer, Derived> ::operator<<=(const value_type &rhs) 
# 308
{ 
# 309
value_type temp = *this; 
# 310
temp <<= rhs; 
# 311
(*this) = temp; 
# 312
return static_cast< derived_type &>(*this); 
# 313
} 
# 315
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 318
reference< Element, Pointer, Derived> ::operator>>=(const value_type &rhs) 
# 319
{ 
# 320
value_type temp = *this; 
# 321
temp >>= rhs; 
# 322
(*this) = temp; 
# 323
return static_cast< derived_type &>(*this); 
# 324
} 
# 326
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 329
reference< Element, Pointer, Derived> ::operator&=(const value_type &rhs) 
# 330
{ 
# 331
value_type temp = *this; 
# 332
temp &= rhs; 
# 333
(*this) = temp; 
# 334
return static_cast< derived_type &>(*this); 
# 335
} 
# 337
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 340
reference< Element, Pointer, Derived> ::operator|=(const value_type &rhs) 
# 341
{ 
# 342
value_type temp = *this; 
# 343
temp |= rhs; 
# 344
(*this) = temp; 
# 345
return static_cast< derived_type &>(*this); 
# 346
} 
# 348
template< class Element, class Pointer, class Derived> typename reference< Element, Pointer, Derived> ::derived_type &
# 351
reference< Element, Pointer, Derived> ::operator^=(const value_type &rhs) 
# 352
{ 
# 353
value_type temp = *this; 
# 354
temp ^= rhs; 
# 355
(*this) = temp; 
# 356
return static_cast< derived_type &>(*this); 
# 357
} 
# 359
template< class Element, class Pointer, class Derived, class 
# 360
charT, class traits> std::basic_ostream< charT, traits>  &
# 362
operator<<(std::basic_ostream< charT, traits>  &os, const reference< Element, Pointer, Derived>  &
# 363
y) { 
# 364
typedef typename reference< Element, Pointer, Derived> ::value_type value_type; 
# 365
return os << (static_cast< value_type>(y)); 
# 366
} 
# 368
}
# 31 "/usr/local/cuda/include/thrust/memory.h"
namespace thrust { 
# 303
template< class DerivedPolicy> pointer< void, DerivedPolicy, use_default, use_default>  malloc(const detail::execution_policy_base< DerivedPolicy>  & system, std::size_t n); 
# 341
template< class T, class DerivedPolicy> pointer< T, DerivedPolicy, use_default, use_default>  malloc(const detail::execution_policy_base< DerivedPolicy>  & system, std::size_t n); 
# 394
template< class T, class DerivedPolicy> pair< pointer< T, DerivedPolicy, use_default, use_default> , typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type>  get_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  & system, typename pointer< T, DerivedPolicy, use_default, use_default> ::difference_type n); 
# 437
template< class DerivedPolicy, class Pointer> void free(const detail::execution_policy_base< DerivedPolicy>  & system, Pointer ptr); 
# 483
template< class DerivedPolicy, class Pointer> void return_temporary_buffer(const detail::execution_policy_base< DerivedPolicy>  & system, Pointer p); 
# 499
template< class Pointer> inline typename detail::pointer_traits< Pointer> ::raw_pointer raw_pointer_cast(const Pointer & ptr); 
# 516
template< class T> inline typename detail::raw_reference< T> ::type raw_reference_cast(T & ref); 
# 533
template< class T> inline typename detail::raw_reference< const T> ::type raw_reference_cast(const T & ref); 
# 542
}
# 27 "/usr/local/cuda/include/thrust/device_ptr.h"
namespace thrust { 
# 37
template< class T> class device_reference; 
# 60
template< class T> 
# 61
class device_ptr : public pointer< T, system::cuda::detail::tag, device_reference< T> , device_ptr< T> >  { 
# 75
typedef ::thrust::pointer< T, ::thrust::system::cuda::detail::tag, device_reference< T> , ::thrust::device_ptr< T> >  super_t; 
# 81
public: device_ptr() : super_t() { } 
# 89
template< class OtherT> explicit 
# 91
device_ptr(OtherT *ptr) : super_t(ptr) { } 
# 96
template< class OtherT> 
# 98
device_ptr(const ::thrust::device_ptr< OtherT>  &other) : super_t(other) { } 
# 104
template< class OtherT> device_ptr &
# 106
operator=(const ::thrust::device_ptr< OtherT>  &other) 
# 107
{ 
# 108
::thrust::pointer< T, ::thrust::system::cuda::detail::tag, device_reference< T> , ::thrust::device_ptr< T> > ::operator=(other); 
# 109
return *this; 
# 110
} 
# 121
}; 
# 153
template< class T> inline device_ptr< T>  device_pointer_cast(T * ptr); 
# 163
template< class T> inline device_ptr< T>  device_pointer_cast(const device_ptr< T>  & ptr); 
# 170
}
# 29 "/usr/local/cuda/include/thrust/device_reference.h"
namespace thrust { 
# 185
template< class T> 
# 186
class device_reference : public reference< T, device_ptr< T> , device_reference< T> >  { 
# 198
typedef ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> >  super_t; 
# 203
public: typedef typename ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> > ::value_type value_type; 
# 207
typedef typename ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> > ::pointer pointer; 
# 239
template< class OtherT> 
# 241
device_reference(const ::thrust::device_reference< OtherT>  &other, typename ::thrust::detail::enable_if_convertible< typename ::thrust::device_reference< OtherT> ::pointer, typename ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> > ::pointer> ::type * = 0) : super_t(other) 
# 247
{ } 
# 279
explicit device_reference(const pointer &ptr) : super_t(ptr) 
# 281
{ } 
# 290
template< class OtherT> device_reference &operator=(const ::thrust::device_reference< OtherT>  & other); 
# 301
device_reference &operator=(const value_type & x); 
# 953
}; 
# 959
template< class T> void swap(device_reference< T>  & x, device_reference< T>  & y); 
# 980
}
# 25 "/usr/local/cuda/include/thrust/detail/device_reference.inl"
namespace thrust { 
# 28
template< class T> 
# 29
template< class OtherT> device_reference< T>  &
# 32
device_reference< T> ::operator=(const ::thrust::device_reference< OtherT>  &other) 
# 33
{ 
# 34
return ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> > ::operator=(other); 
# 35
} 
# 37
template< class T> device_reference< T>  &
# 40
device_reference< T> ::operator=(const value_type &x) 
# 41
{ 
# 42
return ::thrust::reference< T, device_ptr< T> , ::thrust::device_reference< T> > ::operator=(x); 
# 43
} 
# 45
template< class T> void 
# 47
swap(device_reference< T>  &a, device_reference< T>  &b) 
# 48
{ 
# 49
(a.swap(b)); 
# 50
} 
# 52
}
# 27 "/usr/local/cuda/include/thrust/detail/device_ptr.inl"
namespace thrust { 
# 30
template< class T> inline device_ptr< T>  
# 31
device_pointer_cast(T *ptr) 
# 32
{ 
# 33
return ((device_ptr< T> )(ptr)); 
# 34
} 
# 36
template< class T> inline device_ptr< T>  
# 37
device_pointer_cast(const device_ptr< T>  &ptr) 
# 38
{ 
# 39
return ptr; 
# 40
} 
# 43
namespace detail { 
# 46
template< class T> 
# 47
struct is_device_ptr< device_ptr< T> >  : public true_type { 
# 50
}; 
# 63
}
# 64
}
# 28 "/usr/local/cuda/include/thrust/device_malloc.h"
namespace thrust { 
# 64
inline device_ptr< void>  device_malloc(const std::size_t n); 
# 94
template< class T> inline device_ptr< T>  device_malloc(const std::size_t n); 
# 100
}
# 28 "/usr/local/cuda/include/thrust/detail/device_malloc.inl"
namespace thrust { 
# 32
inline device_ptr< void>  device_malloc(const std::size_t n) 
# 33
{ 
# 34
using thrust::system::detail::generic::select_system;
# 36
typedef detail::iterator_category_to_system< detail::iterator_category_with_system_and_traversal< random_access_device_iterator_tag, thrust::system::cuda::detail::tag, random_access_traversal_tag> > ::type system; 
# 39
system s; 
# 41
return ((device_ptr< void> )(thrust::malloc(s, n).get())); 
# 42
} 
# 45
template< class T> inline device_ptr< T>  
# 46
device_malloc(const std::size_t n) 
# 47
{ 
# 48
using thrust::system::detail::generic::select_system;
# 50
typedef detail::iterator_category_to_system< detail::iterator_category_with_system_and_traversal< random_access_device_iterator_tag, thrust::system::cuda::detail::tag, random_access_traversal_tag> > ::type system; 
# 53
system s; 
# 55
return ((device_ptr< T> )((thrust::malloc< T> (s, n).get()))); 
# 56
} 
# 59
}
# 27 "/usr/local/cuda/include/thrust/device_free.h"
namespace thrust { 
# 60
inline void device_free(device_ptr< void>  ptr); 
# 65
}
# 28 "/usr/local/cuda/include/thrust/detail/device_free.inl"
namespace thrust { 
# 31
inline void device_free(device_ptr< void>  ptr) 
# 32
{ 
# 33
using thrust::system::detail::generic::select_system;
# 35
typedef detail::iterator_category_to_system< detail::iterator_category_with_system_and_traversal< random_access_device_iterator_tag, thrust::system::cuda::detail::tag, random_access_traversal_tag> > ::type system; 
# 38
system s; 
# 40
thrust::free(s, ptr); 
# 41
} 
# 43
}
# 32 "/usr/local/cuda/include/thrust/device_malloc_allocator.h"
namespace thrust { 
# 36
template< class > class device_ptr; 
# 37
template< class T> inline device_ptr< T>  device_malloc(const std::size_t n); 
# 52
template< class T> 
# 53
class device_malloc_allocator { 
# 57
public: typedef T value_type; 
# 60
typedef device_ptr< T>  pointer; 
# 63
typedef device_ptr< const T>  const_pointer; 
# 66
typedef device_reference< T>  reference; 
# 69
typedef device_reference< const T>  const_reference; 
# 72
typedef std::size_t size_type; 
# 75
typedef typename device_ptr< T> ::difference_type difference_type; 
# 82
template< class U> 
# 83
struct rebind { 
# 87
typedef thrust::device_malloc_allocator< U>  other; 
# 88
}; 
# 92
device_malloc_allocator() { } 
# 96
~device_malloc_allocator() { } 
# 100
device_malloc_allocator(const device_malloc_allocator &) { } 
# 103
template< class U> 
# 105
device_malloc_allocator(const thrust::device_malloc_allocator< U>  &) { } 
# 111
pointer address(reference r) { return &r; } 
# 117
const_pointer address(const_reference r) { return &r; } 
# 125
pointer allocate(size_type cnt, const_pointer = ((const_pointer)(static_cast< T *>(0)))) 
# 127
{ 
# 128
if (cnt > this->max_size()) 
# 129
{ 
# 130
throw std::bad_alloc(); 
# 131
}  
# 133
return ((pointer)(device_malloc< T> (cnt))); 
# 134
} 
# 143
void deallocate(pointer p, size_type cnt) 
# 144
{ 
# 146
(void)cnt; 
# 148
device_free(p); 
# 149
} 
# 154
size_type max_size() const 
# 155
{ 
# 156
return std::numeric_limits< unsigned long> ::max() / sizeof(T); 
# 157
} 
# 163
bool operator==(const device_malloc_allocator &) { return true; } 
# 169
bool operator!=(const device_malloc_allocator &a) { return !operator==(a); } 
# 170
}; 
# 175
}
# 22 "/usr/local/cuda/include/thrust/iterator/detail/reverse_iterator_base.h"
namespace thrust { 
# 25
template< class > class reverse_iterator; 
# 27
namespace detail { 
# 30
template< class BidirectionalIterator> 
# 31
struct reverse_iterator_base { 
# 36
typedef iterator_adaptor< reverse_iterator< BidirectionalIterator> , BidirectionalIterator>  type; 
# 37
}; 
# 39
}
# 41
}
# 40 "/usr/local/cuda/include/thrust/iterator/reverse_iterator.h"
namespace thrust { 
# 144
template< class BidirectionalIterator> 
# 145
class reverse_iterator : public detail::reverse_iterator_base< BidirectionalIterator> ::type { 
# 153
typedef typename ::thrust::detail::reverse_iterator_base< BidirectionalIterator> ::type super_t; 
# 155
friend class iterator_core_access; 
# 163
public: reverse_iterator() { } 
# 171
explicit reverse_iterator(BidirectionalIterator x); 
# 178
template< class OtherBidirectionalIterator> reverse_iterator(const ::thrust::reverse_iterator< OtherBidirectionalIterator>  & r, typename ::thrust::detail::enable_if< ::thrust::detail::is_convertible< OtherBidirectionalIterator, BidirectionalIterator> ::value> ::type * = 0); 
# 198
private: typename ::thrust::detail::reverse_iterator_base< BidirectionalIterator> ::type::reference dereference() const; 
# 201
void increment(); 
# 204
void decrement(); 
# 207
void advance(typename ::thrust::detail::reverse_iterator_base< BidirectionalIterator> ::type::difference_type n); 
# 209
template< class OtherBidirectionalIterator> typename ::thrust::detail::reverse_iterator_base< BidirectionalIterator> ::type::difference_type distance_to(const ::thrust::reverse_iterator< OtherBidirectionalIterator>  & y) const; 
# 215
}; 
# 224
template< class BidirectionalIterator> reverse_iterator< BidirectionalIterator>  make_reverse_iterator(BidirectionalIterator x); 
# 235
}
# 20 "/usr/local/cuda/include/thrust/iterator/detail/reverse_iterator.inl"
namespace thrust { 
# 23
namespace detail { 
# 27
template< class Iterator> Iterator 
# 29
prior(Iterator x) 
# 30
{ 
# 31
return --x; 
# 32
} 
# 34
}
# 36
template< class BidirectionalIterator> 
# 38
reverse_iterator< BidirectionalIterator> ::reverse_iterator(BidirectionalIterator x) : super_t(x) 
# 40
{ 
# 41
} 
# 43
template< class BidirectionalIterator> 
# 44
template< class OtherBidirectionalIterator> 
# 46
reverse_iterator< BidirectionalIterator> ::reverse_iterator(const ::thrust::reverse_iterator< OtherBidirectionalIterator>  &r, typename ::thrust::detail::enable_if< ::thrust::detail::is_convertible< OtherBidirectionalIterator, BidirectionalIterator> ::value> ::type *) : super_t((r.base())) 
# 58
{ 
# 59
} 
# 61
template< class BidirectionalIterator> typename detail::reverse_iterator_base< BidirectionalIterator> ::type::reference 
# 64
reverse_iterator< BidirectionalIterator> ::dereference() const 
# 65
{ 
# 66
return *::thrust::detail::prior((this->base())); 
# 67
} 
# 69
template< class BidirectionalIterator> void 
# 71
reverse_iterator< BidirectionalIterator> ::increment() 
# 72
{ 
# 73
--(this->base_reference()); 
# 74
} 
# 76
template< class BidirectionalIterator> void 
# 78
reverse_iterator< BidirectionalIterator> ::decrement() 
# 79
{ 
# 80
++(this->base_reference()); 
# 81
} 
# 83
template< class BidirectionalIterator> void 
# 85
reverse_iterator< BidirectionalIterator> ::advance(typename ::thrust::detail::reverse_iterator_base< BidirectionalIterator> ::type::difference_type n) 
# 86
{ 
# 87
(this->base_reference()) += (-n); 
# 88
} 
# 90
template< class BidirectionalIterator> 
# 91
template< class OtherBidirectionalIterator> typename detail::reverse_iterator_base< BidirectionalIterator> ::type::difference_type 
# 94
reverse_iterator< BidirectionalIterator> ::distance_to(const ::thrust::reverse_iterator< OtherBidirectionalIterator>  &y) const 
# 95
{ 
# 96
return (this->base_reference()) - (y.base()); 
# 97
} 
# 99
template< class BidirectionalIterator> reverse_iterator< BidirectionalIterator>  
# 101
make_reverse_iterator(BidirectionalIterator x) 
# 102
{ 
# 103
return ((reverse_iterator< BidirectionalIterator> )(x)); 
# 104
} 
# 107
}
# 66 "/usr/include/c++/5/bits/stl_vector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _Tp, class _Alloc> 
# 72
struct _Vector_base { 
# 75
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 77
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other> ::pointer pointer; 
# 79
struct _Vector_impl : public _Tp_alloc_type { 
# 82
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_start; 
# 83
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_finish; 
# 84
typename ::std::_Vector_base< _Tp, _Alloc> ::pointer _M_end_of_storage; 
# 86
_Vector_impl() : ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() 
# 88
{ } 
# 90
_Vector_impl(const typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &__a) : ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() 
# 92
{ } 
# 101
void _M_swap_data(_Vector_impl &__x) 
# 102
{ 
# 103
::std::swap(_M_start, __x._M_start); 
# 104
::std::swap(_M_finish, __x._M_finish); 
# 105
::std::swap(_M_end_of_storage, __x._M_end_of_storage); 
# 106
} 
# 107
}; 
# 110
typedef _Alloc allocator_type; 
# 113
_Tp_alloc_type &_M_get_Tp_allocator() 
# 114
{ return *(static_cast< _Tp_alloc_type *>(&(this->_M_impl))); } 
# 117
const _Tp_alloc_type &_M_get_Tp_allocator() const 
# 118
{ return *(static_cast< const _Tp_alloc_type *>(&(this->_M_impl))); } 
# 121
allocator_type get_allocator() const 
# 122
{ return (allocator_type)this->_M_get_Tp_allocator(); } 
# 124
_Vector_base() : _M_impl() 
# 125
{ } 
# 127
_Vector_base(const allocator_type &__a) : _M_impl(__a) 
# 128
{ } 
# 130
_Vector_base(size_t __n) : _M_impl() 
# 132
{ _M_create_storage(__n); } 
# 134
_Vector_base(size_t __n, const allocator_type &__a) : _M_impl(__a) 
# 136
{ _M_create_storage(__n); } 
# 159
~_Vector_base() 
# 160
{ _M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 161
} 
# 164
_Vector_impl _M_impl; 
# 167
pointer _M_allocate(size_t __n) 
# 168
{ 
# 169
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Tr; 
# 170
return (__n != (0)) ? _Tr::allocate(_M_impl, __n) : (pointer()); 
# 171
} 
# 174
void _M_deallocate(pointer __p, size_t __n) 
# 175
{ 
# 176
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other>  _Tr; 
# 177
if (__p) { 
# 178
_Tr::deallocate(_M_impl, __p, __n); }  
# 179
} 
# 183
private: void _M_create_storage(size_t __n) 
# 184
{ 
# 185
((this->_M_impl)._M_start) = this->_M_allocate(__n); 
# 186
((this->_M_impl)._M_finish) = ((this->_M_impl)._M_start); 
# 187
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 188
} 
# 189
}; 
# 213
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 214
class vector : protected _Vector_base< _Tp, _Alloc>  { 
# 217
typedef typename _Alloc::value_type _Alloc_value_type; 
# 221
typedef ::std::_Vector_base< _Tp, _Alloc>  _Base; 
# 222
typedef typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 223
typedef ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type>  _Alloc_traits; 
# 226
public: typedef _Tp value_type; 
# 227
typedef typename ::std::_Vector_base< _Tp, _Alloc> ::pointer pointer; 
# 228
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer const_pointer; 
# 229
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::reference reference; 
# 230
typedef typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_reference const_reference; 
# 231
typedef ::__gnu_cxx::__normal_iterator< typename ::std::_Vector_base< _Tp, _Alloc> ::pointer, vector>  iterator; 
# 233
typedef ::__gnu_cxx::__normal_iterator< typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer, vector>  const_iterator; 
# 234
typedef ::std::reverse_iterator< ::__gnu_cxx::__normal_iterator< typename ::__gnu_cxx::__alloc_traits< typename ::std::_Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::const_pointer, vector> >  const_reverse_iterator; 
# 235
typedef ::std::reverse_iterator< ::__gnu_cxx::__normal_iterator< typename ::std::_Vector_base< _Tp, _Alloc> ::pointer, vector> >  reverse_iterator; 
# 236
typedef ::std::size_t size_type; 
# 237
typedef ::std::ptrdiff_t difference_type; 
# 238
typedef _Alloc allocator_type; 
# 241
protected: using ::std::_Vector_base< _Tp, _Alloc> ::_M_allocate;
# 242
using ::std::_Vector_base< _Tp, _Alloc> ::_M_deallocate;
# 243
using ::std::_Vector_base< _Tp, _Alloc> ::_M_impl;
# 244
using ::std::_Vector_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 253
public: vector() : _Base() 
# 257
{ } 
# 264
explicit vector(const allocator_type &__a) : _Base(__a) 
# 265
{ } 
# 303
explicit vector(size_type __n, const value_type &__value = value_type(), const allocator_type &
# 304
__a = allocator_type()) : _Base(__n, __a) 
# 306
{ _M_fill_initialize(__n, __value); } 
# 318
vector(const vector &__x) : _Base(__x.size(), _Alloc_traits::_S_select_on_copy((__x._M_get_Tp_allocator()))) 
# 321
{ ((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 325
} 
# 406
template< class _InputIterator> 
# 407
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 408
__a = allocator_type()) : _Base(__a) 
# 410
{ 
# 412
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 413
_M_initialize_dispatch(__first, __last, _Integral()); 
# 414
} 
# 423
~vector() 
# 424
{ ::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 425
} 
# 436
vector &operator=(const vector & __x); 
# 488
void assign(size_type __n, const value_type &__val) 
# 489
{ _M_fill_assign(__n, __val); } 
# 510
template< class _InputIterator> void 
# 512
assign(_InputIterator __first, _InputIterator __last) 
# 513
{ 
# 515
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 516
_M_assign_dispatch(__first, __last, _Integral()); 
# 517
} 
# 538
using ::std::_Vector_base< _Tp, _Alloc> ::get_allocator;
# 547
iterator begin() 
# 548
{ return ((iterator)(((this->_M_impl)._M_start))); } 
# 556
const_iterator begin() const 
# 557
{ return ((const_iterator)(((this->_M_impl)._M_start))); } 
# 565
iterator end() 
# 566
{ return ((iterator)(((this->_M_impl)._M_finish))); } 
# 574
const_iterator end() const 
# 575
{ return ((const_iterator)(((this->_M_impl)._M_finish))); } 
# 583
reverse_iterator rbegin() 
# 584
{ return ((reverse_iterator)(this->end())); } 
# 592
const_reverse_iterator rbegin() const 
# 593
{ return ((const_reverse_iterator)(this->end())); } 
# 601
reverse_iterator rend() 
# 602
{ return ((reverse_iterator)(this->begin())); } 
# 610
const_reverse_iterator rend() const 
# 611
{ return ((const_reverse_iterator)(this->begin())); } 
# 654
size_type size() const 
# 655
{ return (size_type)(((this->_M_impl)._M_finish) - ((this->_M_impl)._M_start)); } 
# 659
size_type max_size() const 
# 660
{ return _Alloc_traits::max_size(_M_get_Tp_allocator()); } 
# 713
void resize(size_type __new_size, value_type __x = value_type()) 
# 714
{ 
# 715
if (__new_size > size()) { 
# 716
insert(this->end(), __new_size - size(), __x); } else { 
# 717
if (__new_size < size()) { 
# 718
_M_erase_at_end(((this->_M_impl)._M_start) + __new_size); }  }  
# 719
} 
# 734
size_type capacity() const 
# 735
{ return (size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 736
} 
# 743
bool empty() const 
# 744
{ return this->begin() == this->end(); } 
# 764
void reserve(size_type __n); 
# 779
reference operator[](size_type __n) 
# 780
{ return *(((this->_M_impl)._M_start) + __n); } 
# 794
const_reference operator[](size_type __n) const 
# 795
{ return *(((this->_M_impl)._M_start) + __n); } 
# 800
protected: void _M_range_check(size_type __n) const 
# 801
{ 
# 802
if (__n >= this->size()) { 
# 803
__throw_out_of_range_fmt("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 807
} 
# 822
public: reference at(size_type __n) 
# 823
{ 
# 824
_M_range_check(__n); 
# 825
return (*this)[__n]; 
# 826
} 
# 840
const_reference at(size_type __n) const 
# 841
{ 
# 842
_M_range_check(__n); 
# 843
return (*this)[__n]; 
# 844
} 
# 851
reference front() 
# 852
{ return *this->begin(); } 
# 859
const_reference front() const 
# 860
{ return *this->begin(); } 
# 867
reference back() 
# 868
{ return *(this->end() - 1); } 
# 875
const_reference back() const 
# 876
{ return *(this->end() - 1); } 
# 890
pointer data() 
# 891
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 898
const_pointer data() const 
# 899
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 913
void push_back(const value_type &__x) 
# 914
{ 
# 915
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 916
{ 
# 917
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 919
++((this->_M_impl)._M_finish); 
# 920
} else { 
# 925
_M_insert_aux(this->end(), __x); }  
# 927
} 
# 949
void pop_back() 
# 950
{ 
# 951
--((this->_M_impl)._M_finish); 
# 952
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 953
} 
# 998
iterator insert(iterator __position, const value_type & __x); 
# 1072
void insert(iterator __position, size_type __n, const value_type &__x) 
# 1073
{ _M_fill_insert(__position, __n, __x); } 
# 1118
template< class _InputIterator> void 
# 1120
insert(iterator __position, _InputIterator __first, _InputIterator 
# 1121
__last) 
# 1122
{ 
# 1124
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 1125
_M_insert_dispatch(__position, __first, __last, _Integral()); 
# 1126
} 
# 1149
iterator erase(iterator __position) 
# 1150
{ return _M_erase(__position); } 
# 1180
iterator erase(iterator __first, iterator __last) 
# 1181
{ return _M_erase(__first, __last); } 
# 1194
void swap(vector &__x) 
# 1198
{ 
# 1199
((this->_M_impl)._M_swap_data((__x._M_impl))); 
# 1200
_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), (__x._M_get_Tp_allocator())); 
# 1202
} 
# 1211
void clear() 
# 1212
{ _M_erase_at_end(((this->_M_impl)._M_start)); } 
# 1221
protected: 
# 1219
template< class _ForwardIterator> pointer 
# 1221
_M_allocate_and_copy(size_type __n, _ForwardIterator 
# 1222
__first, _ForwardIterator __last) 
# 1223
{ 
# 1224
pointer __result = (this->_M_allocate(__n)); 
# 1225
try 
# 1226
{ 
# 1227
::std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator()); 
# 1229
return __result; 
# 1230
} 
# 1231
catch (...) 
# 1232
{ 
# 1233
_M_deallocate(__result, __n); 
# 1234
throw; 
# 1235
}  
# 1236
} 
# 1245
template< class _Integer> void 
# 1247
_M_initialize_dispatch(_Integer __n, _Integer __value, ::std::__true_type) 
# 1248
{ 
# 1249
((this->_M_impl)._M_start) = _M_allocate(static_cast< size_type>(__n)); 
# 1250
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + (static_cast< size_type>(__n))); 
# 1252
_M_fill_initialize(static_cast< size_type>(__n), __value); 
# 1253
} 
# 1256
template< class _InputIterator> void 
# 1258
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1260
{ 
# 1262
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1263
_M_range_initialize(__first, __last, _IterCategory()); 
# 1264
} 
# 1267
template< class _InputIterator> void 
# 1269
_M_range_initialize(_InputIterator __first, _InputIterator 
# 1270
__last, ::std::input_iterator_tag) 
# 1271
{ 
# 1272
for (; __first != __last; ++__first) { 
# 1276
push_back(*__first); }  
# 1278
} 
# 1281
template< class _ForwardIterator> void 
# 1283
_M_range_initialize(_ForwardIterator __first, _ForwardIterator 
# 1284
__last, ::std::forward_iterator_tag) 
# 1285
{ 
# 1286
const size_type __n = ::std::distance(__first, __last); 
# 1287
((this->_M_impl)._M_start) = (this->_M_allocate(__n)); 
# 1288
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 1289
((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a(__first, __last, ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 1293
} 
# 1298
void _M_fill_initialize(size_type __n, const value_type &__value) 
# 1299
{ 
# 1300
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_start), __n, __value, _M_get_Tp_allocator()); 
# 1303
} 
# 1323
template< class _Integer> void 
# 1325
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1326
{ _M_fill_assign(__n, __val); } 
# 1329
template< class _InputIterator> void 
# 1331
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1333
{ 
# 1335
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1336
_M_assign_aux(__first, __last, _IterCategory()); 
# 1337
} 
# 1340
template< class _InputIterator> void _M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1346
template< class _ForwardIterator> void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1354
void _M_fill_assign(size_type __n, const value_type & __val); 
# 1363
template< class _Integer> void 
# 1365
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, ::std::__true_type) 
# 1367
{ _M_fill_insert(__pos, __n, __val); } 
# 1370
template< class _InputIterator> void 
# 1372
_M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator 
# 1373
__last, ::std::__false_type) 
# 1374
{ 
# 1376
typedef typename iterator_traits< _InputIterator> ::iterator_category _IterCategory; 
# 1377
_M_range_insert(__pos, __first, __last, _IterCategory()); 
# 1378
} 
# 1381
template< class _InputIterator> void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, ::std::input_iterator_tag); 
# 1387
template< class _ForwardIterator> void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1395
void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x); 
# 1409
void _M_insert_aux(iterator __position, const value_type & __x); 
# 1422
size_type _M_check_len(size_type __n, const char *__s) const 
# 1423
{ 
# 1424
if ((max_size() - size()) < __n) { 
# 1425
__throw_length_error(__s); }  
# 1427
const size_type __len = size() + ::std::max(size(), __n); 
# 1428
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1429
} 
# 1436
void _M_erase_at_end(pointer __pos) 
# 1437
{ 
# 1438
::std::_Destroy(__pos, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 1439
((this->_M_impl)._M_finish) = __pos; 
# 1440
} 
# 1443
iterator _M_erase(iterator __position); 
# 1446
iterator _M_erase(iterator __first, iterator __last); 
# 1491
template< class _Ptr> _Ptr 
# 1493
_M_data_ptr(_Ptr __ptr) const 
# 1494
{ return __ptr; } 
# 1496
}; 
# 1509
template< class _Tp, class _Alloc> inline bool 
# 1511
operator==(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1512
{ return ((__x.size()) == (__y.size())) && std::equal((__x.begin()), (__x.end()), (__y.begin())); 
# 1513
} 
# 1526
template< class _Tp, class _Alloc> inline bool 
# 1528
operator<(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1529
{ return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 1530
} 
# 1533
template< class _Tp, class _Alloc> inline bool 
# 1535
operator!=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1536
{ return !(__x == __y); } 
# 1539
template< class _Tp, class _Alloc> inline bool 
# 1541
operator>(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1542
{ return __y < __x; } 
# 1545
template< class _Tp, class _Alloc> inline bool 
# 1547
operator<=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1548
{ return !(__y < __x); } 
# 1551
template< class _Tp, class _Alloc> inline bool 
# 1553
operator>=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1554
{ return !(__x < __y); } 
# 1557
template< class _Tp, class _Alloc> inline void 
# 1559
swap(vector< _Tp, _Alloc>  &__x, vector< _Tp, _Alloc>  &__y) 
# 1560
{ (__x.swap(__y)); } 
# 1563
}
# 63 "/usr/include/c++/5/bits/stl_bvector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 67
typedef unsigned long _Bit_type; 
# 68
enum { _S_word_bit = 64}; 
# 70
struct _Bit_reference { 
# 72
_Bit_type *_M_p; 
# 73
_Bit_type _M_mask; 
# 75
_Bit_reference(_Bit_type *__x, _Bit_type __y) : _M_p(__x), _M_mask(__y) 
# 76
{ } 
# 78
_Bit_reference() : _M_p((0)), _M_mask((0)) { } 
# 80
operator bool() const 
# 81
{ return !(!((*(_M_p)) & (_M_mask))); } 
# 84
_Bit_reference &operator=(bool __x) 
# 85
{ 
# 86
if (__x) { 
# 87
(*(_M_p)) |= (_M_mask); } else { 
# 89
(*(_M_p)) &= (~(_M_mask)); }  
# 90
return *this; 
# 91
} 
# 94
_Bit_reference &operator=(const _Bit_reference &__x) 
# 95
{ return ((*this) = ((bool)__x)); } 
# 98
bool operator==(const _Bit_reference &__x) const 
# 99
{ return ((bool)(*this)) == ((bool)__x); } 
# 102
bool operator<(const _Bit_reference &__x) const 
# 103
{ return (!((bool)(*this))) && ((bool)__x); } 
# 106
void flip() 
# 107
{ (*(_M_p)) ^= (_M_mask); } 
# 108
}; 
# 136
struct _Bit_iterator_base : public iterator< random_access_iterator_tag, bool>  { 
# 139
_Bit_type *_M_p; 
# 140
unsigned _M_offset; 
# 142
_Bit_iterator_base(_Bit_type *__x, unsigned __y) : _M_p(__x), _M_offset(__y) 
# 143
{ } 
# 146
void _M_bump_up() 
# 147
{ 
# 148
if (((_M_offset)++) == (((int)_S_word_bit) - 1)) 
# 149
{ 
# 150
(_M_offset) = (0); 
# 151
++(_M_p); 
# 152
}  
# 153
} 
# 156
void _M_bump_down() 
# 157
{ 
# 158
if (((_M_offset)--) == (0)) 
# 159
{ 
# 160
(_M_offset) = (((int)_S_word_bit) - 1); 
# 161
--(_M_p); 
# 162
}  
# 163
} 
# 166
void _M_incr(ptrdiff_t __i) 
# 167
{ 
# 168
difference_type __n = __i + (_M_offset); 
# 169
(_M_p) += (__n / ((int)_S_word_bit)); 
# 170
__n = (__n % ((int)_S_word_bit)); 
# 171
if (__n < (0)) 
# 172
{ 
# 173
__n += ((int)_S_word_bit); 
# 174
--(_M_p); 
# 175
}  
# 176
(_M_offset) = (static_cast< unsigned>(__n)); 
# 177
} 
# 180
bool operator==(const _Bit_iterator_base &__i) const 
# 181
{ return ((_M_p) == (__i._M_p)) && ((_M_offset) == (__i._M_offset)); } 
# 184
bool operator<(const _Bit_iterator_base &__i) const 
# 185
{ 
# 186
return ((_M_p) < (__i._M_p)) || (((_M_p) == (__i._M_p)) && ((_M_offset) < (__i._M_offset))); 
# 188
} 
# 191
bool operator!=(const _Bit_iterator_base &__i) const 
# 192
{ return !((*this) == __i); } 
# 195
bool operator>(const _Bit_iterator_base &__i) const 
# 196
{ return (__i < (*this)); } 
# 199
bool operator<=(const _Bit_iterator_base &__i) const 
# 200
{ return !(__i < (*this)); } 
# 203
bool operator>=(const _Bit_iterator_base &__i) const 
# 204
{ return !((*this) < __i); } 
# 205
}; 
# 208
inline ptrdiff_t operator-(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) 
# 209
{ 
# 210
return ((((int)_S_word_bit) * ((__x._M_p) - (__y._M_p))) + (__x._M_offset)) - (__y._M_offset); 
# 212
} 
# 214
struct _Bit_iterator : public _Bit_iterator_base { 
# 216
typedef _Bit_reference reference; 
# 217
typedef _Bit_reference *pointer; 
# 218
typedef _Bit_iterator iterator; 
# 220
_Bit_iterator() : _Bit_iterator_base(0, 0) { } 
# 222
_Bit_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 223
{ } 
# 226
iterator _M_const_cast() const 
# 227
{ return *this; } 
# 230
reference operator*() const 
# 231
{ return reference(_M_p, 1UL << (_M_offset)); } 
# 234
iterator &operator++() 
# 235
{ 
# 236
this->_M_bump_up(); 
# 237
return *this; 
# 238
} 
# 241
iterator operator++(int) 
# 242
{ 
# 243
iterator __tmp = *this; 
# 244
this->_M_bump_up(); 
# 245
return __tmp; 
# 246
} 
# 249
iterator &operator--() 
# 250
{ 
# 251
this->_M_bump_down(); 
# 252
return *this; 
# 253
} 
# 256
iterator operator--(int) 
# 257
{ 
# 258
iterator __tmp = *this; 
# 259
this->_M_bump_down(); 
# 260
return __tmp; 
# 261
} 
# 264
iterator &operator+=(difference_type __i) 
# 265
{ 
# 266
this->_M_incr(__i); 
# 267
return *this; 
# 268
} 
# 271
iterator &operator-=(difference_type __i) 
# 272
{ 
# 273
((*this) += (-__i)); 
# 274
return *this; 
# 275
} 
# 278
iterator operator+(difference_type __i) const 
# 279
{ 
# 280
iterator __tmp = *this; 
# 281
return (__tmp += __i); 
# 282
} 
# 285
iterator operator-(difference_type __i) const 
# 286
{ 
# 287
iterator __tmp = *this; 
# 288
return (__tmp -= __i); 
# 289
} 
# 292
reference operator[](difference_type __i) const 
# 293
{ return (*(((*this) + __i))); } 
# 294
}; 
# 297
inline _Bit_iterator operator+(ptrdiff_t __n, const _Bit_iterator &__x) 
# 298
{ return (__x + __n); } 
# 300
struct _Bit_const_iterator : public _Bit_iterator_base { 
# 302
typedef bool reference; 
# 303
typedef bool const_reference; 
# 304
typedef const bool *pointer; 
# 305
typedef _Bit_const_iterator const_iterator; 
# 307
_Bit_const_iterator() : _Bit_iterator_base(0, 0) { } 
# 309
_Bit_const_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 310
{ } 
# 312
_Bit_const_iterator(const _Bit_iterator &__x) : _Bit_iterator_base(__x._M_p, __x._M_offset) 
# 313
{ } 
# 316
_Bit_iterator _M_const_cast() const 
# 317
{ return _Bit_iterator(_M_p, _M_offset); } 
# 320
const_reference operator*() const 
# 321
{ return _Bit_reference(_M_p, 1UL << (_M_offset)); } 
# 324
const_iterator &operator++() 
# 325
{ 
# 326
this->_M_bump_up(); 
# 327
return *this; 
# 328
} 
# 331
const_iterator operator++(int) 
# 332
{ 
# 333
const_iterator __tmp = *this; 
# 334
this->_M_bump_up(); 
# 335
return __tmp; 
# 336
} 
# 339
const_iterator &operator--() 
# 340
{ 
# 341
this->_M_bump_down(); 
# 342
return *this; 
# 343
} 
# 346
const_iterator operator--(int) 
# 347
{ 
# 348
const_iterator __tmp = *this; 
# 349
this->_M_bump_down(); 
# 350
return __tmp; 
# 351
} 
# 354
const_iterator &operator+=(difference_type __i) 
# 355
{ 
# 356
this->_M_incr(__i); 
# 357
return *this; 
# 358
} 
# 361
const_iterator &operator-=(difference_type __i) 
# 362
{ 
# 363
((*this) += (-__i)); 
# 364
return *this; 
# 365
} 
# 368
const_iterator operator+(difference_type __i) const 
# 369
{ 
# 370
const_iterator __tmp = *this; 
# 371
return (__tmp += __i); 
# 372
} 
# 375
const_iterator operator-(difference_type __i) const 
# 376
{ 
# 377
const_iterator __tmp = *this; 
# 378
return (__tmp -= __i); 
# 379
} 
# 382
const_reference operator[](difference_type __i) const 
# 383
{ return (*(((*this) + __i))); } 
# 384
}; 
# 387
inline _Bit_const_iterator operator+(ptrdiff_t __n, const _Bit_const_iterator &__x) 
# 388
{ return (__x + __n); } 
# 391
inline void __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x) 
# 392
{ 
# 393
for (; (__first != __last); (++__first)) { 
# 394
(((*__first)) = __x); }  
# 395
} 
# 398
inline void fill(_Bit_iterator __first, _Bit_iterator __last, const bool &__x) 
# 399
{ 
# 400
if ((__first._M_p) != (__last._M_p)) 
# 401
{ 
# 402
std::fill((__first._M_p) + 1, __last._M_p, __x ? ~0 : 0); 
# 403
__fill_bvector(__first, _Bit_iterator((__first._M_p) + 1, 0), __x); 
# 404
__fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x); 
# 405
} else { 
# 407
__fill_bvector(__first, __last, __x); }  
# 408
} 
# 410
template< class _Alloc> 
# 411
struct _Bvector_base { 
# 414
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other _Bit_alloc_type; 
# 416
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other>  _Bit_alloc_traits; 
# 417
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< unsigned long> ::other> ::pointer _Bit_pointer; 
# 419
struct _Bvector_impl : public _Bit_alloc_type { 
# 422
::std::_Bit_iterator _M_start; 
# 423
::std::_Bit_iterator _M_finish; 
# 424
typename ::std::_Bvector_base< _Alloc> ::_Bit_pointer _M_end_of_storage; 
# 426
_Bvector_impl() : ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage() 
# 428
{ } 
# 430
_Bvector_impl(const typename ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type &__a) : ::std::_Bvector_base< _Alloc> ::_Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage() 
# 432
{ } 
# 442
::std::_Bit_type *_M_end_addr() const 
# 443
{ 
# 444
if (_M_end_of_storage) { 
# 445
return ::std::__addressof((_M_end_of_storage)[-1]) + 1; }  
# 446
return 0; 
# 447
} 
# 448
}; 
# 451
typedef _Alloc allocator_type; 
# 454
_Bit_alloc_type &_M_get_Bit_allocator() 
# 455
{ return *(static_cast< _Bit_alloc_type *>(&(this->_M_impl))); } 
# 458
const _Bit_alloc_type &_M_get_Bit_allocator() const 
# 459
{ return *(static_cast< const _Bit_alloc_type *>(&(this->_M_impl))); } 
# 462
allocator_type get_allocator() const 
# 463
{ return (allocator_type)this->_M_get_Bit_allocator(); } 
# 465
_Bvector_base() : _M_impl() 
# 466
{ } 
# 468
_Bvector_base(const allocator_type &__a) : _M_impl(__a) 
# 469
{ } 
# 484
~_Bvector_base() 
# 485
{ this->_M_deallocate(); } 
# 488
protected: _Bvector_impl _M_impl; 
# 491
_Bit_pointer _M_allocate(size_t __n) 
# 492
{ return _Bit_alloc_traits::allocate(_M_impl, (_S_nword)(__n)); } 
# 495
void _M_deallocate() 
# 496
{ 
# 497
if (((_M_impl)._M_start)._M_p) 
# 498
{ 
# 499
const size_t __n = ((_M_impl)._M_end_addr()) - (((_M_impl)._M_start)._M_p); 
# 500
_Bit_alloc_traits::deallocate(_M_impl, ((_M_impl)._M_end_of_storage) - __n, __n); 
# 503
}  
# 504
} 
# 507
static size_t _S_nword(size_t __n) 
# 508
{ return ((__n + ((int)_S_word_bit)) - (1)) / ((int)_S_word_bit); } 
# 509
}; 
# 512
}
# 517
namespace std __attribute((__visibility__("default"))) { 
# 540
template< class _Alloc> 
# 541
class vector< bool, _Alloc>  : protected _Bvector_base< _Alloc>  { 
# 543
typedef ::std::_Bvector_base< _Alloc>  _Base; 
# 544
typedef typename ::std::_Bvector_base< _Alloc> ::_Bit_pointer _Bit_pointer; 
# 545
typedef typename ::std::_Bvector_base< _Alloc> ::_Bit_alloc_traits _Bit_alloc_traits; 
# 552
public: typedef bool value_type; 
# 553
typedef ::std::size_t size_type; 
# 554
typedef ::std::ptrdiff_t difference_type; 
# 555
typedef ::std::_Bit_reference reference; 
# 556
typedef bool const_reference; 
# 557
typedef ::std::_Bit_reference *pointer; 
# 558
typedef const bool *const_pointer; 
# 559
typedef ::std::_Bit_iterator iterator; 
# 560
typedef ::std::_Bit_const_iterator const_iterator; 
# 561
typedef ::std::reverse_iterator< ::std::_Bit_const_iterator>  const_reverse_iterator; 
# 562
typedef ::std::reverse_iterator< ::std::_Bit_iterator>  reverse_iterator; 
# 563
typedef _Alloc allocator_type; 
# 565
allocator_type get_allocator() const 
# 566
{ return _Base::get_allocator(); } 
# 569
protected: using ::std::_Bvector_base< _Alloc> ::_M_allocate;
# 570
using ::std::_Bvector_base< _Alloc> ::_M_deallocate;
# 571
using ::std::_Bvector_base< _Alloc> ::_S_nword;
# 572
using ::std::_Bvector_base< _Alloc> ::_M_get_Bit_allocator;
# 575
public: vector() : _Base() 
# 579
{ } 
# 582
explicit vector(const allocator_type &__a) : _Base(__a) 
# 583
{ } 
# 601
explicit vector(size_type __n, const bool &__value = ((bool)0), const allocator_type &
# 602
__a = allocator_type()) : _Base(__a) 
# 604
{ 
# 605
_M_initialize(__n); 
# 606
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __value ? ~0 : 0); 
# 608
} 
# 611
vector(const ::std::vector< bool, _Alloc>  &__x) : _Base(_Bit_alloc_traits::_S_select_on_copy((__x._M_get_Bit_allocator()))) 
# 613
{ 
# 614
_M_initialize(__x.size()); 
# 615
_M_copy_aligned(__x.begin(), __x.end(), ((this->_M_impl)._M_start)); 
# 616
} 
# 667
template< class _InputIterator> 
# 668
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 669
__a = allocator_type()) : _Base(__a) 
# 671
{ 
# 672
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 673
_M_initialize_dispatch(__first, __last, _Integral()); 
# 674
} 
# 677
~vector() { } 
# 680
::std::vector< bool, _Alloc>  &operator=(const ::std::vector< bool, _Alloc>  &__x) 
# 681
{ 
# 682
if ((&__x) == this) { 
# 683
return *this; }  
# 699
if (__x.size() > capacity()) 
# 700
{ 
# 701
(this->_M_deallocate()); 
# 702
_M_initialize(__x.size()); 
# 703
}  
# 704
((this->_M_impl)._M_finish) = _M_copy_aligned(__x.begin(), __x.end(), this->begin()); 
# 706
return *this; 
# 707
} 
# 753
void assign(size_type __n, const bool &__x) 
# 754
{ _M_fill_assign(__n, __x); } 
# 763
template< class _InputIterator> void 
# 765
assign(_InputIterator __first, _InputIterator __last) 
# 766
{ 
# 767
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 768
_M_assign_dispatch(__first, __last, _Integral()); 
# 769
} 
# 779
iterator begin() 
# 780
{ return ((this->_M_impl)._M_start); } 
# 783
const_iterator begin() const 
# 784
{ return ((this->_M_impl)._M_start); } 
# 787
iterator end() 
# 788
{ return ((this->_M_impl)._M_finish); } 
# 791
const_iterator end() const 
# 792
{ return ((this->_M_impl)._M_finish); } 
# 795
reverse_iterator rbegin() 
# 796
{ return ((reverse_iterator)(this->end())); } 
# 799
const_reverse_iterator rbegin() const 
# 800
{ return ((const_reverse_iterator)(this->end())); } 
# 803
reverse_iterator rend() 
# 804
{ return ((reverse_iterator)(this->begin())); } 
# 807
const_reverse_iterator rend() const 
# 808
{ return ((const_reverse_iterator)(this->begin())); } 
# 829
size_type size() const 
# 830
{ return (size_type)(((this->end()) - (this->begin()))); } 
# 833
size_type max_size() const 
# 834
{ 
# 835
const size_type __isize = ((::__gnu_cxx::__numeric_traits_integer< long> ::__max - ((int)_S_word_bit)) + (1)); 
# 838
const size_type __asize = _Bit_alloc_traits::max_size(_M_get_Bit_allocator()); 
# 840
return (__asize <= (__isize / ((int)_S_word_bit))) ? __asize * ((int)_S_word_bit) : __isize; 
# 842
} 
# 845
size_type capacity() const 
# 846
{ return (size_type)((const_iterator(((this->_M_impl)._M_end_addr()), 0) - (this->begin()))); 
# 847
} 
# 850
bool empty() const 
# 851
{ return ((this->begin()) == (this->end())); } 
# 854
reference operator[](size_type __n) 
# 855
{ 
# 856
return (*iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 858
} 
# 861
const_reference operator[](size_type __n) const 
# 862
{ 
# 863
return (*const_iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 865
} 
# 869
protected: void _M_range_check(size_type __n) const 
# 870
{ 
# 871
if (__n >= this->size()) { 
# 872
__throw_out_of_range_fmt("vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size()); }  
# 876
} 
# 880
public: reference at(size_type __n) 
# 881
{ _M_range_check(__n); return (*this)[__n]; } 
# 884
const_reference at(size_type __n) const 
# 885
{ _M_range_check(__n); return (*this)[__n]; } 
# 888
void reserve(size_type __n) 
# 889
{ 
# 890
if (__n > max_size()) { 
# 891
__throw_length_error("vector::reserve"); }  
# 892
if (capacity() < __n) { 
# 893
_M_reallocate(__n); }  
# 894
} 
# 897
reference front() 
# 898
{ return (*(this->begin())); } 
# 901
const_reference front() const 
# 902
{ return (*(this->begin())); } 
# 905
reference back() 
# 906
{ return (*(((this->end()) - (1)))); } 
# 909
const_reference back() const 
# 910
{ return (*(((this->end()) - (1)))); } 
# 918
void data() { } 
# 921
void push_back(bool __x) 
# 922
{ 
# 923
if ((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) { 
# 924
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 926
_M_insert_aux(this->end(), __x); }  
# 927
} 
# 930
void swap(::std::vector< bool, _Alloc>  &__x) 
# 934
{ 
# 935
::std::swap(((this->_M_impl)._M_start), ((__x._M_impl)._M_start)); 
# 936
::std::swap(((this->_M_impl)._M_finish), ((__x._M_impl)._M_finish)); 
# 937
::std::swap(((this->_M_impl)._M_end_of_storage), ((__x._M_impl)._M_end_of_storage)); 
# 939
_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(), (__x._M_get_Bit_allocator())); 
# 941
} 
# 945
static void swap(reference __x, reference __y) 
# 946
{ 
# 947
bool __tmp = __x; 
# 948
(__x = __y); 
# 949
(__y = __tmp); 
# 950
} 
# 956
iterator insert(iterator __position, const bool &__x = ((bool)0)) 
# 958
{ 
# 959
const difference_type __n = (__position - (this->begin())); 
# 960
if (((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) && (__position == (this->end()))) { 
# 962
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 964
_M_insert_aux(__position._M_const_cast(), __x); }  
# 965
return ((this->begin()) + __n); 
# 966
} 
# 981
template< class _InputIterator> void 
# 983
insert(iterator __position, _InputIterator 
# 984
__first, _InputIterator __last) 
# 985
{ 
# 986
typedef typename __is_integer< _InputIterator> ::__type _Integral; 
# 987
_M_insert_dispatch(__position, __first, __last, _Integral()); 
# 988
} 
# 1001
void insert(iterator __position, size_type __n, const bool &__x) 
# 1002
{ _M_fill_insert(__position, __n, __x); } 
# 1012
void pop_back() 
# 1013
{ --((this->_M_impl)._M_finish); } 
# 1019
iterator erase(iterator __position) 
# 1021
{ return this->_M_erase(__position._M_const_cast()); } 
# 1027
iterator erase(iterator __first, iterator __last) 
# 1029
{ return this->_M_erase(__first._M_const_cast(), __last._M_const_cast()); } 
# 1032
void resize(size_type __new_size, bool __x = ((bool)0)) 
# 1033
{ 
# 1034
if (__new_size < size()) { 
# 1035
_M_erase_at_end(((this->begin()) + ((difference_type)__new_size))); } else { 
# 1037
insert(this->end(), __new_size - size(), __x); }  
# 1038
} 
# 1047
void flip() 
# 1048
{ 
# 1049
::std::_Bit_type *const __end = ((this->_M_impl)._M_end_addr()); 
# 1050
for (::std::_Bit_type *__p = ((((this->_M_impl)._M_start)._M_p)); __p != __end; ++__p) { 
# 1051
(*__p) = (~(*__p)); }  
# 1052
} 
# 1055
void clear() 
# 1056
{ _M_erase_at_end(this->begin()); } 
# 1073
protected: iterator _M_copy_aligned(const_iterator __first, const_iterator __last, iterator 
# 1074
__result) 
# 1075
{ 
# 1076
::std::_Bit_type *__q = std::copy(__first._M_p, __last._M_p, __result._M_p); 
# 1077
return std::copy(const_iterator(__last._M_p, 0), __last, iterator(__q, 0)); 
# 1079
} 
# 1082
void _M_initialize(size_type __n) 
# 1083
{ 
# 1084
_Bit_pointer __q = (this->_M_allocate(__n)); 
# 1085
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 1086
((this->_M_impl)._M_start) = iterator(::std::__addressof(*__q), 0); 
# 1087
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + ((difference_type)__n)); 
# 1088
} 
# 1091
void _M_reallocate(size_type __n); 
# 1102
template< class _Integer> void 
# 1104
_M_initialize_dispatch(_Integer __n, _Integer __x, ::std::__true_type) 
# 1105
{ 
# 1106
_M_initialize(static_cast< size_type>(__n)); 
# 1107
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), (__x) ? ~0 : 0); 
# 1109
} 
# 1111
template< class _InputIterator> void 
# 1113
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1115
{ _M_initialize_range(__first, __last, ::std::__iterator_category(__first)); 
# 1116
} 
# 1118
template< class _InputIterator> void 
# 1120
_M_initialize_range(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 1122
{ 
# 1123
for (; __first != __last; ++__first) { 
# 1124
push_back(*__first); }  
# 1125
} 
# 1127
template< class _ForwardIterator> void 
# 1129
_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 1131
{ 
# 1132
const size_type __n = ::std::distance(__first, __last); 
# 1133
_M_initialize(__n); 
# 1134
::std::copy(__first, __last, ((this->_M_impl)._M_start)); 
# 1135
} 
# 1139
template< class _Integer> void 
# 1141
_M_assign_dispatch(_Integer __n, _Integer __val, ::std::__true_type) 
# 1142
{ _M_fill_assign(__n, __val); } 
# 1144
template< class _InputIterator> void 
# 1146
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, ::std::__false_type) 
# 1148
{ _M_assign_aux(__first, __last, ::std::__iterator_category(__first)); } 
# 1151
void _M_fill_assign(::std::size_t __n, bool __x) 
# 1152
{ 
# 1153
if (__n > size()) 
# 1154
{ 
# 1155
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __x ? ~0 : 0); 
# 1157
insert(this->end(), __n - size(), __x); 
# 1158
} else 
# 1160
{ 
# 1161
_M_erase_at_end(((this->begin()) + __n)); 
# 1162
::std::fill((((this->_M_impl)._M_start)._M_p), ((this->_M_impl)._M_end_addr()), __x ? ~0 : 0); 
# 1164
}  
# 1165
} 
# 1167
template< class _InputIterator> void 
# 1169
_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 1171
{ 
# 1172
iterator __cur = this->begin(); 
# 1173
for (; (__first != __last) && (__cur != (this->end())); (++__cur), (++__first)) { 
# 1174
(*__cur) = (*__first); }  
# 1175
if (__first == __last) { 
# 1176
_M_erase_at_end(__cur); } else { 
# 1178
insert(this->end(), __first, __last); }  
# 1179
} 
# 1181
template< class _ForwardIterator> void 
# 1183
_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 1185
{ 
# 1186
const size_type __len = ::std::distance(__first, __last); 
# 1187
if (__len < size()) { 
# 1188
_M_erase_at_end(::std::copy(__first, __last, this->begin())); } else 
# 1190
{ 
# 1191
_ForwardIterator __mid = __first; 
# 1192
::std::advance(__mid, size()); 
# 1193
::std::copy(__first, __mid, this->begin()); 
# 1194
insert(this->end(), __mid, __last); 
# 1195
}  
# 1196
} 
# 1202
template< class _Integer> void 
# 1204
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, ::std::__true_type) 
# 1206
{ _M_fill_insert(__pos, __n, __x); } 
# 1208
template< class _InputIterator> void 
# 1210
_M_insert_dispatch(iterator __pos, _InputIterator 
# 1211
__first, _InputIterator __last, ::std::__false_type) 
# 1213
{ _M_insert_range(__pos, __first, __last, ::std::__iterator_category(__first)); 
# 1214
} 
# 1217
void _M_fill_insert(iterator __position, size_type __n, bool __x); 
# 1219
template< class _InputIterator> void 
# 1221
_M_insert_range(iterator __pos, _InputIterator __first, _InputIterator 
# 1222
__last, ::std::input_iterator_tag) 
# 1223
{ 
# 1224
for (; __first != __last; ++__first) 
# 1225
{ 
# 1226
__pos = insert(__pos, *__first); 
# 1227
(++__pos); 
# 1228
}  
# 1229
} 
# 1231
template< class _ForwardIterator> void _M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag); 
# 1237
void _M_insert_aux(iterator __position, bool __x); 
# 1240
size_type _M_check_len(size_type __n, const char *__s) const 
# 1241
{ 
# 1242
if ((max_size() - size()) < __n) { 
# 1243
__throw_length_error(__s); }  
# 1245
const size_type __len = size() + ::std::max(size(), __n); 
# 1246
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1247
} 
# 1250
void _M_erase_at_end(iterator __pos) 
# 1251
{ ((this->_M_impl)._M_finish) = __pos; } 
# 1254
iterator _M_erase(iterator __pos); 
# 1257
iterator _M_erase(iterator __first, iterator __last); 
# 1258
}; 
# 1261
}
# 59 "/usr/include/c++/5/bits/vector.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
template< class _Tp, class _Alloc> void 
# 66
vector< _Tp, _Alloc> ::reserve(size_type __n) 
# 67
{ 
# 68
if (__n > this->max_size()) { 
# 69
__throw_length_error("vector::reserve"); }  
# 70
if (this->capacity() < __n) 
# 71
{ 
# 72
const size_type __old_size = size(); 
# 73
pointer __tmp = _M_allocate_and_copy(__n, ((this->_M_impl)._M_start), ((this->_M_impl)._M_finish)); 
# 76
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 78
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 81
((this->_M_impl)._M_start) = __tmp; 
# 82
((this->_M_impl)._M_finish) = (__tmp + __old_size); 
# 83
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 84
}  
# 85
} 
# 105
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 111
vector< _Tp, _Alloc> ::insert(iterator __position, const value_type &__x) 
# 113
{ 
# 114
const size_type __n = __position - this->begin(); 
# 115
if ((((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) && (__position == this->end())) 
# 117
{ 
# 118
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 119
++((this->_M_impl)._M_finish); 
# 120
} else 
# 122
{ 
# 133
_M_insert_aux(__position, __x); 
# 135
}  
# 136
return ((iterator)(((this->_M_impl)._M_start) + __n)); 
# 137
} 
# 139
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 142
vector< _Tp, _Alloc> ::_M_erase(iterator __position) 
# 143
{ 
# 144
if ((__position + 1) != this->end()) { 
# 145
::std::copy(__position + 1, this->end(), __position); }  
# 146
--((this->_M_impl)._M_finish); 
# 147
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 148
return __position; 
# 149
} 
# 151
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 154
vector< _Tp, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 155
{ 
# 156
if (__first != __last) 
# 157
{ 
# 158
if (__last != this->end()) { 
# 159
::std::copy(__last, this->end(), __first); }  
# 160
_M_erase_at_end((__first.base()) + (this->end() - __last)); 
# 161
}  
# 162
return __first; 
# 163
} 
# 165
template< class _Tp, class _Alloc> vector< _Tp, _Alloc>  &
# 168
vector< _Tp, _Alloc> ::operator=(const vector &__x) 
# 169
{ 
# 170
if ((&__x) != this) 
# 171
{ 
# 191
const size_type __xlen = __x.size(); 
# 192
if (__xlen > capacity()) 
# 193
{ 
# 194
pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); 
# 196
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 198
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 201
((this->_M_impl)._M_start) = __tmp; 
# 202
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __xlen); 
# 203
} else { 
# 204
if (size() >= __xlen) 
# 205
{ 
# 206
::std::_Destroy(::std::copy(__x.begin(), __x.end(), this->begin()), this->end(), _M_get_Tp_allocator()); 
# 208
} else 
# 210
{ 
# 211
::std::copy(((__x._M_impl)._M_start), ((__x._M_impl)._M_start) + size(), ((this->_M_impl)._M_start)); 
# 213
::std::__uninitialized_copy_a(((__x._M_impl)._M_start) + size(), ((__x._M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 217
}  }  
# 218
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __xlen); 
# 219
}  
# 220
return *this; 
# 221
} 
# 223
template< class _Tp, class _Alloc> void 
# 226
vector< _Tp, _Alloc> ::_M_fill_assign(::std::size_t __n, const value_type &__val) 
# 227
{ 
# 228
if (__n > capacity()) 
# 229
{ 
# 230
vector __tmp(__n, __val, _M_get_Tp_allocator()); 
# 231
((__tmp._M_impl)._M_swap_data((this->_M_impl))); 
# 232
} else { 
# 233
if (__n > size()) 
# 234
{ 
# 235
::std::fill(this->begin(), this->end(), __val); 
# 236
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __n - size(), __val, _M_get_Tp_allocator()); 
# 240
} else { 
# 242
_M_erase_at_end(::std::fill_n(((this->_M_impl)._M_start), __n, __val)); }  }  
# 243
} 
# 245
template< class _Tp, class _Alloc> 
# 246
template< class _InputIterator> void 
# 249
vector< _Tp, _Alloc> ::_M_assign_aux(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag) 
# 251
{ 
# 252
pointer __cur(((this->_M_impl)._M_start)); 
# 253
for (; (__first != __last) && (__cur != ((this->_M_impl)._M_finish)); (++__cur), (++__first)) { 
# 255
(*__cur) = (*__first); }  
# 256
if (__first == __last) { 
# 257
_M_erase_at_end(__cur); } else { 
# 259
insert(this->end(), __first, __last); }  
# 260
} 
# 262
template< class _Tp, class _Alloc> 
# 263
template< class _ForwardIterator> void 
# 266
vector< _Tp, _Alloc> ::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, ::std::forward_iterator_tag) 
# 268
{ 
# 269
const size_type __len = ::std::distance(__first, __last); 
# 271
if (__len > capacity()) 
# 272
{ 
# 273
pointer __tmp(_M_allocate_and_copy(__len, __first, __last)); 
# 274
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 276
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 279
((this->_M_impl)._M_start) = __tmp; 
# 280
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __len); 
# 281
((this->_M_impl)._M_end_of_storage) = ((this->_M_impl)._M_finish); 
# 282
} else { 
# 283
if (size() >= __len) { 
# 284
_M_erase_at_end(::std::copy(__first, __last, ((this->_M_impl)._M_start))); } else 
# 286
{ 
# 287
_ForwardIterator __mid = __first; 
# 288
::std::advance(__mid, size()); 
# 289
::std::copy(__first, __mid, ((this->_M_impl)._M_start)); 
# 290
((this->_M_impl)._M_finish) = ::std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 294
}  }  
# 295
} 
# 324
template< class _Tp, class _Alloc> void 
# 327
vector< _Tp, _Alloc> ::_M_insert_aux(iterator __position, const _Tp &__x) 
# 329
{ 
# 330
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 331
{ 
# 332
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), *(((this->_M_impl)._M_finish) - 1)); 
# 335
++((this->_M_impl)._M_finish); 
# 337
_Tp __x_copy = __x; 
# 339
::std::copy_backward((__position.base()), ((this->_M_impl)._M_finish) - 2, ((this->_M_impl)._M_finish) - 1); 
# 343
(*__position) = __x_copy; 
# 347
} else 
# 349
{ 
# 350
const size_type __len = _M_check_len((size_type)1, "vector::_M_insert_aux"); 
# 352
const size_type __elems_before = __position - this->begin(); 
# 353
pointer __new_start((this->_M_allocate(__len))); 
# 354
pointer __new_finish(__new_start); 
# 355
try 
# 356
{ 
# 361
_Alloc_traits::construct((this->_M_impl), __new_start + __elems_before, __x); 
# 368
__new_finish = pointer(); 
# 370
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 375
++__new_finish; 
# 377
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 381
} 
# 382
catch (...) 
# 383
{ 
# 384
if (!__new_finish) { 
# 385
_Alloc_traits::destroy((this->_M_impl), __new_start + __elems_before); } else { 
# 388
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 389
_M_deallocate(__new_start, __len); 
# 390
throw; 
# 391
}  
# 392
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 394
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 397
((this->_M_impl)._M_start) = __new_start; 
# 398
((this->_M_impl)._M_finish) = __new_finish; 
# 399
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 400
}  
# 401
} 
# 447
template< class _Tp, class _Alloc> void 
# 450
vector< _Tp, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, const value_type &__x) 
# 451
{ 
# 452
if (__n != (0)) 
# 453
{ 
# 454
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 456
{ 
# 457
value_type __x_copy = __x; 
# 458
const size_type __elems_after = this->end() - __position; 
# 459
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 460
if (__elems_after > __n) 
# 461
{ 
# 462
::std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 466
((this->_M_impl)._M_finish) += __n; 
# 467
::std::copy_backward((__position.base()), __old_finish - __n, __old_finish); 
# 469
::std::fill((__position.base()), (__position.base()) + __n, __x_copy); 
# 471
} else 
# 473
{ 
# 474
((this->_M_impl)._M_finish) = ::std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __n - __elems_after, __x_copy, _M_get_Tp_allocator()); 
# 479
::std::__uninitialized_move_a((__position.base()), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 482
((this->_M_impl)._M_finish) += __elems_after; 
# 483
::std::fill((__position.base()), __old_finish, __x_copy); 
# 484
}  
# 485
} else 
# 487
{ 
# 488
const size_type __len = _M_check_len(__n, "vector::_M_fill_insert"); 
# 490
const size_type __elems_before = __position - this->begin(); 
# 491
pointer __new_start((this->_M_allocate(__len))); 
# 492
pointer __new_finish(__new_start); 
# 493
try 
# 494
{ 
# 496
::std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, _M_get_Tp_allocator()); 
# 499
__new_finish = pointer(); 
# 501
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 506
__new_finish += __n; 
# 508
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 512
} 
# 513
catch (...) 
# 514
{ 
# 515
if (!__new_finish) { 
# 516
::std::_Destroy(__new_start + __elems_before, (__new_start + __elems_before) + __n, _M_get_Tp_allocator()); } else { 
# 520
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 522
_M_deallocate(__new_start, __len); 
# 523
throw; 
# 524
}  
# 525
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 527
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 530
((this->_M_impl)._M_start) = __new_start; 
# 531
((this->_M_impl)._M_finish) = __new_finish; 
# 532
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 533
}  
# 534
}  
# 535
} 
# 599
template< class _Tp, class _Alloc> 
# 600
template< class _InputIterator> void 
# 603
vector< _Tp, _Alloc> ::_M_range_insert(iterator __pos, _InputIterator __first, _InputIterator 
# 604
__last, ::std::input_iterator_tag) 
# 605
{ 
# 606
for (; __first != __last; ++__first) 
# 607
{ 
# 608
__pos = insert(__pos, *__first); 
# 609
++__pos; 
# 610
}  
# 611
} 
# 613
template< class _Tp, class _Alloc> 
# 614
template< class _ForwardIterator> void 
# 617
vector< _Tp, _Alloc> ::_M_range_insert(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 618
__last, ::std::forward_iterator_tag) 
# 619
{ 
# 620
if (__first != __last) 
# 621
{ 
# 622
const size_type __n = ::std::distance(__first, __last); 
# 623
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 625
{ 
# 626
const size_type __elems_after = this->end() - __position; 
# 627
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 628
if (__elems_after > __n) 
# 629
{ 
# 630
::std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 634
((this->_M_impl)._M_finish) += __n; 
# 635
::std::copy_backward((__position.base()), __old_finish - __n, __old_finish); 
# 637
::std::copy(__first, __last, __position); 
# 638
} else 
# 640
{ 
# 641
_ForwardIterator __mid = __first; 
# 642
::std::advance(__mid, __elems_after); 
# 643
::std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 646
((this->_M_impl)._M_finish) += (__n - __elems_after); 
# 647
::std::__uninitialized_move_a((__position.base()), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 651
((this->_M_impl)._M_finish) += __elems_after; 
# 652
::std::copy(__first, __mid, __position); 
# 653
}  
# 654
} else 
# 656
{ 
# 657
const size_type __len = _M_check_len(__n, "vector::_M_range_insert"); 
# 659
pointer __new_start((this->_M_allocate(__len))); 
# 660
pointer __new_finish(__new_start); 
# 661
try 
# 662
{ 
# 663
__new_finish = ::std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), (__position.base()), __new_start, _M_get_Tp_allocator()); 
# 667
__new_finish = ::std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator()); 
# 671
__new_finish = ::std::__uninitialized_move_if_noexcept_a((__position.base()), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 675
} 
# 676
catch (...) 
# 677
{ 
# 678
::std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); 
# 680
_M_deallocate(__new_start, __len); 
# 681
throw; 
# 682
}  
# 683
::std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 685
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 688
((this->_M_impl)._M_start) = __new_start; 
# 689
((this->_M_impl)._M_finish) = __new_finish; 
# 690
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 691
}  
# 692
}  
# 693
} 
# 697
template< class _Alloc> void 
# 700
vector< bool, _Alloc> ::_M_reallocate(size_type __n) 
# 701
{ 
# 702
_Bit_pointer __q = (this->_M_allocate(__n)); 
# 703
iterator __start(::std::__addressof(*__q), 0); 
# 704
((this->_M_impl)._M_finish) = _M_copy_aligned(this->begin(), this->end(), __start); 
# 705
(this->_M_deallocate()); 
# 706
((this->_M_impl)._M_start) = __start; 
# 707
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 708
} 
# 710
template< class _Alloc> void 
# 713
vector< bool, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, bool __x) 
# 714
{ 
# 715
if (__n == (0)) { 
# 716
return; }  
# 717
if ((capacity() - size()) >= __n) 
# 718
{ 
# 719
::std::copy_backward(__position, this->end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 721
std::fill(__position, (__position + ((difference_type)__n)), __x); 
# 722
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 723
} else 
# 725
{ 
# 726
const size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert"); 
# 728
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 729
iterator __start(::std::__addressof(*__q), 0); 
# 730
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 731
std::fill(__i, (__i + ((difference_type)__n)), __x); 
# 732
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), (__i + ((difference_type)__n))); 
# 734
(this->_M_deallocate()); 
# 735
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 736
((this->_M_impl)._M_start) = __start; 
# 737
}  
# 738
} 
# 740
template< class _Alloc> 
# 741
template< class _ForwardIterator> void 
# 744
vector< bool, _Alloc> ::_M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 745
__last, ::std::forward_iterator_tag) 
# 746
{ 
# 747
if (__first != __last) 
# 748
{ 
# 749
size_type __n = ::std::distance(__first, __last); 
# 750
if ((capacity() - size()) >= __n) 
# 751
{ 
# 752
::std::copy_backward(__position, this->end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 755
::std::copy(__first, __last, __position); 
# 756
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 757
} else 
# 759
{ 
# 760
const size_type __len = _M_check_len(__n, "vector<bool>::_M_insert_range"); 
# 762
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 763
iterator __start(::std::__addressof(*__q), 0); 
# 764
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 765
__i = ::std::copy(__first, __last, __i); 
# 766
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), __i); 
# 767
(this->_M_deallocate()); 
# 768
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 769
((this->_M_impl)._M_start) = __start; 
# 770
}  
# 771
}  
# 772
} 
# 774
template< class _Alloc> void 
# 777
vector< bool, _Alloc> ::_M_insert_aux(iterator __position, bool __x) 
# 778
{ 
# 779
if ((((this->_M_impl)._M_finish)._M_p) != ((this->_M_impl)._M_end_addr())) 
# 780
{ 
# 781
::std::copy_backward(__position, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish) + 1); 
# 783
(((*__position)) = __x); 
# 784
++((this->_M_impl)._M_finish); 
# 785
} else 
# 787
{ 
# 788
const size_type __len = _M_check_len((size_type)1, "vector<bool>::_M_insert_aux"); 
# 790
_Bit_pointer __q = (this->_M_allocate(__len)); 
# 791
iterator __start(::std::__addressof(*__q), 0); 
# 792
iterator __i = _M_copy_aligned(this->begin(), __position, __start); 
# 793
(((*(__i++))) = __x); 
# 794
((this->_M_impl)._M_finish) = ::std::copy(__position, this->end(), __i); 
# 795
(this->_M_deallocate()); 
# 796
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 797
((this->_M_impl)._M_start) = __start; 
# 798
}  
# 799
} 
# 801
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 804
vector< bool, _Alloc> ::_M_erase(iterator __position) 
# 805
{ 
# 806
if ((((__position + (1))) != (this->end()))) { 
# 807
::std::copy((__position + (1)), this->end(), __position); }  
# 808
--((this->_M_impl)._M_finish); 
# 809
return __position; 
# 810
} 
# 812
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 815
vector< bool, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 816
{ 
# 817
if ((__first != __last)) { 
# 818
_M_erase_at_end(::std::copy(__last, this->end(), __first)); }  
# 819
return __first; 
# 820
} 
# 841
}
# 32 "/usr/local/cuda/include/thrust/detail/vector_base.h"
namespace thrust { 
# 35
namespace detail { 
# 38
template< class T, class Alloc> 
# 39
class vector_base { 
# 42
typedef contiguous_storage< T, Alloc>  storage_type; 
# 46
public: typedef typename contiguous_storage< T, Alloc> ::value_type value_type; 
# 47
typedef typename contiguous_storage< T, Alloc> ::pointer pointer; 
# 48
typedef typename contiguous_storage< T, Alloc> ::const_pointer const_pointer; 
# 49
typedef typename contiguous_storage< T, Alloc> ::reference reference; 
# 50
typedef typename contiguous_storage< T, Alloc> ::const_reference const_reference; 
# 51
typedef typename contiguous_storage< T, Alloc> ::size_type size_type; 
# 52
typedef typename contiguous_storage< T, Alloc> ::difference_type difference_type; 
# 53
typedef typename contiguous_storage< T, Alloc> ::allocator_type allocator_type; 
# 55
typedef typename contiguous_storage< T, Alloc> ::iterator iterator; 
# 56
typedef typename contiguous_storage< T, Alloc> ::const_iterator const_iterator; 
# 58
typedef thrust::reverse_iterator< typename contiguous_storage< T, Alloc> ::iterator>  reverse_iterator; 
# 59
typedef thrust::reverse_iterator< typename contiguous_storage< T, Alloc> ::const_iterator>  const_reverse_iterator; 
# 63
vector_base(); 
# 69
explicit vector_base(size_type n); 
# 76
explicit vector_base(size_type n, const value_type & value); 
# 81
vector_base(const vector_base & v); 
# 86
vector_base &operator=(const vector_base & v); 
# 92
template< class OtherT, class OtherAlloc> vector_base(const detail::vector_base< OtherT, OtherAlloc>  & v); 
# 99
template< class OtherT, class OtherAlloc> vector_base &operator=(const detail::vector_base< OtherT, OtherAlloc>  & v); 
# 108
template< class OtherT, class OtherAlloc> vector_base(const std::vector< OtherT, OtherAlloc>  & v); 
# 117
template< class OtherT, class OtherAlloc> vector_base &operator=(const std::vector< OtherT, OtherAlloc>  & v); 
# 124
template< class InputIterator> vector_base(InputIterator first, InputIterator last); 
# 129
~vector_base(); 
# 140
void resize(size_type new_size); 
# 152
void resize(size_type new_size, const value_type & x); 
# 156
size_type size() const; 
# 161
size_type max_size() const; 
# 169
void reserve(size_type n); 
# 174
size_type capacity() const; 
# 179
void shrink_to_fit(); 
# 189
reference operator[](size_type n); 
# 199
const_reference operator[](size_type n) const; 
# 205
iterator begin(); 
# 211
const_iterator begin() const; 
# 217
const_iterator cbegin() const; 
# 224
reverse_iterator rbegin(); 
# 231
const_reverse_iterator rbegin() const; 
# 238
const_reverse_iterator crbegin() const; 
# 244
iterator end(); 
# 250
const_iterator end() const; 
# 256
const_iterator cend() const; 
# 262
reverse_iterator rend(); 
# 268
const_reverse_iterator rend() const; 
# 274
const_reverse_iterator crend() const; 
# 280
const_reference front() const; 
# 286
reference front(); 
# 292
const_reference back() const; 
# 298
reference back(); 
# 303
pointer data(); 
# 308
const_pointer data() const; 
# 312
void clear(); 
# 317
bool empty() const; 
# 322
void push_back(const value_type & x); 
# 327
void pop_back(); 
# 332
void swap(vector_base & v); 
# 339
iterator erase(iterator pos); 
# 347
iterator erase(iterator first, iterator last); 
# 355
iterator insert(iterator position, const T & x); 
# 363
void insert(iterator position, size_type n, const T & x); 
# 374
template< class InputIterator> void insert(iterator position, InputIterator first, InputIterator last); 
# 382
void assign(size_type n, const T & x); 
# 390
template< class InputIterator> void assign(InputIterator first, InputIterator last); 
# 396
allocator_type get_allocator() const; 
# 400
protected: storage_type m_storage; 
# 403
size_type m_size; 
# 407
private: template< class IteratorOrIntegralType> void init_dispatch(IteratorOrIntegralType begin, IteratorOrIntegralType end, false_type); 
# 410
template< class IteratorOrIntegralType> void init_dispatch(IteratorOrIntegralType n, IteratorOrIntegralType value, true_type); 
# 413
template< class InputIterator> void range_init(InputIterator first, InputIterator last); 
# 416
template< class InputIterator> void range_init(InputIterator first, InputIterator last, incrementable_traversal_tag); 
# 419
template< class ForwardIterator> void range_init(ForwardIterator first, ForwardIterator last, random_access_traversal_tag); 
# 422
void default_init(size_type n); 
# 424
void fill_init(size_type n, const T & x); 
# 427
template< class InputIteratorOrIntegralType> void insert_dispatch(iterator position, InputIteratorOrIntegralType first, InputIteratorOrIntegralType last, false_type); 
# 431
template< class InputIteratorOrIntegralType> void insert_dispatch(iterator position, InputIteratorOrIntegralType n, InputIteratorOrIntegralType x, true_type); 
# 435
void append(size_type n); 
# 438
void fill_insert(iterator position, size_type n, const T & x); 
# 441
template< class InputIterator> void copy_insert(iterator position, InputIterator first, InputIterator last); 
# 445
template< class InputIterator> void assign_dispatch(InputIterator first, InputIterator last, false_type); 
# 449
template< class Integral> void assign_dispatch(Integral n, Integral x, true_type); 
# 453
template< class InputIterator> void range_assign(InputIterator first, InputIterator last); 
# 457
template< class RandomAccessIterator> void range_assign(RandomAccessIterator first, RandomAccessIterator last, random_access_traversal_tag); 
# 461
template< class InputIterator> void range_assign(InputIterator first, InputIterator last, incrementable_traversal_tag); 
# 465
void fill_assign(size_type n, const T & x); 
# 468
template< class ForwardIterator> void allocate_and_copy(size_type requested_size, ForwardIterator first, ForwardIterator last, storage_type & new_storage); 
# 472
}; 
# 474
}
# 484
template< class T, class Alloc> void swap(detail::vector_base< T, Alloc>  & a, detail::vector_base< T, Alloc>  & b); 
# 495
template< class T1, class Alloc1, class 
# 496
T2, class Alloc2> bool 
# 495
operator==(const detail::vector_base< T1, Alloc1>  & lhs, const detail::vector_base< T2, Alloc2>  & rhs); 
# 500
template< class T1, class Alloc1, class 
# 501
T2, class Alloc2> bool 
# 500
operator==(const detail::vector_base< T1, Alloc1>  & lhs, const std::vector< T2, Alloc2>  & rhs); 
# 505
template< class T1, class Alloc1, class 
# 506
T2, class Alloc2> bool 
# 505
operator==(const std::vector< T1, Alloc1>  & lhs, const detail::vector_base< T2, Alloc2>  & rhs); 
# 516
template< class T1, class Alloc1, class 
# 517
T2, class Alloc2> bool 
# 516
operator!=(const detail::vector_base< T1, Alloc1>  & lhs, const detail::vector_base< T2, Alloc2>  & rhs); 
# 521
template< class T1, class Alloc1, class 
# 522
T2, class Alloc2> bool 
# 521
operator!=(const detail::vector_base< T1, Alloc1>  & lhs, const std::vector< T2, Alloc2>  & rhs); 
# 526
template< class T1, class Alloc1, class 
# 527
T2, class Alloc2> bool 
# 526
operator!=(const std::vector< T1, Alloc1>  & lhs, const detail::vector_base< T2, Alloc2>  & rhs); 
# 531
}
# 26 "/usr/local/cuda/include/thrust/detail/overlapped_copy.h"
namespace thrust { 
# 28
namespace detail { 
# 32
template< class InputIterator, class 
# 33
OutputIterator> OutputIterator 
# 34
sequential_copy(InputIterator first, InputIterator 
# 35
last, OutputIterator 
# 36
result) 
# 37
{ 
# 38
for (; first != last; (++first), (++result)) 
# 39
{ 
# 40
(*result) = (*first); 
# 41
}  
# 43
return result; 
# 44
} 
# 47
template< class BidirectionalIterator1, class 
# 48
BidirectionalIterator2> BidirectionalIterator2 
# 49
sequential_copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 
# 50
last, BidirectionalIterator2 
# 51
result) 
# 52
{ 
# 55
while (first != last) 
# 56
{ 
# 57
(*(--result)) = (*(--last)); 
# 58
}  
# 60
return result; 
# 61
} 
# 64
namespace dispatch { 
# 68
template< class DerivedPolicy, class 
# 69
RandomAccessIterator1, class 
# 70
RandomAccessIterator2> RandomAccessIterator2 
# 71
overlapped_copy(system::cpp::detail::execution_policy< DerivedPolicy>  &, RandomAccessIterator1 
# 72
first, RandomAccessIterator1 
# 73
last, RandomAccessIterator2 
# 74
result) 
# 75
{ 
# 76
if ((first < last) && (first <= result) && (result < last)) 
# 77
{ 
# 80
detail::sequential_copy_backward(first, last, result + (last - first)); 
# 81
result += (last - first); 
# 82
} else 
# 84
{ 
# 87
result = detail::sequential_copy(first, last, result); 
# 88
}  
# 90
return result; 
# 91
} 
# 94
template< class DerivedPolicy, class 
# 95
RandomAccessIterator1, class 
# 96
RandomAccessIterator2> RandomAccessIterator2 
# 97
overlapped_copy(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator1 
# 98
first, RandomAccessIterator1 
# 99
last, RandomAccessIterator2 
# 100
result) 
# 101
{ 
# 102
typedef typename iterator_value< RandomAccessIterator1> ::type value_type; 
# 105
temporary_array< typename iterator_value< RandomAccessIterator1> ::type, DerivedPolicy>  temp(exec, first, last); 
# 106
return thrust::copy(exec, (temp.begin()), (temp.end()), result); 
# 107
} 
# 109
}
# 112
template< class RandomAccessIterator1, class 
# 113
RandomAccessIterator2> RandomAccessIterator2 
# 114
overlapped_copy(RandomAccessIterator1 first, RandomAccessIterator1 
# 115
last, RandomAccessIterator2 
# 116
result) 
# 117
{ 
# 118
typedef typename iterator_system< RandomAccessIterator2> ::type System1; 
# 119
typedef typename iterator_system< RandomAccessIterator2> ::type System2; 
# 121
typedef typename minimum_system< typename iterator_system< RandomAccessIterator2> ::type, typename iterator_system< RandomAccessIterator2> ::type> ::type System; 
# 124
System system; 
# 126
return dispatch::overlapped_copy(system, first, last, result); 
# 127
} 
# 129
}
# 130
}
# 27 "/usr/local/cuda/include/thrust/equal.h"
namespace thrust { 
# 79
template< class DerivedPolicy, class InputIterator1, class InputIterator2> bool equal(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 119
template< class InputIterator1, class InputIterator2> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 175
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> bool equal(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred); 
# 225
template< class InputIterator1, class InputIterator2, class 
# 226
BinaryPredicate> bool 
# 225
equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred); 
# 235
}
# 22 "/usr/local/cuda/include/thrust/system/detail/generic/equal.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace generic { 
# 32
template< class DerivedPolicy, class InputIterator1, class InputIterator2> bool equal(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 37
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> bool equal(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred); 
# 42
}
# 43
}
# 44
}
# 45
}
# 28 "/usr/local/cuda/include/thrust/mismatch.h"
namespace thrust { 
# 89
template< class DerivedPolicy, class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  mismatch(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 140
template< class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 195
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  mismatch(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred); 
# 248
template< class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred); 
# 257
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/mismatch.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  mismatch(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2); 
# 42
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  mismatch(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred); 
# 52
}
# 53
}
# 54
}
# 55
}
# 27 "/usr/local/cuda/include/thrust/find.h"
namespace thrust { 
# 79
template< class DerivedPolicy, class InputIterator, class T> InputIterator find(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, const T & value); 
# 121
template< class InputIterator, class T> InputIterator find(InputIterator first, InputIterator last, const T & value); 
# 186
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator find_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, Predicate pred); 
# 247
template< class InputIterator, class Predicate> InputIterator find_if(InputIterator first, InputIterator last, Predicate pred); 
# 312
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator find_if_not(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, Predicate pred); 
# 373
template< class InputIterator, class Predicate> InputIterator find_if_not(InputIterator first, InputIterator last, Predicate pred); 
# 382
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/find.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator, class T> InputIterator find(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, const T & value); 
# 41
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator find_if(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, Predicate pred); 
# 49
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator find_if_not(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, Predicate pred); 
# 57
}
# 58
}
# 59
}
# 60
}
# 29 "/usr/local/cuda/include/thrust/reduce.h"
namespace thrust { 
# 82
template< class DerivedPolicy, class InputIterator> typename iterator_traits< InputIterator> ::value_type reduce(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last); 
# 127
template< class InputIterator> typename iterator_traits< InputIterator> ::value_type reduce(InputIterator first, InputIterator last); 
# 176
template< class DerivedPolicy, class InputIterator, class T> T reduce(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, T init); 
# 223
template< class InputIterator, class T> T reduce(InputIterator first, InputIterator last, T init); 
# 281
template< class DerivedPolicy, class 
# 282
InputIterator, class 
# 283
T, class 
# 284
BinaryFunction> T 
# 281
reduce(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, T init, BinaryFunction binary_op); 
# 338
template< class InputIterator, class 
# 339
T, class 
# 340
BinaryFunction> T 
# 338
reduce(InputIterator first, InputIterator last, T init, BinaryFunction binary_op); 
# 402
template< class DerivedPolicy, class 
# 403
InputIterator1, class 
# 404
InputIterator2, class 
# 405
OutputIterator1, class 
# 406
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 402
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output); 
# 466
template< class InputIterator1, class 
# 467
InputIterator2, class 
# 468
OutputIterator1, class 
# 469
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 466
reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output); 
# 536
template< class DerivedPolicy, class 
# 537
InputIterator1, class 
# 538
InputIterator2, class 
# 539
OutputIterator1, class 
# 540
OutputIterator2, class 
# 541
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 536
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred); 
# 605
template< class InputIterator1, class 
# 606
InputIterator2, class 
# 607
OutputIterator1, class 
# 608
OutputIterator2, class 
# 609
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 605
reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred); 
# 684
template< class DerivedPolicy, class 
# 685
InputIterator1, class 
# 686
InputIterator2, class 
# 687
OutputIterator1, class 
# 688
OutputIterator2, class 
# 689
BinaryPredicate, class 
# 690
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 684
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op); 
# 762
template< class InputIterator1, class 
# 763
InputIterator2, class 
# 764
OutputIterator1, class 
# 765
OutputIterator2, class 
# 766
BinaryPredicate, class 
# 767
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 762
reduce_by_key(InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op); 
# 782
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/reduce.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 34
template< class DerivedPolicy, class InputIterator> typename iterator_traits< InputIterator> ::value_type reduce(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last); 
# 40
template< class DerivedPolicy, class InputIterator, class T> T reduce(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, T init); 
# 45
template< class DerivedPolicy, class 
# 46
InputIterator, class 
# 47
T, class 
# 48
BinaryFunction> T 
# 45
reduce(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, T init, BinaryFunction binary_op); 
# 53
}
# 54
}
# 55
}
# 56
}
# 25 "/usr/local/cuda/include/thrust/system/detail/generic/reduce.inl"
namespace thrust { 
# 27
namespace system { 
# 29
namespace detail { 
# 31
namespace generic { 
# 35
template< class ExecutionPolicy, class InputIterator> typename iterator_traits< InputIterator> ::value_type 
# 38
reduce(execution_policy< ExecutionPolicy>  &exec, InputIterator first, InputIterator last) 
# 39
{ 
# 40
typedef typename iterator_value< InputIterator> ::type InputType; 
# 43
return thrust::reduce(exec, first, last, (InputType)0); 
# 44
} 
# 47
template< class ExecutionPolicy, class InputIterator, class T> T 
# 49
reduce(execution_policy< ExecutionPolicy>  &exec, InputIterator first, InputIterator last, T init) 
# 50
{ 
# 52
return thrust::reduce(exec, first, last, init, plus< T> ()); 
# 53
} 
# 56
template< class ExecutionPolicy, class 
# 57
RandomAccessIterator, class 
# 58
OutputType, class 
# 59
BinaryFunction> OutputType 
# 61
reduce(execution_policy< ExecutionPolicy>  &exec, RandomAccessIterator 
# 62
first, RandomAccessIterator 
# 63
last, OutputType 
# 64
init, BinaryFunction 
# 65
binary_op) 
# 66
{ 
# 68
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< RandomAccessIterator, false> ::value)> )>  thrust_static_assert_typedef_68 __attribute((unused)); 
# 69
return OutputType(); 
# 70
} 
# 73
}
# 74
}
# 75
}
# 76
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/reduce_by_key.h"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 34
template< class DerivedPolicy, class 
# 35
InputIterator1, class 
# 36
InputIterator2, class 
# 37
OutputIterator1, class 
# 38
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 34
reduce_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output); 
# 48
template< class DerivedPolicy, class 
# 49
InputIterator1, class 
# 50
InputIterator2, class 
# 51
OutputIterator1, class 
# 52
OutputIterator2, class 
# 53
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 48
reduce_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred); 
# 64
template< class DerivedPolicy, class 
# 65
InputIterator1, class 
# 66
InputIterator2, class 
# 67
OutputIterator1, class 
# 68
OutputIterator2, class 
# 69
BinaryPredicate, class 
# 70
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 64
reduce_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op); 
# 83
}
# 84
}
# 85
}
# 86
}
# 27 "/usr/local/cuda/include/thrust/scatter.h"
namespace thrust { 
# 89
template< class DerivedPolicy, class 
# 90
InputIterator1, class 
# 91
InputIterator2, class 
# 92
RandomAccessIterator> void 
# 89
scatter(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator result); 
# 147
template< class InputIterator1, class 
# 148
InputIterator2, class 
# 149
RandomAccessIterator> void 
# 147
scatter(InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator result); 
# 203
template< class DerivedPolicy, class 
# 204
InputIterator1, class 
# 205
InputIterator2, class 
# 206
InputIterator3, class 
# 207
RandomAccessIterator> void 
# 203
scatter_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output); 
# 259
template< class InputIterator1, class 
# 260
InputIterator2, class 
# 261
InputIterator3, class 
# 262
RandomAccessIterator> void 
# 259
scatter_if(InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output); 
# 331
template< class DerivedPolicy, class 
# 332
InputIterator1, class 
# 333
InputIterator2, class 
# 334
InputIterator3, class 
# 335
RandomAccessIterator, class 
# 336
Predicate> void 
# 331
scatter_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred); 
# 403
template< class InputIterator1, class 
# 404
InputIterator2, class 
# 405
InputIterator3, class 
# 406
RandomAccessIterator, class 
# 407
Predicate> void 
# 403
scatter_if(InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred); 
# 420
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/scatter.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator1, class 
# 35
InputIterator2, class 
# 36
RandomAccessIterator> void 
# 33
scatter(execution_policy< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator output); 
# 45
template< class DerivedPolicy, class 
# 46
InputIterator1, class 
# 47
InputIterator2, class 
# 48
InputIterator3, class 
# 49
RandomAccessIterator> void 
# 45
scatter_if(execution_policy< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output); 
# 59
template< class DerivedPolicy, class 
# 60
InputIterator1, class 
# 61
InputIterator2, class 
# 62
InputIterator3, class 
# 63
RandomAccessIterator, class 
# 64
Predicate> void 
# 59
scatter_if(execution_policy< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred); 
# 75
}
# 76
}
# 77
}
# 78
}
# 24 "/usr/local/cuda/include/thrust/system/detail/generic/scatter.inl"
namespace thrust { 
# 26
namespace system { 
# 28
namespace detail { 
# 30
namespace generic { 
# 34
template< class DerivedPolicy, class 
# 35
InputIterator1, class 
# 36
InputIterator2, class 
# 37
RandomAccessIterator> void 
# 39
scatter(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 40
first, InputIterator1 
# 41
last, InputIterator2 
# 42
map, RandomAccessIterator 
# 43
output) 
# 44
{ 
# 45
thrust::transform(exec, first, last, thrust::make_permutation_iterator(output, map), identity< typename iterator_value< InputIterator1> ::type> ()); 
# 50
} 
# 53
template< class DerivedPolicy, class 
# 54
InputIterator1, class 
# 55
InputIterator2, class 
# 56
InputIterator3, class 
# 57
RandomAccessIterator> void 
# 59
scatter_if(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 60
first, InputIterator1 
# 61
last, InputIterator2 
# 62
map, InputIterator3 
# 63
stencil, RandomAccessIterator 
# 64
output) 
# 65
{ 
# 67
typedef typename iterator_value< InputIterator3> ::type StencilType; 
# 68
thrust::scatter_if(exec, first, last, map, stencil, output, identity< typename iterator_value< InputIterator3> ::type> ()); 
# 69
} 
# 72
template< class DerivedPolicy, class 
# 73
InputIterator1, class 
# 74
InputIterator2, class 
# 75
InputIterator3, class 
# 76
RandomAccessIterator, class 
# 77
Predicate> void 
# 79
scatter_if(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 80
first, InputIterator1 
# 81
last, InputIterator2 
# 82
map, InputIterator3 
# 83
stencil, RandomAccessIterator 
# 84
output, Predicate 
# 85
pred) 
# 86
{ 
# 87
typedef typename iterator_value< InputIterator1> ::type InputType; 
# 88
thrust::transform_if(exec, first, last, stencil, thrust::make_permutation_iterator(output, map), identity< typename iterator_value< InputIterator1> ::type> (), pred); 
# 89
} 
# 92
}
# 93
}
# 94
}
# 95
}
# 28 "/usr/local/cuda/include/thrust/detail/scatter.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator1, class 
# 35
InputIterator2, class 
# 36
RandomAccessIterator> void 
# 38
scatter(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 39
first, InputIterator1 
# 40
last, InputIterator2 
# 41
map, RandomAccessIterator 
# 42
output) 
# 43
{ 
# 44
using system::detail::generic::scatter;
# 45
return scatter(detail::derived_cast(detail::strip_const(exec)), first, last, map, output); 
# 46
} 
# 50
template< class DerivedPolicy, class 
# 51
InputIterator1, class 
# 52
InputIterator2, class 
# 53
InputIterator3, class 
# 54
RandomAccessIterator> void 
# 56
scatter_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 57
first, InputIterator1 
# 58
last, InputIterator2 
# 59
map, InputIterator3 
# 60
stencil, RandomAccessIterator 
# 61
output) 
# 62
{ 
# 63
using system::detail::generic::scatter_if;
# 64
return scatter_if(detail::derived_cast(detail::strip_const(exec)), first, last, map, stencil, output); 
# 65
} 
# 69
template< class DerivedPolicy, class 
# 70
InputIterator1, class 
# 71
InputIterator2, class 
# 72
InputIterator3, class 
# 73
RandomAccessIterator, class 
# 74
Predicate> void 
# 76
scatter_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 77
first, InputIterator1 
# 78
last, InputIterator2 
# 79
map, InputIterator3 
# 80
stencil, RandomAccessIterator 
# 81
output, Predicate 
# 82
pred) 
# 83
{ 
# 84
using system::detail::generic::scatter_if;
# 85
return scatter_if(detail::derived_cast(detail::strip_const(exec)), first, last, map, stencil, output, pred); 
# 86
} 
# 89
template< class InputIterator1, class 
# 90
InputIterator2, class 
# 91
RandomAccessIterator> void 
# 92
scatter(InputIterator1 first, InputIterator1 
# 93
last, InputIterator2 
# 94
map, RandomAccessIterator 
# 95
output) 
# 96
{ 
# 97
using system::detail::generic::select_system;
# 99
typedef typename iterator_system< InputIterator1> ::type System1; 
# 100
typedef typename iterator_system< InputIterator2> ::type System2; 
# 101
typedef typename iterator_system< RandomAccessIterator> ::type System3; 
# 103
System1 system1; 
# 104
System2 system2; 
# 105
System3 system3; 
# 107
return thrust::scatter(select_system(system1, system2, system3), first, last, map, output); 
# 108
} 
# 111
template< class InputIterator1, class 
# 112
InputIterator2, class 
# 113
InputIterator3, class 
# 114
RandomAccessIterator> void 
# 115
scatter_if(InputIterator1 first, InputIterator1 
# 116
last, InputIterator2 
# 117
map, InputIterator3 
# 118
stencil, RandomAccessIterator 
# 119
output) 
# 120
{ 
# 121
using system::detail::generic::select_system;
# 123
typedef typename iterator_system< InputIterator1> ::type System1; 
# 124
typedef typename iterator_system< InputIterator2> ::type System2; 
# 125
typedef typename iterator_system< InputIterator3> ::type System3; 
# 126
typedef typename iterator_system< RandomAccessIterator> ::type System4; 
# 128
System1 system1; 
# 129
System2 system2; 
# 130
System3 system3; 
# 131
System4 system4; 
# 133
return thrust::scatter_if(select_system(system1, system2, system3, system4), first, last, map, stencil, output); 
# 134
} 
# 137
template< class InputIterator1, class 
# 138
InputIterator2, class 
# 139
InputIterator3, class 
# 140
RandomAccessIterator, class 
# 141
Predicate> void 
# 142
scatter_if(InputIterator1 first, InputIterator1 
# 143
last, InputIterator2 
# 144
map, InputIterator3 
# 145
stencil, RandomAccessIterator 
# 146
output, Predicate 
# 147
pred) 
# 148
{ 
# 149
using system::detail::generic::select_system;
# 151
typedef typename iterator_system< InputIterator1> ::type System1; 
# 152
typedef typename iterator_system< InputIterator2> ::type System2; 
# 153
typedef typename iterator_system< InputIterator3> ::type System3; 
# 154
typedef typename iterator_system< RandomAccessIterator> ::type System4; 
# 156
System1 system1; 
# 157
System2 system2; 
# 158
System3 system3; 
# 159
System4 system4; 
# 161
return thrust::scatter_if(select_system(system1, system2, system3, system4), first, last, map, stencil, output, pred); 
# 162
} 
# 165
}
# 27 "/usr/local/cuda/include/thrust/scan.h"
namespace thrust { 
# 93
template< class DerivedPolicy, class 
# 94
InputIterator, class 
# 95
OutputIterator> OutputIterator 
# 93
inclusive_scan(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 148
template< class InputIterator, class 
# 149
OutputIterator> OutputIterator 
# 148
inclusive_scan(InputIterator first, InputIterator last, OutputIterator result); 
# 203
template< class DerivedPolicy, class 
# 204
InputIterator, class 
# 205
OutputIterator, class 
# 206
AssociativeOperator> OutputIterator 
# 203
inclusive_scan(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op); 
# 258
template< class InputIterator, class 
# 259
OutputIterator, class 
# 260
AssociativeOperator> OutputIterator 
# 258
inclusive_scan(InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op); 
# 313
template< class DerivedPolicy, class 
# 314
InputIterator, class 
# 315
OutputIterator> OutputIterator 
# 313
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 362
template< class InputIterator, class 
# 363
OutputIterator> OutputIterator 
# 362
exclusive_scan(InputIterator first, InputIterator last, OutputIterator result); 
# 414
template< class DerivedPolicy, class 
# 415
InputIterator, class 
# 416
OutputIterator, class 
# 417
T> OutputIterator 
# 414
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, T init); 
# 465
template< class InputIterator, class 
# 466
OutputIterator, class 
# 467
T> OutputIterator 
# 465
exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init); 
# 528
template< class DerivedPolicy, class 
# 529
InputIterator, class 
# 530
OutputIterator, class 
# 531
T, class 
# 532
AssociativeOperator> OutputIterator 
# 528
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op); 
# 589
template< class InputIterator, class 
# 590
OutputIterator, class 
# 591
T, class 
# 592
AssociativeOperator> OutputIterator 
# 589
exclusive_scan(InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op); 
# 663
template< class DerivedPolicy, class 
# 664
InputIterator1, class 
# 665
InputIterator2, class 
# 666
OutputIterator> OutputIterator 
# 663
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 725
template< class InputIterator1, class 
# 726
InputIterator2, class 
# 727
OutputIterator> OutputIterator 
# 725
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 796
template< class DerivedPolicy, class 
# 797
InputIterator1, class 
# 798
InputIterator2, class 
# 799
OutputIterator, class 
# 800
BinaryPredicate> OutputIterator 
# 796
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred); 
# 865
template< class InputIterator1, class 
# 866
InputIterator2, class 
# 867
OutputIterator, class 
# 868
BinaryPredicate> OutputIterator 
# 865
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred); 
# 943
template< class DerivedPolicy, class 
# 944
InputIterator1, class 
# 945
InputIterator2, class 
# 946
OutputIterator, class 
# 947
BinaryPredicate, class 
# 948
AssociativeOperator> OutputIterator 
# 943
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 1019
template< class InputIterator1, class 
# 1020
InputIterator2, class 
# 1021
OutputIterator, class 
# 1022
BinaryPredicate, class 
# 1023
AssociativeOperator> OutputIterator 
# 1019
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 1079
template< class DerivedPolicy, class 
# 1080
InputIterator1, class 
# 1081
InputIterator2, class 
# 1082
OutputIterator> OutputIterator 
# 1079
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 1132
template< class InputIterator1, class 
# 1133
InputIterator2, class 
# 1134
OutputIterator> OutputIterator 
# 1132
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 1187
template< class DerivedPolicy, class 
# 1188
InputIterator1, class 
# 1189
InputIterator2, class 
# 1190
OutputIterator, class 
# 1191
T> OutputIterator 
# 1187
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init); 
# 1241
template< class InputIterator1, class 
# 1242
InputIterator2, class 
# 1243
OutputIterator, class 
# 1244
T> OutputIterator 
# 1241
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init); 
# 1306
template< class DerivedPolicy, class 
# 1307
InputIterator1, class 
# 1308
InputIterator2, class 
# 1309
OutputIterator, class 
# 1310
T, class 
# 1311
BinaryPredicate> OutputIterator 
# 1306
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred); 
# 1370
template< class InputIterator1, class 
# 1371
InputIterator2, class 
# 1372
OutputIterator, class 
# 1373
T, class 
# 1374
BinaryPredicate> OutputIterator 
# 1370
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred); 
# 1455
template< class DerivedPolicy, class 
# 1456
InputIterator1, class 
# 1457
InputIterator2, class 
# 1458
OutputIterator, class 
# 1459
T, class 
# 1460
BinaryPredicate, class 
# 1461
AssociativeOperator> OutputIterator 
# 1455
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 1538
template< class InputIterator1, class 
# 1539
InputIterator2, class 
# 1540
OutputIterator, class 
# 1541
T, class 
# 1542
BinaryPredicate, class 
# 1543
AssociativeOperator> OutputIterator 
# 1538
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 1561
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/scan.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class ExecutionPolicy, class 
# 34
InputIterator, class 
# 35
OutputIterator> OutputIterator 
# 33
inclusive_scan(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 44
template< class ExecutionPolicy, class 
# 45
InputIterator, class 
# 46
OutputIterator, class 
# 47
BinaryFunction> OutputIterator 
# 44
inclusive_scan(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op); 
# 56
template< class ExecutionPolicy, class 
# 57
InputIterator, class 
# 58
OutputIterator> OutputIterator 
# 56
exclusive_scan(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result); 
# 66
template< class ExecutionPolicy, class 
# 67
InputIterator, class 
# 68
OutputIterator, class 
# 69
T> OutputIterator 
# 66
exclusive_scan(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, T init); 
# 79
template< class ExecutionPolicy, class 
# 80
InputIterator, class 
# 81
OutputIterator, class 
# 82
T, class 
# 83
BinaryFunction> OutputIterator 
# 79
exclusive_scan(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, T init, BinaryFunction binary_op); 
# 93
}
# 94
}
# 95
}
# 96
}
# 29 "/usr/local/cuda/include/thrust/system/detail/generic/scan.inl"
namespace thrust { 
# 31
namespace system { 
# 33
namespace detail { 
# 35
namespace generic { 
# 39
template< class ExecutionPolicy, class 
# 40
InputIterator, class 
# 41
OutputIterator> OutputIterator 
# 43
inclusive_scan(execution_policy< ExecutionPolicy>  &exec, InputIterator 
# 44
first, InputIterator 
# 45
last, OutputIterator 
# 46
result) 
# 47
{ 
# 59
typedef typename thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > ::type ValueType; 
# 62
return thrust::inclusive_scan(exec, first, last, result, plus< typename thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > ::type> ()); 
# 63
} 
# 66
template< class ExecutionPolicy, class 
# 67
InputIterator, class 
# 68
OutputIterator> OutputIterator 
# 70
exclusive_scan(execution_policy< ExecutionPolicy>  &exec, InputIterator 
# 71
first, InputIterator 
# 72
last, OutputIterator 
# 73
result) 
# 74
{ 
# 86
typedef typename thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > ::type ValueType; 
# 89
return thrust::exclusive_scan(exec, first, last, result, (ValueType)0); 
# 90
} 
# 93
template< class ExecutionPolicy, class 
# 94
InputIterator, class 
# 95
OutputIterator, class 
# 96
T> OutputIterator 
# 98
exclusive_scan(execution_policy< ExecutionPolicy>  &exec, InputIterator 
# 99
first, InputIterator 
# 100
last, OutputIterator 
# 101
result, T 
# 102
init) 
# 103
{ 
# 105
return thrust::exclusive_scan(exec, first, last, result, init, plus< T> ()); 
# 106
} 
# 109
template< class ExecutionPolicy, class 
# 110
InputIterator, class 
# 111
OutputIterator, class 
# 112
BinaryFunction> OutputIterator 
# 114
inclusive_scan(execution_policy< ExecutionPolicy>  &exec, InputIterator 
# 115
first, InputIterator 
# 116
last, OutputIterator 
# 117
result, BinaryFunction 
# 118
binary_op) 
# 119
{ 
# 121
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, false> ::value)> )>  thrust_static_assert_typedef_121 __attribute((unused)); 
# 122
return result; 
# 123
} 
# 126
template< class ExecutionPolicy, class 
# 127
InputIterator, class 
# 128
OutputIterator, class 
# 129
T, class 
# 130
BinaryFunction> OutputIterator 
# 132
exclusive_scan(execution_policy< ExecutionPolicy>  &exec, InputIterator 
# 133
first, InputIterator 
# 134
last, OutputIterator 
# 135
result, T 
# 136
init, BinaryFunction 
# 137
binary_op) 
# 138
{ 
# 140
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, false> ::value)> )>  thrust_static_assert_typedef_140 __attribute((unused)); 
# 141
return result; 
# 142
} 
# 145
}
# 146
}
# 147
}
# 148
}
# 27 "/usr/local/cuda/include/thrust/system/detail/generic/scan_by_key.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace detail { 
# 33
namespace generic { 
# 37
template< class DerivedPolicy, class 
# 38
InputIterator1, class 
# 39
InputIterator2, class 
# 40
OutputIterator> OutputIterator 
# 37
inclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 49
template< class DerivedPolicy, class 
# 50
InputIterator1, class 
# 51
InputIterator2, class 
# 52
OutputIterator, class 
# 53
BinaryPredicate> OutputIterator 
# 49
inclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred); 
# 63
template< class DerivedPolicy, class 
# 64
InputIterator1, class 
# 65
InputIterator2, class 
# 66
OutputIterator, class 
# 67
BinaryPredicate, class 
# 68
AssociativeOperator> OutputIterator 
# 63
inclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 79
template< class DerivedPolicy, class 
# 80
InputIterator1, class 
# 81
InputIterator2, class 
# 82
OutputIterator> OutputIterator 
# 79
exclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result); 
# 91
template< class DerivedPolicy, class 
# 92
InputIterator1, class 
# 93
InputIterator2, class 
# 94
OutputIterator, class 
# 95
T> OutputIterator 
# 91
exclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init); 
# 105
template< class DerivedPolicy, class 
# 106
InputIterator1, class 
# 107
InputIterator2, class 
# 108
OutputIterator, class 
# 109
T, class 
# 110
BinaryPredicate> OutputIterator 
# 105
exclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred); 
# 121
template< class DerivedPolicy, class 
# 122
InputIterator1, class 
# 123
InputIterator2, class 
# 124
OutputIterator, class 
# 125
T, class 
# 126
BinaryPredicate, class 
# 127
AssociativeOperator> OutputIterator 
# 121
exclusive_scan_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op); 
# 138
}
# 139
}
# 140
}
# 141
}
# 27 "/usr/local/cuda/include/thrust/replace.h"
namespace thrust { 
# 86
template< class DerivedPolicy, class ForwardIterator, class T> void replace(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, const T & old_value, const T & new_value); 
# 136
template< class ForwardIterator, class T> void replace(ForwardIterator first, ForwardIterator last, const T & old_value, const T & new_value); 
# 200
template< class DerivedPolicy, class ForwardIterator, class Predicate, class T> void replace_if(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, Predicate pred, const T & new_value); 
# 261
template< class ForwardIterator, class Predicate, class T> void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T & new_value); 
# 334
template< class DerivedPolicy, class ForwardIterator, class InputIterator, class Predicate, class T> void replace_if(const detail::execution_policy_base< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T & new_value); 
# 404
template< class ForwardIterator, class InputIterator, class Predicate, class T> void replace_if(ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T & new_value); 
# 463
template< class DerivedPolicy, class InputIterator, class OutputIterator, class T> OutputIterator replace_copy(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, const T & old_value, const T & new_value); 
# 519
template< class InputIterator, class OutputIterator, class T> OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T & old_value, const T & new_value); 
# 588
template< class DerivedPolicy, class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T & new_value); 
# 655
template< class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T & new_value); 
# 732
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T & new_value); 
# 807
template< class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T & new_value); 
# 820
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/replace.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T & new_value); 
# 43
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator replace_copy_if(execution_policy< DerivedPolicy>  & exec, InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T & new_value); 
# 54
template< class DerivedPolicy, class InputIterator, class OutputIterator, class T> OutputIterator replace_copy(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, const T & old_value, const T & new_value); 
# 64
template< class DerivedPolicy, class ForwardIterator, class Predicate, class T> void replace_if(execution_policy< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, Predicate pred, const T & new_value); 
# 73
template< class DerivedPolicy, class ForwardIterator, class InputIterator, class Predicate, class T> void replace_if(execution_policy< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T & new_value); 
# 83
template< class DerivedPolicy, class ForwardIterator, class T> void replace(execution_policy< DerivedPolicy>  & exec, ForwardIterator first, ForwardIterator last, const T & old_value, const T & new_value); 
# 92
}
# 93
}
# 94
}
# 95
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/replace.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 31
namespace detail { 
# 37
template< class Predicate, class NewType, class OutputType> 
# 38
struct new_value_if { 
# 41
new_value_if(Predicate p, NewType nv) : pred(p), new_value(nv) { } 
# 43
template< class InputType> OutputType 
# 45
operator()(const InputType &x) const 
# 46
{ 
# 47
return ((pred)(x)) ? new_value : x; 
# 48
} 
# 52
template< class InputType, class PredicateArgumentType> OutputType 
# 54
operator()(const InputType &x, const PredicateArgumentType &y) 
# 55
{ 
# 56
return ((pred)(y)) ? new_value : x; 
# 57
} 
# 59
Predicate pred; 
# 60
NewType new_value; 
# 61
}; 
# 65
template< class T> 
# 66
struct constant_unary { 
# 69
constant_unary(T _c) : c(_c) { } 
# 71
template< class U> T 
# 73
operator()(U &x) 
# 74
{ 
# 75
return c; 
# 76
} 
# 78
T c; 
# 79
}; 
# 82
}
# 85
template< class DerivedPolicy, class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator 
# 87
replace_copy_if(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 88
first, InputIterator 
# 89
last, OutputIterator 
# 90
result, Predicate 
# 91
pred, const T &
# 92
new_value) 
# 93
{ 
# 94
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 96
detail::new_value_if< Predicate, T, typename iterator_traits< OutputIterator> ::value_type>  op(pred, new_value); 
# 97
return thrust::transform(exec, first, last, result, op); 
# 98
} 
# 101
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator 
# 103
replace_copy_if(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 104
first, InputIterator1 
# 105
last, InputIterator2 
# 106
stencil, OutputIterator 
# 107
result, Predicate 
# 108
pred, const T &
# 109
new_value) 
# 110
{ 
# 111
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 113
detail::new_value_if< Predicate, T, typename iterator_traits< OutputIterator> ::value_type>  op(pred, new_value); 
# 114
return thrust::transform(exec, first, last, stencil, result, op); 
# 115
} 
# 118
template< class DerivedPolicy, class InputIterator, class OutputIterator, class T> OutputIterator 
# 120
replace_copy(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 121
first, InputIterator 
# 122
last, OutputIterator 
# 123
result, const T &
# 124
old_value, const T &
# 125
new_value) 
# 126
{ 
# 127
thrust::detail::equal_to_value< T>  pred(old_value); 
# 128
return thrust::replace_copy_if(exec, first, last, result, pred, new_value); 
# 129
} 
# 132
template< class DerivedPolicy, class ForwardIterator, class Predicate, class T> void 
# 134
replace_if(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 135
first, ForwardIterator 
# 136
last, Predicate 
# 137
pred, const T &
# 138
new_value) 
# 139
{ 
# 140
detail::constant_unary< T>  f(new_value); 
# 141
thrust::transform_if(exec, first, last, first, first, f, pred); 
# 142
} 
# 145
template< class DerivedPolicy, class ForwardIterator, class InputIterator, class Predicate, class T> void 
# 147
replace_if(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 148
first, ForwardIterator 
# 149
last, InputIterator 
# 150
stencil, Predicate 
# 151
pred, const T &
# 152
new_value) 
# 153
{ 
# 154
detail::constant_unary< T>  f(new_value); 
# 155
thrust::transform_if(exec, first, last, stencil, first, f, pred); 
# 156
} 
# 159
template< class DerivedPolicy, class ForwardIterator, class T> void 
# 161
replace(execution_policy< DerivedPolicy>  &exec, ForwardIterator 
# 162
first, ForwardIterator 
# 163
last, const T &
# 164
old_value, const T &
# 165
new_value) 
# 166
{ 
# 167
thrust::detail::equal_to_value< T>  pred(old_value); 
# 168
return thrust::replace_if(exec, first, last, pred, new_value); 
# 169
} 
# 172
}
# 173
}
# 174
}
# 175
}
# 29 "/usr/local/cuda/include/thrust/detail/replace.inl"
namespace thrust { 
# 34
template< class DerivedPolicy, class ForwardIterator, class T> void 
# 36
replace(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 37
first, ForwardIterator last, const T &
# 38
old_value, const T &
# 39
new_value) 
# 40
{ 
# 41
using system::detail::generic::replace;
# 42
return replace(detail::derived_cast(detail::strip_const(exec)), first, last, old_value, new_value); 
# 43
} 
# 47
template< class DerivedPolicy, class ForwardIterator, class Predicate, class T> void 
# 49
replace_if(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 50
first, ForwardIterator last, Predicate 
# 51
pred, const T &
# 52
new_value) 
# 53
{ 
# 54
using system::detail::generic::replace_if;
# 55
return replace_if(detail::derived_cast(detail::strip_const(exec)), first, last, pred, new_value); 
# 56
} 
# 60
template< class DerivedPolicy, class ForwardIterator, class InputIterator, class Predicate, class T> void 
# 62
replace_if(const detail::execution_policy_base< DerivedPolicy>  &exec, ForwardIterator 
# 63
first, ForwardIterator last, InputIterator 
# 64
stencil, Predicate 
# 65
pred, const T &
# 66
new_value) 
# 67
{ 
# 68
using system::detail::generic::replace_if;
# 69
return replace_if(detail::derived_cast(detail::strip_const(exec)), first, last, stencil, pred, new_value); 
# 70
} 
# 74
template< class DerivedPolicy, class InputIterator, class OutputIterator, class T> OutputIterator 
# 76
replace_copy(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 77
first, InputIterator last, OutputIterator 
# 78
result, const T &
# 79
old_value, const T &
# 80
new_value) 
# 81
{ 
# 82
using system::detail::generic::replace_copy;
# 83
return replace_copy(detail::derived_cast(detail::strip_const(exec)), first, last, result, old_value, new_value); 
# 84
} 
# 88
template< class DerivedPolicy, class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator 
# 90
replace_copy_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 91
first, InputIterator last, OutputIterator 
# 92
result, Predicate 
# 93
pred, const T &
# 94
new_value) 
# 95
{ 
# 96
using system::detail::generic::replace_copy_if;
# 97
return replace_copy_if(detail::derived_cast(detail::strip_const(exec)), first, last, result, pred, new_value); 
# 98
} 
# 102
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator 
# 104
replace_copy_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 105
first, InputIterator1 last, InputIterator2 
# 106
stencil, OutputIterator 
# 107
result, Predicate 
# 108
pred, const T &
# 109
new_value) 
# 110
{ 
# 111
using system::detail::generic::replace_copy_if;
# 112
return replace_copy_if(detail::derived_cast(detail::strip_const(exec)), first, last, stencil, result, pred, new_value); 
# 113
} 
# 116
template< class InputIterator, class OutputIterator, class Predicate, class T> OutputIterator 
# 117
replace_copy_if(InputIterator first, InputIterator last, OutputIterator 
# 118
result, Predicate 
# 119
pred, const T &
# 120
new_value) 
# 121
{ 
# 122
using system::detail::generic::select_system;
# 124
typedef typename iterator_system< InputIterator> ::type System1; 
# 125
typedef typename iterator_system< OutputIterator> ::type System2; 
# 127
System1 system1; 
# 128
System2 system2; 
# 130
return thrust::replace_copy_if(select_system(system1, system2), first, last, result, pred, new_value); 
# 131
} 
# 134
template< class InputIterator1, class InputIterator2, class OutputIterator, class Predicate, class T> OutputIterator 
# 135
replace_copy_if(InputIterator1 first, InputIterator1 last, InputIterator2 
# 136
stencil, OutputIterator 
# 137
result, Predicate 
# 138
pred, const T &
# 139
new_value) 
# 140
{ 
# 141
using system::detail::generic::select_system;
# 143
typedef typename iterator_system< InputIterator1> ::type System1; 
# 144
typedef typename iterator_system< InputIterator2> ::type System2; 
# 145
typedef typename iterator_system< OutputIterator> ::type System3; 
# 147
System1 system1; 
# 148
System2 system2; 
# 149
System3 system3; 
# 151
return thrust::replace_copy_if(select_system(system1, system2, system3), first, last, stencil, result, pred, new_value); 
# 152
} 
# 155
template< class InputIterator, class OutputIterator, class T> OutputIterator 
# 156
replace_copy(InputIterator first, InputIterator last, OutputIterator 
# 157
result, const T &
# 158
old_value, const T &
# 159
new_value) 
# 160
{ 
# 161
using system::detail::generic::select_system;
# 163
typedef typename iterator_system< InputIterator> ::type System1; 
# 164
typedef typename iterator_system< OutputIterator> ::type System2; 
# 166
System1 system1; 
# 167
System2 system2; 
# 169
return thrust::replace_copy(select_system(system1, system2), first, last, result, old_value, new_value); 
# 170
} 
# 173
template< class ForwardIterator, class Predicate, class T> void 
# 174
replace_if(ForwardIterator first, ForwardIterator last, Predicate 
# 175
pred, const T &
# 176
new_value) 
# 177
{ 
# 178
using thrust::system::detail::generic::select_system;
# 180
typedef typename iterator_system< ForwardIterator> ::type System; 
# 182
System system; 
# 184
return thrust::replace_if(select_system(system), first, last, pred, new_value); 
# 185
} 
# 188
template< class ForwardIterator, class InputIterator, class Predicate, class T> void 
# 189
replace_if(ForwardIterator first, ForwardIterator last, InputIterator 
# 190
stencil, Predicate 
# 191
pred, const T &
# 192
new_value) 
# 193
{ 
# 194
using system::detail::generic::select_system;
# 196
typedef typename iterator_system< ForwardIterator> ::type System1; 
# 197
typedef typename iterator_system< InputIterator> ::type System2; 
# 199
System1 system1; 
# 200
System2 system2; 
# 202
return thrust::replace_if(select_system(system1, system2), first, last, stencil, pred, new_value); 
# 203
} 
# 206
template< class ForwardIterator, class T> void 
# 207
replace(ForwardIterator first, ForwardIterator last, const T &
# 208
old_value, const T &
# 209
new_value) 
# 210
{ 
# 211
using thrust::system::detail::generic::select_system;
# 213
typedef typename iterator_system< ForwardIterator> ::type System; 
# 215
System system; 
# 217
return thrust::replace(select_system(system), first, last, old_value, new_value); 
# 218
} 
# 221
}
# 29 "/usr/local/cuda/include/thrust/system/detail/generic/scan_by_key.inl"
namespace thrust { 
# 31
namespace system { 
# 33
namespace detail { 
# 35
namespace generic { 
# 37
namespace detail { 
# 41
template< class OutputType, class HeadFlagType, class AssociativeOperator> 
# 42
struct segmented_scan_functor { 
# 44
AssociativeOperator binary_op; 
# 46
typedef tuple< OutputType, HeadFlagType, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  result_type; 
# 49
segmented_scan_functor(AssociativeOperator _binary_op) : binary_op(_binary_op) { } 
# 52
result_type operator()(result_type a, result_type b) 
# 53
{ 
# 54
return result_type((thrust::get< 1> (b)) ? thrust::get< 0> (b) : (binary_op)(thrust::get< 0> (a), thrust::get< 0> (b)), thrust::get< 1> (a) | thrust::get< 1> (b)); 
# 56
} 
# 57
}; 
# 60
}
# 63
template< class DerivedPolicy, class 
# 64
InputIterator1, class 
# 65
InputIterator2, class 
# 66
OutputIterator> OutputIterator 
# 68
inclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 69
first1, InputIterator1 
# 70
last1, InputIterator2 
# 71
first2, OutputIterator 
# 72
result) 
# 73
{ 
# 74
typedef typename iterator_traits< InputIterator1> ::value_type InputType1; 
# 75
return thrust::inclusive_scan_by_key(exec, first1, last1, first2, result, equal_to< typename iterator_traits< InputIterator1> ::value_type> ()); 
# 76
} 
# 79
template< class DerivedPolicy, class 
# 80
InputIterator1, class 
# 81
InputIterator2, class 
# 82
OutputIterator, class 
# 83
BinaryPredicate> OutputIterator 
# 85
inclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 86
first1, InputIterator1 
# 87
last1, InputIterator2 
# 88
first2, OutputIterator 
# 89
result, BinaryPredicate 
# 90
binary_pred) 
# 91
{ 
# 92
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 93
return thrust::inclusive_scan_by_key(exec, first1, last1, first2, result, binary_pred, plus< typename iterator_traits< OutputIterator> ::value_type> ()); 
# 94
} 
# 97
template< class DerivedPolicy, class 
# 98
InputIterator1, class 
# 99
InputIterator2, class 
# 100
OutputIterator, class 
# 101
BinaryPredicate, class 
# 102
AssociativeOperator> OutputIterator 
# 104
inclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 105
first1, InputIterator1 
# 106
last1, InputIterator2 
# 107
first2, OutputIterator 
# 108
result, BinaryPredicate 
# 109
binary_pred, AssociativeOperator 
# 110
binary_op) 
# 111
{ 
# 112
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 113
typedef unsigned HeadFlagType; 
# 115
const size_t n = last1 - first1; 
# 117
if (n != (0)) 
# 118
{ 
# 120
thrust::detail::temporary_array< unsigned, DerivedPolicy>  flags(exec, n); 
# 121
(flags[0]) = 1; thrust::transform(exec, first1, last1 - 1, first1 + 1, (flags.begin()) + 1, thrust::detail::not2(binary_pred)); 
# 128
thrust::inclusive_scan(exec, thrust::make_zip_iterator(thrust::make_tuple(first2, (flags.begin()))), thrust::make_zip_iterator(thrust::make_tuple(first2, (flags.begin()))) + n, thrust::make_zip_iterator(thrust::make_tuple(result, (flags.begin()))), ((detail::segmented_scan_functor< typename iterator_traits< OutputIterator> ::value_type, unsigned, AssociativeOperator> )(binary_op))); 
# 133
}  
# 135
return result + n; 
# 136
} 
# 139
template< class DerivedPolicy, class 
# 140
InputIterator1, class 
# 141
InputIterator2, class 
# 142
OutputIterator> OutputIterator 
# 144
exclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 145
first1, InputIterator1 
# 146
last1, InputIterator2 
# 147
first2, OutputIterator 
# 148
result) 
# 149
{ 
# 150
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 151
return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, (OutputType)0); 
# 152
} 
# 155
template< class DerivedPolicy, class 
# 156
InputIterator1, class 
# 157
InputIterator2, class 
# 158
OutputIterator, class 
# 159
T> OutputIterator 
# 161
exclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 162
first1, InputIterator1 
# 163
last1, InputIterator2 
# 164
first2, OutputIterator 
# 165
result, T 
# 166
init) 
# 167
{ 
# 168
typedef typename iterator_traits< InputIterator1> ::value_type InputType1; 
# 169
return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, init, equal_to< typename iterator_traits< InputIterator1> ::value_type> ()); 
# 170
} 
# 173
template< class DerivedPolicy, class 
# 174
InputIterator1, class 
# 175
InputIterator2, class 
# 176
OutputIterator, class 
# 177
T, class 
# 178
BinaryPredicate> OutputIterator 
# 180
exclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 181
first1, InputIterator1 
# 182
last1, InputIterator2 
# 183
first2, OutputIterator 
# 184
result, T 
# 185
init, BinaryPredicate 
# 186
binary_pred) 
# 187
{ 
# 188
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 189
return thrust::exclusive_scan_by_key(exec, first1, last1, first2, result, init, binary_pred, plus< typename iterator_traits< OutputIterator> ::value_type> ()); 
# 190
} 
# 193
template< class DerivedPolicy, class 
# 194
InputIterator1, class 
# 195
InputIterator2, class 
# 196
OutputIterator, class 
# 197
T, class 
# 198
BinaryPredicate, class 
# 199
AssociativeOperator> OutputIterator 
# 201
exclusive_scan_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 202
first1, InputIterator1 
# 203
last1, InputIterator2 
# 204
first2, OutputIterator 
# 205
result, T 
# 206
init, BinaryPredicate 
# 207
binary_pred, AssociativeOperator 
# 208
binary_op) 
# 209
{ 
# 210
typedef typename iterator_traits< OutputIterator> ::value_type OutputType; 
# 211
typedef unsigned HeadFlagType; 
# 213
const size_t n = last1 - first1; 
# 215
if (n != (0)) 
# 216
{ 
# 217
InputIterator2 last2 = first2 + n; 
# 220
thrust::detail::temporary_array< unsigned, DerivedPolicy>  flags(exec, n); 
# 221
(flags[0]) = 1; thrust::transform(exec, first1, last1 - 1, first1 + 1, (flags.begin()) + 1, thrust::detail::not2(binary_pred)); 
# 224
thrust::detail::temporary_array< typename iterator_traits< OutputIterator> ::value_type, DerivedPolicy>  temp(exec, n); 
# 225
thrust::replace_copy_if(exec, first2, last2 - 1, (flags.begin()) + 1, (temp.begin()) + 1, negate< unsigned> (), init); 
# 226
(temp[0]) = init; 
# 233
thrust::inclusive_scan(exec, thrust::make_zip_iterator(thrust::make_tuple((temp.begin()), (flags.begin()))), thrust::make_zip_iterator(thrust::make_tuple((temp.begin()), (flags.begin()))) + n, thrust::make_zip_iterator(thrust::make_tuple(result, (flags.begin()))), ((detail::segmented_scan_functor< typename iterator_traits< OutputIterator> ::value_type, unsigned, AssociativeOperator> )(binary_op))); 
# 238
}  
# 240
return result + n; 
# 241
} 
# 244
}
# 245
}
# 246
}
# 247
}
# 32 "/usr/local/cuda/include/thrust/system/detail/sequential/scan.h"
namespace thrust { 
# 34
namespace system { 
# 36
namespace detail { 
# 38
namespace sequential { 
# 43
template< class DerivedPolicy, class 
# 44
InputIterator, class 
# 45
OutputIterator, class 
# 46
BinaryFunction> OutputIterator 
# 48
inclusive_scan(execution_policy< DerivedPolicy>  &, InputIterator 
# 49
first, InputIterator 
# 50
last, OutputIterator 
# 51
result, BinaryFunction 
# 52
binary_op) 
# 53
{ 
# 66
using namespace thrust::detail;
# 76
typedef typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > > ::type ValueType; 
# 82
thrust::detail::wrapped_function< BinaryFunction, typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > > ::type>  wrapped_binary_op(binary_op); 
# 84
if (first != last) 
# 85
{ 
# 86
ValueType sum = *first; 
# 88
(*result) = sum; 
# 90
for ((++first), (++result); first != last; (++first), (++result)) { 
# 91
(*result) = (sum = wrapped_binary_op(sum, *first)); }  
# 92
}  
# 94
return result; 
# 95
} 
# 99
template< class DerivedPolicy, class 
# 100
InputIterator, class 
# 101
OutputIterator, class 
# 102
T, class 
# 103
BinaryFunction> OutputIterator 
# 105
exclusive_scan(execution_policy< DerivedPolicy>  &, InputIterator 
# 106
first, InputIterator 
# 107
last, OutputIterator 
# 108
result, T 
# 109
init, BinaryFunction 
# 110
binary_op) 
# 111
{ 
# 124
using namespace thrust::detail;
# 134
typedef typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > > ::type ValueType; 
# 136
if (first != last) 
# 137
{ 
# 138
ValueType tmp = *first; 
# 139
ValueType sum = init; 
# 141
(*result) = sum; 
# 142
sum = binary_op(sum, tmp); 
# 144
for ((++first), (++result); first != last; (++first), (++result)) 
# 145
{ 
# 146
tmp = (*first); 
# 147
(*result) = sum; 
# 148
sum = binary_op(sum, tmp); 
# 149
}  
# 150
}  
# 152
return result; 
# 153
} 
# 156
}
# 157
}
# 158
}
# 159
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace cuda { 
# 33
namespace detail { 
# 37
template< class DerivedPolicy, class 
# 38
InputIterator, class 
# 39
OutputIterator, class 
# 40
AssociativeOperator> OutputIterator 
# 37
inclusive_scan(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op); 
# 49
template< class DerivedPolicy, class 
# 50
InputIterator, class 
# 51
OutputIterator, class 
# 52
T, class 
# 53
AssociativeOperator> OutputIterator 
# 49
exclusive_scan(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op); 
# 63
}
# 64
}
# 65
}
# 66
}
# 22 "/usr/local/cuda/include/thrust/system/cuda/detail/decomposition.h"
namespace thrust { 
# 24
namespace system { 
# 26
namespace cuda { 
# 28
namespace detail { 
# 32
template< class Size> 
# 33
class trivial_decomposition { 
# 36
public: typedef Size size_type; 
# 38
typedef pair< Size, Size>  range; 
# 41
trivial_decomposition() : m_n(0) 
# 43
{ } 
# 46
trivial_decomposition(size_type n) : m_n(n) 
# 48
{ } 
# 51
range operator[](size_type) const 
# 52
{ 
# 53
return range(0, n()); 
# 54
} 
# 57
size_type size() const 
# 58
{ 
# 59
return 1; 
# 60
} 
# 64
size_type n() const 
# 65
{ 
# 66
return m_n; 
# 67
} 
# 70
private: Size m_n; 
# 71
}; 
# 74
template< class Size> trivial_decomposition< Size>  
# 76
make_trivial_decomposition(Size n) 
# 77
{ 
# 78
return ((trivial_decomposition< Size> )(n)); 
# 79
} 
# 82
template< class Size> 
# 83
class blocked_decomposition { 
# 86
public: typedef Size size_type; 
# 88
typedef pair< Size, Size>  range; 
# 91
blocked_decomposition() : m_n(0), m_block_size(0), m_num_partitions(0) 
# 95
{ } 
# 98
blocked_decomposition(size_type n, Size block_size) : m_n(n), m_block_size(block_size), m_num_partitions(((n + block_size) - 1) / block_size) 
# 102
{ } 
# 105
range operator[](size_type i) const 
# 106
{ 
# 107
size_type first = i * (m_block_size); 
# 108
size_type last = thrust::min(m_n, first + (m_block_size)); 
# 110
return range(first, last); 
# 111
} 
# 114
size_type size() const 
# 115
{ 
# 116
return m_num_partitions; 
# 117
} 
# 121
size_type n() const 
# 122
{ 
# 123
return m_n; 
# 124
} 
# 127
private: Size m_n; 
# 128
Size m_block_size; 
# 129
Size m_num_partitions; 
# 130
}; 
# 133
template< class Size> blocked_decomposition< Size>  
# 135
make_blocked_decomposition(Size n, Size block_size) 
# 136
{ 
# 137
return blocked_decomposition< Size> (n, block_size); 
# 138
} 
# 141
template< class Size> 
# 142
class uniform_decomposition : public blocked_decomposition< Size>  { 
# 146
typedef ::thrust::system::cuda::detail::blocked_decomposition< Size>  super_t; 
# 150
public: uniform_decomposition() : super_t() 
# 152
{ } 
# 155
uniform_decomposition(Size n, Size num_partitions) : super_t(n, n / num_partitions) 
# 157
{ } 
# 158
}; 
# 161
template< class Size> uniform_decomposition< Size>  
# 163
make_uniform_decomposition(Size n, Size num_partitions) 
# 164
{ 
# 165
return uniform_decomposition< Size> (n, num_partitions); 
# 166
} 
# 169
template< class Size> 
# 170
class aligned_decomposition { 
# 173
public: typedef Size size_type; 
# 175
typedef pair< Size, Size>  range; 
# 178
aligned_decomposition() : m_n(0), m_num_partitions(0), m_tile_size(0) 
# 182
{ } 
# 185
aligned_decomposition(Size n, Size num_partitions, Size aligned_size) : m_n(n), m_num_partitions(num_partitions), m_tile_size(aligned_size) 
# 189
{ 
# 190
size_type num_tiles = ((n + (m_tile_size)) - 1) / (m_tile_size); 
# 192
(m_num_tiles_per_partition) = (num_tiles / size()); 
# 193
(m_last_partial_tile_size) = (num_tiles % size()); 
# 194
} 
# 197
range operator[](Size i) const 
# 198
{ 
# 199
range result = range_in_tiles(i); 
# 200
(result.first) *= (m_tile_size); 
# 201
(result.second) = thrust::min< size_type> (m_n, (result.second) * (m_tile_size)); 
# 202
return result; 
# 203
} 
# 206
size_type size() const 
# 207
{ 
# 208
return m_num_partitions; 
# 209
} 
# 213
size_type n() const 
# 214
{ 
# 215
return m_n; 
# 216
} 
# 220
private: range range_in_tiles(size_type i) const 
# 221
{ 
# 222
range result; 
# 224
(result.first) = ((m_num_tiles_per_partition) * i); 
# 225
(result.first) += thrust::min< size_type> (i, m_last_partial_tile_size); 
# 227
(result.second) = (((result.first) + (m_num_tiles_per_partition)) + (i < (m_last_partial_tile_size))); 
# 229
return result; 
# 230
} 
# 232
size_type m_n; 
# 233
size_type m_num_partitions; 
# 234
size_type m_num_tiles_per_partition; 
# 235
size_type m_tile_size; 
# 236
size_type m_last_partial_tile_size; 
# 237
}; 
# 240
template< class Size> aligned_decomposition< Size>  
# 242
make_aligned_decomposition(Size n, Size num_partitions, Size aligned_size) 
# 243
{ 
# 244
return aligned_decomposition< Size> (n, num_partitions, aligned_size); 
# 245
} 
# 248
}
# 249
}
# 250
}
# 251
}
# 31 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
namespace thrust { 
# 33
namespace system { 
# 35
namespace cuda { 
# 37
namespace detail { 
# 39
namespace scan_detail { 
# 43
struct inclusive_scan_n { 
# 45
template< class ConcurrentGroup, class InputIterator, class Size, class OutputIterator, class T, class BinaryFunction> void 
# 46
operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, T init, BinaryFunction binary_op) 
# 47
{int volatile ___ = 1;(void)this_group;(void)first;(void)n;(void)result;(void)init;(void)binary_op;
# 49
::exit(___);}
#if 0
# 47
{ 
# 48
bulk_::inclusive_scan(this_group, first, first + n, result, init, binary_op); 
# 49
} 
#endif
# 52 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
template< class ConcurrentGroup, class InputIterator, class Size, class OutputIterator, class BinaryFunction> void 
# 53
operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, BinaryFunction binary_op) 
# 54
{int volatile ___ = 1;(void)this_group;(void)first;(void)n;(void)result;(void)binary_op;
# 56
::exit(___);}
#if 0
# 54
{ 
# 55
bulk_::inclusive_scan(this_group, first, first + n, result, binary_op); 
# 56
} 
#endif
# 57 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
}; 
# 60
struct exclusive_scan_n { 
# 62
template< class ConcurrentGroup, class InputIterator, class Size, class OutputIterator, class T, class BinaryFunction> void 
# 63
operator()(ConcurrentGroup &this_group, InputIterator first, Size n, OutputIterator result, T init, BinaryFunction binary_op) 
# 64
{int volatile ___ = 1;(void)this_group;(void)first;(void)n;(void)result;(void)init;(void)binary_op;
# 66
::exit(___);}
#if 0
# 64
{ 
# 65
bulk_::exclusive_scan(this_group, first, first + n, result, init, binary_op); 
# 66
} 
#endif
# 67 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
}; 
# 70
struct inclusive_downsweep { 
# 72
template< class ConcurrentGroup, class RandomAccessIterator1, class Decomposition, class RandomAccessIterator2, class RandomAccessIterator3, class BinaryFunction> void 
# 73
operator()(ConcurrentGroup &this_group, RandomAccessIterator1 
# 74
first, Decomposition 
# 75
decomp, RandomAccessIterator2 
# 76
carries_first, RandomAccessIterator3 
# 77
result, BinaryFunction 
# 78
binary_op) 
# 79
{int volatile ___ = 1;(void)this_group;(void)first;(void)decomp;(void)carries_first;(void)result;(void)binary_op;
# 96
::exit(___);}
#if 0
# 79
{ 
# 80
typename Decomposition::range range = decomp[(this_group.index())]; 
# 82
RandomAccessIterator1 last = first + (range.second); 
# 83
first += (range.first); 
# 84
result += (range.first); 
# 86
if ((this_group.index()) == 0) 
# 87
{ 
# 88
bulk_::inclusive_scan(this_group, first, last, result, binary_op); 
# 89
} else 
# 91
{ 
# 92
typename iterator_value< RandomAccessIterator2> ::type carry = carries_first[(this_group.index()) - 1]; 
# 94
bulk_::inclusive_scan(this_group, first, last, result, carry, binary_op); 
# 95
}  
# 96
} 
#endif
# 97 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
}; 
# 100
struct exclusive_downsweep { 
# 102
template< class ConcurrentGroup, class RandomAccessIterator1, class Decomposition, class RandomAccessIterator2, class RandomAccessIterator3, class BinaryFunction> void 
# 103
operator()(ConcurrentGroup &this_group, RandomAccessIterator1 
# 104
first, Decomposition 
# 105
decomp, RandomAccessIterator2 
# 106
carries_first, RandomAccessIterator3 
# 107
result, BinaryFunction 
# 108
binary_op) 
# 109
{int volatile ___ = 1;(void)this_group;(void)first;(void)decomp;(void)carries_first;(void)result;(void)binary_op;
# 119
::exit(___);}
#if 0
# 109
{ 
# 110
typename Decomposition::range range = decomp[(this_group.index())]; 
# 112
RandomAccessIterator1 last = first + (range.second); 
# 113
first += (range.first); 
# 114
result += (range.first); 
# 116
typename iterator_value< RandomAccessIterator2> ::type carry = carries_first[(this_group.index())]; 
# 118
bulk_::exclusive_scan(this_group, first, last, result, carry, binary_op); 
# 119
} 
#endif
# 120 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
}; 
# 123
template< class T> struct accumulate_tiles_tuning_impl; 
# 126
template<> struct accumulate_tiles_tuning_impl< int>  { 
# 129
static const int groupsize = 128; 
# 130
static const int grainsize = 9; 
# 131
}; 
# 134
template<> struct accumulate_tiles_tuning_impl< double>  { 
# 137
static const int groupsize = 128; 
# 138
static const int grainsize = 9; 
# 139
}; 
# 143
template< class T> 
# 144
struct accumulate_tiles_tuning { 
# 146
static const int groupsize = ((sizeof(T) <= sizeof(int)) ? accumulate_tiles_tuning_impl< int> ::groupsize : ((sizeof(T) <= ((2) * sizeof(int))) ? accumulate_tiles_tuning_impl< double> ::groupsize : 128)); 
# 151
static const int grainsize = ((sizeof(T) <= sizeof(int)) ? accumulate_tiles_tuning_impl< int> ::grainsize : ((sizeof(T) <= ((2) * sizeof(int))) ? accumulate_tiles_tuning_impl< double> ::grainsize : 3)); 
# 155
}; 
# 159
template< class T1, class T2> 
# 160
struct accumulate_tiles_tuning< tuple< T1, T2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  { 
# 163
static const int groupsize = 128; 
# 164
static const int grainsize = (((sizeof(T1) + sizeof(T2)) <= ((2) * sizeof(double))) ? 5 : 3); 
# 165
}; 
# 171
struct accumulate_tiles { 
# 173
template< class ConcurrentGroup, class RandomAccessIterator1, class Decomposition, class RandomAccessIterator2, class BinaryFunction> void 
# 174
operator()(ConcurrentGroup &this_group, RandomAccessIterator1 
# 175
first, Decomposition 
# 176
decomp, RandomAccessIterator2 
# 177
result, BinaryFunction 
# 178
binary_op) 
# 179
{int volatile ___ = 1;(void)this_group;(void)first;(void)decomp;(void)result;(void)binary_op;
# 197
::exit(___);}
#if 0
# 179
{ 
# 180
typedef typename iterator_value< RandomAccessIterator1> ::type value_type; 
# 182
typename Decomposition::range range = decomp[(this_group.index())]; 
# 184
const bool commutative = (thrust::detail::is_commutative< BinaryFunction> ::value); 
# 187
value_type init = commutative ? first[(range.second) - 1] : (first[range.first]); 
# 189
value_type sum = commutative ? bulk_::accumulate(this_group, first + (range.first), (first + (range.second)) - 1, init, binary_op) : bulk_::accumulate(this_group, (first + (range.first)) + 1, first + (range.second), init, binary_op); 
# 193
if (((this_group.this_exec).index()) == 0) 
# 194
{ 
# 195
(result[(this_group.index())]) = sum; 
# 196
}  
# 197
} 
#endif
# 198 "/usr/local/cuda/include/thrust/system/cuda/detail/scan.inl"
}; 
# 201
template< class DerivedPolicy, class 
# 202
InputIterator, class 
# 203
OutputIterator, class 
# 204
AssociativeOperator> OutputIterator 
# 206
inclusive_scan(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 207
first, InputIterator 
# 208
last, OutputIterator 
# 209
result, AssociativeOperator 
# 210
binary_op) 
# 211
{ 
# 216
typedef typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type intermediate_type; 
# 218
typedef typename iterator_difference< InputIterator> ::type Size; 
# 220
Size n = last - first; 
# 222
cudaStream_t s = stream(thrust::detail::derived_cast(exec)); 
# 224
const Size threshold_of_parallelism = (20000); 
# 226
if (n < threshold_of_parallelism) 
# 227
{ 
# 228
const Size groupsize = ((sizeof(intermediate_type) <= ((2) * sizeof(int))) ? 512 : ((sizeof(intermediate_type) <= ((4) * sizeof(int))) ? 256 : 128)); 
# 233
typedef bulk_::detail::scan_detail::scan_buffer< groupsize, 3UL, InputIterator, OutputIterator, AssociativeOperator>  heap_type; 
# 234
Size heap_size = (sizeof(heap_type)); 
# 235
bulk_::async(bulk_::grid< groupsize, 3> (1, heap_size, s), inclusive_scan_n(), bulk_::root.this_exec, first, n, result, binary_op); 
# 238
(void)groupsize; 
# 239
} else 
# 241
{ 
# 242
const Size groupsize = (scan_detail::accumulate_tiles_tuning< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type> ::groupsize); 
# 243
const Size grainsize = (scan_detail::accumulate_tiles_tuning< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type> ::grainsize); 
# 245
const Size tile_size = groupsize * grainsize; 
# 246
Size num_tiles = ((n + tile_size) - 1) / tile_size; 
# 249
Size subscription = (20); 
# 250
Size num_groups = thrust::min< typename iterator_difference< InputIterator> ::type> (subscription * bulk_::concurrent_group<> ::hardware_concurrency(), num_tiles); 
# 252
aligned_decomposition< typename iterator_difference< InputIterator> ::type>  decomp(n, num_groups, tile_size); 
# 254
thrust::detail::temporary_array< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type, DerivedPolicy>  carries(exec, num_groups); 
# 258
Size heap_size = groupsize * sizeof(intermediate_type); 
# 259
bulk_::async(bulk_::grid< groupsize, grainsize> (num_groups, heap_size, s), accumulate_tiles(), bulk_::root.this_exec, first, decomp, (carries.begin()), binary_op); 
# 263
const Size groupsize2 = ((sizeof(intermediate_type) <= ((2) * sizeof(int))) ? 256 : 128); 
# 264
const Size grainsize2 = (3); 
# 265
typedef bulk_::detail::scan_detail::scan_buffer< groupsize2, grainsize2, InputIterator, OutputIterator, AssociativeOperator>  heap_type2; 
# 266
heap_size = sizeof(heap_type2); 
# 267
bulk_::async(bulk_::grid< groupsize2, grainsize2> (1, heap_size, s), inclusive_scan_n(), bulk_::root.this_exec, (carries.begin()), num_groups, (carries.begin()), binary_op); 
# 274
typedef bulk_::detail::scan_detail::scan_buffer< groupsize, grainsize, InputIterator, OutputIterator, AssociativeOperator>  heap_type3; 
# 275
heap_size = sizeof(heap_type3); 
# 276
bulk_::async(bulk_::grid< groupsize, grainsize> (num_groups, heap_size, s), inclusive_downsweep(), bulk_::root.this_exec, first, decomp, (carries.begin()), result, binary_op); 
# 279
(void)groupsize2; 
# 280
(void)grainsize2; 
# 281
}  
# 283
return result + n; 
# 284
} 
# 287
template< class DerivedPolicy, class 
# 288
InputIterator, class 
# 289
OutputIterator, class 
# 290
T, class 
# 291
AssociativeOperator> OutputIterator 
# 293
exclusive_scan(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 294
first, InputIterator 
# 295
last, OutputIterator 
# 296
result, T 
# 297
init, AssociativeOperator 
# 298
binary_op) 
# 299
{ 
# 304
typedef typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type intermediate_type; 
# 306
typedef typename iterator_difference< InputIterator> ::type Size; 
# 308
Size n = last - first; 
# 310
cudaStream_t s = stream(thrust::detail::derived_cast(exec)); 
# 312
const Size threshold_of_parallelism = (20000); 
# 314
if (n < threshold_of_parallelism) 
# 315
{ 
# 316
const Size groupsize = ((sizeof(intermediate_type) <= ((2) * sizeof(int))) ? 512 : ((sizeof(intermediate_type) <= ((4) * sizeof(int))) ? 256 : 128)); 
# 321
typedef bulk_::detail::scan_detail::scan_buffer< groupsize, 3UL, InputIterator, OutputIterator, AssociativeOperator>  heap_type; 
# 322
Size heap_size = (sizeof(heap_type)); 
# 323
bulk_::async(bulk_::grid< groupsize, 3> (1, heap_size, s), exclusive_scan_n(), bulk_::root.this_exec, first, n, result, init, binary_op); 
# 326
(void)groupsize; 
# 327
} else 
# 329
{ 
# 330
const Size groupsize = (scan_detail::accumulate_tiles_tuning< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type> ::groupsize); 
# 331
const Size grainsize = (scan_detail::accumulate_tiles_tuning< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type> ::grainsize); 
# 333
const Size tile_size = groupsize * grainsize; 
# 334
Size num_tiles = ((n + tile_size) - 1) / tile_size; 
# 337
Size subscription = (20); 
# 338
Size num_groups = thrust::min< typename iterator_difference< InputIterator> ::type> (subscription * bulk_::concurrent_group<> ::hardware_concurrency(), num_tiles); 
# 340
aligned_decomposition< typename iterator_difference< InputIterator> ::type>  decomp(n, num_groups, tile_size); 
# 342
thrust::detail::temporary_array< typename bulk_::detail::scan_detail::scan_intermediate< InputIterator, OutputIterator, AssociativeOperator> ::type, DerivedPolicy>  carries(exec, num_groups); 
# 346
Size heap_size = groupsize * sizeof(intermediate_type); 
# 347
bulk_::async(bulk_::grid< groupsize, grainsize> (num_groups, heap_size, s), accumulate_tiles(), bulk_::root.this_exec, first, decomp, (carries.begin()), binary_op); 
# 351
const Size groupsize2 = ((sizeof(intermediate_type) <= ((2) * sizeof(int))) ? 256 : 128); 
# 352
const Size grainsize2 = (3); 
# 354
typedef bulk_::detail::scan_detail::scan_buffer< groupsize2, grainsize2, InputIterator, OutputIterator, AssociativeOperator>  heap_type2; 
# 355
heap_size = sizeof(heap_type2); 
# 356
bulk_::async(bulk_::grid< groupsize2, grainsize2> (1, heap_size, s), exclusive_scan_n(), bulk_::root.this_exec, (carries.begin()), num_groups, (carries.begin()), init, binary_op); 
# 363
typedef bulk_::detail::scan_detail::scan_buffer< groupsize, grainsize, InputIterator, OutputIterator, AssociativeOperator>  heap_type3; 
# 364
heap_size = sizeof(heap_type3); 
# 365
bulk_::async(bulk_::grid< groupsize, grainsize> (num_groups, heap_size, s), exclusive_downsweep(), bulk_::root.this_exec, first, decomp, (carries.begin()), result, binary_op); 
# 368
(void)groupsize2; 
# 369
(void)grainsize2; 
# 370
}  
# 372
return result + n; 
# 373
} 
# 376
}
# 379
template< class DerivedPolicy, class 
# 380
InputIterator, class 
# 381
OutputIterator, class 
# 382
AssociativeOperator> OutputIterator 
# 384
inclusive_scan(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 385
first, InputIterator 
# 386
last, OutputIterator 
# 387
result, AssociativeOperator 
# 388
binary_op) 
# 389
{ 
# 395
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, true> ::value)> )>  thrust_static_assert_typedef_395 __attribute((unused)); 
# 397
struct workaround { 
# 400
static OutputIterator parallel_path(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 401
first, InputIterator 
# 402
last, OutputIterator 
# 403
result, AssociativeOperator 
# 404
binary_op) 
# 405
{ 
# 406
return scan_detail::inclusive_scan(exec, first, last, result, binary_op); 
# 407
} 
# 410
static OutputIterator sequential_path(execution_policy< DerivedPolicy>  &, InputIterator 
# 411
first, InputIterator 
# 412
last, OutputIterator 
# 413
result, AssociativeOperator 
# 414
binary_op) 
# 415
{ 
# 416
return thrust::inclusive_scan(thrust::seq, first, last, result, binary_op); 
# 417
} 
# 418
}; 
# 421
return (workaround::parallel_path)(exec, first, last, result, binary_op); 
# 425
} 
# 428
template< class DerivedPolicy, class 
# 429
InputIterator, class 
# 430
OutputIterator, class 
# 431
T, class 
# 432
AssociativeOperator> OutputIterator 
# 434
exclusive_scan(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 435
first, InputIterator 
# 436
last, OutputIterator 
# 437
result, T 
# 438
init, AssociativeOperator 
# 439
binary_op) 
# 440
{ 
# 446
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, true> ::value)> )>  thrust_static_assert_typedef_446 __attribute((unused)); 
# 448
struct workaround { 
# 451
static OutputIterator parallel_path(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 452
first, InputIterator 
# 453
last, OutputIterator 
# 454
result, T 
# 455
init, AssociativeOperator 
# 456
binary_op) 
# 457
{ 
# 458
return scan_detail::exclusive_scan(exec, first, last, result, init, binary_op); 
# 459
} 
# 462
static OutputIterator sequential_path(execution_policy< DerivedPolicy>  &, InputIterator 
# 463
first, InputIterator 
# 464
last, OutputIterator 
# 465
result, T 
# 466
init, AssociativeOperator 
# 467
binary_op) 
# 468
{ 
# 469
return thrust::exclusive_scan(thrust::seq, first, last, result, init, binary_op); 
# 470
} 
# 471
}; 
# 474
return (workaround::parallel_path)(exec, first, last, result, init, binary_op); 
# 478
} 
# 481
}
# 482
}
# 483
}
# 484
}
# 29 "/usr/local/cuda/include/thrust/system/detail/sequential/scan_by_key.h"
namespace thrust { 
# 31
namespace system { 
# 33
namespace detail { 
# 35
namespace sequential { 
# 40
template< class DerivedPolicy, class 
# 41
InputIterator1, class 
# 42
InputIterator2, class 
# 43
OutputIterator, class 
# 44
BinaryPredicate, class 
# 45
BinaryFunction> OutputIterator 
# 47
inclusive_scan_by_key(execution_policy< DerivedPolicy>  &, InputIterator1 
# 48
first1, InputIterator1 
# 49
last1, InputIterator2 
# 50
first2, OutputIterator 
# 51
result, BinaryPredicate 
# 52
binary_pred, BinaryFunction 
# 53
binary_op) 
# 54
{ 
# 55
typedef typename iterator_traits< InputIterator1> ::value_type KeyType; 
# 56
typedef typename iterator_traits< OutputIterator> ::value_type ValueType; 
# 62
thrust::detail::wrapped_function< BinaryFunction, typename iterator_traits< OutputIterator> ::value_type>  wrapped_binary_op(binary_op); 
# 64
if (first1 != last1) 
# 65
{ 
# 66
KeyType prev_key = *first1; 
# 67
ValueType prev_value = *first2; 
# 69
(*result) = prev_value; 
# 71
for (((++first1), (++first2)), (++result); first1 != last1; ((++first1), (++first2)), (++result)) 
# 74
{ 
# 75
KeyType key = *first1; 
# 77
if (binary_pred(prev_key, key)) { 
# 78
(*result) = (prev_value = wrapped_binary_op(prev_value, *first2)); } else { 
# 80
(*result) = (prev_value = (*first2)); }  
# 82
prev_key = key; 
# 83
}  
# 84
}  
# 86
return result; 
# 87
} 
# 91
template< class DerivedPolicy, class 
# 92
InputIterator1, class 
# 93
InputIterator2, class 
# 94
OutputIterator, class 
# 95
T, class 
# 96
BinaryPredicate, class 
# 97
BinaryFunction> OutputIterator 
# 99
exclusive_scan_by_key(execution_policy< DerivedPolicy>  &, InputIterator1 
# 100
first1, InputIterator1 
# 101
last1, InputIterator2 
# 102
first2, OutputIterator 
# 103
result, T 
# 104
init, BinaryPredicate 
# 105
binary_pred, BinaryFunction 
# 106
binary_op) 
# 107
{ 
# 108
typedef typename iterator_traits< InputIterator1> ::value_type KeyType; 
# 109
typedef typename iterator_traits< OutputIterator> ::value_type ValueType; 
# 111
if (first1 != last1) 
# 112
{ 
# 113
KeyType temp_key = *first1; 
# 114
ValueType temp_value = *first2; 
# 116
ValueType next = init; 
# 119
(*result) = next; 
# 121
next = binary_op(next, temp_value); 
# 123
for (((++first1), (++first2)), (++result); first1 != last1; ((++first1), (++first2)), (++result)) 
# 126
{ 
# 127
KeyType key = *first1; 
# 130
temp_value = (*first2); 
# 132
if (!binary_pred(temp_key, key)) { 
# 133
next = init; }  
# 135
(*result) = next; 
# 136
next = binary_op(next, temp_value); 
# 138
temp_key = key; 
# 139
}  
# 140
}  
# 142
return result; 
# 143
} 
# 146
}
# 147
}
# 148
}
# 149
}
# 31 "/usr/local/cuda/include/thrust/detail/scan.inl"
namespace thrust { 
# 36
template< class DerivedPolicy, class 
# 37
InputIterator, class 
# 38
OutputIterator> OutputIterator 
# 40
inclusive_scan(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 41
first, InputIterator 
# 42
last, OutputIterator 
# 43
result) 
# 44
{ 
# 45
using system::detail::generic::inclusive_scan;
# 46
return inclusive_scan(detail::derived_cast(detail::strip_const(exec)), first, last, result); 
# 47
} 
# 51
template< class DerivedPolicy, class 
# 52
InputIterator, class 
# 53
OutputIterator, class 
# 54
AssociativeOperator> OutputIterator 
# 56
inclusive_scan(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 57
first, InputIterator 
# 58
last, OutputIterator 
# 59
result, AssociativeOperator 
# 60
binary_op) 
# 61
{ 
# 62
using system::detail::generic::inclusive_scan;
# 63
return inclusive_scan(detail::derived_cast(detail::strip_const(exec)), first, last, result, binary_op); 
# 64
} 
# 68
template< class DerivedPolicy, class 
# 69
InputIterator, class 
# 70
OutputIterator> OutputIterator 
# 72
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 73
first, InputIterator 
# 74
last, OutputIterator 
# 75
result) 
# 76
{ 
# 77
using system::detail::generic::exclusive_scan;
# 78
return exclusive_scan(detail::derived_cast(detail::strip_const(exec)), first, last, result); 
# 79
} 
# 83
template< class DerivedPolicy, class 
# 84
InputIterator, class 
# 85
OutputIterator, class 
# 86
T> OutputIterator 
# 88
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 89
first, InputIterator 
# 90
last, OutputIterator 
# 91
result, T 
# 92
init) 
# 93
{ 
# 94
using system::detail::generic::exclusive_scan;
# 95
return exclusive_scan(detail::derived_cast(detail::strip_const(exec)), first, last, result, init); 
# 96
} 
# 100
template< class DerivedPolicy, class 
# 101
InputIterator, class 
# 102
OutputIterator, class 
# 103
T, class 
# 104
AssociativeOperator> OutputIterator 
# 106
exclusive_scan(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 107
first, InputIterator 
# 108
last, OutputIterator 
# 109
result, T 
# 110
init, AssociativeOperator 
# 111
binary_op) 
# 112
{ 
# 113
using system::detail::generic::exclusive_scan;
# 114
return exclusive_scan(detail::derived_cast(detail::strip_const(exec)), first, last, result, init, binary_op); 
# 115
} 
# 119
template< class DerivedPolicy, class 
# 120
InputIterator1, class 
# 121
InputIterator2, class 
# 122
OutputIterator> OutputIterator 
# 124
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 125
first1, InputIterator1 
# 126
last1, InputIterator2 
# 127
first2, OutputIterator 
# 128
result) 
# 129
{ 
# 130
using system::detail::generic::inclusive_scan_by_key;
# 131
return inclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result); 
# 132
} 
# 136
template< class DerivedPolicy, class 
# 137
InputIterator1, class 
# 138
InputIterator2, class 
# 139
OutputIterator, class 
# 140
BinaryPredicate> OutputIterator 
# 142
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 143
first1, InputIterator1 
# 144
last1, InputIterator2 
# 145
first2, OutputIterator 
# 146
result, BinaryPredicate 
# 147
binary_pred) 
# 148
{ 
# 149
using system::detail::generic::inclusive_scan_by_key;
# 150
return inclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, binary_pred); 
# 151
} 
# 155
template< class DerivedPolicy, class 
# 156
InputIterator1, class 
# 157
InputIterator2, class 
# 158
OutputIterator, class 
# 159
BinaryPredicate, class 
# 160
AssociativeOperator> OutputIterator 
# 162
inclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 163
first1, InputIterator1 
# 164
last1, InputIterator2 
# 165
first2, OutputIterator 
# 166
result, BinaryPredicate 
# 167
binary_pred, AssociativeOperator 
# 168
binary_op) 
# 169
{ 
# 170
using system::detail::generic::inclusive_scan_by_key;
# 171
return inclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, binary_pred, binary_op); 
# 172
} 
# 176
template< class DerivedPolicy, class 
# 177
InputIterator1, class 
# 178
InputIterator2, class 
# 179
OutputIterator> OutputIterator 
# 181
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 182
first1, InputIterator1 
# 183
last1, InputIterator2 
# 184
first2, OutputIterator 
# 185
result) 
# 186
{ 
# 187
using system::detail::generic::exclusive_scan_by_key;
# 188
return exclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result); 
# 189
} 
# 193
template< class DerivedPolicy, class 
# 194
InputIterator1, class 
# 195
InputIterator2, class 
# 196
OutputIterator, class 
# 197
T> OutputIterator 
# 199
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 200
first1, InputIterator1 
# 201
last1, InputIterator2 
# 202
first2, OutputIterator 
# 203
result, T 
# 204
init) 
# 205
{ 
# 206
using system::detail::generic::exclusive_scan_by_key;
# 207
return exclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, init); 
# 208
} 
# 212
template< class DerivedPolicy, class 
# 213
InputIterator1, class 
# 214
InputIterator2, class 
# 215
OutputIterator, class 
# 216
T, class 
# 217
BinaryPredicate> OutputIterator 
# 219
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 220
first1, InputIterator1 
# 221
last1, InputIterator2 
# 222
first2, OutputIterator 
# 223
result, T 
# 224
init, BinaryPredicate 
# 225
binary_pred) 
# 226
{ 
# 227
using system::detail::generic::exclusive_scan_by_key;
# 228
return exclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, init, binary_pred); 
# 229
} 
# 233
template< class DerivedPolicy, class 
# 234
InputIterator1, class 
# 235
InputIterator2, class 
# 236
OutputIterator, class 
# 237
T, class 
# 238
BinaryPredicate, class 
# 239
AssociativeOperator> OutputIterator 
# 241
exclusive_scan_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 242
first1, InputIterator1 
# 243
last1, InputIterator2 
# 244
first2, OutputIterator 
# 245
result, T 
# 246
init, BinaryPredicate 
# 247
binary_pred, AssociativeOperator 
# 248
binary_op) 
# 249
{ 
# 250
using system::detail::generic::exclusive_scan_by_key;
# 251
return exclusive_scan_by_key(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, result, init, binary_pred, binary_op); 
# 252
} 
# 255
template< class InputIterator, class 
# 256
OutputIterator> OutputIterator 
# 257
inclusive_scan(InputIterator first, InputIterator 
# 258
last, OutputIterator 
# 259
result) 
# 260
{ 
# 261
using system::detail::generic::select_system;
# 263
typedef typename iterator_system< InputIterator> ::type System1; 
# 264
typedef typename iterator_system< OutputIterator> ::type System2; 
# 266
System1 system1; 
# 267
System2 system2; 
# 269
return thrust::inclusive_scan(select_system(system1, system2), first, last, result); 
# 270
} 
# 273
template< class InputIterator, class 
# 274
OutputIterator, class 
# 275
BinaryFunction> OutputIterator 
# 276
inclusive_scan(InputIterator first, InputIterator 
# 277
last, OutputIterator 
# 278
result, BinaryFunction 
# 279
binary_op) 
# 280
{ 
# 281
using system::detail::generic::select_system;
# 283
typedef typename iterator_system< InputIterator> ::type System1; 
# 284
typedef typename iterator_system< OutputIterator> ::type System2; 
# 286
System1 system1; 
# 287
System2 system2; 
# 289
return thrust::inclusive_scan(select_system(system1, system2), first, last, result, binary_op); 
# 290
} 
# 293
template< class InputIterator, class 
# 294
OutputIterator> OutputIterator 
# 295
exclusive_scan(InputIterator first, InputIterator 
# 296
last, OutputIterator 
# 297
result) 
# 298
{ 
# 299
using system::detail::generic::select_system;
# 301
typedef typename iterator_system< InputIterator> ::type System1; 
# 302
typedef typename iterator_system< OutputIterator> ::type System2; 
# 304
System1 system1; 
# 305
System2 system2; 
# 307
return thrust::exclusive_scan(select_system(system1, system2), first, last, result); 
# 308
} 
# 311
template< class InputIterator, class 
# 312
OutputIterator, class 
# 313
T> OutputIterator 
# 314
exclusive_scan(InputIterator first, InputIterator 
# 315
last, OutputIterator 
# 316
result, T 
# 317
init) 
# 318
{ 
# 319
using system::detail::generic::select_system;
# 321
typedef typename iterator_system< InputIterator> ::type System1; 
# 322
typedef typename iterator_system< OutputIterator> ::type System2; 
# 324
System1 system1; 
# 325
System2 system2; 
# 327
return thrust::exclusive_scan(select_system(system1, system2), first, last, result, init); 
# 328
} 
# 331
template< class InputIterator, class 
# 332
OutputIterator, class 
# 333
T, class 
# 334
BinaryFunction> OutputIterator 
# 335
exclusive_scan(InputIterator first, InputIterator 
# 336
last, OutputIterator 
# 337
result, T 
# 338
init, BinaryFunction 
# 339
binary_op) 
# 340
{ 
# 341
using system::detail::generic::select_system;
# 343
typedef typename iterator_system< InputIterator> ::type System1; 
# 344
typedef typename iterator_system< OutputIterator> ::type System2; 
# 346
System1 system1; 
# 347
System2 system2; 
# 349
return thrust::exclusive_scan(select_system(system1, system2), first, last, result, init, binary_op); 
# 350
} 
# 353
template< class InputIterator1, class 
# 354
InputIterator2, class 
# 355
OutputIterator> OutputIterator 
# 356
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 357
last1, InputIterator2 
# 358
first2, OutputIterator 
# 359
result) 
# 360
{ 
# 361
using system::detail::generic::select_system;
# 363
typedef typename iterator_system< InputIterator1> ::type System1; 
# 364
typedef typename iterator_system< InputIterator2> ::type System2; 
# 365
typedef typename iterator_system< OutputIterator> ::type System3; 
# 367
System1 system1; 
# 368
System2 system2; 
# 369
System3 system3; 
# 371
return thrust::inclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result); 
# 372
} 
# 375
template< class InputIterator1, class 
# 376
InputIterator2, class 
# 377
OutputIterator, class 
# 378
BinaryPredicate> OutputIterator 
# 379
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 380
last1, InputIterator2 
# 381
first2, OutputIterator 
# 382
result, BinaryPredicate 
# 383
binary_pred) 
# 384
{ 
# 385
using system::detail::generic::select_system;
# 387
typedef typename iterator_system< InputIterator1> ::type System1; 
# 388
typedef typename iterator_system< InputIterator2> ::type System2; 
# 389
typedef typename iterator_system< OutputIterator> ::type System3; 
# 391
System1 system1; 
# 392
System2 system2; 
# 393
System3 system3; 
# 395
return thrust::inclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result, binary_pred); 
# 396
} 
# 399
template< class InputIterator1, class 
# 400
InputIterator2, class 
# 401
OutputIterator, class 
# 402
BinaryPredicate, class 
# 403
AssociativeOperator> OutputIterator 
# 404
inclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 405
last1, InputIterator2 
# 406
first2, OutputIterator 
# 407
result, BinaryPredicate 
# 408
binary_pred, AssociativeOperator 
# 409
binary_op) 
# 410
{ 
# 411
using system::detail::generic::select_system;
# 413
typedef typename iterator_system< InputIterator1> ::type System1; 
# 414
typedef typename iterator_system< InputIterator2> ::type System2; 
# 415
typedef typename iterator_system< OutputIterator> ::type System3; 
# 417
System1 system1; 
# 418
System2 system2; 
# 419
System3 system3; 
# 421
return thrust::inclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result, binary_pred, binary_op); 
# 422
} 
# 425
template< class InputIterator1, class 
# 426
InputIterator2, class 
# 427
OutputIterator> OutputIterator 
# 428
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 429
last1, InputIterator2 
# 430
first2, OutputIterator 
# 431
result) 
# 432
{ 
# 433
using system::detail::generic::select_system;
# 435
typedef typename iterator_system< InputIterator1> ::type System1; 
# 436
typedef typename iterator_system< InputIterator2> ::type System2; 
# 437
typedef typename iterator_system< OutputIterator> ::type System3; 
# 439
System1 system1; 
# 440
System2 system2; 
# 441
System3 system3; 
# 443
return thrust::exclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result); 
# 444
} 
# 447
template< class InputIterator1, class 
# 448
InputIterator2, class 
# 449
OutputIterator, class 
# 450
T> OutputIterator 
# 451
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 452
last1, InputIterator2 
# 453
first2, OutputIterator 
# 454
result, T 
# 455
init) 
# 456
{ 
# 457
using system::detail::generic::select_system;
# 459
typedef typename iterator_system< InputIterator1> ::type System1; 
# 460
typedef typename iterator_system< InputIterator2> ::type System2; 
# 461
typedef typename iterator_system< OutputIterator> ::type System3; 
# 463
System1 system1; 
# 464
System2 system2; 
# 465
System3 system3; 
# 467
return thrust::exclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result, init); 
# 468
} 
# 471
template< class InputIterator1, class 
# 472
InputIterator2, class 
# 473
OutputIterator, class 
# 474
T, class 
# 475
BinaryPredicate> OutputIterator 
# 476
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 477
last1, InputIterator2 
# 478
first2, OutputIterator 
# 479
result, T 
# 480
init, BinaryPredicate 
# 481
binary_pred) 
# 482
{ 
# 483
using system::detail::generic::select_system;
# 485
typedef typename iterator_system< InputIterator1> ::type System1; 
# 486
typedef typename iterator_system< InputIterator2> ::type System2; 
# 487
typedef typename iterator_system< OutputIterator> ::type System3; 
# 489
System1 system1; 
# 490
System2 system2; 
# 491
System3 system3; 
# 493
return thrust::exclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result, init, binary_pred); 
# 494
} 
# 497
template< class InputIterator1, class 
# 498
InputIterator2, class 
# 499
OutputIterator, class 
# 500
T, class 
# 501
BinaryPredicate, class 
# 502
AssociativeOperator> OutputIterator 
# 503
exclusive_scan_by_key(InputIterator1 first1, InputIterator1 
# 504
last1, InputIterator2 
# 505
first2, OutputIterator 
# 506
result, T 
# 507
init, BinaryPredicate 
# 508
binary_pred, AssociativeOperator 
# 509
binary_op) 
# 510
{ 
# 511
using system::detail::generic::select_system;
# 513
typedef typename iterator_system< InputIterator1> ::type System1; 
# 514
typedef typename iterator_system< InputIterator2> ::type System2; 
# 515
typedef typename iterator_system< OutputIterator> ::type System3; 
# 517
System1 system1; 
# 518
System2 system2; 
# 519
System3 system3; 
# 521
return thrust::exclusive_scan_by_key(select_system(system1, system2, system3), first1, last1, first2, result, init, binary_pred, binary_op); 
# 522
} 
# 525
}
# 38 "/usr/local/cuda/include/thrust/system/detail/generic/reduce_by_key.inl"
namespace thrust { 
# 40
namespace system { 
# 42
namespace detail { 
# 44
namespace generic { 
# 46
namespace detail { 
# 50
template< class ValueType, class TailFlagType, class AssociativeOperator> 
# 51
struct reduce_by_key_functor { 
# 53
AssociativeOperator binary_op; 
# 55
typedef tuple< ValueType, TailFlagType, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  result_type; 
# 58
reduce_by_key_functor(AssociativeOperator _binary_op) : binary_op(_binary_op) { } 
# 61
result_type operator()(result_type a, result_type b) 
# 62
{ 
# 63
return result_type((thrust::get< 1> (b)) ? thrust::get< 0> (b) : (binary_op)(thrust::get< 0> (a), thrust::get< 0> (b)), thrust::get< 1> (a) | thrust::get< 1> (b)); 
# 65
} 
# 66
}; 
# 69
}
# 72
template< class ExecutionPolicy, class 
# 73
InputIterator1, class 
# 74
InputIterator2, class 
# 75
OutputIterator1, class 
# 76
OutputIterator2, class 
# 77
BinaryPredicate, class 
# 78
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 81
reduce_by_key(execution_policy< ExecutionPolicy>  &exec, InputIterator1 
# 82
keys_first, InputIterator1 
# 83
keys_last, InputIterator2 
# 84
values_first, OutputIterator1 
# 85
keys_output, OutputIterator2 
# 86
values_output, BinaryPredicate 
# 87
binary_pred, BinaryFunction 
# 88
binary_op) 
# 89
{ 
# 90
typedef typename iterator_traits< InputIterator1> ::difference_type difference_type; 
# 92
typedef unsigned FlagType; 
# 114
typedef typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator2> ::value, iterator_value< InputIterator2> , iterator_value< OutputIterator2> > > ::type ValueType; 
# 116
if (keys_first == keys_last) { 
# 117
return thrust::make_pair(keys_output, values_output); }  
# 120
difference_type n = keys_last - keys_first; 
# 122
InputIterator2 values_last = values_first + n; 
# 125
thrust::detail::temporary_array< unsigned, ExecutionPolicy>  head_flags(exec, n); 
# 126
thrust::transform(exec, keys_first, keys_last - 1, keys_first + 1, (head_flags.begin()) + 1, thrust::detail::not2(binary_pred)); 
# 127
(head_flags[0]) = 1; 
# 130
thrust::detail::temporary_array< unsigned, ExecutionPolicy>  tail_flags(exec, n); 
# 131
thrust::transform(exec, keys_first, keys_last - 1, keys_first + 1, (tail_flags.begin()), thrust::detail::not2(binary_pred)); 
# 132
(tail_flags[n - 1]) = 1; 
# 135
thrust::detail::temporary_array< typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator2> ::value, iterator_value< InputIterator2> , iterator_value< OutputIterator2> > > ::type, ExecutionPolicy>  scanned_values(exec, n); 
# 136
thrust::detail::temporary_array< unsigned, ExecutionPolicy>  scanned_tail_flags(exec, n); 
# 138
thrust::inclusive_scan(exec, thrust::make_zip_iterator(thrust::make_tuple(values_first, (head_flags.begin()))), thrust::make_zip_iterator(thrust::make_tuple(values_last, (head_flags.end()))), thrust::make_zip_iterator(thrust::make_tuple((scanned_values.begin()), (scanned_tail_flags.begin()))), ((detail::reduce_by_key_functor< typename thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator2> ::value, iterator_value< InputIterator2> , iterator_value< OutputIterator2> > > ::type, unsigned, BinaryFunction> )(binary_op))); 
# 145
thrust::exclusive_scan(exec, (tail_flags.begin()), (tail_flags.end()), (scanned_tail_flags.begin()), (FlagType)0, plus< unsigned> ()); 
# 148
FlagType N = (scanned_tail_flags[n - 1]) + 1; 
# 151
thrust::scatter_if(exec, keys_first, keys_last, (scanned_tail_flags.begin()), (head_flags.begin()), keys_output); 
# 152
thrust::scatter_if(exec, (scanned_values.begin()), (scanned_values.end()), (scanned_tail_flags.begin()), (tail_flags.begin()), values_output); 
# 154
return thrust::make_pair(keys_output + N, values_output + N); 
# 155
} 
# 158
template< class ExecutionPolicy, class 
# 159
InputIterator1, class 
# 160
InputIterator2, class 
# 161
OutputIterator1, class 
# 162
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 165
reduce_by_key(execution_policy< ExecutionPolicy>  &exec, InputIterator1 
# 166
keys_first, InputIterator1 
# 167
keys_last, InputIterator2 
# 168
values_first, OutputIterator1 
# 169
keys_output, OutputIterator2 
# 170
values_output) 
# 171
{ 
# 172
typedef typename iterator_value< InputIterator1> ::type KeyType; 
# 175
return thrust::reduce_by_key(exec, keys_first, keys_last, values_first, keys_output, values_output, equal_to< typename iterator_value< InputIterator1> ::type> ()); 
# 176
} 
# 179
template< class ExecutionPolicy, class 
# 180
InputIterator1, class 
# 181
InputIterator2, class 
# 182
OutputIterator1, class 
# 183
OutputIterator2, class 
# 184
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 187
reduce_by_key(execution_policy< ExecutionPolicy>  &exec, InputIterator1 
# 188
keys_first, InputIterator1 
# 189
keys_last, InputIterator2 
# 190
values_first, OutputIterator1 
# 191
keys_output, OutputIterator2 
# 192
values_output, BinaryPredicate 
# 193
binary_pred) 
# 194
{ 
# 199
typedef typename thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator2> ::value, iterator_value< InputIterator2> , iterator_value< OutputIterator2> > ::type T; 
# 202
return thrust::reduce_by_key(exec, keys_first, keys_last, values_first, keys_output, values_output, binary_pred, plus< typename thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator2> ::value, iterator_value< InputIterator2> , iterator_value< OutputIterator2> > ::type> ()); 
# 209
} 
# 212
}
# 213
}
# 214
}
# 215
}
# 28 "/usr/local/cuda/include/thrust/system/detail/sequential/reduce.h"
namespace thrust { 
# 30
namespace system { 
# 32
namespace detail { 
# 34
namespace sequential { 
# 39
template< class DerivedPolicy, class 
# 40
InputIterator, class 
# 41
OutputType, class 
# 42
BinaryFunction> OutputType 
# 44
reduce(execution_policy< DerivedPolicy>  &, InputIterator 
# 45
begin, InputIterator 
# 46
end, OutputType 
# 47
init, BinaryFunction 
# 48
binary_op) 
# 49
{ 
# 54
thrust::detail::wrapped_function< BinaryFunction, OutputType>  wrapped_binary_op(binary_op); 
# 57
OutputType result = init; 
# 59
while (begin != end) 
# 60
{ 
# 61
result = wrapped_binary_op(result, *begin); 
# 62
++begin; 
# 63
}  
# 65
return result; 
# 66
} 
# 69
}
# 70
}
# 71
}
# 72
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace cuda { 
# 33
namespace detail { 
# 37
template< class DerivedPolicy, class 
# 38
InputIterator, class 
# 39
OutputType, class 
# 40
BinaryFunction> OutputType 
# 37
reduce(execution_policy< DerivedPolicy>  & exec, InputIterator first, InputIterator last, OutputType init, BinaryFunction binary_op); 
# 49
}
# 50
}
# 51
}
# 52
}
# 32 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce.inl"
namespace thrust { 
# 34
namespace system { 
# 36
namespace cuda { 
# 38
namespace detail { 
# 40
namespace reduce_detail { 
# 44
struct reduce_partitions { 
# 46
template< class ConcurrentGroup, class Iterator1, class Iterator2, class T, class BinaryOperation> void 
# 48
operator()(ConcurrentGroup &this_group, Iterator1 first, Iterator1 last, Iterator2 result, T init, BinaryOperation binary_op) 
# 49
{int volatile ___ = 1;(void)this_group;(void)first;(void)last;(void)result;(void)init;(void)binary_op;
# 56
::exit(___);}
#if 0
# 49
{ 
# 50
T sum = bulk_::reduce(this_group, first, last, init, binary_op); 
# 52
if (((this_group.this_exec).index()) == 0) 
# 53
{ 
# 54
(*result) = sum; 
# 55
}  
# 56
} 
#endif
# 58 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce.inl"
template< class ConcurrentGroup, class Iterator1, class Iterator2, class BinaryOperation> void 
# 60
operator()(ConcurrentGroup &this_group, Iterator1 first, Iterator1 last, Iterator2 result, BinaryOperation binary_op) 
# 61
{int volatile ___ = 1;(void)this_group;(void)first;(void)last;(void)result;(void)binary_op;
# 65
::exit(___);}
#if 0
# 61
{ 
# 63
typename iterator_value< Iterator2> ::type init = thrust::raw_reference_cast(last[-1]); 
# 64
(*this)(this_group, first, last - 1, result, init, binary_op); 
# 65
} 
#endif
# 68 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce.inl"
template< class ConcurrentGroup, class Iterator1, class Decomposition, class Iterator2, class T, class BinaryFunction> void 
# 70
operator()(ConcurrentGroup &this_group, Iterator1 first, Decomposition decomp, Iterator2 result, T init, BinaryFunction binary_op) 
# 71
{int volatile ___ = 1;(void)this_group;(void)first;(void)decomp;(void)result;(void)init;(void)binary_op;
# 85
::exit(___);}
#if 0
# 71
{ 
# 72
typename Decomposition::range range = decomp[(this_group.index())]; 
# 74
Iterator1 last = first + (range.second); 
# 75
first += (range.first); 
# 77
if ((this_group.index()) != 0) 
# 78
{ 
# 80
init = thrust::raw_reference_cast(last[-1]); 
# 81
--last; 
# 82
}  
# 84
(*this)(this_group, first, last, result + (this_group.index()), init, binary_op); 
# 85
} 
#endif
# 86 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce.inl"
}; 
# 89
template< class DerivedPolicy, class 
# 90
InputIterator, class 
# 91
OutputType, class 
# 92
BinaryFunction> OutputType 
# 94
tuned_reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 95
first, InputIterator 
# 96
last, OutputType 
# 97
init, BinaryFunction 
# 98
binary_op) 
# 99
{ 
# 100
typedef typename iterator_difference< InputIterator> ::type size_type; 
# 102
const size_type n = last - first; 
# 104
if (n <= 0) { return init; }  
# 106
cudaStream_t s = stream(thrust::detail::derived_cast(exec)); 
# 108
const size_type groupsize = (128); 
# 109
const size_type grainsize = (7); 
# 110
const size_type tile_size = groupsize * grainsize; 
# 111
const size_type num_tiles = ((n + tile_size) - 1) / tile_size; 
# 112
const size_type subscription = (10); 
# 117
bulk_::concurrent_group< bulk_::agent< grainsize> , groupsize>  g; 
# 119
const size_type num_groups = thrust::min< typename iterator_difference< InputIterator> ::type> (subscription * (g.hardware_concurrency()), num_tiles); 
# 121
aligned_decomposition< typename iterator_difference< InputIterator> ::type>  decomp(n, num_groups, tile_size); 
# 123
thrust::detail::temporary_array< OutputType, DerivedPolicy>  partial_sums(exec, (decomp.size())); 
# 126
(bulk_::async(bulk_::par(s, g, (decomp.size())), reduce_partitions(), bulk_::root.this_exec, first, decomp, (partial_sums.begin()), init, binary_op).wait()); 
# 128
if ((partial_sums.size()) > 1) 
# 129
{ 
# 131
bulk_::async(bulk_::par(s, g, 1), reduce_partitions(), bulk_::root.this_exec, (partial_sums.begin()), (partial_sums.end()), (partial_sums.begin()), binary_op); 
# 132
}  
# 134
return get_value(exec, &(partial_sums[0])); 
# 135
} 
# 138
template< class DerivedPolicy, class 
# 139
InputIterator, class 
# 140
OutputType, class 
# 141
BinaryFunction> OutputType 
# 143
general_reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 144
first, InputIterator 
# 145
last, OutputType 
# 146
init, BinaryFunction 
# 147
binary_op) 
# 148
{ 
# 149
typedef typename iterator_difference< InputIterator> ::type size_type; 
# 151
const size_type n = last - first; 
# 153
if (n <= 0) { return init; }  
# 155
cudaStream_t s = stream(thrust::detail::derived_cast(exec)); 
# 157
typedef thrust::detail::temporary_array< OutputType, DerivedPolicy>  temporary_array; 
# 160
size_type num_groups = (0); 
# 161
size_type group_size = (0); 
# 163
thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(), reduce_partitions(), bulk_::root.this_exec, first, uniform_decomposition< typename iterator_difference< InputIterator> ::type> (), typename thrust::detail::temporary_array< OutputType, DerivedPolicy> ::iterator(), init, binary_op); 
# 165
num_groups = thrust::min< typename iterator_difference< InputIterator> ::type> (num_groups, thrust::detail::util::divide_ri(n, group_size)); 
# 167
uniform_decomposition< typename iterator_difference< InputIterator> ::type>  decomp(n, num_groups); 
# 168
temporary_array partial_sums(exec, (decomp.size())); 
# 171
bulk_::async(bulk_::grid((decomp.size()), group_size, bulk_::use_default, s), reduce_partitions(), bulk_::root.this_exec, first, decomp, (partial_sums.begin()), init, binary_op); 
# 173
if ((partial_sums.size()) > 1) 
# 174
{ 
# 176
thrust::tie(num_groups, group_size) = bulk_::choose_sizes(bulk_::grid(1), reduce_partitions(), bulk_::root.this_exec, (partial_sums.begin()), (partial_sums.end()), (partial_sums.begin()), binary_op); 
# 179
bulk_::async(bulk_::grid(num_groups, group_size, bulk_::use_default, s), reduce_partitions(), bulk_::root.this_exec, (partial_sums.begin()), (partial_sums.end()), (partial_sums.begin()), binary_op); 
# 180
}  
# 182
return get_value(exec, &(partial_sums[0])); 
# 183
} 
# 187
template< class DerivedPolicy, class 
# 188
InputIterator, class 
# 189
OutputType, class 
# 190
BinaryFunction> typename thrust::detail::enable_if< thrust::detail::is_arithmetic< OutputType> ::value, OutputType> ::type 
# 196
reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 197
first, InputIterator 
# 198
last, OutputType 
# 199
init, BinaryFunction 
# 200
binary_op) 
# 201
{ 
# 202
return reduce_detail::tuned_reduce(exec, first, last, init, binary_op); 
# 203
} 
# 207
template< class DerivedPolicy, class 
# 208
InputIterator, class 
# 209
OutputType, class 
# 210
BinaryFunction> typename thrust::detail::disable_if< thrust::detail::is_arithmetic< OutputType> ::value, OutputType> ::type 
# 216
reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 217
first, InputIterator 
# 218
last, OutputType 
# 219
init, BinaryFunction 
# 220
binary_op) 
# 221
{ 
# 222
return reduce_detail::general_reduce(exec, first, last, init, binary_op); 
# 223
} 
# 227
}
# 230
template< class DerivedPolicy, class 
# 231
InputIterator, class 
# 232
OutputType, class 
# 233
BinaryFunction> OutputType 
# 235
reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 236
first, InputIterator 
# 237
last, OutputType 
# 238
init, BinaryFunction 
# 239
binary_op) 
# 240
{ 
# 246
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator, true> ::value)> )>  thrust_static_assert_typedef_246 __attribute((unused)); 
# 248
struct workaround { 
# 251
static OutputType parallel_path(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 252
first, InputIterator 
# 253
last, OutputType 
# 254
init, BinaryFunction 
# 255
binary_op) 
# 256
{ 
# 257
return reduce_detail::reduce(exec, first, last, init, binary_op); 
# 258
} 
# 261
static OutputType sequential_path(execution_policy< DerivedPolicy>  &, InputIterator 
# 262
first, InputIterator 
# 263
last, OutputType 
# 264
init, BinaryFunction 
# 265
binary_op) 
# 266
{ 
# 267
return thrust::reduce(thrust::seq, first, last, init, binary_op); 
# 268
} 
# 269
}; 
# 272
return (workaround::parallel_path)(exec, first, last, init, binary_op); 
# 276
} 
# 279
}
# 280
}
# 281
}
# 282
}
# 24 "/usr/local/cuda/include/thrust/detail/type_traits/algorithm/intermediate_type_from_function_and_iterators.h"
namespace thrust { 
# 27
namespace detail { 
# 44
template< class InputIterator, class OutputIterator, class Function> 
# 45
struct intermediate_type_from_function_and_iterators : public eval_if< has_result_type< Function> ::value, result_type< Function> , eval_if< is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > >  { 
# 56
}; 
# 58
}
# 60
}
# 25 "/usr/local/cuda/include/thrust/system/detail/sequential/reduce_by_key.h"
namespace thrust { 
# 27
namespace system { 
# 29
namespace detail { 
# 31
namespace sequential { 
# 36
template< class DerivedPolicy, class 
# 37
InputIterator1, class 
# 38
InputIterator2, class 
# 39
OutputIterator1, class 
# 40
OutputIterator2, class 
# 41
BinaryPredicate, class 
# 42
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 45
reduce_by_key(execution_policy< DerivedPolicy>  &, InputIterator1 
# 46
keys_first, InputIterator1 
# 47
keys_last, InputIterator2 
# 48
values_first, OutputIterator1 
# 49
keys_output, OutputIterator2 
# 50
values_output, BinaryPredicate 
# 51
binary_pred, BinaryFunction 
# 52
binary_op) 
# 53
{ 
# 54
typedef typename iterator_traits< InputIterator1> ::value_type InputKeyType; 
# 55
typedef typename iterator_traits< InputIterator2> ::value_type InputValueType; 
# 61
typedef typename thrust::detail::intermediate_type_from_function_and_iterators< InputIterator2, OutputIterator2, BinaryFunction> ::type TemporaryType; 
# 63
if (keys_first != keys_last) 
# 64
{ 
# 65
InputKeyType temp_key = *keys_first; 
# 66
TemporaryType temp_value = *values_first; 
# 68
for ((++keys_first), (++values_first); keys_first != keys_last; (++keys_first), (++values_first)) 
# 71
{ 
# 72
InputKeyType key = *keys_first; 
# 73
InputValueType value = *values_first; 
# 75
if (binary_pred(temp_key, key)) 
# 76
{ 
# 77
temp_value = binary_op(temp_value, value); 
# 78
} else 
# 80
{ 
# 81
(*keys_output) = temp_key; 
# 82
(*values_output) = temp_value; 
# 84
++keys_output; 
# 85
++values_output; 
# 87
temp_key = key; 
# 88
temp_value = value; 
# 89
}  
# 90
}  
# 92
(*keys_output) = temp_key; 
# 93
(*values_output) = temp_value; 
# 95
++keys_output; 
# 96
++values_output; 
# 97
}  
# 99
return thrust::make_pair(keys_output, values_output); 
# 100
} 
# 103
}
# 104
}
# 105
}
# 106
}
# 27 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_by_key.h"
namespace thrust { 
# 29
namespace system { 
# 31
namespace cuda { 
# 33
namespace detail { 
# 37
template< class DerivedPolicy, class 
# 38
InputIterator1, class 
# 39
InputIterator2, class 
# 40
OutputIterator1, class 
# 41
OutputIterator2, class 
# 42
BinaryPredicate, class 
# 43
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 37
reduce_by_key(execution_policy< DerivedPolicy>  & exec, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op); 
# 56
}
# 57
}
# 58
}
# 59
}
# 22 "/usr/local/cuda/include/thrust/iterator/detail/constant_iterator_base.h"
namespace thrust { 
# 26
template< class , class , class > class constant_iterator; 
# 28
namespace detail { 
# 31
template< class Value, class 
# 32
Incrementable, class 
# 33
System> 
# 34
struct constant_iterator_base { 
# 36
typedef Value value_type; 
# 43
typedef value_type reference; 
# 49
typedef typename ia_dflt_help< Incrementable, identity_< signed int> > ::type incrementable; 
# 55
typedef counting_iterator< typename ia_dflt_help< Incrementable, identity_< signed int> > ::type, System, random_access_traversal_tag>  base_iterator; 
# 64
typedef iterator_adaptor< constant_iterator< Value, Incrementable, System> , counting_iterator< typename ia_dflt_help< Incrementable, identity_< signed int> > ::type, System, random_access_traversal_tag> , Value, typename iterator_system< counting_iterator< typename ia_dflt_help< Incrementable, identity_< signed int> > ::type, System, random_access_traversal_tag> > ::type, typename iterator_traversal< counting_iterator< typename ia_dflt_help< Incrementable, identity_< signed int> > ::type, System, random_access_traversal_tag> > ::type, Value>  type; 
# 65
}; 
# 67
}
# 69
}
# 29 "/usr/local/cuda/include/thrust/iterator/constant_iterator.h"
namespace thrust { 
# 96
template< class Value, class 
# 97
Incrementable = use_default, class 
# 98
System = use_default> 
# 99
class constant_iterator : public detail::constant_iterator_base< Value, Incrementable, System> ::type { 
# 104
friend class iterator_core_access; 
# 105
typedef typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::type super_t; 
# 106
typedef typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::incrementable incrementable; 
# 107
typedef typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::base_iterator base_iterator; 
# 110
public: typedef typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::type::reference reference; 
# 111
typedef typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::type::value_type value_type; 
# 120
constant_iterator() : super_t(), m_value() 
# 121
{ } 
# 129
constant_iterator(const constant_iterator &rhs) : super_t((rhs.base())), m_value(rhs.m_value) 
# 130
{ } 
# 137
template< class OtherSystem> 
# 139
constant_iterator(const ::thrust::constant_iterator< Value, Incrementable, OtherSystem>  &rhs, typename ::thrust::detail::enable_if_convertible< typename iterator_system< ::thrust::constant_iterator< Value, Incrementable, OtherSystem> > ::type, typename iterator_system< typename ::thrust::detail::constant_iterator_base< Value, Incrementable, System> ::type> ::type> ::type * = 0) : super_t((rhs.base())), m_value((rhs.value())) 
# 144
{ } 
# 156
constant_iterator(const value_type &v, const incrementable &i = incrementable()) : super_t((base_iterator)i), m_value(v) 
# 157
{ } 
# 167
template< class OtherValue, class OtherIncrementable> 
# 169
constant_iterator(const OtherValue &v, const OtherIncrementable &i = incrementable()) : super_t((base_iterator)i), m_value(v) 
# 170
{ } 
# 176
const Value &value() const 
# 177
{ return m_value; } 
# 184
protected: const Value &value_reference() const 
# 185
{ return m_value; } 
# 188
Value &value_reference() 
# 189
{ return m_value; } 
# 193
private: reference dereference() const 
# 194
{ 
# 195
return m_value; 
# 196
} 
# 199
Value m_value; 
# 203
}; 
# 220
template< class V, class I> inline constant_iterator< V, I>  
# 222
make_constant_iterator(V x, I i = ((int)0)) 
# 223
{ 
# 224
return constant_iterator< V, I> (x, i); 
# 225
} 
# 237
template< class V> inline constant_iterator< V>  
# 239
make_constant_iterator(V x) 
# 240
{ 
# 241
return constant_iterator< V> (x, 0); 
# 242
} 
# 250
}
# 25 "/usr/local/cuda/include/thrust/iterator/detail/discard_iterator_base.h"
namespace thrust { 
# 29
template< class > class discard_iterator; 
# 31
namespace detail { 
# 35
template< class System> 
# 36
struct discard_iterator_base { 
# 40
typedef any_assign value_type; 
# 41
typedef any_assign &reference; 
# 42
typedef std::ptrdiff_t incrementable; 
# 48
typedef counting_iterator< long, System, random_access_traversal_tag>  base_iterator; 
# 57
typedef iterator_adaptor< discard_iterator< System> , counting_iterator< long, System, random_access_traversal_tag> , any_assign, typename iterator_system< counting_iterator< long, System, random_access_traversal_tag> > ::type, typename iterator_traversal< counting_iterator< long, System, random_access_traversal_tag> > ::type, any_assign &>  type; 
# 58
}; 
# 61
}
# 63
}
# 30 "/usr/local/cuda/include/thrust/iterator/discard_iterator.h"
namespace thrust { 
# 93
template< class System = use_default> 
# 94
class discard_iterator : public detail::discard_iterator_base< System> ::type { 
# 99
friend class iterator_core_access; 
# 100
typedef typename ::thrust::detail::discard_iterator_base< System> ::type super_t; 
# 101
typedef typename ::thrust::detail::discard_iterator_base< System> ::incrementable incrementable; 
# 102
typedef typename ::thrust::detail::discard_iterator_base< System> ::base_iterator base_iterator; 
# 105
public: typedef typename ::thrust::detail::discard_iterator_base< System> ::type::reference reference; 
# 106
typedef typename ::thrust::detail::discard_iterator_base< System> ::type::value_type value_type; 
# 116
discard_iterator(const discard_iterator &rhs) : super_t((rhs.base())) 
# 117
{ } 
# 127
discard_iterator(const incrementable &i = incrementable()) : super_t((base_iterator)i) 
# 128
{ } 
# 135
private: reference dereference() const 
# 136
{ 
# 137
return m_element; 
# 138
} 
# 140
mutable value_type m_element; 
# 144
}; 
# 157
inline discard_iterator<>  make_discard_iterator(iterator_adaptor< discard_iterator<> , counting_iterator< long, use_default, random_access_traversal_tag> , detail::any_assign, any_system_tag, random_access_traversal_tag, detail::any_assign &> ::difference_type i = (iterator_adaptor< discard_iterator<> , counting_iterator< long, use_default, random_access_traversal_tag> , detail::any_assign, any_system_tag, random_access_traversal_tag, detail::any_assign &> ::difference_type)0) 
# 158
{ 
# 159
return ((discard_iterator<> )(i)); 
# 160
} 
# 168
}
# 27 "/usr/local/cuda/include/thrust/detail/range/head_flags.h"
namespace thrust { 
# 29
namespace detail { 
# 33
template< class RandomAccessIterator, class 
# 34
BinaryPredicate = thrust::equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 35
ValueType = bool, class 
# 36
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 37
class head_flags_with_init { 
# 39
typedef typename iterator_value< RandomAccessIterator> ::type init_type; 
# 44
public: struct head_flag_functor { 
# 46
BinaryPredicate binary_pred; 
# 47
init_type init; 
# 48
IndexType n; 
# 50
typedef ValueType result_type; 
# 53
head_flag_functor(init_type init, IndexType n) : binary_pred(), init(init), n(n) 
# 55
{ } 
# 58
head_flag_functor(init_type init, IndexType n, BinaryPredicate binary_pred) : binary_pred(binary_pred), init(init), n(n) 
# 60
{ } 
# 62
template< class Tuple> 
# 63
__attribute((always_inline)) result_type 
# 64
operator()(const Tuple &t) 
# 65
{ 
# 66
const IndexType i = thrust::get< 0> (t); 
# 68
if (i == 0) 
# 69
{ 
# 70
return !(binary_pred)(init, thrust::get< 1> (t)); 
# 71
}  
# 73
return !(binary_pred)(thrust::get< 1> (t), thrust::get< 2> (t)); 
# 74
} 
# 75
}; 
# 77
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 83
typedef transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > >  iterator; 
# 87
head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(init, last - first))), m_end((m_begin) + (last - first)) 
# 91
{ } 
# 95
head_flags_with_init(RandomAccessIterator first, RandomAccessIterator last, init_type init, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(init, last - first, binary_pred))), m_end((m_begin) + (last - first)) 
# 99
{ } 
# 102
iterator begin() const 
# 103
{ 
# 104
return m_begin; 
# 105
} 
# 108
iterator end() const 
# 109
{ 
# 110
return m_end; 
# 111
} 
# 113
template< class OtherIndex> typename transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > > ::reference 
# 115
operator[](OtherIndex i) 
# 116
{ 
# 117
return *(begin() + i); 
# 118
} 
# 121
private: iterator m_begin, m_end; 
# 122
}; 
# 126
template< class RandomAccessIterator, class 
# 127
BinaryPredicate = thrust::equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 128
ValueType = bool, class 
# 129
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 130
class head_flags { 
# 135
public: struct head_flag_functor { 
# 137
BinaryPredicate binary_pred; 
# 138
IndexType n; 
# 140
typedef ValueType result_type; 
# 143
head_flag_functor(IndexType n) : binary_pred(), n(n) 
# 145
{ } 
# 148
head_flag_functor(IndexType n, BinaryPredicate binary_pred) : binary_pred(binary_pred), n(n) 
# 150
{ } 
# 152
template< class Tuple> 
# 153
__attribute((always_inline)) result_type 
# 154
operator()(const Tuple &t) 
# 155
{ 
# 156
const IndexType i = thrust::get< 0> (t); 
# 160
return (i == 0) || (!(binary_pred)(thrust::get< 1> (t), thrust::get< 2> (t))); 
# 161
} 
# 162
}; 
# 164
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 170
typedef transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > >  iterator; 
# 173
head_flags(RandomAccessIterator first, RandomAccessIterator last) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), (head_flag_functor)(last - first))), m_end((m_begin) + (last - first)) 
# 177
{ } 
# 180
head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple(((thrust::counting_iterator< IndexType> )(0)), first, first - 1)), head_flag_functor(last - first, binary_pred))), m_end((m_begin) + (last - first)) 
# 184
{ } 
# 187
iterator begin() const 
# 188
{ 
# 189
return m_begin; 
# 190
} 
# 193
iterator end() const 
# 194
{ 
# 195
return m_end; 
# 196
} 
# 198
template< class OtherIndex> typename transform_iterator< head_flag_functor, zip_iterator< tuple< thrust::counting_iterator< IndexType> , RandomAccessIterator, RandomAccessIterator, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > > ::reference 
# 200
operator[](OtherIndex i) 
# 201
{ 
# 202
return *(begin() + i); 
# 203
} 
# 206
private: iterator m_begin, m_end; 
# 207
}; 
# 210
template< class RandomAccessIterator, class BinaryPredicate> head_flags< RandomAccessIterator, BinaryPredicate>  
# 213
make_head_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) 
# 214
{ 
# 215
return head_flags< RandomAccessIterator, BinaryPredicate> (first, last, binary_pred); 
# 216
} 
# 219
template< class RandomAccessIterator> head_flags< RandomAccessIterator>  
# 222
make_head_flags(RandomAccessIterator first, RandomAccessIterator last) 
# 223
{ 
# 224
return head_flags< RandomAccessIterator> (first, last); 
# 225
} 
# 228
}
# 229
}
# 26 "/usr/local/cuda/include/thrust/detail/range/tail_flags.h"
namespace thrust { 
# 28
namespace detail { 
# 32
template< class RandomAccessIterator, class 
# 33
BinaryPredicate = thrust::equal_to< typename iterator_value< RandomAccessIterator> ::type> , class 
# 34
ValueType = bool, class 
# 35
IndexType = typename iterator_difference< RandomAccessIterator> ::type> 
# 36
class tail_flags { 
# 41
public: struct tail_flag_functor { 
# 43
BinaryPredicate binary_pred; 
# 44
RandomAccessIterator iter; 
# 45
IndexType n; 
# 47
typedef ValueType result_type; 
# 50
tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last) : binary_pred(), iter(first), n(last - first) 
# 52
{ } 
# 55
tail_flag_functor(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : binary_pred(binary_pred), iter(first), n(last - first) 
# 57
{ } 
# 59
__attribute((always_inline)) result_type 
# 60
operator()(const IndexType &i) 
# 61
{ 
# 62
return (i == ((n) - 1)) || (!(binary_pred)((iter)[i], (iter)[i + 1])); 
# 63
} 
# 64
}; 
# 66
typedef thrust::counting_iterator< IndexType>  counting_iterator; 
# 72
typedef transform_iterator< tail_flag_functor, thrust::counting_iterator< IndexType> >  iterator; 
# 76
tail_flags(RandomAccessIterator first, RandomAccessIterator last) : m_begin(thrust::make_transform_iterator(((thrust::counting_iterator< IndexType> )(0)), tail_flag_functor(first, last))), m_end((m_begin) + (last - first)) 
# 80
{ } 
# 84
tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) : m_begin(thrust::make_transform_iterator(((thrust::counting_iterator< IndexType> )(0)), tail_flag_functor(first, last, binary_pred))), m_end((m_begin) + (last - first)) 
# 88
{ } 
# 91
iterator begin() const 
# 92
{ 
# 93
return m_begin; 
# 94
} 
# 97
iterator end() const 
# 98
{ 
# 99
return m_end; 
# 100
} 
# 102
template< class OtherIndex> typename transform_iterator< tail_flag_functor, thrust::counting_iterator< IndexType> > ::reference 
# 104
operator[](OtherIndex i) 
# 105
{ 
# 106
return *(begin() + i); 
# 107
} 
# 110
private: iterator m_begin, m_end; 
# 111
}; 
# 114
template< class RandomAccessIterator, class BinaryPredicate> tail_flags< RandomAccessIterator, BinaryPredicate>  
# 117
make_tail_flags(RandomAccessIterator first, RandomAccessIterator last, BinaryPredicate binary_pred) 
# 118
{ 
# 119
return tail_flags< RandomAccessIterator, BinaryPredicate> (first, last, binary_pred); 
# 120
} 
# 123
template< class RandomAccessIterator> tail_flags< RandomAccessIterator>  
# 126
make_tail_flags(RandomAccessIterator first, RandomAccessIterator last) 
# 127
{ 
# 128
return tail_flags< RandomAccessIterator> (first, last); 
# 129
} 
# 132
}
# 133
}
# 9 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_intervals.hpp"
namespace thrust { 
# 11
namespace system { 
# 13
namespace cuda { 
# 15
namespace detail { 
# 17
namespace reduce_intervals_detail { 
# 21
struct reduce_intervals_kernel { 
# 23
template< std::size_t groupsize, std::size_t grainsize, class RandomAccessIterator1, class Decomposition, class RandomAccessIterator2, class BinaryFunction> void 
# 24
operator()(bulk_::concurrent_group< bulk_::agent< grainsize> , groupsize>  &this_group, RandomAccessIterator1 
# 25
first, Decomposition 
# 26
decomp, RandomAccessIterator2 
# 27
result, BinaryFunction 
# 28
binary_op) 
# 29
{int volatile ___ = 1;(void)this_group;(void)first;(void)decomp;(void)result;(void)binary_op;
# 42
::exit(___);}
#if 0
# 29
{ 
# 30
typedef typename iterator_value< RandomAccessIterator1> ::type value_type; 
# 32
typename Decomposition::range rng = decomp[(this_group.index())]; 
# 34
value_type init = first[(rng.second) - 1]; 
# 36
value_type sum = bulk_::reduce(this_group, first + (rng.first), (first + (rng.second)) - 1, init, binary_op); 
# 38
if (((this_group.this_exec).index()) == 0) 
# 39
{ 
# 40
(result[(this_group.index())]) = sum; 
# 41
}  
# 42
} 
#endif
# 43 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_intervals.hpp"
}; 
# 46
}
# 49
template< class DerivedPolicy, class RandomAccessIterator1, class Decomposition, class RandomAccessIterator2, class BinaryFunction> RandomAccessIterator2 
# 51
reduce_intervals_(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator1 first, Decomposition decomp, RandomAccessIterator2 result, BinaryFunction binary_op) 
# 52
{ 
# 53
typedef typename iterator_value< RandomAccessIterator2> ::type result_type; 
# 54
const size_t groupsize = (128); 
# 55
size_t heap_size = (groupsize * sizeof(result_type)); 
# 56
bulk_::async(bulk_::grid< 128UL, 7> ((decomp.size()), heap_size, stream(thrust::detail::derived_cast(exec))), reduce_intervals_detail::reduce_intervals_kernel(), bulk_::root.this_exec, first, decomp, result, binary_op); 
# 58
return result + (decomp.size()); 
# 59
} 
# 62
template< class DerivedPolicy, class RandomAccessIterator1, class Size, class RandomAccessIterator2, class BinaryFunction> RandomAccessIterator2 
# 64
reduce_intervals_(execution_policy< DerivedPolicy>  &exec, RandomAccessIterator1 first, RandomAccessIterator1 last, Size interval_size, RandomAccessIterator2 result, BinaryFunction binary_op) 
# 65
{ 
# 66
return cuda::detail::reduce_intervals_(exec, first, make_blocked_decomposition< Size> (last - first, interval_size), result, binary_op); 
# 67
} 
# 70
}
# 71
}
# 72
}
# 73
}
# 34 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_by_key.inl"
namespace thrust { 
# 36
namespace system { 
# 38
namespace cuda { 
# 40
namespace detail { 
# 42
namespace reduce_by_key_detail { 
# 46
struct reduce_by_key_kernel { 
# 48
template< class ConcurrentGroup, class 
# 49
RandomAccessIterator1, class 
# 50
Decomposition, class 
# 51
RandomAccessIterator2, class 
# 52
RandomAccessIterator3, class 
# 53
RandomAccessIterator4, class 
# 54
RandomAccessIterator5, class 
# 55
RandomAccessIterator6, class 
# 56
RandomAccessIterator7, class 
# 57
BinaryPredicate, class 
# 58
BinaryFunction> pair< RandomAccessIterator3, RandomAccessIterator4>  
# 61
operator()(ConcurrentGroup &g, RandomAccessIterator1 
# 62
keys_first, Decomposition 
# 63
decomp, RandomAccessIterator2 
# 64
values_first, RandomAccessIterator3 
# 65
keys_result, RandomAccessIterator4 
# 66
values_result, RandomAccessIterator5 
# 67
interval_output_offsets, RandomAccessIterator6 
# 68
interval_values, RandomAccessIterator7 
# 69
is_carry, tuple< BinaryPredicate, BinaryFunction, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  
# 72
pred_and_binary_op) 
# 73
{int volatile ___ = 1;(void)g;(void)keys_first;(void)decomp;(void)values_first;(void)keys_result;(void)values_result;(void)interval_output_offsets;(void)interval_values;(void)is_carry;(void)pred_and_binary_op;
# 124
::exit(___);}
#if 0
# 73
{ 
# 74
typedef typename iterator_value< RandomAccessIterator1> ::type key_type; 
# 75
typedef typename iterator_value< RandomAccessIterator2> ::type value_type; 
# 77
BinaryPredicate pred = thrust::get< 0> (pred_and_binary_op); 
# 78
BinaryFunction binary_op = thrust::get< 1> (pred_and_binary_op); 
# 80
thrust::detail::tail_flags< RandomAccessIterator1, BinaryPredicate>  tail_flags(keys_first, keys_first + (decomp.n()), pred); 
# 82
typename Decomposition::size_type input_first, input_last; 
# 83
thrust::tie(input_first, input_last) = (decomp[(g.index())]); 
# 85
typename Decomposition::size_type output_first = ((g.index()) == 0) ? 0 : (interval_output_offsets[(g.index()) - 1]); 
# 87
key_type init_key = keys_first[input_first]; 
# 88
value_type init_value = values_first[input_first]; 
# 91
thrust::tie(keys_result, values_result, init_key, init_value) = bulk_::reduce_by_key(g, (keys_first + input_first) + 1, keys_first + input_last, (values_first + input_first) + 1, keys_result + output_first, values_result + output_first, init_key, init_value, pred, binary_op); 
# 103
if (((g.this_exec).index()) == 0) 
# 104
{ 
# 105
bool interval_has_carry = !(tail_flags[input_last - 1]); 
# 107
if (interval_has_carry) 
# 108
{ 
# 109
(interval_values[(g.index())]) = init_value; 
# 110
} else 
# 112
{ 
# 113
(*keys_result) = init_key; 
# 114
(*values_result) = init_value; 
# 116
++keys_result; 
# 117
++values_result; 
# 118
}  
# 120
(is_carry[(g.index())]) = interval_has_carry; 
# 121
}  
# 123
return thrust::make_pair(keys_result, values_result); 
# 124
} 
#endif
# 127 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_by_key.inl"
template< class ConcurrentGroup, class 
# 128
RandomAccessIterator1, class 
# 129
RandomAccessIterator2, class 
# 130
RandomAccessIterator3, class 
# 131
RandomAccessIterator4, class 
# 132
BinaryPredicate, class 
# 133
BinaryFunction, class 
# 134
Iterator> void 
# 136
operator()(ConcurrentGroup &g, RandomAccessIterator1 
# 137
keys_first, RandomAccessIterator1 
# 138
keys_last, RandomAccessIterator2 
# 139
values_first, RandomAccessIterator3 
# 140
keys_result, RandomAccessIterator4 
# 141
values_result, BinaryPredicate 
# 142
pred, BinaryFunction 
# 143
binary_op, Iterator 
# 144
result_size) 
# 145
{int volatile ___ = 1;(void)g;(void)keys_first;(void)keys_last;(void)values_first;(void)keys_result;(void)values_result;(void)pred;(void)binary_op;(void)result_size;
# 159
::exit(___);}
#if 0
# 145
{ 
# 146
RandomAccessIterator3 old_keys_result = keys_result; 
# 148
thrust::tie(keys_result, values_result) = operator()(g, keys_first, make_trivial_decomposition(keys_last - keys_first), values_first, keys_result, values_result, thrust::make_constant_iterator< int> (0), thrust::make_discard_iterator(), thrust::make_discard_iterator(), thrust::make_tuple(pred, binary_op)); 
# 155
if (((g.this_exec).index()) == 0) 
# 156
{ 
# 157
(*result_size) = (keys_result - old_keys_result); 
# 158
}  
# 159
} 
#endif
# 160 "/usr/local/cuda/include/thrust/system/cuda/detail/reduce_by_key.inl"
}; 
# 163
struct tuple_and { 
# 165
typedef bool result_type; 
# 167
template< class Tuple> bool 
# 169
operator()(Tuple t) 
# 170
{ 
# 171
return thrust::get< 0> (t) && thrust::get< 1> (t); 
# 172
} 
# 173
}; 
# 176
template< class DerivedPolicy, class 
# 177
Iterator1, class 
# 178
Iterator2, class 
# 179
Iterator3, class 
# 180
Iterator4, class 
# 181
BinaryFunction> void 
# 183
sum_tail_carries(execution_policy< DerivedPolicy>  &exec, Iterator1 
# 184
interval_values_first, Iterator1 
# 185
interval_values_last, Iterator2 
# 186
interval_output_offsets_first, Iterator2 
# 187
interval_output_offsets_last, Iterator3 
# 188
is_carry, Iterator4 
# 189
values_result, BinaryFunction 
# 190
binary_op) 
# 191
{ 
# 192
typedef thrust::zip_iterator< tuple< Iterator2, Iterator3, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  zip_iterator; 
# 194
thrust::detail::tail_flags< thrust::zip_iterator< tuple< Iterator2, Iterator3, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > >  tail_flags(thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets_first, is_carry)), thrust::make_zip_iterator(thrust::make_tuple(interval_output_offsets_last, is_carry))); 
# 200
thrust::transform_if(exec, interval_values_first, interval_values_last, thrust::make_permutation_iterator(values_result, interval_output_offsets_first), thrust::make_transform_iterator(thrust::make_zip_iterator(thrust::make_tuple((tail_flags.begin()), is_carry)), tuple_and()), thrust::make_permutation_iterator(values_result, interval_output_offsets_first), binary_op, identity< bool> ()); 
# 207
} 
# 210
template< class InputIterator, class OutputIterator, class BinaryFunction> 
# 211
struct intermediate_type : public thrust::detail::eval_if< thrust::detail::has_result_type< BinaryFunction> ::value, thrust::detail::result_type< BinaryFunction> , thrust::detail::eval_if< thrust::detail::is_output_iterator< OutputIterator> ::value, iterator_value< InputIterator> , iterator_value< OutputIterator> > >  { 
# 221
}; 
# 224
template< class Size, class 
# 225
DerivedPolicy, class 
# 226
InputIterator1, class 
# 227
InputIterator2, class 
# 228
OutputIterator1, class 
# 229
OutputIterator2, class 
# 230
BinaryPredicate, class 
# 231
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 234
reduce_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 235
keys_first, InputIterator1 
# 236
keys_last, InputIterator2 
# 237
values_first, OutputIterator1 
# 238
keys_result, OutputIterator2 
# 239
values_result, BinaryPredicate 
# 240
binary_pred, BinaryFunction 
# 241
binary_op) 
# 242
{ 
# 243
typedef typename iterator_difference< InputIterator1> ::type difference_type; 
# 244
typedef typename iterator_value< InputIterator2> ::type value_type; 
# 245
typedef Size size_type; 
# 247
const difference_type n = keys_last - keys_first; 
# 249
if (n <= 0) { return thrust::make_pair(keys_result, values_result); }  
# 251
const size_type threshold_of_parallelism = (20000); 
# 253
if (n <= threshold_of_parallelism) 
# 254
{ 
# 255
thrust::detail::temporary_array< Size, DerivedPolicy>  result_size_storage(exec, 1); 
# 260
const int groupsize = ((sizeof(value_type) <= sizeof(int)) ? 512 : ((sizeof(value_type) <= ((2) * sizeof(int))) ? 256 : 128)); 
# 265
const int grainsize = ((sizeof(value_type) == sizeof(int)) ? 3 : 5); 
# 267
size_type heap_size = ((groupsize * grainsize) * (sizeof(size_type) + sizeof(value_type))); 
# 268
bulk_::async(bulk_::grid< groupsize, grainsize> (1, heap_size, stream(thrust::detail::derived_cast(exec))), reduce_by_key_kernel(), bulk_::root.this_exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op, (result_size_storage.begin())); 
# 271
size_type result_size = get_value(exec, &(result_size_storage[0])); 
# 273
return thrust::make_pair(keys_result + result_size, values_result + result_size); 
# 274
}  
# 278
typedef typename reduce_by_key_detail::intermediate_type< InputIterator2, OutputIterator2, BinaryFunction> ::type intermediate_type; 
# 280
const size_type groupsize = (128); 
# 281
const size_type grainsize = (5); 
# 282
size_type tile_size = groupsize * grainsize; 
# 284
const size_type interval_size = threshold_of_parallelism; 
# 286
size_type subscription = (100); 
# 287
size_type num_groups = thrust::min< Size> (subscription * bulk_::concurrent_group<> ::hardware_concurrency(), ((n + interval_size) - 1) / interval_size); 
# 288
aligned_decomposition< Size>  decomp(n, num_groups, tile_size); 
# 295
thrust::detail::tail_flags< InputIterator1, BinaryPredicate, Size>  tail_flags(keys_first, keys_last, binary_pred); 
# 297
thrust::detail::temporary_array< Size, DerivedPolicy>  interval_output_offsets(exec, (decomp.size())); 
# 299
reduce_intervals_(exec, (tail_flags.begin()), decomp, (interval_output_offsets.begin()), plus< Size> ()); 
# 302
thrust::inclusive_scan(exec, (interval_output_offsets.begin()), (interval_output_offsets.end()), (interval_output_offsets.begin())); 
# 305
thrust::detail::temporary_array< bool, DerivedPolicy>  is_carry(exec, (decomp.size())); 
# 306
thrust::detail::temporary_array< typename reduce_by_key_detail::intermediate_type< InputIterator2, OutputIterator2, BinaryFunction> ::type, DerivedPolicy>  interval_values(exec, (decomp.size())); 
# 308
size_type heap_size = tile_size * (sizeof(size_type) + sizeof(value_type)); 
# 309
bulk_::async(bulk_::grid< groupsize, grainsize> ((decomp.size()), heap_size, stream(thrust::detail::derived_cast(exec))), reduce_by_key_kernel(), bulk_::root.this_exec, keys_first, decomp, values_first, keys_result, values_result, (interval_output_offsets.begin()), (interval_values.begin()), (is_carry.begin()), thrust::make_tuple(binary_pred, binary_op)); 
# 314
thrust::inclusive_scan_by_key(exec, thrust::make_zip_iterator(thrust::make_tuple((interval_output_offsets.begin()), (is_carry.begin()))), thrust::make_zip_iterator(thrust::make_tuple((interval_output_offsets.end()), (is_carry.end()))), (interval_values.begin()), (interval_values.begin()), equal_to< tuple< Size, bool, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > (), binary_op); 
# 323
reduce_by_key_detail::sum_tail_carries(exec, (interval_values.begin()), (interval_values.end()), (interval_output_offsets.begin()), (interval_output_offsets.end()), (is_carry.begin()), values_result, binary_op); 
# 330
difference_type result_size = interval_output_offsets[(interval_output_offsets.size()) - 1]; 
# 332
return thrust::make_pair(keys_result + result_size, values_result + result_size); 
# 333
} 
# 336
template< class DerivedPolicy, class 
# 337
InputIterator1, class 
# 338
InputIterator2, class 
# 339
OutputIterator1, class 
# 340
OutputIterator2, class 
# 341
BinaryPredicate, class 
# 342
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 345
reduce_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 346
keys_first, InputIterator1 
# 347
keys_last, InputIterator2 
# 348
values_first, OutputIterator1 
# 349
keys_result, OutputIterator2 
# 350
values_result, BinaryPredicate 
# 351
binary_pred, BinaryFunction 
# 352
binary_op) 
# 353
{ 
# 354
pair< OutputIterator1, OutputIterator2>  result(keys_result, values_result); 
# 356
typedef typename iterator_difference< InputIterator1> ::type difference_type; 
# 360
if ((keys_last - keys_first) <= (static_cast< difference_type>(((2147483647) * 2U) + 1U))) 
# 361
{ 
# 362
result = reduce_by_key_detail::reduce_by_key< unsigned> (exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op); 
# 369
} else 
# 371
{ 
# 372
result = reduce_by_key_detail::reduce_by_key< typename iterator_difference< InputIterator1> ::type> (exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op); 
# 379
}  
# 381
return result; 
# 382
} 
# 385
}
# 388
template< class DerivedPolicy, class 
# 389
InputIterator1, class 
# 390
InputIterator2, class 
# 391
OutputIterator1, class 
# 392
OutputIterator2, class 
# 393
BinaryPredicate, class 
# 394
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 397
reduce_by_key(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 398
keys_first, InputIterator1 
# 399
keys_last, InputIterator2 
# 400
values_first, OutputIterator1 
# 401
keys_result, OutputIterator2 
# 402
values_result, BinaryPredicate 
# 403
binary_pred, BinaryFunction 
# 404
binary_op) 
# 405
{ 
# 411
typedef thrust::detail::static_assert_test< sizeof(thrust::detail::STATIC_ASSERTION_FAILURE< (bool)(thrust::detail::depend_on_instantiation< InputIterator1, true> ::value)> )>  thrust_static_assert_typedef_411 __attribute((unused)); 
# 413
struct workaround { 
# 417
static pair< OutputIterator1, OutputIterator2>  parallel_path(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 418
keys_first, InputIterator1 
# 419
keys_last, InputIterator2 
# 420
values_first, OutputIterator1 
# 421
keys_result, OutputIterator2 
# 422
values_result, BinaryPredicate 
# 423
binary_pred, BinaryFunction 
# 424
binary_op) 
# 425
{ 
# 426
return reduce_by_key_detail::reduce_by_key(exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op); 
# 427
} 
# 431
static pair< OutputIterator1, OutputIterator2>  sequential_path(execution_policy< DerivedPolicy>  &, InputIterator1 
# 432
keys_first, InputIterator1 
# 433
keys_last, InputIterator2 
# 434
values_first, OutputIterator1 
# 435
keys_result, OutputIterator2 
# 436
values_result, BinaryPredicate 
# 437
binary_pred, BinaryFunction 
# 438
binary_op) 
# 439
{ 
# 440
return thrust::reduce_by_key(thrust::seq, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op); 
# 441
} 
# 442
}; 
# 445
return (workaround::parallel_path)(exec, keys_first, keys_last, values_first, keys_result, values_result, binary_pred, binary_op); 
# 449
} 
# 452
}
# 453
}
# 454
}
# 455
}
# 30 "/usr/local/cuda/include/thrust/detail/reduce.inl"
namespace thrust { 
# 35
template< class DerivedPolicy, class InputIterator> typename iterator_traits< InputIterator> ::value_type 
# 38
reduce(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator first, InputIterator last) 
# 39
{ 
# 40
using system::detail::generic::reduce;
# 41
return reduce(detail::derived_cast(detail::strip_const(exec)), first, last); 
# 42
} 
# 46
template< class DerivedPolicy, class InputIterator, class T> T 
# 48
reduce(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 49
first, InputIterator 
# 50
last, T 
# 51
init) 
# 52
{ 
# 53
using system::detail::generic::reduce;
# 54
return reduce(detail::derived_cast(detail::strip_const(exec)), first, last, init); 
# 55
} 
# 59
template< class DerivedPolicy, class 
# 60
InputIterator, class 
# 61
T, class 
# 62
BinaryFunction> T 
# 64
reduce(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 65
first, InputIterator 
# 66
last, T 
# 67
init, BinaryFunction 
# 68
binary_op) 
# 69
{ 
# 70
using system::detail::generic::reduce;
# 71
return reduce(detail::derived_cast(detail::strip_const(exec)), first, last, init, binary_op); 
# 72
} 
# 76
template< class DerivedPolicy, class 
# 77
InputIterator1, class 
# 78
InputIterator2, class 
# 79
OutputIterator1, class 
# 80
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 83
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 84
keys_first, InputIterator1 
# 85
keys_last, InputIterator2 
# 86
values_first, OutputIterator1 
# 87
keys_output, OutputIterator2 
# 88
values_output) 
# 89
{ 
# 90
using system::detail::generic::reduce_by_key;
# 91
return reduce_by_key(detail::derived_cast(detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output); 
# 92
} 
# 96
template< class DerivedPolicy, class 
# 97
InputIterator1, class 
# 98
InputIterator2, class 
# 99
OutputIterator1, class 
# 100
OutputIterator2, class 
# 101
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 104
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 105
keys_first, InputIterator1 
# 106
keys_last, InputIterator2 
# 107
values_first, OutputIterator1 
# 108
keys_output, OutputIterator2 
# 109
values_output, BinaryPredicate 
# 110
binary_pred) 
# 111
{ 
# 112
using system::detail::generic::reduce_by_key;
# 113
return reduce_by_key(detail::derived_cast(detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output, binary_pred); 
# 114
} 
# 118
template< class DerivedPolicy, class 
# 119
InputIterator1, class 
# 120
InputIterator2, class 
# 121
OutputIterator1, class 
# 122
OutputIterator2, class 
# 123
BinaryPredicate, class 
# 124
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 127
reduce_by_key(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 128
keys_first, InputIterator1 
# 129
keys_last, InputIterator2 
# 130
values_first, OutputIterator1 
# 131
keys_output, OutputIterator2 
# 132
values_output, BinaryPredicate 
# 133
binary_pred, BinaryFunction 
# 134
binary_op) 
# 135
{ 
# 136
using system::detail::generic::reduce_by_key;
# 137
return reduce_by_key(detail::derived_cast(detail::strip_const(exec)), keys_first, keys_last, values_first, keys_output, values_output, binary_pred, binary_op); 
# 138
} 
# 141
template< class InputIterator> typename iterator_traits< InputIterator> ::value_type 
# 143
reduce(InputIterator first, InputIterator 
# 144
last) 
# 145
{ 
# 146
using thrust::system::detail::generic::select_system;
# 148
typedef typename iterator_system< InputIterator> ::type System; 
# 150
System system; 
# 152
return thrust::reduce(select_system(system), first, last); 
# 153
} 
# 156
template< class InputIterator, class 
# 157
T> T 
# 158
reduce(InputIterator first, InputIterator 
# 159
last, T 
# 160
init) 
# 161
{ 
# 162
using thrust::system::detail::generic::select_system;
# 164
typedef typename iterator_system< InputIterator> ::type System; 
# 166
System system; 
# 168
return thrust::reduce(select_system(system), first, last, init); 
# 169
} 
# 172
template< class InputIterator, class 
# 173
T, class 
# 174
BinaryFunction> T 
# 175
reduce(InputIterator first, InputIterator 
# 176
last, T 
# 177
init, BinaryFunction 
# 178
binary_op) 
# 179
{ 
# 180
using thrust::system::detail::generic::select_system;
# 182
typedef typename iterator_system< InputIterator> ::type System; 
# 184
System system; 
# 186
return thrust::reduce(select_system(system), first, last, init, binary_op); 
# 187
} 
# 190
template< class InputIterator1, class 
# 191
InputIterator2, class 
# 192
OutputIterator1, class 
# 193
OutputIterator2> pair< OutputIterator1, OutputIterator2>  
# 195
reduce_by_key(InputIterator1 keys_first, InputIterator1 
# 196
keys_last, InputIterator2 
# 197
values_first, OutputIterator1 
# 198
keys_output, OutputIterator2 
# 199
values_output) 
# 200
{ 
# 201
using system::detail::generic::select_system;
# 203
typedef typename iterator_system< InputIterator1> ::type System1; 
# 204
typedef typename iterator_system< InputIterator2> ::type System2; 
# 205
typedef typename iterator_system< OutputIterator1> ::type System3; 
# 206
typedef typename iterator_system< OutputIterator2> ::type System4; 
# 208
System1 system1; 
# 209
System2 system2; 
# 210
System3 system3; 
# 211
System4 system4; 
# 213
return thrust::reduce_by_key(select_system(system1, system2, system3, system4), keys_first, keys_last, values_first, keys_output, values_output); 
# 214
} 
# 217
template< class InputIterator1, class 
# 218
InputIterator2, class 
# 219
OutputIterator1, class 
# 220
OutputIterator2, class 
# 221
BinaryPredicate> pair< OutputIterator1, OutputIterator2>  
# 223
reduce_by_key(InputIterator1 keys_first, InputIterator1 
# 224
keys_last, InputIterator2 
# 225
values_first, OutputIterator1 
# 226
keys_output, OutputIterator2 
# 227
values_output, BinaryPredicate 
# 228
binary_pred) 
# 229
{ 
# 230
using system::detail::generic::select_system;
# 232
typedef typename iterator_system< InputIterator1> ::type System1; 
# 233
typedef typename iterator_system< InputIterator2> ::type System2; 
# 234
typedef typename iterator_system< OutputIterator1> ::type System3; 
# 235
typedef typename iterator_system< OutputIterator2> ::type System4; 
# 237
System1 system1; 
# 238
System2 system2; 
# 239
System3 system3; 
# 240
System4 system4; 
# 242
return thrust::reduce_by_key(select_system(system1, system2, system3, system4), keys_first, keys_last, values_first, keys_output, values_output, binary_pred); 
# 243
} 
# 246
template< class InputIterator1, class 
# 247
InputIterator2, class 
# 248
OutputIterator1, class 
# 249
OutputIterator2, class 
# 250
BinaryPredicate, class 
# 251
BinaryFunction> pair< OutputIterator1, OutputIterator2>  
# 253
reduce_by_key(InputIterator1 keys_first, InputIterator1 
# 254
keys_last, InputIterator2 
# 255
values_first, OutputIterator1 
# 256
keys_output, OutputIterator2 
# 257
values_output, BinaryPredicate 
# 258
binary_pred, BinaryFunction 
# 259
binary_op) 
# 260
{ 
# 261
using system::detail::generic::select_system;
# 263
typedef typename iterator_system< InputIterator1> ::type System1; 
# 264
typedef typename iterator_system< InputIterator2> ::type System2; 
# 265
typedef typename iterator_system< OutputIterator1> ::type System3; 
# 266
typedef typename iterator_system< OutputIterator2> ::type System4; 
# 268
System1 system1; 
# 269
System2 system2; 
# 270
System3 system3; 
# 271
System4 system4; 
# 273
return thrust::reduce_by_key(select_system(system1, system2, system3, system4), keys_first, keys_last, values_first, keys_output, values_output, binary_pred, binary_op); 
# 274
} 
# 277
}
# 31 "/usr/local/cuda/include/thrust/system/detail/generic/find.inl"
namespace thrust { 
# 33
namespace system { 
# 35
namespace detail { 
# 37
namespace generic { 
# 41
template< class DerivedPolicy, class InputIterator, class T> InputIterator 
# 43
find(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 44
first, InputIterator 
# 45
last, const T &
# 46
value) 
# 47
{ 
# 49
return thrust::find_if(exec, first, last, ((thrust::detail::equal_to_value< T> )(value))); 
# 50
} 
# 53
template< class TupleType> 
# 54
struct find_if_functor { 
# 57
TupleType operator()(const TupleType &lhs, const TupleType &rhs) const 
# 58
{ 
# 60
if (thrust::get< 0> (lhs) && thrust::get< 0> (rhs)) 
# 61
{ 
# 62
return TupleType(true, (thrust::min)(thrust::get< 1> (lhs), thrust::get< 1> (rhs))); 
# 63
} else { 
# 64
if (thrust::get< 0> (lhs)) 
# 65
{ 
# 66
return lhs; 
# 67
} else 
# 69
{ 
# 70
return rhs; 
# 71
}  }  
# 72
} 
# 73
}; 
# 76
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator 
# 78
find_if(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 79
first, InputIterator 
# 80
last, Predicate 
# 81
pred) 
# 82
{ 
# 83
typedef typename iterator_traits< InputIterator> ::difference_type difference_type; 
# 84
typedef tuple< bool, typename iterator_traits< InputIterator> ::difference_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  result_type; 
# 87
if (first == last) { return last; }  
# 89
const difference_type n = thrust::distance(first, last); 
# 95
const difference_type interval_threshold = (1 << 20); 
# 96
const difference_type interval_size = (thrust::min)(interval_threshold, n); 
# 99
typedef transform_iterator< Predicate, InputIterator, bool>  XfrmIterator; 
# 100
typedef tuple< transform_iterator< Predicate, InputIterator, bool> , counting_iterator< typename iterator_traits< InputIterator> ::difference_type> , null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 101
typedef zip_iterator< tuple< transform_iterator< Predicate, InputIterator, bool> , counting_iterator< typename iterator_traits< InputIterator> ::difference_type> , null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 103
IteratorTuple iter_tuple = thrust::make_tuple(XfrmIterator(first, pred), ((counting_iterator< typename iterator_traits< InputIterator> ::difference_type> )(0))); 
# 106
ZipIterator begin = thrust::make_zip_iterator(iter_tuple); 
# 107
ZipIterator end = begin + n; 
# 109
for (ZipIterator interval_begin = begin; interval_begin < end; interval_begin += interval_size) 
# 110
{ 
# 111
ZipIterator interval_end = interval_begin + interval_size; 
# 112
if (end < interval_end) 
# 113
{ 
# 114
interval_end = end; 
# 115
}  
# 117
result_type result = thrust::reduce(exec, interval_begin, interval_end, result_type(false, interval_end - begin), find_if_functor< tuple< bool, typename iterator_traits< InputIterator> ::difference_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> > ()); 
# 123
if (thrust::get< 0> (result)) 
# 124
{ 
# 125
return first + thrust::get< 1> (result); 
# 126
}  
# 127
}  
# 130
return first + n; 
# 131
} 
# 134
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator 
# 136
find_if_not(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 137
first, InputIterator 
# 138
last, Predicate 
# 139
pred) 
# 140
{ 
# 141
return thrust::find_if(exec, first, last, thrust::detail::not1(pred)); 
# 142
} 
# 145
}
# 146
}
# 147
}
# 148
}
# 28 "/usr/local/cuda/include/thrust/system/detail/sequential/find.h"
namespace thrust { 
# 30
namespace system { 
# 32
namespace detail { 
# 34
namespace sequential { 
# 39
template< class DerivedPolicy, class 
# 40
InputIterator, class 
# 41
Predicate> InputIterator 
# 43
find_if(execution_policy< DerivedPolicy>  &, InputIterator 
# 44
first, InputIterator 
# 45
last, Predicate 
# 46
pred) 
# 47
{ 
# 52
thrust::detail::wrapped_function< Predicate, bool>  wrapped_pred(pred); 
# 54
while (first != last) 
# 55
{ 
# 56
if (wrapped_pred(*first)) { 
# 57
return first; }  
# 59
++first; 
# 60
}  
# 63
return first; 
# 64
} 
# 67
}
# 68
}
# 69
}
# 70
}
# 28 "/usr/local/cuda/include/thrust/detail/find.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class InputIterator, class T> InputIterator 
# 35
find(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 36
first, InputIterator 
# 37
last, const T &
# 38
value) 
# 39
{ 
# 40
using system::detail::generic::find;
# 41
return find(detail::derived_cast(detail::strip_const(exec)), first, last, value); 
# 42
} 
# 46
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator 
# 48
find_if(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 49
first, InputIterator 
# 50
last, Predicate 
# 51
pred) 
# 52
{ 
# 53
using system::detail::generic::find_if;
# 54
return find_if(detail::derived_cast(detail::strip_const(exec)), first, last, pred); 
# 55
} 
# 59
template< class DerivedPolicy, class InputIterator, class Predicate> InputIterator 
# 61
find_if_not(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 62
first, InputIterator 
# 63
last, Predicate 
# 64
pred) 
# 65
{ 
# 66
using system::detail::generic::find_if_not;
# 67
return find_if_not(detail::derived_cast(detail::strip_const(exec)), first, last, pred); 
# 68
} 
# 71
template< class InputIterator, class T> InputIterator 
# 72
find(InputIterator first, InputIterator 
# 73
last, const T &
# 74
value) 
# 75
{ 
# 76
using thrust::system::detail::generic::select_system;
# 78
typedef typename iterator_system< InputIterator> ::type System; 
# 80
System system; 
# 82
return thrust::find(select_system(system), first, last, value); 
# 83
} 
# 85
template< class InputIterator, class Predicate> InputIterator 
# 86
find_if(InputIterator first, InputIterator 
# 87
last, Predicate 
# 88
pred) 
# 89
{ 
# 90
using thrust::system::detail::generic::select_system;
# 92
typedef typename iterator_system< InputIterator> ::type System; 
# 94
System system; 
# 96
return thrust::find_if(select_system(system), first, last, pred); 
# 97
} 
# 99
template< class InputIterator, class Predicate> InputIterator 
# 100
find_if_not(InputIterator first, InputIterator 
# 101
last, Predicate 
# 102
pred) 
# 103
{ 
# 104
using thrust::system::detail::generic::select_system;
# 106
typedef typename iterator_system< InputIterator> ::type System; 
# 108
System system; 
# 110
return thrust::find_if_not(select_system(system), first, last, pred); 
# 111
} 
# 114
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/mismatch.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  
# 36
mismatch(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 37
first1, InputIterator1 
# 38
last1, InputIterator2 
# 39
first2) 
# 40
{ 
# 41
typedef typename iterator_value< InputIterator1> ::type InputType1; 
# 44
return thrust::mismatch(exec, first1, last1, first2, thrust::detail::equal_to< typename iterator_value< InputIterator1> ::type> ()); 
# 45
} 
# 48
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  
# 51
mismatch(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 52
first1, InputIterator1 
# 53
last1, InputIterator2 
# 54
first2, BinaryPredicate 
# 55
pred) 
# 56
{ 
# 58
typedef tuple< InputIterator1, InputIterator2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  IteratorTuple; 
# 59
typedef zip_iterator< tuple< InputIterator1, InputIterator2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIterator; 
# 61
ZipIterator zipped_first = thrust::make_zip_iterator(thrust::make_tuple(first1, first2)); 
# 62
ZipIterator zipped_last = thrust::make_zip_iterator(thrust::make_tuple(last1, first2)); 
# 64
ZipIterator result = thrust::find_if_not(exec, zipped_first, zipped_last, ((thrust::detail::tuple_binary_predicate< BinaryPredicate> )(pred))); 
# 66
return thrust::make_pair(thrust::get< 0> ((result.get_iterator_tuple())), thrust::get< 1> ((result.get_iterator_tuple()))); 
# 68
} 
# 71
}
# 72
}
# 73
}
# 74
}
# 30 "/usr/local/cuda/include/thrust/detail/mismatch.inl"
namespace thrust { 
# 35
template< class DerivedPolicy, class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  
# 37
mismatch(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 38
first1, InputIterator1 
# 39
last1, InputIterator2 
# 40
first2) 
# 41
{ 
# 42
using system::detail::generic::mismatch;
# 43
return mismatch(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2); 
# 44
} 
# 48
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  
# 50
mismatch(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 51
first1, InputIterator1 
# 52
last1, InputIterator2 
# 53
first2, BinaryPredicate 
# 54
pred) 
# 55
{ 
# 56
using system::detail::generic::mismatch;
# 57
return mismatch(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, pred); 
# 58
} 
# 61
template< class InputIterator1, class InputIterator2> pair< InputIterator1, InputIterator2>  
# 62
mismatch(InputIterator1 first1, InputIterator1 
# 63
last1, InputIterator2 
# 64
first2) 
# 65
{ 
# 66
using system::detail::generic::select_system;
# 68
typedef typename iterator_system< InputIterator1> ::type System1; 
# 69
typedef typename iterator_system< InputIterator2> ::type System2; 
# 71
System1 system1; 
# 72
System2 system2; 
# 74
return thrust::mismatch(select_system(system1, system2), first1, last1, first2); 
# 75
} 
# 78
template< class InputIterator1, class InputIterator2, class BinaryPredicate> pair< InputIterator1, InputIterator2>  
# 79
mismatch(InputIterator1 first1, InputIterator1 
# 80
last1, InputIterator2 
# 81
first2, BinaryPredicate 
# 82
pred) 
# 83
{ 
# 84
using system::detail::generic::select_system;
# 86
typedef typename iterator_system< InputIterator1> ::type System1; 
# 87
typedef typename iterator_system< InputIterator2> ::type System2; 
# 89
System1 system1; 
# 90
System2 system2; 
# 92
return thrust::mismatch(select_system(system1, system2), first1, last1, first2, pred); 
# 93
} 
# 96
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/equal.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator1, class InputIterator2> bool 
# 35
equal(execution_policy< DerivedPolicy>  &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) 
# 36
{ 
# 37
typedef typename iterator_traits< InputIterator1> ::value_type InputType1; 
# 39
return thrust::equal(exec, first1, last1, first2, thrust::detail::equal_to< typename iterator_traits< InputIterator1> ::value_type> ()); 
# 40
} 
# 46
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate> bool 
# 48
equal(execution_policy< DerivedPolicy>  &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred) 
# 49
{ 
# 50
return (thrust::mismatch(exec, first1, last1, first2, binary_pred).first) == last1; 
# 51
} 
# 54
}
# 55
}
# 56
}
# 57
}
# 28 "/usr/local/cuda/include/thrust/detail/equal.inl"
namespace thrust { 
# 33
template< class System, class InputIterator1, class InputIterator2> bool 
# 35
equal(const detail::execution_policy_base< System>  &system, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) 
# 36
{ 
# 37
using thrust::system::detail::generic::equal;
# 38
return equal(detail::derived_cast(detail::strip_const(system)), first1, last1, first2); 
# 39
} 
# 43
template< class System, class InputIterator1, class InputIterator2, class BinaryPredicate> bool 
# 45
equal(const detail::execution_policy_base< System>  &system, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred) 
# 46
{ 
# 47
using thrust::system::detail::generic::equal;
# 48
return equal(detail::derived_cast(detail::strip_const(system)), first1, last1, first2, binary_pred); 
# 49
} 
# 52
template< class InputIterator1, class InputIterator2> bool 
# 53
equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 54
first2) 
# 55
{ 
# 56
using system::detail::generic::select_system;
# 58
typedef typename iterator_system< InputIterator1> ::type System1; 
# 59
typedef typename iterator_system< InputIterator2> ::type System2; 
# 61
System1 system1; 
# 62
System2 system2; 
# 64
return thrust::equal(select_system(system1, system2), first1, last1, first2); 
# 65
} 
# 68
template< class InputIterator1, class InputIterator2, class 
# 69
BinaryPredicate> bool 
# 70
equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 71
first2, BinaryPredicate binary_pred) 
# 72
{ 
# 73
using system::detail::generic::select_system;
# 75
typedef typename iterator_system< InputIterator1> ::type System1; 
# 76
typedef typename iterator_system< InputIterator2> ::type System2; 
# 78
System1 system1; 
# 79
System2 system2; 
# 81
return thrust::equal(select_system(system1, system2), first1, last1, first2, binary_pred); 
# 82
} 
# 85
}
# 35 "/usr/local/cuda/include/thrust/detail/vector_base.inl"
namespace thrust { 
# 38
namespace detail { 
# 41
template< class T, class Alloc> 
# 43
vector_base< T, Alloc> ::vector_base() : m_storage(), m_size(0) 
# 46
{ 
# 47
; 
# 48
} 
# 50
template< class T, class Alloc> 
# 52
vector_base< T, Alloc> ::vector_base(size_type n) : m_storage(), m_size(0) 
# 55
{ 
# 56
default_init(n); 
# 57
} 
# 59
template< class T, class Alloc> 
# 61
vector_base< T, Alloc> ::vector_base(size_type n, const value_type &value) : m_storage(), m_size(0) 
# 64
{ 
# 65
fill_init(n, value); 
# 66
} 
# 68
template< class T, class Alloc> 
# 70
vector_base< T, Alloc> ::vector_base(const vector_base &v) : m_storage(), m_size(0) 
# 73
{ 
# 74
range_init(v.begin(), v.end()); 
# 75
} 
# 77
template< class T, class Alloc> vector_base< T, Alloc>  &
# 80
vector_base< T, Alloc> ::operator=(const vector_base &v) 
# 81
{ 
# 82
if (this != (&v)) 
# 83
{ 
# 84
assign(v.begin(), v.end()); 
# 85
}  
# 87
return *this; 
# 88
} 
# 90
template< class T, class Alloc> 
# 91
template< class OtherT, class OtherAlloc> 
# 93
vector_base< T, Alloc> ::vector_base(const detail::vector_base< OtherT, OtherAlloc>  &v) : m_storage(), m_size(0) 
# 96
{ 
# 97
range_init((v.begin()), (v.end())); 
# 98
} 
# 100
template< class T, class Alloc> 
# 101
template< class OtherT, class OtherAlloc> vector_base< T, Alloc>  &
# 104
vector_base< T, Alloc> ::operator=(const detail::vector_base< OtherT, OtherAlloc>  &v) 
# 105
{ 
# 106
assign((v.begin()), (v.end())); 
# 108
return *this; 
# 109
} 
# 111
template< class T, class Alloc> 
# 112
template< class OtherT, class OtherAlloc> 
# 114
vector_base< T, Alloc> ::vector_base(const std::vector< OtherT, OtherAlloc>  &v) : m_storage(), m_size(0) 
# 117
{ 
# 118
range_init((v.begin()), (v.end())); 
# 119
} 
# 121
template< class T, class Alloc> 
# 122
template< class OtherT, class OtherAlloc> vector_base< T, Alloc>  &
# 125
vector_base< T, Alloc> ::operator=(const std::vector< OtherT, OtherAlloc>  &v) 
# 126
{ 
# 127
assign((v.begin()), (v.end())); 
# 129
return *this; 
# 130
} 
# 132
template< class T, class Alloc> 
# 133
template< class IteratorOrIntegralType> void 
# 135
vector_base< T, Alloc> ::init_dispatch(IteratorOrIntegralType n, IteratorOrIntegralType 
# 136
value, true_type) 
# 138
{ 
# 139
fill_init(n, value); 
# 140
} 
# 142
template< class T, class Alloc> void 
# 144
vector_base< T, Alloc> ::default_init(size_type n) 
# 145
{ 
# 146
if (n > 0) 
# 147
{ 
# 148
((m_storage).allocate(n)); 
# 149
(m_size) = n; 
# 151
((m_storage).default_construct_n(this->begin(), size())); 
# 152
}  
# 153
} 
# 155
template< class T, class Alloc> void 
# 157
vector_base< T, Alloc> ::fill_init(size_type n, const T &x) 
# 158
{ 
# 159
if (n > 0) 
# 160
{ 
# 161
((m_storage).allocate(n)); 
# 162
(m_size) = n; 
# 164
((m_storage).uninitialized_fill_n(this->begin(), size(), x)); 
# 165
}  
# 166
} 
# 168
template< class T, class Alloc> 
# 169
template< class InputIterator> void 
# 171
vector_base< T, Alloc> ::init_dispatch(InputIterator first, InputIterator 
# 172
last, false_type) 
# 174
{ 
# 175
range_init(first, last); 
# 176
} 
# 178
template< class T, class Alloc> 
# 179
template< class InputIterator> void 
# 181
vector_base< T, Alloc> ::range_init(InputIterator first, InputIterator 
# 182
last) 
# 183
{ 
# 184
range_init(first, last, typename iterator_traversal< InputIterator> ::type()); 
# 186
} 
# 188
template< class T, class Alloc> 
# 189
template< class InputIterator> void 
# 191
vector_base< T, Alloc> ::range_init(InputIterator first, InputIterator 
# 192
last, incrementable_traversal_tag) 
# 194
{ 
# 195
for (; first != last; ++first) { 
# 196
push_back(*first); }  
# 197
} 
# 199
template< class T, class Alloc> 
# 200
template< class ForwardIterator> void 
# 202
vector_base< T, Alloc> ::range_init(ForwardIterator first, ForwardIterator 
# 203
last, random_access_traversal_tag) 
# 205
{ 
# 206
size_type new_size = thrust::distance(first, last); 
# 208
allocate_and_copy(new_size, first, last, m_storage); 
# 209
(m_size) = new_size; 
# 210
} 
# 212
template< class T, class Alloc> 
# 213
template< class InputIterator> 
# 215
vector_base< T, Alloc> ::vector_base(InputIterator first, InputIterator 
# 216
last) : m_storage(), m_size(0) 
# 219
{ 
# 222
typedef is_integral< InputIterator>  Integer; 
# 224
init_dispatch(first, last, Integer()); 
# 225
} 
# 227
template< class T, class Alloc> void 
# 229
vector_base< T, Alloc> ::resize(size_type new_size) 
# 230
{ 
# 231
if (new_size < size()) 
# 232
{ 
# 233
iterator new_end = this->begin(); 
# 234
thrust::advance(new_end, new_size); 
# 235
erase(new_end, this->end()); 
# 236
} else 
# 238
{ 
# 239
append(new_size - size()); 
# 240
}  
# 241
} 
# 243
template< class T, class Alloc> void 
# 245
vector_base< T, Alloc> ::resize(size_type new_size, const value_type &x) 
# 246
{ 
# 247
if (new_size < size()) 
# 248
{ 
# 249
iterator new_end = this->begin(); 
# 250
thrust::advance(new_end, new_size); 
# 251
erase(new_end, this->end()); 
# 252
} else 
# 254
{ 
# 255
insert(this->end(), new_size - size(), x); 
# 256
}  
# 257
} 
# 259
template< class T, class Alloc> typename vector_base< T, Alloc> ::size_type 
# 262
vector_base< T, Alloc> ::size() const 
# 263
{ 
# 264
return m_size; 
# 265
} 
# 267
template< class T, class Alloc> typename vector_base< T, Alloc> ::size_type 
# 270
vector_base< T, Alloc> ::max_size() const 
# 271
{ 
# 272
return ((m_storage).max_size()); 
# 273
} 
# 275
template< class T, class Alloc> void 
# 277
vector_base< T, Alloc> ::reserve(size_type n) 
# 278
{ 
# 279
if (n > capacity()) 
# 280
{ 
# 281
allocate_and_copy(n, this->begin(), this->end(), m_storage); 
# 282
}  
# 283
} 
# 285
template< class T, class Alloc> typename vector_base< T, Alloc> ::size_type 
# 288
vector_base< T, Alloc> ::capacity() const 
# 289
{ 
# 290
return ((m_storage).size()); 
# 291
} 
# 293
template< class T, class Alloc> void 
# 295
vector_base< T, Alloc> ::shrink_to_fit() 
# 296
{ 
# 298
((vector_base)(*this)).swap(*this); 
# 299
} 
# 301
template< class T, class Alloc> typename vector_base< T, Alloc> ::reference 
# 304
vector_base< T, Alloc> ::operator[](const typename contiguous_storage< T, Alloc> ::size_type n) 
# 305
{ 
# 306
return (m_storage)[n]; 
# 307
} 
# 309
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reference 
# 312
vector_base< T, Alloc> ::operator[](const typename contiguous_storage< T, Alloc> ::size_type n) const 
# 313
{ 
# 314
return (m_storage)[n]; 
# 315
} 
# 317
template< class T, class Alloc> typename vector_base< T, Alloc> ::iterator 
# 320
vector_base< T, Alloc> ::begin() 
# 321
{ 
# 322
return ((m_storage).begin()); 
# 323
} 
# 325
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_iterator 
# 328
vector_base< T, Alloc> ::begin() const 
# 329
{ 
# 330
return ((m_storage).begin()); 
# 331
} 
# 333
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_iterator 
# 336
vector_base< T, Alloc> ::cbegin() const 
# 337
{ 
# 338
return this->begin(); 
# 339
} 
# 341
template< class T, class Alloc> typename vector_base< T, Alloc> ::reverse_iterator 
# 344
vector_base< T, Alloc> ::rbegin() 
# 345
{ 
# 346
return ((reverse_iterator)(this->end())); 
# 347
} 
# 349
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reverse_iterator 
# 352
vector_base< T, Alloc> ::rbegin() const 
# 353
{ 
# 354
return ((const_reverse_iterator)(this->end())); 
# 355
} 
# 357
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reverse_iterator 
# 360
vector_base< T, Alloc> ::crbegin() const 
# 361
{ 
# 362
return this->rbegin(); 
# 363
} 
# 365
template< class T, class Alloc> typename vector_base< T, Alloc> ::iterator 
# 368
vector_base< T, Alloc> ::end() 
# 369
{ 
# 370
iterator result = this->begin(); 
# 371
thrust::advance(result, size()); 
# 372
return result; 
# 373
} 
# 375
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_iterator 
# 378
vector_base< T, Alloc> ::end() const 
# 379
{ 
# 380
const_iterator result = this->begin(); 
# 381
thrust::advance(result, size()); 
# 382
return result; 
# 383
} 
# 385
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_iterator 
# 388
vector_base< T, Alloc> ::cend() const 
# 389
{ 
# 390
return this->end(); 
# 391
} 
# 393
template< class T, class Alloc> typename vector_base< T, Alloc> ::reverse_iterator 
# 396
vector_base< T, Alloc> ::rend() 
# 397
{ 
# 398
return ((reverse_iterator)(this->begin())); 
# 399
} 
# 401
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reverse_iterator 
# 404
vector_base< T, Alloc> ::rend() const 
# 405
{ 
# 406
return ((const_reverse_iterator)(this->begin())); 
# 407
} 
# 409
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reverse_iterator 
# 412
vector_base< T, Alloc> ::crend() const 
# 413
{ 
# 414
return this->rend(); 
# 415
} 
# 417
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reference 
# 420
vector_base< T, Alloc> ::front() const 
# 421
{ 
# 422
return *this->begin(); 
# 423
} 
# 425
template< class T, class Alloc> typename vector_base< T, Alloc> ::reference 
# 428
vector_base< T, Alloc> ::front() 
# 429
{ 
# 430
return *this->begin(); 
# 431
} 
# 433
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_reference 
# 436
vector_base< T, Alloc> ::back() const 
# 437
{ 
# 438
const_iterator ptr_to_back = this->end(); 
# 439
--ptr_to_back; 
# 440
return *ptr_to_back; 
# 441
} 
# 443
template< class T, class Alloc> typename vector_base< T, Alloc> ::reference 
# 446
vector_base< T, Alloc> ::back() 
# 447
{ 
# 448
iterator ptr_to_back = this->end(); 
# 449
--ptr_to_back; 
# 450
return *ptr_to_back; 
# 451
} 
# 453
template< class T, class Alloc> typename vector_base< T, Alloc> ::pointer 
# 456
vector_base< T, Alloc> ::data() 
# 457
{ 
# 458
return &this->front(); 
# 459
} 
# 461
template< class T, class Alloc> typename vector_base< T, Alloc> ::const_pointer 
# 464
vector_base< T, Alloc> ::data() const 
# 465
{ 
# 466
return &this->front(); 
# 467
} 
# 469
template< class T, class Alloc> 
# 471
vector_base< T, Alloc> ::~vector_base() 
# 472
{ 
# 474
((m_storage).destroy(this->begin(), this->end())); 
# 475
} 
# 477
template< class T, class Alloc> void 
# 479
vector_base< T, Alloc> ::clear() 
# 480
{ 
# 481
erase(this->begin(), this->end()); 
# 482
} 
# 484
template< class T, class Alloc> bool 
# 486
vector_base< T, Alloc> ::empty() const 
# 487
{ 
# 488
return size() == 0; 
# 489
} 
# 491
template< class T, class Alloc> void 
# 493
vector_base< T, Alloc> ::push_back(const value_type &x) 
# 494
{ 
# 495
insert(this->end(), x); 
# 496
} 
# 498
template< class T, class Alloc> void 
# 500
vector_base< T, Alloc> ::pop_back() 
# 501
{ 
# 502
iterator e = this->end(); 
# 503
iterator ptr_to_back = e; 
# 504
--ptr_to_back; 
# 505
((m_storage).destroy(ptr_to_back, e)); 
# 506
--(m_size); 
# 507
} 
# 509
template< class T, class Alloc> typename vector_base< T, Alloc> ::iterator 
# 511
vector_base< T, Alloc> ::erase(iterator pos) 
# 512
{ 
# 513
iterator end = pos; 
# 514
++end; 
# 515
return erase(pos, end); 
# 516
} 
# 518
template< class T, class Alloc> typename vector_base< T, Alloc> ::iterator 
# 520
vector_base< T, Alloc> ::erase(iterator first, iterator last) 
# 521
{ 
# 524
iterator i = detail::overlapped_copy(last, this->end(), first); 
# 527
((m_storage).destroy(i, this->end())); 
# 530
(m_size) -= (last - first); 
# 534
return first; 
# 535
} 
# 537
template< class T, class Alloc> void 
# 539
vector_base< T, Alloc> ::swap(vector_base &v) 
# 540
{ 
# 541
thrust::swap(m_storage, v.m_storage); 
# 542
thrust::swap(m_size, v.m_size); 
# 543
} 
# 545
template< class T, class Alloc> void 
# 547
vector_base< T, Alloc> ::assign(size_type n, const T &x) 
# 548
{ 
# 549
fill_assign(n, x); 
# 550
} 
# 552
template< class T, class Alloc> 
# 553
template< class InputIterator> void 
# 555
vector_base< T, Alloc> ::assign(InputIterator first, InputIterator last) 
# 556
{ 
# 559
typedef is_integral< InputIterator>  integral; 
# 561
assign_dispatch(first, last, integral()); 
# 562
} 
# 564
template< class T, class Alloc> typename vector_base< T, Alloc> ::allocator_type 
# 567
vector_base< T, Alloc> ::get_allocator() const 
# 568
{ 
# 569
return ((m_storage).get_allocator()); 
# 570
} 
# 572
template< class T, class Alloc> typename vector_base< T, Alloc> ::iterator 
# 575
vector_base< T, Alloc> ::insert(iterator position, const T &x) 
# 576
{ 
# 578
size_type index = thrust::distance(this->begin(), position); 
# 581
insert(position, 1, x); 
# 584
iterator result = this->begin(); 
# 585
thrust::advance(result, index); 
# 586
return result; 
# 587
} 
# 589
template< class T, class Alloc> void 
# 591
vector_base< T, Alloc> ::insert(iterator position, size_type n, const T &x) 
# 592
{ 
# 593
fill_insert(position, n, x); 
# 594
} 
# 596
template< class T, class Alloc> 
# 597
template< class InputIterator> void 
# 599
vector_base< T, Alloc> ::insert(iterator position, InputIterator first, InputIterator last) 
# 600
{ 
# 603
typedef is_integral< InputIterator>  integral; 
# 605
insert_dispatch(position, first, last, integral()); 
# 606
} 
# 608
template< class T, class Alloc> 
# 609
template< class InputIterator> void 
# 611
vector_base< T, Alloc> ::assign_dispatch(InputIterator first, InputIterator last, false_type) 
# 612
{ 
# 613
range_assign(first, last); 
# 614
} 
# 616
template< class T, class Alloc> 
# 617
template< class Integral> void 
# 619
vector_base< T, Alloc> ::assign_dispatch(Integral n, Integral x, true_type) 
# 620
{ 
# 621
fill_assign(n, x); 
# 622
} 
# 624
template< class T, class Alloc> 
# 625
template< class InputIterator> void 
# 627
vector_base< T, Alloc> ::insert_dispatch(iterator position, InputIterator first, InputIterator last, false_type) 
# 628
{ 
# 629
copy_insert(position, first, last); 
# 630
} 
# 632
template< class T, class Alloc> 
# 633
template< class Integral> void 
# 635
vector_base< T, Alloc> ::insert_dispatch(iterator position, Integral n, Integral x, true_type) 
# 636
{ 
# 637
fill_insert(position, n, x); 
# 638
} 
# 640
template< class T, class Alloc> 
# 641
template< class ForwardIterator> void 
# 643
vector_base< T, Alloc> ::copy_insert(iterator position, ForwardIterator 
# 644
first, ForwardIterator 
# 645
last) 
# 646
{ 
# 647
if (first != last) 
# 648
{ 
# 650
const size_type num_new_elements = thrust::distance(first, last); 
# 651
if ((capacity() - size()) >= num_new_elements) 
# 652
{ 
# 655
const size_type num_displaced_elements = this->end() - position; 
# 656
iterator old_end = this->end(); 
# 658
if (num_displaced_elements > num_new_elements) 
# 659
{ 
# 662
((m_storage).uninitialized_copy(this->end() - num_new_elements, this->end(), this->end())); 
# 665
(m_size) += num_new_elements; 
# 669
const size_type copy_length = (old_end - num_new_elements) - position; 
# 670
detail::overlapped_copy(position, old_end - num_new_elements, old_end - copy_length); 
# 673
thrust::copy(first, last, position); 
# 674
} else 
# 676
{ 
# 677
ForwardIterator mid = first; 
# 678
thrust::advance(mid, num_displaced_elements); 
# 681
((m_storage).uninitialized_copy(mid, last, this->end())); 
# 684
(m_size) += (num_new_elements - num_displaced_elements); 
# 687
((m_storage).uninitialized_copy(position, old_end, this->end())); 
# 690
(m_size) += num_displaced_elements; 
# 693
thrust::copy(first, mid, position); 
# 694
}  
# 695
} else 
# 697
{ 
# 698
const size_type old_size = size(); 
# 701
size_type new_capacity = old_size + thrust::max(old_size, num_new_elements); 
# 704
new_capacity = thrust::max< size_type> (new_capacity, 2 * capacity()); 
# 707
new_capacity = thrust::min< size_type> (new_capacity, max_size()); 
# 709
if (new_capacity > max_size()) 
# 710
{ 
# 711
throw ((std::length_error)("insert(): insertion exceeds max_size().")); 
# 712
}  
# 714
storage_type new_storage(new_capacity); 
# 717
iterator new_end = (new_storage.begin()); 
# 719
try 
# 720
{ 
# 723
new_end = ((m_storage).uninitialized_copy(this->begin(), position, (new_storage.begin()))); 
# 726
new_end = ((m_storage).uninitialized_copy(first, last, new_end)); 
# 730
new_end = ((m_storage).uninitialized_copy(position, this->end(), new_end)); 
# 731
} 
# 732
catch (...) 
# 733
{ 
# 735
((m_storage).destroy((new_storage.begin()), new_end)); 
# 736
(new_storage.deallocate()); 
# 739
throw; 
# 740
}  
# 743
((m_storage).destroy(this->begin(), this->end())); 
# 746
((m_storage).swap(new_storage)); 
# 747
(m_size) = (old_size + num_new_elements); 
# 748
}  
# 749
}  
# 750
} 
# 752
template< class T, class Alloc> void 
# 754
vector_base< T, Alloc> ::append(size_type n) 
# 755
{ 
# 756
if (n != 0) 
# 757
{ 
# 758
if ((capacity() - size()) >= n) 
# 759
{ 
# 763
((m_storage).default_construct_n(this->end(), n)); 
# 766
(m_size) += n; 
# 767
} else 
# 769
{ 
# 770
const size_type old_size = size(); 
# 773
size_type new_capacity = old_size + thrust::max(old_size, n); 
# 776
new_capacity = thrust::max< size_type> (new_capacity, 2 * capacity()); 
# 779
new_capacity = thrust::min< size_type> (new_capacity, max_size()); 
# 782
storage_type new_storage(new_capacity); 
# 785
iterator new_end = (new_storage.begin()); 
# 787
try 
# 788
{ 
# 790
new_end = ((m_storage).uninitialized_copy(this->begin(), this->end(), (new_storage.begin()))); 
# 793
((m_storage).default_construct_n(new_end, n)); 
# 794
new_end += n; 
# 795
} 
# 796
catch (...) 
# 797
{ 
# 799
((m_storage).destroy((new_storage.begin()), new_end)); 
# 800
(new_storage.deallocate()); 
# 803
throw; 
# 804
}  
# 807
((m_storage).destroy(this->begin(), this->end())); 
# 810
((m_storage).swap(new_storage)); 
# 811
(m_size) = (old_size + n); 
# 812
}  
# 813
}  
# 814
} 
# 816
template< class T, class Alloc> void 
# 818
vector_base< T, Alloc> ::fill_insert(iterator position, size_type n, const T &x) 
# 819
{ 
# 820
if (n != 0) 
# 821
{ 
# 822
if ((capacity() - size()) >= n) 
# 823
{ 
# 826
const size_type num_displaced_elements = this->end() - position; 
# 827
iterator old_end = this->end(); 
# 829
if (num_displaced_elements > n) 
# 830
{ 
# 833
((m_storage).uninitialized_copy(this->end() - n, this->end(), this->end())); 
# 836
(m_size) += n; 
# 840
const size_type copy_length = (old_end - n) - position; 
# 841
detail::overlapped_copy(position, old_end - n, old_end - copy_length); 
# 844
thrust::fill_n(position, n, x); 
# 845
} else 
# 847
{ 
# 849
((m_storage).uninitialized_fill_n(this->end(), n - num_displaced_elements, x)); 
# 852
(m_size) += (n - num_displaced_elements); 
# 855
((m_storage).uninitialized_copy(position, old_end, this->end())); 
# 858
(m_size) += num_displaced_elements; 
# 861
thrust::fill(position, old_end, x); 
# 862
}  
# 863
} else 
# 865
{ 
# 866
const size_type old_size = size(); 
# 869
size_type new_capacity = old_size + thrust::max(old_size, n); 
# 872
new_capacity = thrust::max< size_type> (new_capacity, 2 * capacity()); 
# 875
new_capacity = thrust::min< size_type> (new_capacity, max_size()); 
# 877
if (new_capacity > max_size()) 
# 878
{ 
# 879
throw ((std::length_error)("insert(): insertion exceeds max_size().")); 
# 880
}  
# 882
storage_type new_storage(new_capacity); 
# 885
iterator new_end = (new_storage.begin()); 
# 887
try 
# 888
{ 
# 891
new_end = ((m_storage).uninitialized_copy(this->begin(), position, (new_storage.begin()))); 
# 894
((m_storage).uninitialized_fill_n(new_end, n, x)); 
# 895
new_end += n; 
# 899
new_end = ((m_storage).uninitialized_copy(position, this->end(), new_end)); 
# 900
} 
# 901
catch (...) 
# 902
{ 
# 904
((m_storage).destroy((new_storage.begin()), new_end)); 
# 905
(new_storage.deallocate()); 
# 908
throw; 
# 909
}  
# 912
((m_storage).destroy(this->begin(), this->end())); 
# 915
((m_storage).swap(new_storage)); 
# 916
(m_size) = (old_size + n); 
# 917
}  
# 918
}  
# 919
} 
# 921
template< class T, class Alloc> 
# 922
template< class InputIterator> void 
# 924
vector_base< T, Alloc> ::range_assign(InputIterator first, InputIterator 
# 925
last) 
# 926
{ 
# 928
range_assign(first, last, typename iterator_traversal< InputIterator> ::type()); 
# 930
} 
# 932
template< class T, class Alloc> 
# 933
template< class InputIterator> void 
# 935
vector_base< T, Alloc> ::range_assign(InputIterator first, InputIterator 
# 936
last, incrementable_traversal_tag) 
# 938
{ 
# 939
iterator current(this->begin()); 
# 942
for (; (first != last) && (current != this->end()); (++current), (++first)) 
# 943
{ 
# 944
(*current) = (*first); 
# 945
}  
# 949
if (first == last) 
# 950
{ 
# 952
erase(current, this->end()); 
# 953
} else 
# 955
{ 
# 957
insert(this->end(), first, last); 
# 958
}  
# 959
} 
# 961
template< class T, class Alloc> 
# 962
template< class RandomAccessIterator> void 
# 964
vector_base< T, Alloc> ::range_assign(RandomAccessIterator first, RandomAccessIterator 
# 965
last, random_access_traversal_tag) 
# 967
{ 
# 968
const size_type n = thrust::distance(first, last); 
# 970
if (n > capacity()) 
# 971
{ 
# 972
storage_type new_storage; 
# 973
allocate_and_copy(n, first, last, new_storage); 
# 976
((m_storage).destroy(this->begin(), this->end())); 
# 979
((m_storage).swap(new_storage)); 
# 980
(m_size) = n; 
# 981
} else { 
# 982
if (size() >= n) 
# 983
{ 
# 985
iterator new_end = thrust::copy(first, last, this->begin()); 
# 988
((m_storage).destroy(new_end, this->end())); 
# 991
(m_size) = n; 
# 992
} else 
# 994
{ 
# 1002
RandomAccessIterator mid = first; 
# 1003
thrust::advance(mid, size()); 
# 1004
thrust::copy(first, mid, this->begin()); 
# 1007
((m_storage).uninitialized_copy(mid, last, this->end())); 
# 1010
(m_size) = n; 
# 1011
}  }  
# 1012
} 
# 1014
template< class T, class Alloc> void 
# 1016
vector_base< T, Alloc> ::fill_assign(size_type n, const T &x) 
# 1017
{ 
# 1018
if (n > capacity()) 
# 1019
{ 
# 1022
vector_base temp(n, x); 
# 1023
temp.swap(*this); 
# 1024
} else { 
# 1025
if (n > size()) 
# 1026
{ 
# 1028
thrust::fill(this->begin(), this->end(), x); 
# 1031
((m_storage).uninitialized_fill_n(this->end(), n - size(), x)); 
# 1034
(m_size) += (n - size()); 
# 1035
} else 
# 1037
{ 
# 1039
iterator new_end = thrust::fill_n(this->begin(), n, x); 
# 1042
erase(new_end, this->end()); 
# 1043
}  }  
# 1044
} 
# 1046
template< class T, class Alloc> 
# 1047
template< class ForwardIterator> void 
# 1049
vector_base< T, Alloc> ::allocate_and_copy(size_type requested_size, ForwardIterator 
# 1050
first, ForwardIterator last, storage_type &
# 1051
new_storage) 
# 1052
{ 
# 1053
if (requested_size == 0) 
# 1054
{ 
# 1055
(new_storage.deallocate()); 
# 1056
return; 
# 1057
}  
# 1060
size_type allocated_size = thrust::max< size_type> (requested_size, 2 * capacity()); 
# 1063
allocated_size = thrust::min< size_type> (allocated_size, max_size()); 
# 1065
if (requested_size > allocated_size) 
# 1066
{ 
# 1067
throw ((std::length_error)("assignment exceeds max_size().")); 
# 1068
}  
# 1070
(new_storage.allocate(allocated_size)); 
# 1072
try 
# 1073
{ 
# 1075
((m_storage).uninitialized_copy(first, last, (new_storage.begin()))); 
# 1076
} 
# 1077
catch (...) 
# 1078
{ 
# 1081
iterator new_storage_end = (new_storage.begin()); 
# 1082
thrust::advance(new_storage_end, requested_size); 
# 1083
((m_storage).destroy((new_storage.begin()), new_storage_end)); 
# 1084
(new_storage.deallocate()); 
# 1087
throw; 
# 1088
}  
# 1089
} 
# 1092
}
# 1094
template< class T, class Alloc> void 
# 1095
swap(detail::vector_base< T, Alloc>  &a, detail::vector_base< T, Alloc>  &
# 1096
b) 
# 1097
{ 
# 1098
(a.swap(b)); 
# 1099
} 
# 1103
namespace detail { 
# 1107
template< class InputIterator1, class InputIterator2> bool 
# 1108
vector_equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 1109
first2, true_type) 
# 1111
{ 
# 1112
return thrust::equal(first1, last1, first2); 
# 1113
} 
# 1116
template< class InputIterator1, class InputIterator2> bool 
# 1117
vector_equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 1118
first2, false_type) 
# 1120
{ 
# 1121
typename iterator_difference< InputIterator1> ::type n = thrust::distance(first1, last1); 
# 1123
typedef typename iterator_system< InputIterator1> ::type FromSystem1; 
# 1124
typedef typename iterator_system< InputIterator2> ::type FromSystem2; 
# 1128
FromSystem1 from_system1; 
# 1129
FromSystem2 from_system2; 
# 1130
host_system_tag to_system; 
# 1131
move_to_system< InputIterator1, typename iterator_system< InputIterator1> ::type, system::cpp::detail::tag>  rng1(from_system1, to_system, first1, last1); 
# 1132
move_to_system< InputIterator2, typename iterator_system< InputIterator2> ::type, system::cpp::detail::tag>  rng2(from_system2, to_system, first2, first2 + n); 
# 1134
return thrust::equal((rng1.begin()), (rng1.end()), (rng2.begin())); 
# 1135
} 
# 1137
template< class InputIterator1, class InputIterator2> bool 
# 1138
vector_equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 1139
first2) 
# 1140
{ 
# 1141
typedef typename iterator_system< InputIterator1> ::type system1; 
# 1142
typedef typename iterator_system< InputIterator2> ::type system2; 
# 1145
return vector_equal(first1, last1, first2, is_same< typename iterator_system< InputIterator1> ::type, typename iterator_system< InputIterator2> ::type> ()); 
# 1147
} 
# 1149
}
# 1154
template< class T1, class Alloc1, class 
# 1155
T2, class Alloc2> bool 
# 1156
operator==(const detail::vector_base< T1, Alloc1>  &lhs, const detail::vector_base< T2, Alloc2>  &
# 1157
rhs) 
# 1158
{ 
# 1159
return ((lhs.size()) == (rhs.size())) && detail::vector_equal((lhs.begin()), (lhs.end()), (rhs.begin())); 
# 1160
} 
# 1162
template< class T1, class Alloc1, class 
# 1163
T2, class Alloc2> bool 
# 1164
operator==(const detail::vector_base< T1, Alloc1>  &lhs, const std::vector< T2, Alloc2>  &
# 1165
rhs) 
# 1166
{ 
# 1167
return ((lhs.size()) == (rhs.size())) && detail::vector_equal((lhs.begin()), (lhs.end()), (rhs.begin())); 
# 1168
} 
# 1170
template< class T1, class Alloc1, class 
# 1171
T2, class Alloc2> bool 
# 1172
operator==(const std::vector< T1, Alloc1>  &lhs, const detail::vector_base< T2, Alloc2>  &
# 1173
rhs) 
# 1174
{ 
# 1175
return ((lhs.size()) == (rhs.size())) && detail::vector_equal((lhs.begin()), (lhs.end()), (rhs.begin())); 
# 1176
} 
# 1178
template< class T1, class Alloc1, class 
# 1179
T2, class Alloc2> bool 
# 1180
operator!=(const detail::vector_base< T1, Alloc1>  &lhs, const detail::vector_base< T2, Alloc2>  &
# 1181
rhs) 
# 1182
{ 
# 1183
return !(lhs == rhs); 
# 1184
} 
# 1186
template< class T1, class Alloc1, class 
# 1187
T2, class Alloc2> bool 
# 1188
operator!=(const detail::vector_base< T1, Alloc1>  &lhs, const std::vector< T2, Alloc2>  &
# 1189
rhs) 
# 1190
{ 
# 1191
return !(lhs == rhs); 
# 1192
} 
# 1194
template< class T1, class Alloc1, class 
# 1195
T2, class Alloc2> bool 
# 1196
operator!=(const std::vector< T1, Alloc1>  &lhs, const detail::vector_base< T2, Alloc2>  &
# 1197
rhs) 
# 1198
{ 
# 1199
return !(lhs == rhs); 
# 1200
} 
# 1202
}
# 29 "/usr/local/cuda/include/thrust/device_vector.h"
namespace thrust { 
# 33
template< class T, class Alloc> class host_vector; 
# 51
template< class T, class Alloc = device_malloc_allocator< T> > 
# 52
class device_vector : public detail::vector_base< T, Alloc>  { 
# 56
typedef ::thrust::detail::vector_base< T, Alloc>  Parent; 
# 61
public: typedef typename ::thrust::detail::vector_base< T, Alloc> ::size_type size_type; 
# 62
typedef typename ::thrust::detail::vector_base< T, Alloc> ::value_type value_type; 
# 69
device_vector() : Parent() 
# 70
{ } 
# 77
~device_vector() { } 
# 84
explicit device_vector(size_type n) : Parent(n) 
# 85
{ } 
# 93
explicit device_vector(size_type n, const value_type &value) : Parent(n, value) 
# 94
{ } 
# 100
device_vector(const device_vector &v) : Parent(v) 
# 101
{ } 
# 106
template< class OtherT, class OtherAlloc> 
# 108
device_vector(const ::thrust::device_vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 109
{int *volatile ___ = 0;(void)v;::free(___);}
#if 0
# 109
{ } 
#endif
# 114 "/usr/local/cuda/include/thrust/device_vector.h"
template< class OtherT, class OtherAlloc> device_vector &
# 116
operator=(const ::thrust::device_vector< OtherT, OtherAlloc>  &v) 
# 117
{int volatile ___ = 1;(void)v;::exit(___);}
#if 0
# 117
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
#endif
# 122 "/usr/local/cuda/include/thrust/device_vector.h"
template< class OtherT, class OtherAlloc> 
# 124
device_vector(const ::std::vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 125
{ } 
# 130
template< class OtherT, class OtherAlloc> device_vector &
# 132
operator=(const ::std::vector< OtherT, OtherAlloc>  &v) 
# 133
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 138
template< class OtherT, class OtherAlloc> device_vector(const host_vector< OtherT, OtherAlloc>  & v); 
# 145
template< class OtherT, class OtherAlloc> device_vector &
# 147
operator=(const host_vector< OtherT, OtherAlloc>  &v) 
# 148
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 154
template< class InputIterator> 
# 156
device_vector(InputIterator first, InputIterator last) : Parent(first, last) 
# 157
{ } 
# 418
}; 
# 423
}
# 29 "/usr/local/cuda/include/thrust/host_vector.h"
namespace thrust { 
# 33
template< class T, class Alloc> class device_vector; 
# 51
template< class T, class Alloc = std::allocator< T> > 
# 52
class host_vector : public detail::vector_base< T, Alloc>  { 
# 56
typedef ::thrust::detail::vector_base< T, Alloc>  Parent; 
# 61
public: typedef typename ::thrust::detail::vector_base< T, Alloc> ::size_type size_type; 
# 62
typedef typename ::thrust::detail::vector_base< T, Alloc> ::value_type value_type; 
# 69
host_vector() : Parent() 
# 70
{ } 
# 77
~host_vector() { } 
# 84
explicit host_vector(size_type n) : Parent(n) 
# 85
{ } 
# 93
explicit host_vector(size_type n, const value_type &value) : Parent(n, value) 
# 94
{ } 
# 100
host_vector(const host_vector &v) : Parent(v) 
# 101
{ } 
# 107
host_vector &operator=(const host_vector &v) 
# 108
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 113
template< class OtherT, class OtherAlloc> 
# 115
host_vector(const ::thrust::host_vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 116
{ } 
# 121
template< class OtherT, class OtherAlloc> host_vector &
# 123
operator=(const ::thrust::host_vector< OtherT, OtherAlloc>  &v) 
# 124
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 129
template< class OtherT, class OtherAlloc> 
# 131
host_vector(const ::std::vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 132
{ } 
# 137
template< class OtherT, class OtherAlloc> host_vector &
# 139
operator=(const ::std::vector< OtherT, OtherAlloc>  &v) 
# 140
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 145
template< class OtherT, class OtherAlloc> host_vector(const device_vector< OtherT, OtherAlloc>  & v); 
# 152
template< class OtherT, class OtherAlloc> host_vector &
# 154
operator=(const device_vector< OtherT, OtherAlloc>  &v) 
# 155
{ ::thrust::detail::vector_base< T, Alloc> ::operator=(v); return *this; } 
# 161
template< class InputIterator> 
# 163
host_vector(InputIterator first, InputIterator last) : Parent(first, last) 
# 164
{ } 
# 425
}; 
# 430
}
# 24 "/usr/local/cuda/include/thrust/detail/host_vector.inl"
namespace thrust { 
# 27
template< class T, class Alloc> 
# 28
template< class OtherT, class OtherAlloc> 
# 31
host_vector< T, Alloc> ::host_vector(const device_vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 33
{ 
# 34
; 
# 35
} 
# 37
}
# 24 "/usr/local/cuda/include/thrust/detail/device_vector.inl"
namespace thrust { 
# 27
template< class T, class Alloc> 
# 28
template< class OtherT, class OtherAlloc> 
# 31
device_vector< T, Alloc> ::device_vector(const host_vector< OtherT, OtherAlloc>  &v) : Parent(v) 
# 33
{ 
# 34
; 
# 35
} 
# 37
}
# 27 "/usr/local/cuda/include/thrust/inner_product.h"
namespace thrust { 
# 80
template< class DerivedPolicy, class 
# 81
InputIterator1, class 
# 82
InputIterator2, class 
# 83
OutputType> OutputType 
# 80
inner_product(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init); 
# 131
template< class InputIterator1, class InputIterator2, class OutputType> OutputType inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init); 
# 186
template< class DerivedPolicy, class 
# 187
InputIterator1, class 
# 188
InputIterator2, class 
# 189
OutputType, class 
# 190
BinaryFunction1, class 
# 191
BinaryFunction2> OutputType 
# 186
inner_product(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2); 
# 250
template< class InputIterator1, class InputIterator2, class OutputType, class 
# 251
BinaryFunction1, class BinaryFunction2> OutputType 
# 250
inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2); 
# 261
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/inner_product.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputType> OutputType inner_product(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init); 
# 42
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputType, class BinaryFunction1, class BinaryFunction2> OutputType inner_product(execution_policy< DerivedPolicy>  & exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2); 
# 53
}
# 54
}
# 55
}
# 56
}
# 27 "/usr/local/cuda/include/thrust/transform_reduce.h"
namespace thrust { 
# 105
template< class DerivedPolicy, class 
# 106
InputIterator, class 
# 107
UnaryFunction, class 
# 108
OutputType, class 
# 109
BinaryFunction> OutputType 
# 105
transform_reduce(const detail::execution_policy_base< DerivedPolicy>  & exec, InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op); 
# 179
template< class InputIterator, class 
# 180
UnaryFunction, class 
# 181
OutputType, class 
# 182
BinaryFunction> OutputType 
# 179
transform_reduce(InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op); 
# 195
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/transform_reduce.h"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class ExecutionPolicy, class 
# 34
InputIterator, class 
# 35
UnaryFunction, class 
# 36
OutputType, class 
# 37
BinaryFunction> OutputType 
# 33
transform_reduce(execution_policy< ExecutionPolicy>  & exec, InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op); 
# 47
}
# 48
}
# 49
}
# 50
}
# 22 "/usr/local/cuda/include/thrust/system/detail/generic/transform_reduce.inl"
namespace thrust { 
# 24
namespace system { 
# 26
namespace detail { 
# 28
namespace generic { 
# 32
template< class DerivedPolicy, class 
# 33
InputIterator, class 
# 34
UnaryFunction, class 
# 35
OutputType, class 
# 36
BinaryFunction> OutputType 
# 38
transform_reduce(execution_policy< DerivedPolicy>  &exec, InputIterator 
# 39
first, InputIterator 
# 40
last, UnaryFunction 
# 41
unary_op, OutputType 
# 42
init, BinaryFunction 
# 43
binary_op) 
# 44
{ 
# 45
transform_iterator< UnaryFunction, InputIterator, OutputType>  xfrm_first(first, unary_op); 
# 46
transform_iterator< UnaryFunction, InputIterator, OutputType>  xfrm_last(last, unary_op); 
# 48
return thrust::reduce(exec, xfrm_first, xfrm_last, init, binary_op); 
# 49
} 
# 52
}
# 53
}
# 54
}
# 55
}
# 28 "/usr/local/cuda/include/thrust/detail/transform_reduce.inl"
namespace thrust { 
# 33
template< class DerivedPolicy, class 
# 34
InputIterator, class 
# 35
UnaryFunction, class 
# 36
OutputType, class 
# 37
BinaryFunction> OutputType 
# 39
transform_reduce(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator 
# 40
first, InputIterator 
# 41
last, UnaryFunction 
# 42
unary_op, OutputType 
# 43
init, BinaryFunction 
# 44
binary_op) 
# 45
{ 
# 46
using system::detail::generic::transform_reduce;
# 47
return transform_reduce(detail::derived_cast(detail::strip_const(exec)), first, last, unary_op, init, binary_op); 
# 48
} 
# 51
template< class InputIterator, class 
# 52
UnaryFunction, class 
# 53
OutputType, class 
# 54
BinaryFunction> OutputType 
# 55
transform_reduce(InputIterator first, InputIterator 
# 56
last, UnaryFunction 
# 57
unary_op, OutputType 
# 58
init, BinaryFunction 
# 59
binary_op) 
# 60
{ 
# 61
using thrust::system::detail::generic::select_system;
# 63
typedef typename iterator_system< InputIterator> ::type System; 
# 65
System system; 
# 67
return thrust::transform_reduce(select_system(system), first, last, unary_op, init, binary_op); 
# 68
} 
# 71
}
# 23 "/usr/local/cuda/include/thrust/system/detail/generic/inner_product.inl"
namespace thrust { 
# 25
namespace system { 
# 27
namespace detail { 
# 29
namespace generic { 
# 33
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputType> OutputType 
# 35
inner_product(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 36
first1, InputIterator1 
# 37
last1, InputIterator2 
# 38
first2, OutputType 
# 39
init) 
# 40
{ 
# 41
plus< OutputType>  binary_op1; 
# 42
multiplies< OutputType>  binary_op2; 
# 43
return thrust::inner_product(exec, first1, last1, first2, init, binary_op1, binary_op2); 
# 44
} 
# 47
template< class DerivedPolicy, class InputIterator1, class InputIterator2, class OutputType, class BinaryFunction1, class BinaryFunction2> OutputType 
# 49
inner_product(execution_policy< DerivedPolicy>  &exec, InputIterator1 
# 50
first1, InputIterator1 
# 51
last1, InputIterator2 
# 52
first2, OutputType 
# 53
init, BinaryFunction1 
# 54
binary_op1, BinaryFunction2 
# 55
binary_op2) 
# 56
{ 
# 57
typedef zip_iterator< tuple< InputIterator1, InputIterator2, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> >  ZipIter; 
# 59
ZipIter first = thrust::make_zip_iterator(thrust::make_tuple(first1, first2)); 
# 62
ZipIter last = thrust::make_zip_iterator(thrust::make_tuple(last1, first2)); 
# 64
return thrust::transform_reduce(exec, first, last, ((thrust::detail::zipped_binary_op< OutputType, BinaryFunction2> )(binary_op2)), init, binary_op1); 
# 65
} 
# 68
}
# 69
}
# 70
}
# 71
}
# 29 "/usr/local/cuda/include/thrust/detail/inner_product.inl"
namespace thrust { 
# 34
template< class DerivedPolicy, class 
# 35
InputIterator1, class 
# 36
InputIterator2, class 
# 37
OutputType> OutputType 
# 39
inner_product(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 40
first1, InputIterator1 
# 41
last1, InputIterator2 
# 42
first2, OutputType 
# 43
init) 
# 44
{ 
# 45
using system::detail::generic::inner_product;
# 46
return inner_product(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, init); 
# 47
} 
# 51
template< class DerivedPolicy, class 
# 52
InputIterator1, class 
# 53
InputIterator2, class 
# 54
OutputType, class 
# 55
BinaryFunction1, class 
# 56
BinaryFunction2> OutputType 
# 58
inner_product(const detail::execution_policy_base< DerivedPolicy>  &exec, InputIterator1 
# 59
first1, InputIterator1 
# 60
last1, InputIterator2 
# 61
first2, OutputType 
# 62
init, BinaryFunction1 
# 63
binary_op1, BinaryFunction2 
# 64
binary_op2) 
# 65
{ 
# 66
using system::detail::generic::inner_product;
# 67
return inner_product(detail::derived_cast(detail::strip_const(exec)), first1, last1, first2, init, binary_op1, binary_op2); 
# 68
} 
# 71
template< class InputIterator1, class InputIterator2, class OutputType> OutputType 
# 73
inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 74
first2, OutputType init) 
# 75
{ 
# 76
using system::detail::generic::select_system;
# 78
typedef typename iterator_system< InputIterator1> ::type System1; 
# 79
typedef typename iterator_system< InputIterator2> ::type System2; 
# 81
System1 system1; 
# 82
System2 system2; 
# 84
return thrust::inner_product(select_system(system1, system2), first1, last1, first2, init); 
# 85
} 
# 88
template< class InputIterator1, class InputIterator2, class OutputType, class 
# 89
BinaryFunction1, class BinaryFunction2> OutputType 
# 91
inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 
# 92
first2, OutputType init, BinaryFunction1 
# 93
binary_op1, BinaryFunction2 binary_op2) 
# 94
{ 
# 95
using system::detail::generic::select_system;
# 97
typedef typename iterator_system< InputIterator1> ::type System1; 
# 98
typedef typename iterator_system< InputIterator2> ::type System2; 
# 100
System1 system1; 
# 101
System2 system2; 
# 103
return thrust::inner_product(select_system(system1, system2), first1, last1, first2, init, binary_op1, binary_op2); 
# 104
} 
# 107
}
# 30 "/usr/include/complex.h" 3
extern "C" {
# 53 "/usr/include/x86_64-linux-gnu/bits/cmathcalls.h" 3
extern double __complex__ cacos(double __complex__ __z) throw(); extern double __complex__ __cacos(double __complex__ __z) throw(); 
# 55
extern double __complex__ casin(double __complex__ __z) throw(); extern double __complex__ __casin(double __complex__ __z) throw(); 
# 57
extern double __complex__ catan(double __complex__ __z) throw(); extern double __complex__ __catan(double __complex__ __z) throw(); 
# 60
extern double __complex__ ccos(double __complex__ __z) throw(); extern double __complex__ __ccos(double __complex__ __z) throw(); 
# 62
extern double __complex__ csin(double __complex__ __z) throw(); extern double __complex__ __csin(double __complex__ __z) throw(); 
# 64
extern double __complex__ ctan(double __complex__ __z) throw(); extern double __complex__ __ctan(double __complex__ __z) throw(); 
# 70
extern double __complex__ cacosh(double __complex__ __z) throw(); extern double __complex__ __cacosh(double __complex__ __z) throw(); 
# 72
extern double __complex__ casinh(double __complex__ __z) throw(); extern double __complex__ __casinh(double __complex__ __z) throw(); 
# 74
extern double __complex__ catanh(double __complex__ __z) throw(); extern double __complex__ __catanh(double __complex__ __z) throw(); 
# 77
extern double __complex__ ccosh(double __complex__ __z) throw(); extern double __complex__ __ccosh(double __complex__ __z) throw(); 
# 79
extern double __complex__ csinh(double __complex__ __z) throw(); extern double __complex__ __csinh(double __complex__ __z) throw(); 
# 81
extern double __complex__ ctanh(double __complex__ __z) throw(); extern double __complex__ __ctanh(double __complex__ __z) throw(); 
# 87
extern double __complex__ cexp(double __complex__ __z) throw(); extern double __complex__ __cexp(double __complex__ __z) throw(); 
# 90
extern double __complex__ clog(double __complex__ __z) throw(); extern double __complex__ __clog(double __complex__ __z) throw(); 
# 95
extern double __complex__ clog10(double __complex__ __z) throw(); extern double __complex__ __clog10(double __complex__ __z) throw(); 
# 101
extern double __complex__ cpow(double __complex__ __x, double __complex__ __y) throw(); extern double __complex__ __cpow(double __complex__ __x, double __complex__ __y) throw(); 
# 104
extern double __complex__ csqrt(double __complex__ __z) throw(); extern double __complex__ __csqrt(double __complex__ __z) throw(); 
# 110
extern double cabs(double __complex__ __z) throw(); extern double __cabs(double __complex__ __z) throw(); 
# 113
extern double carg(double __complex__ __z) throw(); extern double __carg(double __complex__ __z) throw(); 
# 116
extern double __complex__ conj(double __complex__ __z) throw(); extern double __complex__ __conj(double __complex__ __z) throw(); 
# 119
extern double __complex__ cproj(double __complex__ __z) throw(); extern double __complex__ __cproj(double __complex__ __z) throw(); 
# 125
extern double cimag(double __complex__ __z) throw(); extern double __cimag(double __complex__ __z) throw(); 
# 128
extern double creal(double __complex__ __z) throw(); extern double __creal(double __complex__ __z) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/cmathcalls.h" 3
extern float __complex__ cacosf(float __complex__ __z) throw(); extern float __complex__ __cacosf(float __complex__ __z) throw(); 
# 55
extern float __complex__ casinf(float __complex__ __z) throw(); extern float __complex__ __casinf(float __complex__ __z) throw(); 
# 57
extern float __complex__ catanf(float __complex__ __z) throw(); extern float __complex__ __catanf(float __complex__ __z) throw(); 
# 60
extern float __complex__ ccosf(float __complex__ __z) throw(); extern float __complex__ __ccosf(float __complex__ __z) throw(); 
# 62
extern float __complex__ csinf(float __complex__ __z) throw(); extern float __complex__ __csinf(float __complex__ __z) throw(); 
# 64
extern float __complex__ ctanf(float __complex__ __z) throw(); extern float __complex__ __ctanf(float __complex__ __z) throw(); 
# 70
extern float __complex__ cacoshf(float __complex__ __z) throw(); extern float __complex__ __cacoshf(float __complex__ __z) throw(); 
# 72
extern float __complex__ casinhf(float __complex__ __z) throw(); extern float __complex__ __casinhf(float __complex__ __z) throw(); 
# 74
extern float __complex__ catanhf(float __complex__ __z) throw(); extern float __complex__ __catanhf(float __complex__ __z) throw(); 
# 77
extern float __complex__ ccoshf(float __complex__ __z) throw(); extern float __complex__ __ccoshf(float __complex__ __z) throw(); 
# 79
extern float __complex__ csinhf(float __complex__ __z) throw(); extern float __complex__ __csinhf(float __complex__ __z) throw(); 
# 81
extern float __complex__ ctanhf(float __complex__ __z) throw(); extern float __complex__ __ctanhf(float __complex__ __z) throw(); 
# 87
extern float __complex__ cexpf(float __complex__ __z) throw(); extern float __complex__ __cexpf(float __complex__ __z) throw(); 
# 90
extern float __complex__ clogf(float __complex__ __z) throw(); extern float __complex__ __clogf(float __complex__ __z) throw(); 
# 95
extern float __complex__ clog10f(float __complex__ __z) throw(); extern float __complex__ __clog10f(float __complex__ __z) throw(); 
# 101
extern float __complex__ cpowf(float __complex__ __x, float __complex__ __y) throw(); extern float __complex__ __cpowf(float __complex__ __x, float __complex__ __y) throw(); 
# 104
extern float __complex__ csqrtf(float __complex__ __z) throw(); extern float __complex__ __csqrtf(float __complex__ __z) throw(); 
# 110
extern float cabsf(float __complex__ __z) throw(); extern float __cabsf(float __complex__ __z) throw(); 
# 113
extern float cargf(float __complex__ __z) throw(); extern float __cargf(float __complex__ __z) throw(); 
# 116
extern float __complex__ conjf(float __complex__ __z) throw(); extern float __complex__ __conjf(float __complex__ __z) throw(); 
# 119
extern float __complex__ cprojf(float __complex__ __z) throw(); extern float __complex__ __cprojf(float __complex__ __z) throw(); 
# 125
extern float cimagf(float __complex__ __z) throw(); extern float __cimagf(float __complex__ __z) throw(); 
# 128
extern float crealf(float __complex__ __z) throw(); extern float __crealf(float __complex__ __z) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/cmathcalls.h" 3
extern long double __complex__ cacosl(long double __complex__ __z) throw(); extern long double __complex__ __cacosl(long double __complex__ __z) throw(); 
# 55
extern long double __complex__ casinl(long double __complex__ __z) throw(); extern long double __complex__ __casinl(long double __complex__ __z) throw(); 
# 57
extern long double __complex__ catanl(long double __complex__ __z) throw(); extern long double __complex__ __catanl(long double __complex__ __z) throw(); 
# 60
extern long double __complex__ ccosl(long double __complex__ __z) throw(); extern long double __complex__ __ccosl(long double __complex__ __z) throw(); 
# 62
extern long double __complex__ csinl(long double __complex__ __z) throw(); extern long double __complex__ __csinl(long double __complex__ __z) throw(); 
# 64
extern long double __complex__ ctanl(long double __complex__ __z) throw(); extern long double __complex__ __ctanl(long double __complex__ __z) throw(); 
# 70
extern long double __complex__ cacoshl(long double __complex__ __z) throw(); extern long double __complex__ __cacoshl(long double __complex__ __z) throw(); 
# 72
extern long double __complex__ casinhl(long double __complex__ __z) throw(); extern long double __complex__ __casinhl(long double __complex__ __z) throw(); 
# 74
extern long double __complex__ catanhl(long double __complex__ __z) throw(); extern long double __complex__ __catanhl(long double __complex__ __z) throw(); 
# 77
extern long double __complex__ ccoshl(long double __complex__ __z) throw(); extern long double __complex__ __ccoshl(long double __complex__ __z) throw(); 
# 79
extern long double __complex__ csinhl(long double __complex__ __z) throw(); extern long double __complex__ __csinhl(long double __complex__ __z) throw(); 
# 81
extern long double __complex__ ctanhl(long double __complex__ __z) throw(); extern long double __complex__ __ctanhl(long double __complex__ __z) throw(); 
# 87
extern long double __complex__ cexpl(long double __complex__ __z) throw(); extern long double __complex__ __cexpl(long double __complex__ __z) throw(); 
# 90
extern long double __complex__ clogl(long double __complex__ __z) throw(); extern long double __complex__ __clogl(long double __complex__ __z) throw(); 
# 95
extern long double __complex__ clog10l(long double __complex__ __z) throw(); extern long double __complex__ __clog10l(long double __complex__ __z) throw(); 
# 101
extern long double __complex__ cpowl(long double __complex__ __x, long double __complex__ __y) throw(); extern long double __complex__ __cpowl(long double __complex__ __x, long double __complex__ __y) throw(); 
# 104
extern long double __complex__ csqrtl(long double __complex__ __z) throw(); extern long double __complex__ __csqrtl(long double __complex__ __z) throw(); 
# 110
extern long double cabsl(long double __complex__ __z) throw(); extern long double __cabsl(long double __complex__ __z) throw(); 
# 113
extern long double cargl(long double __complex__ __z) throw(); extern long double __cargl(long double __complex__ __z) throw(); 
# 116
extern long double __complex__ conjl(long double __complex__ __z) throw(); extern long double __complex__ __conjl(long double __complex__ __z) throw(); 
# 119
extern long double __complex__ cprojl(long double __complex__ __z) throw(); extern long double __complex__ __cprojl(long double __complex__ __z) throw(); 
# 125
extern long double cimagl(long double __complex__ __z) throw(); extern long double __cimagl(long double __complex__ __z) throw(); 
# 128
extern long double creall(long double __complex__ __z) throw(); extern long double __creall(long double __complex__ __z) throw(); 
# 110 "/usr/include/complex.h" 3
}
# 62 "/usr/local/cuda/include/cuComplex.h"
extern "C" {
# 67
typedef float2 cuFloatComplex; 
# 69
static inline float cuCrealf(cuFloatComplex x) 
# 70
{ 
# 71
return x.x; 
# 72
} 
# 74
static inline float cuCimagf(cuFloatComplex x) 
# 75
{ 
# 76
return x.y; 
# 77
} 
# 79
static inline cuFloatComplex make_cuFloatComplex(float 
# 80
r, float i) 
# 81
{ 
# 82
cuFloatComplex res; 
# 83
(res.x) = r; 
# 84
(res.y) = i; 
# 85
return res; 
# 86
} 
# 88
static inline cuFloatComplex cuConjf(cuFloatComplex x) 
# 89
{ 
# 90
return make_cuFloatComplex(cuCrealf(x), -cuCimagf(x)); 
# 91
} 
# 92
static inline cuFloatComplex cuCaddf(cuFloatComplex x, cuFloatComplex 
# 93
y) 
# 94
{ 
# 95
return make_cuFloatComplex(cuCrealf(x) + cuCrealf(y), cuCimagf(x) + cuCimagf(y)); 
# 97
} 
# 99
static inline cuFloatComplex cuCsubf(cuFloatComplex x, cuFloatComplex 
# 100
y) 
# 101
{ 
# 102
return make_cuFloatComplex(cuCrealf(x) - cuCrealf(y), cuCimagf(x) - cuCimagf(y)); 
# 104
} 
# 111
static inline cuFloatComplex cuCmulf(cuFloatComplex x, cuFloatComplex 
# 112
y) 
# 113
{ 
# 114
cuFloatComplex prod; 
# 115
prod = make_cuFloatComplex((cuCrealf(x) * cuCrealf(y)) - (cuCimagf(x) * cuCimagf(y)), (cuCrealf(x) * cuCimagf(y)) + (cuCimagf(x) * cuCrealf(y))); 
# 119
return prod; 
# 120
} 
# 127
static inline cuFloatComplex cuCdivf(cuFloatComplex x, cuFloatComplex 
# 128
y) 
# 129
{ 
# 130
cuFloatComplex quot; 
# 131
float s = fabsf(cuCrealf(y)) + fabsf(cuCimagf(y)); 
# 132
float oos = (1.0F) / s; 
# 133
float ars = cuCrealf(x) * oos; 
# 134
float ais = cuCimagf(x) * oos; 
# 135
float brs = cuCrealf(y) * oos; 
# 136
float bis = cuCimagf(y) * oos; 
# 137
s = ((brs * brs) + (bis * bis)); 
# 138
oos = ((1.0F) / s); 
# 139
quot = make_cuFloatComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
# 141
return quot; 
# 142
} 
# 152
static inline float cuCabsf(cuFloatComplex x) 
# 153
{ 
# 154
float a = cuCrealf(x); 
# 155
float b = cuCimagf(x); 
# 156
float v, w, t; 
# 157
a = fabsf(a); 
# 158
b = fabsf(b); 
# 159
if (a > b) { 
# 160
v = a; 
# 161
w = b; 
# 162
} else { 
# 163
v = b; 
# 164
w = a; 
# 165
}  
# 166
t = (w / v); 
# 167
t = ((1.0F) + (t * t)); 
# 168
t = (v * sqrtf(t)); 
# 169
if (((v == (0.0F)) || (v > (3.402823466e+38F))) || (w > (3.402823466e+38F))) { 
# 170
t = (v + w); 
# 171
}  
# 172
return t; 
# 173
} 
# 176
typedef double2 cuDoubleComplex; 
# 178
static inline double cuCreal(cuDoubleComplex x) 
# 179
{ 
# 180
return x.x; 
# 181
} 
# 183
static inline double cuCimag(cuDoubleComplex x) 
# 184
{ 
# 185
return x.y; 
# 186
} 
# 188
static inline cuDoubleComplex make_cuDoubleComplex(double 
# 189
r, double i) 
# 190
{ 
# 191
cuDoubleComplex res; 
# 192
(res.x) = r; 
# 193
(res.y) = i; 
# 194
return res; 
# 195
} 
# 197
static inline cuDoubleComplex cuConj(cuDoubleComplex x) 
# 198
{ 
# 199
return make_cuDoubleComplex(cuCreal(x), -cuCimag(x)); 
# 200
} 
# 202
static inline cuDoubleComplex cuCadd(cuDoubleComplex x, cuDoubleComplex 
# 203
y) 
# 204
{ 
# 205
return make_cuDoubleComplex(cuCreal(x) + cuCreal(y), cuCimag(x) + cuCimag(y)); 
# 207
} 
# 209
static inline cuDoubleComplex cuCsub(cuDoubleComplex x, cuDoubleComplex 
# 210
y) 
# 211
{ 
# 212
return make_cuDoubleComplex(cuCreal(x) - cuCreal(y), cuCimag(x) - cuCimag(y)); 
# 214
} 
# 221
static inline cuDoubleComplex cuCmul(cuDoubleComplex x, cuDoubleComplex 
# 222
y) 
# 223
{ 
# 224
cuDoubleComplex prod; 
# 225
prod = make_cuDoubleComplex((cuCreal(x) * cuCreal(y)) - (cuCimag(x) * cuCimag(y)), (cuCreal(x) * cuCimag(y)) + (cuCimag(x) * cuCreal(y))); 
# 229
return prod; 
# 230
} 
# 237
static inline cuDoubleComplex cuCdiv(cuDoubleComplex x, cuDoubleComplex 
# 238
y) 
# 239
{ 
# 240
cuDoubleComplex quot; 
# 241
double s = fabs(cuCreal(y)) + fabs(cuCimag(y)); 
# 242
double oos = (1.0) / s; 
# 243
double ars = cuCreal(x) * oos; 
# 244
double ais = cuCimag(x) * oos; 
# 245
double brs = cuCreal(y) * oos; 
# 246
double bis = cuCimag(y) * oos; 
# 247
s = ((brs * brs) + (bis * bis)); 
# 248
oos = ((1.0) / s); 
# 249
quot = make_cuDoubleComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
# 251
return quot; 
# 252
} 
# 260
static inline double cuCabs(cuDoubleComplex x) 
# 261
{ 
# 262
double a = cuCreal(x); 
# 263
double b = cuCimag(x); 
# 264
double v, w, t; 
# 265
a = fabs(a); 
# 266
b = fabs(b); 
# 267
if (a > b) { 
# 268
v = a; 
# 269
w = b; 
# 270
} else { 
# 271
v = b; 
# 272
w = a; 
# 273
}  
# 274
t = (w / v); 
# 275
t = ((1.0) + (t * t)); 
# 276
t = (v * sqrt(t)); 
# 277
if (((v == (0.0)) || (v > (1.797693134862315708e+308))) || (w > (1.797693134862315708e+308))) 
# 278
{ 
# 279
t = (v + w); 
# 280
}  
# 281
return t; 
# 282
} 
# 285
}
# 289
typedef cuFloatComplex cuComplex; 
# 290
static inline cuComplex make_cuComplex(float x, float 
# 291
y) 
# 292
{ 
# 293
return make_cuFloatComplex(x, y); 
# 294
} 
# 297
static inline cuDoubleComplex cuComplexFloatToDouble(cuFloatComplex 
# 298
c) 
# 299
{ 
# 300
return make_cuDoubleComplex((double)cuCrealf(c), (double)cuCimagf(c)); 
# 301
} 
# 303
static inline cuFloatComplex cuComplexDoubleToFloat(cuDoubleComplex 
# 304
c) 
# 305
{ 
# 306
return make_cuFloatComplex((float)cuCreal(c), (float)cuCimag(c)); 
# 307
} 
# 310
static inline cuComplex cuCfmaf(cuComplex x, cuComplex y, cuComplex d) 
# 311
{ 
# 312
float real_res; 
# 313
float imag_res; 
# 315
real_res = ((cuCrealf(x) * cuCrealf(y)) + cuCrealf(d)); 
# 316
imag_res = ((cuCrealf(x) * cuCimagf(y)) + cuCimagf(d)); 
# 318
real_res = ((-(cuCimagf(x) * cuCimagf(y))) + real_res); 
# 319
imag_res = ((cuCimagf(x) * cuCrealf(y)) + imag_res); 
# 321
return make_cuComplex(real_res, imag_res); 
# 322
} 
# 324
static inline cuDoubleComplex cuCfma(cuDoubleComplex x, cuDoubleComplex y, cuDoubleComplex d) 
# 325
{ 
# 326
double real_res; 
# 327
double imag_res; 
# 329
real_res = ((cuCreal(x) * cuCreal(y)) + cuCreal(d)); 
# 330
imag_res = ((cuCreal(x) * cuCimag(y)) + cuCimag(d)); 
# 332
real_res = ((-(cuCimag(x) * cuCimag(y))) + real_res); 
# 333
imag_res = ((cuCimag(x) * cuCreal(y)) + imag_res); 
# 335
return make_cuDoubleComplex(real_res, imag_res); 
# 336
} 
# 74 "/usr/local/cuda/include/cufft.h"
extern "C" {
# 97
typedef 
# 78
enum cufftResult_t { 
# 79
CUFFT_SUCCESS, 
# 80
CUFFT_INVALID_PLAN, 
# 81
CUFFT_ALLOC_FAILED, 
# 82
CUFFT_INVALID_TYPE, 
# 83
CUFFT_INVALID_VALUE, 
# 84
CUFFT_INTERNAL_ERROR, 
# 85
CUFFT_EXEC_FAILED, 
# 86
CUFFT_SETUP_FAILED, 
# 87
CUFFT_INVALID_SIZE, 
# 88
CUFFT_UNALIGNED_DATA, 
# 89
CUFFT_INCOMPLETE_PARAMETER_LIST, 
# 90
CUFFT_INVALID_DEVICE, 
# 91
CUFFT_PARSE_ERROR, 
# 92
CUFFT_NO_WORKSPACE, 
# 93
CUFFT_NOT_IMPLEMENTED, 
# 94
CUFFT_LICENSE_ERROR, 
# 95
CUFFT_NOT_SUPPORTED
# 97
} cufftResult; 
# 107
typedef float cufftReal; 
# 108
typedef double cufftDoubleReal; 
# 113
typedef cuComplex cufftComplex; 
# 114
typedef cuDoubleComplex cufftDoubleComplex; 
# 128
typedef 
# 121
enum cufftType_t { 
# 122
CUFFT_R2C = 42, 
# 123
CUFFT_C2R = 44, 
# 124
CUFFT_C2C = 41, 
# 125
CUFFT_D2Z = 106, 
# 126
CUFFT_Z2D = 108, 
# 127
CUFFT_Z2Z = 105
# 128
} cufftType; 
# 133
typedef 
# 131
enum cufftCompatibility_t { 
# 132
CUFFT_COMPATIBILITY_FFTW_PADDING = 1
# 133
} cufftCompatibility; 
# 143
typedef int cufftHandle; 
# 146
__attribute((visibility("default"))) cufftResult cufftPlan1d(cufftHandle * plan, int nx, cufftType type, int batch); 
# 151
__attribute((visibility("default"))) cufftResult cufftPlan2d(cufftHandle * plan, int nx, int ny, cufftType type); 
# 155
__attribute((visibility("default"))) cufftResult cufftPlan3d(cufftHandle * plan, int nx, int ny, int nz, cufftType type); 
# 159
__attribute((visibility("default"))) cufftResult cufftPlanMany(cufftHandle * plan, int rank, int * n, int * inembed, int istride, int idist, int * onembed, int ostride, int odist, cufftType type, int batch); 
# 167
__attribute((visibility("default"))) cufftResult cufftMakePlan1d(cufftHandle plan, int nx, cufftType type, int batch, size_t * workSize); 
# 173
__attribute((visibility("default"))) cufftResult cufftMakePlan2d(cufftHandle plan, int nx, int ny, cufftType type, size_t * workSize); 
# 178
__attribute((visibility("default"))) cufftResult cufftMakePlan3d(cufftHandle plan, int nx, int ny, int nz, cufftType type, size_t * workSize); 
# 183
__attribute((visibility("default"))) cufftResult cufftMakePlanMany(cufftHandle plan, int rank, int * n, int * inembed, int istride, int idist, int * onembed, int ostride, int odist, cufftType type, int batch, size_t * workSize); 
# 192
__attribute((visibility("default"))) cufftResult cufftMakePlanMany64(cufftHandle plan, int rank, long long * n, long long * inembed, long long istride, long long idist, long long * onembed, long long ostride, long long odist, cufftType type, long long batch, size_t * workSize); 
# 204
__attribute((visibility("default"))) cufftResult cufftGetSizeMany64(cufftHandle plan, int rank, long long * n, long long * inembed, long long istride, long long idist, long long * onembed, long long ostride, long long odist, cufftType type, long long batch, size_t * workSize); 
# 218
__attribute((visibility("default"))) cufftResult cufftEstimate1d(int nx, cufftType type, int batch, size_t * workSize); 
# 223
__attribute((visibility("default"))) cufftResult cufftEstimate2d(int nx, int ny, cufftType type, size_t * workSize); 
# 227
__attribute((visibility("default"))) cufftResult cufftEstimate3d(int nx, int ny, int nz, cufftType type, size_t * workSize); 
# 231
__attribute((visibility("default"))) cufftResult cufftEstimateMany(int rank, int * n, int * inembed, int istride, int idist, int * onembed, int ostride, int odist, cufftType type, int batch, size_t * workSize); 
# 239
__attribute((visibility("default"))) cufftResult cufftCreate(cufftHandle * handle); 
# 241
__attribute((visibility("default"))) cufftResult cufftGetSize1d(cufftHandle handle, int nx, cufftType type, int batch, size_t * workSize); 
# 247
__attribute((visibility("default"))) cufftResult cufftGetSize2d(cufftHandle handle, int nx, int ny, cufftType type, size_t * workSize); 
# 252
__attribute((visibility("default"))) cufftResult cufftGetSize3d(cufftHandle handle, int nx, int ny, int nz, cufftType type, size_t * workSize); 
# 257
__attribute((visibility("default"))) cufftResult cufftGetSizeMany(cufftHandle handle, int rank, int * n, int * inembed, int istride, int idist, int * onembed, int ostride, int odist, cufftType type, int batch, size_t * workArea); 
# 263
__attribute((visibility("default"))) cufftResult cufftGetSize(cufftHandle handle, size_t * workSize); 
# 265
__attribute((visibility("default"))) cufftResult cufftSetWorkArea(cufftHandle plan, void * workArea); 
# 267
__attribute((visibility("default"))) cufftResult cufftSetAutoAllocation(cufftHandle plan, int autoAllocate); 
# 269
__attribute((visibility("default"))) cufftResult cufftExecC2C(cufftHandle plan, cufftComplex * idata, cufftComplex * odata, int direction); 
# 274
__attribute((visibility("default"))) cufftResult cufftExecR2C(cufftHandle plan, cufftReal * idata, cufftComplex * odata); 
# 278
__attribute((visibility("default"))) cufftResult cufftExecC2R(cufftHandle plan, cufftComplex * idata, cufftReal * odata); 
# 282
__attribute((visibility("default"))) cufftResult cufftExecZ2Z(cufftHandle plan, cufftDoubleComplex * idata, cufftDoubleComplex * odata, int direction); 
# 287
__attribute((visibility("default"))) cufftResult cufftExecD2Z(cufftHandle plan, cufftDoubleReal * idata, cufftDoubleComplex * odata); 
# 291
__attribute((visibility("default"))) cufftResult cufftExecZ2D(cufftHandle plan, cufftDoubleComplex * idata, cufftDoubleReal * odata); 
# 297
__attribute((visibility("default"))) cufftResult cufftSetStream(cufftHandle plan, cudaStream_t stream); 
# 300
__attribute((visibility("default"))) cufftResult cufftSetCompatibilityMode(cufftHandle plan, cufftCompatibility mode); 
# 303
__attribute((visibility("default"))) cufftResult cufftDestroy(cufftHandle plan); 
# 305
__attribute((visibility("default"))) cufftResult cufftGetVersion(int * version); 
# 307
__attribute((visibility("default"))) cufftResult cufftGetProperty(libraryPropertyType type, int * value); 
# 311
}
# 96 "/usr/local/cuda/include/cuda_fp16.h"
typedef 
# 94
struct __attribute((aligned(2))) { 
# 95
unsigned short x; 
# 96
} __half; 
# 100
typedef 
# 98
struct __attribute((aligned(4))) { 
# 99
unsigned x; 
# 100
} __half2; 
# 103
typedef __half half; 
# 104
typedef __half2 half2; 
# 128
__attribute__((unused)) static inline __half __float2half(const float a); 
# 138
__attribute__((unused)) static inline __half __float2half_rz(const float a); 
# 148
__attribute__((unused)) static inline __half __float2half_rd(const float a); 
# 158
__attribute__((unused)) static inline __half __float2half_ru(const float a); 
# 167
__attribute__((unused)) static inline float __half2float(const __half a); 
# 178
__attribute__((unused)) static inline int __half2int_rn(__half h); 
# 188
__attribute__((unused)) static inline int __half2int_rz(__half h); 
# 198
__attribute__((unused)) static inline int __half2int_rd(__half h); 
# 208
__attribute__((unused)) static inline int __half2int_ru(__half h); 
# 219
__attribute__((unused)) static inline __half __int2half_rn(int i); 
# 229
__attribute__((unused)) static inline __half __int2half_rz(int i); 
# 239
__attribute__((unused)) static inline __half __int2half_rd(int i); 
# 249
__attribute__((unused)) static inline __half __int2half_ru(int i); 
# 261
__attribute__((unused)) static inline short __half2short_rn(__half h); 
# 271
__attribute__((unused)) static inline short __half2short_rz(__half h); 
# 281
__attribute__((unused)) static inline short __half2short_rd(__half h); 
# 291
__attribute__((unused)) static inline short __half2short_ru(__half h); 
# 303
__attribute__((unused)) static inline __half __short2half_rn(short i); 
# 313
__attribute__((unused)) static inline __half __short2half_rz(short i); 
# 323
__attribute__((unused)) static inline __half __short2half_rd(short i); 
# 333
__attribute__((unused)) static inline __half __short2half_ru(short i); 
# 344
__attribute__((unused)) static inline unsigned __half2uint_rn(__half h); 
# 354
__attribute__((unused)) static inline unsigned __half2uint_rz(__half h); 
# 364
__attribute__((unused)) static inline unsigned __half2uint_rd(__half h); 
# 374
__attribute__((unused)) static inline unsigned __half2uint_ru(__half h); 
# 385
__attribute__((unused)) static inline __half __uint2half_rn(unsigned i); 
# 395
__attribute__((unused)) static inline __half __uint2half_rz(unsigned i); 
# 405
__attribute__((unused)) static inline __half __uint2half_rd(unsigned i); 
# 415
__attribute__((unused)) static inline __half __uint2half_ru(unsigned i); 
# 427
__attribute__((unused)) static inline unsigned short __half2ushort_rn(__half h); 
# 438
__attribute__((unused)) static inline unsigned short __half2ushort_rz(__half h); 
# 448
__attribute__((unused)) static inline unsigned short __half2ushort_rd(__half h); 
# 458
__attribute__((unused)) static inline unsigned short __half2ushort_ru(__half h); 
# 470
__attribute__((unused)) static inline __half __ushort2half_rn(unsigned short i); 
# 481
__attribute__((unused)) static inline __half __ushort2half_rz(unsigned short i); 
# 491
__attribute__((unused)) static inline __half __ushort2half_rd(unsigned short i); 
# 501
__attribute__((unused)) static inline __half __ushort2half_ru(unsigned short i); 
# 513
__attribute__((unused)) static inline unsigned long long __half2ull_rn(__half h); 
# 524
__attribute__((unused)) static inline unsigned long long __half2ull_rz(__half h); 
# 534
__attribute__((unused)) static inline unsigned long long __half2ull_rd(__half h); 
# 544
__attribute__((unused)) static inline unsigned long long __half2ull_ru(__half h); 
# 556
__attribute__((unused)) static inline __half __ull2half_rn(unsigned long long i); 
# 567
__attribute__((unused)) static inline __half __ull2half_rz(unsigned long long i); 
# 577
__attribute__((unused)) static inline __half __ull2half_rd(unsigned long long i); 
# 587
__attribute__((unused)) static inline __half __ull2half_ru(unsigned long long i); 
# 599
__attribute__((unused)) static inline long long __half2ll_rn(__half h); 
# 609
__attribute__((unused)) static inline long long __half2ll_rz(__half h); 
# 619
__attribute__((unused)) static inline long long __half2ll_rd(__half h); 
# 629
__attribute__((unused)) static inline long long __half2ll_ru(__half h); 
# 641
__attribute__((unused)) static inline __half __ll2half_rn(long long i); 
# 651
__attribute__((unused)) static inline __half __ll2half_rz(long long i); 
# 661
__attribute__((unused)) static inline __half __ll2half_rd(long long i); 
# 671
__attribute__((unused)) static inline __half __ll2half_ru(long long i); 
# 682
__attribute__((unused)) static inline __half htrunc(const __half h); 
# 691
__attribute__((unused)) static inline __half hceil(const __half h); 
# 700
__attribute__((unused)) static inline __half hfloor(const __half h); 
# 712
__attribute__((unused)) static inline __half hrint(const __half h); 
# 723
__attribute__((unused)) static inline __half2 h2trunc(const __half2 h); 
# 734
__attribute__((unused)) static inline __half2 h2ceil(const __half2 h); 
# 745
__attribute__((unused)) static inline __half2 h2floor(const __half2 h); 
# 758
__attribute__((unused)) static inline __half2 h2rint(const __half2 h); 
# 771
__attribute__((unused)) static inline __half2 __float2half2_rn(const float a); 
# 785
__attribute__((unused)) static inline __half2 __floats2half2_rn(const float a, const float b); 
# 799
__attribute__((unused)) static inline __half2 __float22half2_rn(const float2 a); 
# 809
__attribute__((unused)) static inline float2 __half22float2(const __half2 a); 
# 819
__attribute__((unused)) static inline float __low2float(const __half2 a); 
# 829
__attribute__((unused)) static inline __half2 __half2half2(const __half a); 
# 839
__attribute__((unused)) static inline float __high2float(const __half2 a); 
# 849
__attribute__((unused)) static inline __half2 __lowhigh2highlow(const __half2 a); 
# 862
__attribute__((unused)) static inline __half2 __lows2half2(const __half2 a, const __half2 b); 
# 875
__attribute__((unused)) static inline __half2 __highs2half2(const __half2 a, const __half2 b); 
# 884
__attribute__((unused)) static inline __half __high2half(const __half2 a); 
# 893
__attribute__((unused)) static inline __half __low2half(const __half2 a); 
# 903
__attribute__((unused)) static inline int __hisinf(const __half a); 
# 915
__attribute__((unused)) static inline __half2 __halves2half2(const __half a, const __half b); 
# 926
__attribute__((unused)) static inline __half2 __low2half2(const __half2 a); 
# 937
__attribute__((unused)) static inline __half2 __high2half2(const __half2 a); 
# 948
__attribute__((unused)) static inline short __half_as_short(const __half h); 
# 958
__attribute__((unused)) static inline unsigned short __half_as_ushort(const __half h); 
# 968
__attribute__((unused)) static inline __half __short_as_half(const short i); 
# 978
__attribute__((unused)) static inline __half __ushort_as_half(const unsigned short i); 
# 985
__attribute__((unused)) static inline __half2 __shfl(__half2 var, int delta, int width = 32); 
# 986
__attribute__((unused)) static inline __half2 __shfl_up(__half2 var, unsigned delta, int width = 32); 
# 987
__attribute__((unused)) static inline __half2 __shfl_down(__half2 var, unsigned delta, int width = 32); 
# 988
__attribute__((unused)) static inline __half2 __shfl_xor(__half2 var, int delta, int width = 32); 
# 989
__attribute__((unused)) static inline __half __shfl(__half var, int delta, int width = 32); 
# 990
__attribute__((unused)) static inline __half __shfl_up(__half var, unsigned delta, int width = 32); 
# 991
__attribute__((unused)) static inline __half __shfl_down(__half var, unsigned delta, int width = 32); 
# 992
__attribute__((unused)) static inline __half __shfl_xor(__half var, int delta, int width = 32); 
# 1000
__attribute__((unused)) static inline __half2 __ldg(const __half2 * ptr); 
# 1001
__attribute__((unused)) static inline __half __ldg(const __half * ptr); 
# 1002
__attribute__((unused)) static inline __half2 __ldcg(const __half2 * ptr); 
# 1003
__attribute__((unused)) static inline __half __ldcg(const __half * ptr); 
# 1004
__attribute__((unused)) static inline __half2 __ldca(const __half2 * ptr); 
# 1005
__attribute__((unused)) static inline __half __ldca(const __half * ptr); 
# 1006
__attribute__((unused)) static inline __half2 __ldcs(const __half2 * ptr); 
# 1007
__attribute__((unused)) static inline __half __ldcs(const __half * ptr); 
# 1022
__attribute__((unused)) static inline __half2 __heq2(const __half2 a, const __half2 b); 
# 1034
__attribute__((unused)) static inline __half2 __hne2(const __half2 a, const __half2 b); 
# 1046
__attribute__((unused)) static inline __half2 __hle2(const __half2 a, const __half2 b); 
# 1058
__attribute__((unused)) static inline __half2 __hge2(const __half2 a, const __half2 b); 
# 1070
__attribute__((unused)) static inline __half2 __hlt2(const __half2 a, const __half2 b); 
# 1082
__attribute__((unused)) static inline __half2 __hgt2(const __half2 a, const __half2 b); 
# 1094
__attribute__((unused)) static inline __half2 __hequ2(const __half2 a, const __half2 b); 
# 1106
__attribute__((unused)) static inline __half2 __hneu2(const __half2 a, const __half2 b); 
# 1118
__attribute__((unused)) static inline __half2 __hleu2(const __half2 a, const __half2 b); 
# 1130
__attribute__((unused)) static inline __half2 __hgeu2(const __half2 a, const __half2 b); 
# 1142
__attribute__((unused)) static inline __half2 __hltu2(const __half2 a, const __half2 b); 
# 1154
__attribute__((unused)) static inline __half2 __hgtu2(const __half2 a, const __half2 b); 
# 1164
__attribute__((unused)) static inline __half2 __hisnan2(const __half2 a); 
# 1174
__attribute__((unused)) static inline __half2 __hadd2(const __half2 a, const __half2 b); 
# 1185
__attribute__((unused)) static inline __half2 __hsub2(const __half2 a, const __half2 b); 
# 1196
__attribute__((unused)) static inline __half2 __hmul2(const __half2 a, const __half2 b); 
# 1206
__attribute__((unused)) static inline __half2 h2div(const __half2 a, const __half2 b); 
# 1219
__attribute__((unused)) static inline __half2 __hadd2_sat(const __half2 a, const __half2 b); 
# 1232
__attribute__((unused)) static inline __half2 __hsub2_sat(const __half2 a, const __half2 b); 
# 1245
__attribute__((unused)) static inline __half2 __hmul2_sat(const __half2 a, const __half2 b); 
# 1258
__attribute__((unused)) static inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c); 
# 1272
__attribute__((unused)) static inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c); 
# 1282
__attribute__((unused)) static inline __half2 __hneg2(const __half2 a); 
# 1292
__attribute__((unused)) static inline __half __hadd(const __half a, const __half b); 
# 1302
__attribute__((unused)) static inline __half __hsub(const __half a, const __half b); 
# 1312
__attribute__((unused)) static inline __half __hmul(const __half a, const __half b); 
# 1322
__attribute__((unused)) static inline __half hdiv(const __half a, const __half b); 
# 1333
__attribute__((unused)) static inline __half __hadd_sat(const __half a, const __half b); 
# 1346
__attribute__((unused)) static inline __half __hsub_sat(const __half a, const __half b); 
# 1359
__attribute__((unused)) static inline __half __hmul_sat(const __half a, const __half b); 
# 1371
__attribute__((unused)) static inline __half __hfma(const __half a, const __half b, const __half c); 
# 1385
__attribute__((unused)) static inline __half __hfma_sat(const __half a, const __half b, const __half c); 
# 1394
__attribute__((unused)) static inline __half __hneg(const __half a); 
# 1408
__attribute__((unused)) static inline bool __hbeq2(const __half2 a, const __half2 b); 
# 1422
__attribute__((unused)) static inline bool __hbne2(const __half2 a, const __half2 b); 
# 1436
__attribute__((unused)) static inline bool __hble2(const __half2 a, const __half2 b); 
# 1450
__attribute__((unused)) static inline bool __hbge2(const __half2 a, const __half2 b); 
# 1464
__attribute__((unused)) static inline bool __hblt2(const __half2 a, const __half2 b); 
# 1478
__attribute__((unused)) static inline bool __hbgt2(const __half2 a, const __half2 b); 
# 1492
__attribute__((unused)) static inline bool __hbequ2(const __half2 a, const __half2 b); 
# 1506
__attribute__((unused)) static inline bool __hbneu2(const __half2 a, const __half2 b); 
# 1520
__attribute__((unused)) static inline bool __hbleu2(const __half2 a, const __half2 b); 
# 1536
__attribute__((unused)) static inline bool __hbgeu2(const __half2 a, const __half2 b); 
# 1550
__attribute__((unused)) static inline bool __hbltu2(const __half2 a, const __half2 b); 
# 1566
__attribute__((unused)) static inline bool __hbgtu2(const __half2 a, const __half2 b); 
# 1576
__attribute__((unused)) static inline bool __heq(const __half a, const __half b); 
# 1586
__attribute__((unused)) static inline bool __hne(const __half a, const __half b); 
# 1596
__attribute__((unused)) static inline bool __hle(const __half a, const __half b); 
# 1606
__attribute__((unused)) static inline bool __hge(const __half a, const __half b); 
# 1616
__attribute__((unused)) static inline bool __hlt(const __half a, const __half b); 
# 1626
__attribute__((unused)) static inline bool __hgt(const __half a, const __half b); 
# 1637
__attribute__((unused)) static inline bool __hequ(const __half a, const __half b); 
# 1648
__attribute__((unused)) static inline bool __hneu(const __half a, const __half b); 
# 1659
__attribute__((unused)) static inline bool __hleu(const __half a, const __half b); 
# 1670
__attribute__((unused)) static inline bool __hgeu(const __half a, const __half b); 
# 1681
__attribute__((unused)) static inline bool __hltu(const __half a, const __half b); 
# 1692
__attribute__((unused)) static inline bool __hgtu(const __half a, const __half b); 
# 1701
__attribute__((unused)) static inline bool __hisnan(const __half a); 
# 1710
__attribute__((unused)) static inline __half hsqrt(const __half a); 
# 1721
__attribute__((unused)) static inline __half hrsqrt(const __half a); 
# 1730
__attribute__((unused)) static inline __half hrcp(const __half a); 
# 1740
__attribute__((unused)) static inline __half hlog(const __half a); 
# 1750
__attribute__((unused)) static inline __half hlog2(const __half a); 
# 1760
__attribute__((unused)) static inline __half hlog10(const __half a); 
# 1771
__attribute__((unused)) static inline __half hexp(const __half a); 
# 1782
__attribute__((unused)) static inline __half hexp2(const __half a); 
# 1793
__attribute__((unused)) static inline __half hexp10(const __half a); 
# 1802
__attribute__((unused)) static inline __half hcos(const __half a); 
# 1811
__attribute__((unused)) static inline __half hsin(const __half a); 
# 1821
__attribute__((unused)) static inline __half2 h2sqrt(const __half2 a); 
# 1832
__attribute__((unused)) static inline __half2 h2rsqrt(const __half2 a); 
# 1842
__attribute__((unused)) static inline __half2 h2rcp(const __half2 a); 
# 1853
__attribute__((unused)) static inline __half2 h2log(const __half2 a); 
# 1864
__attribute__((unused)) static inline __half2 h2log2(const __half2 a); 
# 1875
__attribute__((unused)) static inline __half2 h2log10(const __half2 a); 
# 1886
__attribute__((unused)) static inline __half2 h2exp(const __half2 a); 
# 1897
__attribute__((unused)) static inline __half2 h2exp2(const __half2 a); 
# 1908
__attribute__((unused)) static inline __half2 h2exp10(const __half2 a); 
# 1918
__attribute__((unused)) static inline __half2 h2cos(const __half2 a); 
# 1927
__attribute__((unused)) static inline __half2 h2sin(const __half2 a); 
# 1931
__attribute__((unused)) static inline int __half2int_rn(__half h) 
# 1932
{int volatile ___ = 1;(void)h;
# 1936
::exit(___);}
#if 0
# 1932
{ 
# 1933
int i; 
# 1934
__asm__("cvt.rni.s32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 1935
return i; 
# 1936
} 
#endif
# 1937 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_rz(__half h) 
# 1938
{int volatile ___ = 1;(void)h;
# 1942
::exit(___);}
#if 0
# 1938
{ 
# 1939
int i; 
# 1940
__asm__("cvt.rzi.s32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 1941
return i; 
# 1942
} 
#endif
# 1943 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_rd(__half h) 
# 1944
{int volatile ___ = 1;(void)h;
# 1948
::exit(___);}
#if 0
# 1944
{ 
# 1945
int i; 
# 1946
__asm__("cvt.rmi.s32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 1947
return i; 
# 1948
} 
#endif
# 1949 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_ru(__half h) 
# 1950
{int volatile ___ = 1;(void)h;
# 1954
::exit(___);}
#if 0
# 1950
{ 
# 1951
int i; 
# 1952
__asm__("cvt.rpi.s32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 1953
return i; 
# 1954
} 
#endif
# 1955 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_rn(int i) 
# 1956
{int volatile ___ = 1;(void)i;
# 1960
::exit(___);}
#if 0
# 1956
{ 
# 1957
__half h; 
# 1958
__asm__("cvt.rn.f16.s32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 1959
return h; 
# 1960
} 
#endif
# 1961 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_rz(int i) 
# 1962
{int volatile ___ = 1;(void)i;
# 1966
::exit(___);}
#if 0
# 1962
{ 
# 1963
__half h; 
# 1964
__asm__("cvt.rz.f16.s32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 1965
return h; 
# 1966
} 
#endif
# 1967 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_rd(int i) 
# 1968
{int volatile ___ = 1;(void)i;
# 1972
::exit(___);}
#if 0
# 1968
{ 
# 1969
__half h; 
# 1970
__asm__("cvt.rm.f16.s32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 1971
return h; 
# 1972
} 
#endif
# 1973 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_ru(int i) 
# 1974
{int volatile ___ = 1;(void)i;
# 1978
::exit(___);}
#if 0
# 1974
{ 
# 1975
__half h; 
# 1976
__asm__("cvt.rp.f16.s32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 1977
return h; 
# 1978
} 
#endif
# 1980 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_rn(__half h) 
# 1981
{int volatile ___ = 1;(void)h;
# 1985
::exit(___);}
#if 0
# 1981
{ 
# 1982
short i; 
# 1983
__asm__("cvt.rni.s16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 1984
return i; 
# 1985
} 
#endif
# 1986 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_rz(__half h) 
# 1987
{int volatile ___ = 1;(void)h;
# 1991
::exit(___);}
#if 0
# 1987
{ 
# 1988
short i; 
# 1989
__asm__("cvt.rzi.s16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 1990
return i; 
# 1991
} 
#endif
# 1992 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_rd(__half h) 
# 1993
{int volatile ___ = 1;(void)h;
# 1997
::exit(___);}
#if 0
# 1993
{ 
# 1994
short i; 
# 1995
__asm__("cvt.rmi.s16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 1996
return i; 
# 1997
} 
#endif
# 1998 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_ru(__half h) 
# 1999
{int volatile ___ = 1;(void)h;
# 2003
::exit(___);}
#if 0
# 1999
{ 
# 2000
short i; 
# 2001
__asm__("cvt.rpi.s16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 2002
return i; 
# 2003
} 
#endif
# 2004 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_rn(short i) 
# 2005
{int volatile ___ = 1;(void)i;
# 2009
::exit(___);}
#if 0
# 2005
{ 
# 2006
__half h; 
# 2007
__asm__("cvt.rn.f16.s16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2008
return h; 
# 2009
} 
#endif
# 2010 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_rz(short i) 
# 2011
{int volatile ___ = 1;(void)i;
# 2015
::exit(___);}
#if 0
# 2011
{ 
# 2012
__half h; 
# 2013
__asm__("cvt.rz.f16.s16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2014
return h; 
# 2015
} 
#endif
# 2016 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_rd(short i) 
# 2017
{int volatile ___ = 1;(void)i;
# 2021
::exit(___);}
#if 0
# 2017
{ 
# 2018
__half h; 
# 2019
__asm__("cvt.rm.f16.s16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2020
return h; 
# 2021
} 
#endif
# 2022 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_ru(short i) 
# 2023
{int volatile ___ = 1;(void)i;
# 2027
::exit(___);}
#if 0
# 2023
{ 
# 2024
__half h; 
# 2025
__asm__("cvt.rp.f16.s16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2026
return h; 
# 2027
} 
#endif
# 2029 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_rn(__half h) 
# 2030
{int volatile ___ = 1;(void)h;
# 2034
::exit(___);}
#if 0
# 2030
{ 
# 2031
unsigned i; 
# 2032
__asm__("cvt.rni.u32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 2033
return i; 
# 2034
} 
#endif
# 2035 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_rz(__half h) 
# 2036
{int volatile ___ = 1;(void)h;
# 2040
::exit(___);}
#if 0
# 2036
{ 
# 2037
unsigned i; 
# 2038
__asm__("cvt.rzi.u32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 2039
return i; 
# 2040
} 
#endif
# 2041 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_rd(__half h) 
# 2042
{int volatile ___ = 1;(void)h;
# 2046
::exit(___);}
#if 0
# 2042
{ 
# 2043
unsigned i; 
# 2044
__asm__("cvt.rmi.u32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 2045
return i; 
# 2046
} 
#endif
# 2047 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_ru(__half h) 
# 2048
{int volatile ___ = 1;(void)h;
# 2052
::exit(___);}
#if 0
# 2048
{ 
# 2049
unsigned i; 
# 2050
__asm__("cvt.rpi.u32.f16 %0, %1;" : "=r" (i) : "h" (h.x)); 
# 2051
return i; 
# 2052
} 
#endif
# 2053 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_rn(unsigned i) 
# 2054
{int volatile ___ = 1;(void)i;
# 2058
::exit(___);}
#if 0
# 2054
{ 
# 2055
__half h; 
# 2056
__asm__("cvt.rn.f16.u32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 2057
return h; 
# 2058
} 
#endif
# 2059 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_rz(unsigned i) 
# 2060
{int volatile ___ = 1;(void)i;
# 2064
::exit(___);}
#if 0
# 2060
{ 
# 2061
__half h; 
# 2062
__asm__("cvt.rz.f16.u32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 2063
return h; 
# 2064
} 
#endif
# 2065 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_rd(unsigned i) 
# 2066
{int volatile ___ = 1;(void)i;
# 2070
::exit(___);}
#if 0
# 2066
{ 
# 2067
__half h; 
# 2068
__asm__("cvt.rm.f16.u32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 2069
return h; 
# 2070
} 
#endif
# 2071 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_ru(unsigned i) 
# 2072
{int volatile ___ = 1;(void)i;
# 2076
::exit(___);}
#if 0
# 2072
{ 
# 2073
__half h; 
# 2074
__asm__("cvt.rp.f16.u32 %0, %1;" : "=h" (h.x) : "r" (i)); 
# 2075
return h; 
# 2076
} 
#endif
# 2078 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_rn(__half h) 
# 2079
{int volatile ___ = 1;(void)h;
# 2083
::exit(___);}
#if 0
# 2079
{ 
# 2080
unsigned short i; 
# 2081
__asm__("cvt.rni.u16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 2082
return i; 
# 2083
} 
#endif
# 2084 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_rz(__half h) 
# 2085
{int volatile ___ = 1;(void)h;
# 2089
::exit(___);}
#if 0
# 2085
{ 
# 2086
unsigned short i; 
# 2087
__asm__("cvt.rzi.u16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 2088
return i; 
# 2089
} 
#endif
# 2090 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_rd(__half h) 
# 2091
{int volatile ___ = 1;(void)h;
# 2095
::exit(___);}
#if 0
# 2091
{ 
# 2092
unsigned short i; 
# 2093
__asm__("cvt.rmi.u16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 2094
return i; 
# 2095
} 
#endif
# 2096 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_ru(__half h) 
# 2097
{int volatile ___ = 1;(void)h;
# 2101
::exit(___);}
#if 0
# 2097
{ 
# 2098
unsigned short i; 
# 2099
__asm__("cvt.rpi.u16.f16 %0, %1;" : "=h" (i) : "h" (h.x)); 
# 2100
return i; 
# 2101
} 
#endif
# 2102 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_rn(unsigned short i) 
# 2103
{int volatile ___ = 1;(void)i;
# 2107
::exit(___);}
#if 0
# 2103
{ 
# 2104
__half h; 
# 2105
__asm__("cvt.rn.f16.u16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2106
return h; 
# 2107
} 
#endif
# 2108 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_rz(unsigned short i) 
# 2109
{int volatile ___ = 1;(void)i;
# 2113
::exit(___);}
#if 0
# 2109
{ 
# 2110
__half h; 
# 2111
__asm__("cvt.rz.f16.u16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2112
return h; 
# 2113
} 
#endif
# 2114 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_rd(unsigned short i) 
# 2115
{int volatile ___ = 1;(void)i;
# 2119
::exit(___);}
#if 0
# 2115
{ 
# 2116
__half h; 
# 2117
__asm__("cvt.rm.f16.u16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2118
return h; 
# 2119
} 
#endif
# 2120 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_ru(unsigned short i) 
# 2121
{int volatile ___ = 1;(void)i;
# 2125
::exit(___);}
#if 0
# 2121
{ 
# 2122
__half h; 
# 2123
__asm__("cvt.rp.f16.u16 %0, %1;" : "=h" (h.x) : "h" (i)); 
# 2124
return h; 
# 2125
} 
#endif
# 2127 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_rn(__half h) 
# 2128
{int volatile ___ = 1;(void)h;
# 2132
::exit(___);}
#if 0
# 2128
{ 
# 2129
unsigned long long i; 
# 2130
__asm__("cvt.rni.u64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2131
return i; 
# 2132
} 
#endif
# 2133 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_rz(__half h) 
# 2134
{int volatile ___ = 1;(void)h;
# 2138
::exit(___);}
#if 0
# 2134
{ 
# 2135
unsigned long long i; 
# 2136
__asm__("cvt.rzi.u64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2137
return i; 
# 2138
} 
#endif
# 2139 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_rd(__half h) 
# 2140
{int volatile ___ = 1;(void)h;
# 2144
::exit(___);}
#if 0
# 2140
{ 
# 2141
unsigned long long i; 
# 2142
__asm__("cvt.rmi.u64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2143
return i; 
# 2144
} 
#endif
# 2145 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_ru(__half h) 
# 2146
{int volatile ___ = 1;(void)h;
# 2150
::exit(___);}
#if 0
# 2146
{ 
# 2147
unsigned long long i; 
# 2148
__asm__("cvt.rpi.u64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2149
return i; 
# 2150
} 
#endif
# 2151 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_rn(unsigned long long i) 
# 2152
{int volatile ___ = 1;(void)i;
# 2156
::exit(___);}
#if 0
# 2152
{ 
# 2153
__half h; 
# 2154
__asm__("cvt.rn.f16.u64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2155
return h; 
# 2156
} 
#endif
# 2157 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_rz(unsigned long long i) 
# 2158
{int volatile ___ = 1;(void)i;
# 2162
::exit(___);}
#if 0
# 2158
{ 
# 2159
__half h; 
# 2160
__asm__("cvt.rz.f16.u64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2161
return h; 
# 2162
} 
#endif
# 2163 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_rd(unsigned long long i) 
# 2164
{int volatile ___ = 1;(void)i;
# 2168
::exit(___);}
#if 0
# 2164
{ 
# 2165
__half h; 
# 2166
__asm__("cvt.rm.f16.u64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2167
return h; 
# 2168
} 
#endif
# 2169 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_ru(unsigned long long i) 
# 2170
{int volatile ___ = 1;(void)i;
# 2174
::exit(___);}
#if 0
# 2170
{ 
# 2171
__half h; 
# 2172
__asm__("cvt.rp.f16.u64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2173
return h; 
# 2174
} 
#endif
# 2176 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_rn(__half h) 
# 2177
{int volatile ___ = 1;(void)h;
# 2181
::exit(___);}
#if 0
# 2177
{ 
# 2178
long long i; 
# 2179
__asm__("cvt.rni.s64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2180
return i; 
# 2181
} 
#endif
# 2182 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_rz(__half h) 
# 2183
{int volatile ___ = 1;(void)h;
# 2187
::exit(___);}
#if 0
# 2183
{ 
# 2184
long long i; 
# 2185
__asm__("cvt.rzi.s64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2186
return i; 
# 2187
} 
#endif
# 2188 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_rd(__half h) 
# 2189
{int volatile ___ = 1;(void)h;
# 2193
::exit(___);}
#if 0
# 2189
{ 
# 2190
long long i; 
# 2191
__asm__("cvt.rmi.s64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2192
return i; 
# 2193
} 
#endif
# 2194 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_ru(__half h) 
# 2195
{int volatile ___ = 1;(void)h;
# 2199
::exit(___);}
#if 0
# 2195
{ 
# 2196
long long i; 
# 2197
__asm__("cvt.rpi.s64.f16 %0, %1;" : "=l" (i) : "h" (h.x)); 
# 2198
return i; 
# 2199
} 
#endif
# 2200 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_rn(long long i) 
# 2201
{int volatile ___ = 1;(void)i;
# 2205
::exit(___);}
#if 0
# 2201
{ 
# 2202
__half h; 
# 2203
__asm__("cvt.rn.f16.s64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2204
return h; 
# 2205
} 
#endif
# 2206 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_rz(long long i) 
# 2207
{int volatile ___ = 1;(void)i;
# 2211
::exit(___);}
#if 0
# 2207
{ 
# 2208
__half h; 
# 2209
__asm__("cvt.rz.f16.s64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2210
return h; 
# 2211
} 
#endif
# 2212 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_rd(long long i) 
# 2213
{int volatile ___ = 1;(void)i;
# 2217
::exit(___);}
#if 0
# 2213
{ 
# 2214
__half h; 
# 2215
__asm__("cvt.rm.f16.s64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2216
return h; 
# 2217
} 
#endif
# 2218 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_ru(long long i) 
# 2219
{int volatile ___ = 1;(void)i;
# 2223
::exit(___);}
#if 0
# 2219
{ 
# 2220
__half h; 
# 2221
__asm__("cvt.rp.f16.s64 %0, %1;" : "=h" (h.x) : "l" (i)); 
# 2222
return h; 
# 2223
} 
#endif
# 2225 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half htrunc(const __half h) 
# 2226
{int volatile ___ = 1;(void)h;
# 2230
::exit(___);}
#if 0
# 2226
{ 
# 2227
__half r; 
# 2228
__asm__("cvt.rzi.f16.f16 %0, %1;" : "=h" (r.x) : "h" (h.x)); 
# 2229
return r; 
# 2230
} 
#endif
# 2231 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hceil(const __half h) 
# 2232
{int volatile ___ = 1;(void)h;
# 2236
::exit(___);}
#if 0
# 2232
{ 
# 2233
__half r; 
# 2234
__asm__("cvt.rpi.f16.f16 %0, %1;" : "=h" (r.x) : "h" (h.x)); 
# 2235
return r; 
# 2236
} 
#endif
# 2237 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hfloor(const __half h) 
# 2238
{int volatile ___ = 1;(void)h;
# 2242
::exit(___);}
#if 0
# 2238
{ 
# 2239
__half r; 
# 2240
__asm__("cvt.rmi.f16.f16 %0, %1;" : "=h" (r.x) : "h" (h.x)); 
# 2241
return r; 
# 2242
} 
#endif
# 2243 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrint(const __half h) 
# 2244
{int volatile ___ = 1;(void)h;
# 2248
::exit(___);}
#if 0
# 2244
{ 
# 2245
__half r; 
# 2246
__asm__("cvt.rni.f16.f16 %0, %1;" : "=h" (r.x) : "h" (h.x)); 
# 2247
return r; 
# 2248
} 
#endif
# 2250 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2trunc(const __half2 h) 
# 2251
{int volatile ___ = 1;(void)h;
# 2259
::exit(___);}
#if 0
# 2251
{ 
# 2252
__half2 val; 
# 2253
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rzi.f16.f16 low, low;\n  cvt.rzi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (val.x) : "r" (h.x)); 
# 2258
return val; 
# 2259
} 
#endif
# 2260 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2ceil(const __half2 h) 
# 2261
{int volatile ___ = 1;(void)h;
# 2269
::exit(___);}
#if 0
# 2261
{ 
# 2262
__half2 val; 
# 2263
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rpi.f16.f16 low, low;\n  cvt.rpi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (val.x) : "r" (h.x)); 
# 2268
return val; 
# 2269
} 
#endif
# 2270 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2floor(const __half2 h) 
# 2271
{int volatile ___ = 1;(void)h;
# 2279
::exit(___);}
#if 0
# 2271
{ 
# 2272
__half2 val; 
# 2273
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rmi.f16.f16 low, low;\n  cvt.rmi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (val.x) : "r" (h.x)); 
# 2278
return val; 
# 2279
} 
#endif
# 2280 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rint(const __half2 h) 
# 2281
{int volatile ___ = 1;(void)h;
# 2289
::exit(___);}
#if 0
# 2281
{ 
# 2282
__half2 val; 
# 2283
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rni.f16.f16 low, low;\n  cvt.rni.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (val.x) : "r" (h.x)); 
# 2288
return val; 
# 2289
} 
#endif
# 2291 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline float2 __half22float2(const __half2 l) 
# 2292
{int volatile ___ = 1;(void)l;
# 2304
::exit(___);}
#if 0
# 2292
{ 
# 2293
float hi_float; 
# 2294
float lo_float; 
# 2295
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high},%1;\n  cvt.f32.f16 %0, low;}\n" : "=f" (lo_float) : "r" (l.x)); 
# 2299
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high},%1;\n  cvt.f32.f16 %0, high;}\n" : "=f" (hi_float) : "r" (l.x)); 
# 2303
return make_float2(lo_float, hi_float); 
# 2304
} 
#endif
# 2305 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __float2half(const float f) 
# 2306
{int volatile ___ = 1;(void)f;
# 2310
::exit(___);}
#if 0
# 2306
{ 
# 2307
__half val; 
# 2308
__asm__ volatile("{  cvt.rn.f16.f32 %0, %1;}\n" : "=h" (val.x) : "f" (f)); 
# 2309
return val; 
# 2310
} 
#endif
# 2311 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __float2half_rz(const float f) 
# 2312
{int volatile ___ = 1;(void)f;
# 2316
::exit(___);}
#if 0
# 2312
{ 
# 2313
__half val; 
# 2314
__asm__ volatile("{  cvt.rz.f16.f32 %0, %1;}\n" : "=h" (val.x) : "f" (f)); 
# 2315
return val; 
# 2316
} 
#endif
# 2317 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __float2half_rd(const float f) 
# 2318
{int volatile ___ = 1;(void)f;
# 2322
::exit(___);}
#if 0
# 2318
{ 
# 2319
__half val; 
# 2320
__asm__ volatile("{  cvt.rm.f16.f32 %0, %1;}\n" : "=h" (val.x) : "f" (f)); 
# 2321
return val; 
# 2322
} 
#endif
# 2323 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __float2half_ru(const float f) 
# 2324
{int volatile ___ = 1;(void)f;
# 2328
::exit(___);}
#if 0
# 2324
{ 
# 2325
__half val; 
# 2326
__asm__ volatile("{  cvt.rp.f16.f32 %0, %1;}\n" : "=h" (val.x) : "f" (f)); 
# 2327
return val; 
# 2328
} 
#endif
# 2329 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline float __half2float(const __half h) 
# 2330
{int volatile ___ = 1;(void)h;
# 2334
::exit(___);}
#if 0
# 2330
{ 
# 2331
float val; 
# 2332
__asm__ volatile("{  cvt.f32.f16 %0, %1;}\n" : "=f" (val) : "h" (h.x)); 
# 2333
return val; 
# 2334
} 
#endif
# 2335 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __float2half2_rn(const float f) 
# 2336
{int volatile ___ = 1;(void)f;
# 2342
::exit(___);}
#if 0
# 2336
{ 
# 2337
__half2 val; 
# 2338
__asm__("{.reg .f16 low;\n  cvt.rn.f16.f32 low, %1;\n  mov.b32 %0, {low,low};}\n" : "=r" (val.x) : "f" (f)); 
# 2341
return val; 
# 2342
} 
#endif
# 2343 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __floats2half2_rn(const float f1, const float f2) 
# 2344
{int volatile ___ = 1;(void)f1;(void)f2;
# 2351
::exit(___);}
#if 0
# 2344
{ 
# 2345
__half2 val; 
# 2346
__asm__("{.reg .f16 low,high;\n  cvt.rn.f16.f32 low, %1;\n  cvt.rn.f16.f32 high, %2;\n  mov.b32 %0, {low,high};}\n" : "=r" (val.x) : "f" (f1), "f" (f2)); 
# 2350
return val; 
# 2351
} 
#endif
# 2352 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __float22half2_rn(const float2 f) 
# 2353
{int volatile ___ = 1;(void)f;
# 2356
::exit(___);}
#if 0
# 2353
{ 
# 2354
__half2 val = __floats2half2_rn(f.x, f.y); 
# 2355
return val; 
# 2356
} 
#endif
# 2357 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline float __low2float(const __half2 l) 
# 2358
{int volatile ___ = 1;(void)l;
# 2364
::exit(___);}
#if 0
# 2358
{ 
# 2359
float val; 
# 2360
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high},%1;\n  cvt.f32.f16 %0, low;}\n" : "=f" (val) : "r" (l.x)); 
# 2363
return val; 
# 2364
} 
#endif
# 2365 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline float __high2float(const __half2 l) 
# 2366
{int volatile ___ = 1;(void)l;
# 2372
::exit(___);}
#if 0
# 2366
{ 
# 2367
float val; 
# 2368
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high},%1;\n  cvt.f32.f16 %0, high;}\n" : "=f" (val) : "r" (l.x)); 
# 2371
return val; 
# 2372
} 
#endif
# 2373 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __lows2half2(const __half2 l, const __half2 h) 
# 2374
{int volatile ___ = 1;(void)l;(void)h;
# 2381
::exit(___);}
#if 0
# 2374
{ 
# 2375
__half2 val; 
# 2376
__asm__("{.reg .f16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {alow,blow};}\n" : "=r" (val.x) : "r" (l.x), "r" (h.x)); 
# 2380
return val; 
# 2381
} 
#endif
# 2382 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __highs2half2(const __half2 l, const __half2 h) 
# 2383
{int volatile ___ = 1;(void)l;(void)h;
# 2390
::exit(___);}
#if 0
# 2383
{ 
# 2384
__half2 val; 
# 2385
__asm__("{.reg .f16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {ahigh,bhigh};}\n" : "=r" (val.x) : "r" (l.x), "r" (h.x)); 
# 2389
return val; 
# 2390
} 
#endif
# 2391 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __low2half(const __half2 h) 
# 2392
{int volatile ___ = 1;(void)h;
# 2398
::exit(___);}
#if 0
# 2392
{ 
# 2393
__half ret; 
# 2394
__asm__("{.reg .f16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, low;}" : "=h" (ret.x) : "r" (h.x)); 
# 2397
return ret; 
# 2398
} 
#endif
# 2399 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline int __hisinf(const __half a) 
# 2400
{int volatile ___ = 1;(void)a;
# 2406
::exit(___);}
#if 0
# 2400
{ 
# 2401
if ((a.x) == 64512) { 
# 2402
return -1; }  
# 2403
if ((a.x) == 31744) { 
# 2404
return 1; }  
# 2405
return 0; 
# 2406
} 
#endif
# 2407 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __low2half2(const __half2 l) 
# 2408
{int volatile ___ = 1;(void)l;
# 2414
::exit(___);}
#if 0
# 2408
{ 
# 2409
__half2 val; 
# 2410
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {low,low};}\n" : "=r" (val.x) : "r" (l.x)); 
# 2413
return val; 
# 2414
} 
#endif
# 2415 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __high2half2(const __half2 l) 
# 2416
{int volatile ___ = 1;(void)l;
# 2422
::exit(___);}
#if 0
# 2416
{ 
# 2417
__half2 val; 
# 2418
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,high};}\n" : "=r" (val.x) : "r" (l.x)); 
# 2421
return val; 
# 2422
} 
#endif
# 2423 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __high2half(const __half2 h) 
# 2424
{int volatile ___ = 1;(void)h;
# 2430
::exit(___);}
#if 0
# 2424
{ 
# 2425
__half ret; 
# 2426
__asm__("{.reg .f16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, high;}" : "=h" (ret.x) : "r" (h.x)); 
# 2429
return ret; 
# 2430
} 
#endif
# 2431 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __halves2half2(const __half l, const __half h) 
# 2432
{int volatile ___ = 1;(void)l;(void)h;
# 2437
::exit(___);}
#if 0
# 2432
{ 
# 2433
__half2 val; 
# 2434
__asm__("{  mov.b32 %0, {%1,%2};}\n" : "=r" (val.x) : "h" (l.x), "h" (h.x)); 
# 2436
return val; 
# 2437
} 
#endif
# 2438 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __half2half2(const __half lh) 
# 2439
{int volatile ___ = 1;(void)lh;
# 2444
::exit(___);}
#if 0
# 2439
{ 
# 2440
__half2 val; 
# 2441
__asm__("{  mov.b32 %0, {%1,%1};}\n" : "=r" (val.x) : "h" (lh.x)); 
# 2443
return val; 
# 2444
} 
#endif
# 2445 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __lowhigh2highlow(const __half2 lh) 
# 2446
{int volatile ___ = 1;(void)lh;
# 2452
::exit(___);}
#if 0
# 2446
{ 
# 2447
__half2 val; 
# 2448
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,low};}\n" : "=r" (val.x) : "r" (lh.x)); 
# 2451
return val; 
# 2452
} 
#endif
# 2453 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half_as_short(const __half h) 
# 2454
{int volatile ___ = 1;(void)h;
# 2456
::exit(___);}
#if 0
# 2454
{ 
# 2455
return (short)(h.x); 
# 2456
} 
#endif
# 2457 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half_as_ushort(const __half h) 
# 2458
{int volatile ___ = 1;(void)h;
# 2460
::exit(___);}
#if 0
# 2458
{ 
# 2459
return h.x; 
# 2460
} 
#endif
# 2461 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short_as_half(const short i) 
# 2462
{int volatile ___ = 1;(void)i;
# 2466
::exit(___);}
#if 0
# 2462
{ 
# 2463
__half h; 
# 2464
(h.x) = ((unsigned short)i); 
# 2465
return h; 
# 2466
} 
#endif
# 2467 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort_as_half(const unsigned short i) 
# 2468
{int volatile ___ = 1;(void)i;
# 2472
::exit(___);}
#if 0
# 2468
{ 
# 2469
__half h; 
# 2470
(h.x) = i; 
# 2471
return h; 
# 2472
} 
#endif
# 2484 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl(__half2 var, int delta, int width) 
# 2485
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2490
::exit(___);}
#if 0
# 2485
{ 
# 2486
int warpSize; 
# 2487
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warpSize) :); 
# 2488
int c = ((warpSize - width) << 8) | 31; 
# 2489
do { __half2 r; __asm__("{shfl.idx.b32 %0,%1,%2,%3;\n}" : "=r" (r.x) : "r" (var.x), "r" (delta), "r" (c)); return r; } while (0); ; 
# 2490
} 
#endif
# 2491 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_up(__half2 var, unsigned delta, int width) 
# 2492
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2497
::exit(___);}
#if 0
# 2492
{ 
# 2493
int warpSize; 
# 2494
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warpSize) :); 
# 2495
int c = (warpSize - width) << 8; 
# 2496
do { __half2 r; __asm__("{shfl.up.b32 %0,%1,%2,%3;\n}" : "=r" (r.x) : "r" (var.x), "r" (delta), "r" (c)); return r; } while (0); ; 
# 2497
} 
#endif
# 2498 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_down(__half2 var, unsigned delta, int width) 
# 2499
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2504
::exit(___);}
#if 0
# 2499
{ 
# 2500
int warpSize; 
# 2501
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warpSize) :); 
# 2502
int c = ((warpSize - width) << 8) | 31; 
# 2503
do { __half2 r; __asm__("{shfl.down.b32 %0,%1,%2,%3;\n}" : "=r" (r.x) : "r" (var.x), "r" (delta), "r" (c)); return r; } while (0); ; 
# 2504
} 
#endif
# 2505 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_xor(__half2 var, int delta, int width) 
# 2506
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2511
::exit(___);}
#if 0
# 2506
{ 
# 2507
int warpSize; 
# 2508
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warpSize) :); 
# 2509
int c = ((warpSize - width) << 8) | 31; 
# 2510
do { __half2 r; __asm__("{shfl.bfly.b32 %0,%1,%2,%3;\n}" : "=r" (r.x) : "r" (var.x), "r" (delta), "r" (c)); return r; } while (0); ; 
# 2511
} 
#endif
# 2513 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl(__half var, int delta, int width) 
# 2514
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2518
::exit(___);}
#if 0
# 2514
{ 
# 2515
__half2 temp1 = __halves2half2(var, var); 
# 2516
__half2 temp2 = __shfl(temp1, delta, width); 
# 2517
return __low2half(temp2); 
# 2518
} 
#endif
# 2519 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_up(__half var, unsigned delta, int width) 
# 2520
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2524
::exit(___);}
#if 0
# 2520
{ 
# 2521
__half2 temp1 = __halves2half2(var, var); 
# 2522
__half2 temp2 = __shfl_up(temp1, delta, width); 
# 2523
return __low2half(temp2); 
# 2524
} 
#endif
# 2525 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_down(__half var, unsigned delta, int width) 
# 2526
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2530
::exit(___);}
#if 0
# 2526
{ 
# 2527
__half2 temp1 = __halves2half2(var, var); 
# 2528
__half2 temp2 = __shfl_down(temp1, delta, width); 
# 2529
return __low2half(temp2); 
# 2530
} 
#endif
# 2531 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_xor(__half var, int delta, int width) 
# 2532
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 2536
::exit(___);}
#if 0
# 2532
{ 
# 2533
__half2 temp1 = __halves2half2(var, var); 
# 2534
__half2 temp2 = __shfl_xor(temp1, delta, width); 
# 2535
return __low2half(temp2); 
# 2536
} 
#endif
# 2548 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __ldg(const __half2 *ptr) 
# 2549
{int volatile ___ = 1;(void)ptr;
# 2553
::exit(___);}
#if 0
# 2549
{ 
# 2550
__half2 ret; 
# 2551
__asm__ volatile("ld.global.nc.b32 %0, [%1];" : "=r" (ret.x) : "l" (ptr)); 
# 2552
return ret; 
# 2553
} 
#endif
# 2554 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ldg(const __half *ptr) 
# 2555
{int volatile ___ = 1;(void)ptr;
# 2559
::exit(___);}
#if 0
# 2555
{ 
# 2556
__half ret; 
# 2557
__asm__ volatile("ld.global.nc.b16 %0, [%1];" : "=h" (ret.x) : "l" (ptr)); 
# 2558
return ret; 
# 2559
} 
#endif
# 2560 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __ldcg(const __half2 *ptr) 
# 2561
{int volatile ___ = 1;(void)ptr;
# 2565
::exit(___);}
#if 0
# 2561
{ 
# 2562
__half2 ret; 
# 2563
__asm__ volatile("ld.global.cg.b32 %0, [%1];" : "=r" (ret.x) : "l" (ptr)); 
# 2564
return ret; 
# 2565
} 
#endif
# 2566 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ldcg(const __half *ptr) 
# 2567
{int volatile ___ = 1;(void)ptr;
# 2571
::exit(___);}
#if 0
# 2567
{ 
# 2568
__half ret; 
# 2569
__asm__ volatile("ld.global.cg.b16 %0, [%1];" : "=h" (ret.x) : "l" (ptr)); 
# 2570
return ret; 
# 2571
} 
#endif
# 2572 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __ldca(const __half2 *ptr) 
# 2573
{int volatile ___ = 1;(void)ptr;
# 2577
::exit(___);}
#if 0
# 2573
{ 
# 2574
__half2 ret; 
# 2575
__asm__ volatile("ld.global.ca.b32 %0, [%1];" : "=r" (ret.x) : "l" (ptr)); 
# 2576
return ret; 
# 2577
} 
#endif
# 2578 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ldca(const __half *ptr) 
# 2579
{int volatile ___ = 1;(void)ptr;
# 2583
::exit(___);}
#if 0
# 2579
{ 
# 2580
__half ret; 
# 2581
__asm__ volatile("ld.global.ca.b16 %0, [%1];" : "=h" (ret.x) : "l" (ptr)); 
# 2582
return ret; 
# 2583
} 
#endif
# 2584 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __ldcs(const __half2 *ptr) 
# 2585
{int volatile ___ = 1;(void)ptr;
# 2589
::exit(___);}
#if 0
# 2585
{ 
# 2586
__half2 ret; 
# 2587
__asm__ volatile("ld.global.cs.b32 %0, [%1];" : "=r" (ret.x) : "l" (ptr)); 
# 2588
return ret; 
# 2589
} 
#endif
# 2590 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ldcs(const __half *ptr) 
# 2591
{int volatile ___ = 1;(void)ptr;
# 2595
::exit(___);}
#if 0
# 2591
{ 
# 2592
__half ret; 
# 2593
__asm__ volatile("ld.global.cs.b16 %0, [%1];" : "=h" (ret.x) : "l" (ptr)); 
# 2594
return ret; 
# 2595
} 
#endif
# 2608 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __heq2(const __half2 a, const __half2 b) 
# 2609
{int volatile ___ = 1;(void)a;(void)b;
# 2611
::exit(___);}
#if 0
# 2609
{ 
# 2610
do { __half2 val; __asm__("{ set.eq.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2611
} 
#endif
# 2612 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hne2(const __half2 a, const __half2 b) 
# 2613
{int volatile ___ = 1;(void)a;(void)b;
# 2615
::exit(___);}
#if 0
# 2613
{ 
# 2614
do { __half2 val; __asm__("{ set.ne.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2615
} 
#endif
# 2616 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hle2(const __half2 a, const __half2 b) 
# 2617
{int volatile ___ = 1;(void)a;(void)b;
# 2619
::exit(___);}
#if 0
# 2617
{ 
# 2618
do { __half2 val; __asm__("{ set.le.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2619
} 
#endif
# 2620 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hge2(const __half2 a, const __half2 b) 
# 2621
{int volatile ___ = 1;(void)a;(void)b;
# 2623
::exit(___);}
#if 0
# 2621
{ 
# 2622
do { __half2 val; __asm__("{ set.ge.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2623
} 
#endif
# 2624 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hlt2(const __half2 a, const __half2 b) 
# 2625
{int volatile ___ = 1;(void)a;(void)b;
# 2627
::exit(___);}
#if 0
# 2625
{ 
# 2626
do { __half2 val; __asm__("{ set.lt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2627
} 
#endif
# 2628 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgt2(const __half2 a, const __half2 b) 
# 2629
{int volatile ___ = 1;(void)a;(void)b;
# 2631
::exit(___);}
#if 0
# 2629
{ 
# 2630
do { __half2 val; __asm__("{ set.gt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2631
} 
#endif
# 2632 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hequ2(const __half2 a, const __half2 b) 
# 2633
{int volatile ___ = 1;(void)a;(void)b;
# 2635
::exit(___);}
#if 0
# 2633
{ 
# 2634
do { __half2 val; __asm__("{ set.equ.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2635
} 
#endif
# 2636 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hneu2(const __half2 a, const __half2 b) 
# 2637
{int volatile ___ = 1;(void)a;(void)b;
# 2639
::exit(___);}
#if 0
# 2637
{ 
# 2638
do { __half2 val; __asm__("{ set.neu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2639
} 
#endif
# 2640 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hleu2(const __half2 a, const __half2 b) 
# 2641
{int volatile ___ = 1;(void)a;(void)b;
# 2643
::exit(___);}
#if 0
# 2641
{ 
# 2642
do { __half2 val; __asm__("{ set.leu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2643
} 
#endif
# 2644 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgeu2(const __half2 a, const __half2 b) 
# 2645
{int volatile ___ = 1;(void)a;(void)b;
# 2647
::exit(___);}
#if 0
# 2645
{ 
# 2646
do { __half2 val; __asm__("{ set.geu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2647
} 
#endif
# 2648 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hltu2(const __half2 a, const __half2 b) 
# 2649
{int volatile ___ = 1;(void)a;(void)b;
# 2651
::exit(___);}
#if 0
# 2649
{ 
# 2650
do { __half2 val; __asm__("{ set.ltu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2651
} 
#endif
# 2652 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgtu2(const __half2 a, const __half2 b) 
# 2653
{int volatile ___ = 1;(void)a;(void)b;
# 2655
::exit(___);}
#if 0
# 2653
{ 
# 2654
do { __half2 val; __asm__("{ set.gtu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2655
} 
#endif
# 2666 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbeq2(const __half2 a, const __half2 b) 
# 2667
{int volatile ___ = 1;(void)a;(void)b;
# 2669
::exit(___);}
#if 0
# 2667
{ 
# 2668
do { __half2 val; __asm__("{ set.eq.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2669
} 
#endif
# 2670 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbne2(const __half2 a, const __half2 b) 
# 2671
{int volatile ___ = 1;(void)a;(void)b;
# 2673
::exit(___);}
#if 0
# 2671
{ 
# 2672
do { __half2 val; __asm__("{ set.ne.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2673
} 
#endif
# 2674 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hble2(const __half2 a, const __half2 b) 
# 2675
{int volatile ___ = 1;(void)a;(void)b;
# 2677
::exit(___);}
#if 0
# 2675
{ 
# 2676
do { __half2 val; __asm__("{ set.le.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2677
} 
#endif
# 2678 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbge2(const __half2 a, const __half2 b) 
# 2679
{int volatile ___ = 1;(void)a;(void)b;
# 2681
::exit(___);}
#if 0
# 2679
{ 
# 2680
do { __half2 val; __asm__("{ set.ge.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2681
} 
#endif
# 2682 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hblt2(const __half2 a, const __half2 b) 
# 2683
{int volatile ___ = 1;(void)a;(void)b;
# 2685
::exit(___);}
#if 0
# 2683
{ 
# 2684
do { __half2 val; __asm__("{ set.lt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2685
} 
#endif
# 2686 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgt2(const __half2 a, const __half2 b) 
# 2687
{int volatile ___ = 1;(void)a;(void)b;
# 2689
::exit(___);}
#if 0
# 2687
{ 
# 2688
do { __half2 val; __asm__("{ set.gt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2689
} 
#endif
# 2690 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbequ2(const __half2 a, const __half2 b) 
# 2691
{int volatile ___ = 1;(void)a;(void)b;
# 2693
::exit(___);}
#if 0
# 2691
{ 
# 2692
do { __half2 val; __asm__("{ set.equ.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2693
} 
#endif
# 2694 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbneu2(const __half2 a, const __half2 b) 
# 2695
{int volatile ___ = 1;(void)a;(void)b;
# 2697
::exit(___);}
#if 0
# 2695
{ 
# 2696
do { __half2 val; __asm__("{ set.neu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2697
} 
#endif
# 2698 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbleu2(const __half2 a, const __half2 b) 
# 2699
{int volatile ___ = 1;(void)a;(void)b;
# 2701
::exit(___);}
#if 0
# 2699
{ 
# 2700
do { __half2 val; __asm__("{ set.leu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2701
} 
#endif
# 2702 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgeu2(const __half2 a, const __half2 b) 
# 2703
{int volatile ___ = 1;(void)a;(void)b;
# 2705
::exit(___);}
#if 0
# 2703
{ 
# 2704
do { __half2 val; __asm__("{ set.geu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2705
} 
#endif
# 2706 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbltu2(const __half2 a, const __half2 b) 
# 2707
{int volatile ___ = 1;(void)a;(void)b;
# 2709
::exit(___);}
#if 0
# 2707
{ 
# 2708
do { __half2 val; __asm__("{ set.ltu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2709
} 
#endif
# 2710 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgtu2(const __half2 a, const __half2 b) 
# 2711
{int volatile ___ = 1;(void)a;(void)b;
# 2713
::exit(___);}
#if 0
# 2711
{ 
# 2712
do { __half2 val; __asm__("{ set.gtu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); if ((val.x) == (1006648320)) { return true; } else { return false; }  } while (0); ; 
# 2713
} 
#endif
# 2726 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __heq(const __half a, const __half b) 
# 2727
{int volatile ___ = 1;(void)a;(void)b;
# 2729
::exit(___);}
#if 0
# 2727
{ 
# 2728
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.eq.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2729
} 
#endif
# 2730 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hne(const __half a, const __half b) 
# 2731
{int volatile ___ = 1;(void)a;(void)b;
# 2733
::exit(___);}
#if 0
# 2731
{ 
# 2732
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ne.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2733
} 
#endif
# 2734 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hle(const __half a, const __half b) 
# 2735
{int volatile ___ = 1;(void)a;(void)b;
# 2737
::exit(___);}
#if 0
# 2735
{ 
# 2736
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.le.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2737
} 
#endif
# 2738 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hge(const __half a, const __half b) 
# 2739
{int volatile ___ = 1;(void)a;(void)b;
# 2741
::exit(___);}
#if 0
# 2739
{ 
# 2740
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ge.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2741
} 
#endif
# 2742 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hlt(const __half a, const __half b) 
# 2743
{int volatile ___ = 1;(void)a;(void)b;
# 2745
::exit(___);}
#if 0
# 2743
{ 
# 2744
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.lt.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2745
} 
#endif
# 2746 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgt(const __half a, const __half b) 
# 2747
{int volatile ___ = 1;(void)a;(void)b;
# 2749
::exit(___);}
#if 0
# 2747
{ 
# 2748
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.gt.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2749
} 
#endif
# 2750 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hequ(const __half a, const __half b) 
# 2751
{int volatile ___ = 1;(void)a;(void)b;
# 2753
::exit(___);}
#if 0
# 2751
{ 
# 2752
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.equ.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2753
} 
#endif
# 2754 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hneu(const __half a, const __half b) 
# 2755
{int volatile ___ = 1;(void)a;(void)b;
# 2757
::exit(___);}
#if 0
# 2755
{ 
# 2756
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.neu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2757
} 
#endif
# 2758 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hleu(const __half a, const __half b) 
# 2759
{int volatile ___ = 1;(void)a;(void)b;
# 2761
::exit(___);}
#if 0
# 2759
{ 
# 2760
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.leu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2761
} 
#endif
# 2762 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgeu(const __half a, const __half b) 
# 2763
{int volatile ___ = 1;(void)a;(void)b;
# 2765
::exit(___);}
#if 0
# 2763
{ 
# 2764
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.geu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2765
} 
#endif
# 2766 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hltu(const __half a, const __half b) 
# 2767
{int volatile ___ = 1;(void)a;(void)b;
# 2769
::exit(___);}
#if 0
# 2767
{ 
# 2768
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ltu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2769
} 
#endif
# 2770 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgtu(const __half a, const __half b) 
# 2771
{int volatile ___ = 1;(void)a;(void)b;
# 2773
::exit(___);}
#if 0
# 2771
{ 
# 2772
do { unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.gtu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (a.x), "h" (b.x)); return (val) ? true : false; } while (0); ; 
# 2773
} 
#endif
# 2784 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hadd2(const __half2 a, const __half2 b) 
# 2785
{int volatile ___ = 1;(void)a;(void)b;
# 2787
::exit(___);}
#if 0
# 2785
{ 
# 2786
do { __half2 val; __asm__("{add.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2787
} 
#endif
# 2788 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hsub2(const __half2 a, const __half2 b) 
# 2789
{int volatile ___ = 1;(void)a;(void)b;
# 2791
::exit(___);}
#if 0
# 2789
{ 
# 2790
do { __half2 val; __asm__("{sub.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2791
} 
#endif
# 2792 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmul2(const __half2 a, const __half2 b) 
# 2793
{int volatile ___ = 1;(void)a;(void)b;
# 2795
::exit(___);}
#if 0
# 2793
{ 
# 2794
do { __half2 val; __asm__("{mul.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2795
} 
#endif
# 2796 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hadd2_sat(const __half2 a, const __half2 b) 
# 2797
{int volatile ___ = 1;(void)a;(void)b;
# 2799
::exit(___);}
#if 0
# 2797
{ 
# 2798
do { __half2 val; __asm__("{add.sat.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2799
} 
#endif
# 2800 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hsub2_sat(const __half2 a, const __half2 b) 
# 2801
{int volatile ___ = 1;(void)a;(void)b;
# 2803
::exit(___);}
#if 0
# 2801
{ 
# 2802
do { __half2 val; __asm__("{sub.sat.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2803
} 
#endif
# 2804 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmul2_sat(const __half2 a, const __half2 b) 
# 2805
{int volatile ___ = 1;(void)a;(void)b;
# 2807
::exit(___);}
#if 0
# 2805
{ 
# 2806
do { __half2 val; __asm__("{mul.sat.f16x2 %0,%1,%2;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x)); return val; } while (0); ; 
# 2807
} 
#endif
# 2815 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c) 
# 2816
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2818
::exit(___);}
#if 0
# 2816
{ 
# 2817
do { __half2 val; __asm__("{fma.rn.f16x2 %0,%1,%2,%3;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x), "r" (c.x)); return val; } while (0); ; 
# 2818
} 
#endif
# 2819 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c) 
# 2820
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2822
::exit(___);}
#if 0
# 2820
{ 
# 2821
do { __half2 val; __asm__("{fma.rn.sat.f16x2 %0,%1,%2,%3;\n}" : "=r" (val.x) : "r" (a.x), "r" (b.x), "r" (c.x)); return val; } while (0); ; 
# 2822
} 
#endif
# 2824 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2div(__half2 a, __half2 b) {int volatile ___ = 1;(void)a;(void)b;
# 2838
::exit(___);}
#if 0
# 2824
{ 
# 2825
__half ha, hb; 
# 2827
ha = __low2half(a); 
# 2828
hb = __low2half(b); 
# 2830
__half v1 = hdiv(ha, hb); 
# 2832
ha = __high2half(a); 
# 2833
hb = __high2half(b); 
# 2835
__half v2 = hdiv(ha, hb); 
# 2837
return __halves2half2(v1, v2); 
# 2838
} 
#endif
# 2848 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hadd(const __half a, const __half b) 
# 2849
{int volatile ___ = 1;(void)a;(void)b;
# 2851
::exit(___);}
#if 0
# 2849
{ 
# 2850
do { __half val; __asm__("{add.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2851
} 
#endif
# 2852 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hsub(const __half a, const __half b) 
# 2853
{int volatile ___ = 1;(void)a;(void)b;
# 2855
::exit(___);}
#if 0
# 2853
{ 
# 2854
do { __half val; __asm__("{sub.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2855
} 
#endif
# 2856 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmul(const __half a, const __half b) 
# 2857
{int volatile ___ = 1;(void)a;(void)b;
# 2859
::exit(___);}
#if 0
# 2857
{ 
# 2858
do { __half val; __asm__("{mul.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2859
} 
#endif
# 2860 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hadd_sat(const __half a, const __half b) 
# 2861
{int volatile ___ = 1;(void)a;(void)b;
# 2863
::exit(___);}
#if 0
# 2861
{ 
# 2862
do { __half val; __asm__("{add.sat.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2863
} 
#endif
# 2864 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hsub_sat(const __half a, const __half b) 
# 2865
{int volatile ___ = 1;(void)a;(void)b;
# 2867
::exit(___);}
#if 0
# 2865
{ 
# 2866
do { __half val; __asm__("{sub.sat.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2867
} 
#endif
# 2868 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmul_sat(const __half a, const __half b) 
# 2869
{int volatile ___ = 1;(void)a;(void)b;
# 2871
::exit(___);}
#if 0
# 2869
{ 
# 2870
do { __half val; __asm__("{mul.sat.f16 %0,%1,%2;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x)); return val; } while (0); ; 
# 2871
} 
#endif
# 2879 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hfma(const __half a, const __half b, const __half c) 
# 2880
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2882
::exit(___);}
#if 0
# 2880
{ 
# 2881
do { __half val; __asm__("{fma.rn.f16 %0,%1,%2,%3;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x), "h" (c.x)); return val; } while (0); ; 
# 2882
} 
#endif
# 2883 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hfma_sat(const __half a, const __half b, const __half c) 
# 2884
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2886
::exit(___);}
#if 0
# 2884
{ 
# 2885
do { __half val; __asm__("{fma.rn.sat.f16 %0,%1,%2,%3;\n}" : "=h" (val.x) : "h" (a.x), "h" (b.x), "h" (c.x)); return val; } while (0); ; 
# 2886
} 
#endif
# 2888 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hdiv(__half a, __half b) {int volatile ___ = 1;(void)a;(void)b;
# 2908
::exit(___);}
#if 0
# 2888
{ 
# 2889
__half v, abs, den; 
# 2890
(den.x) = (143); 
# 2891
float fa, fb, fv, rcp; 
# 2893
fa = __half2float(a); 
# 2894
fb = __half2float(b); 
# 2896
__asm__ volatile("{rcp.approx.f32 %0, %1;\n}" : "=f" (rcp) : "f" (fb)); 
# 2898
fv = (rcp * fa); 
# 2900
v = __float2half(fv); 
# 2901
(abs.x) = ((unsigned short)(((unsigned)(v.x)) & (32767))); 
# 2902
if (__hlt(abs, den) && (!((abs.x) == 0))) { 
# 2903
float err = __fmaf_rn(-fb, fv, fa); 
# 2904
fv = __fmaf_rn(rcp, err, fv); 
# 2905
v = __float2half(fv); 
# 2906
}  
# 2907
return v; 
# 2908
} 
#endif
# 2952 "/usr/local/cuda/include/cuda_fp16.h"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_sinf(float); 
# 2953
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_cosf(float); 
# 2954
__attribute__((unused)) static inline __half __hsin_internal(const __half a) {int volatile ___ = 1;(void)a;
# 2960
::exit(___);}
#if 0
# 2954
{ 
# 2955
__half val; 
# 2956
float f = __half2float(a); 
# 2957
f = __float_simpl_sinf(f); 
# 2958
(val.x) = __float2half_rn(f); 
# 2959
return val; 
# 2960
} 
#endif
# 2961 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hsin(const __half a) {int volatile ___ = 1;(void)a;
# 2977
::exit(___);}
#if 0
# 2961
{ 
# 2962
__half r = __hsin_internal(a); 
# 2963
__asm__ volatile("{\n\t  .reg.b16 i,r,t;     \n\t  mov.b16 r, %0;      \n\t  mov.b16 i, %1;      \n\t  mov.b16 t, 0x8000;  \n\t  and.b16 t,r,t;   " "   \n\t{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X32B3;\n  mov.b16 ulp,0x0800;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;" "\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X5CB0;\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n" "}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XB2B3;\n  mov.b16 ulp,0x8800;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n" "{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XDCB0;\n  mov.b16 ulp,0x9000;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  " "or.b16  r,r,t;      \n\t  mov.b16 %0, r;      \n}\n" : "+h" (r.x) : "h" (a.x)); 
# 2976
return r; 
# 2977
} 
#endif
# 2978 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2sin(const __half2 a) {int volatile ___ = 1;(void)a;
# 2995
::exit(___);}
#if 0
# 2978
{ 
# 2979
__half l = __low2half(a); 
# 2980
__half h = __high2half(a); 
# 2981
__half2 r = __halves2half2(__hsin_internal(l), __hsin_internal(h)); 
# 2982
__asm__ volatile("{\n\t  .reg.b32 i,r,t;             \n\t  mov.b32 r, %0;              \n\t  mov.b32 i, %1;              \n\t  and.b32 t, r, 0x800" "08000;   \n\t{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X32B332B3;\n  mov.b32 ulp,0x08000800;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma" ".rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X5CB05CB0;\n  mov.b32 ulp,0x10001000;\n  set.eq.f16x2.f16x2 p,i," " spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XB2B3B2B3;\n  mov.b32 ulp,0x88008800;\n  set.eq.f16x" "2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XDCB0DCB0;\n  mov.b32 ulp,0x90009000;\n " " set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  or.b32  r, r, t;            \n\t  mov.b32 %0, r;              \n}" "\n" : "+r" (r.x) : "r" (a.x)); 
# 2994
return r; 
# 2995
} 
#endif
# 2996 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hcos_internal(const __half a) {int volatile ___ = 1;(void)a;
# 3002
::exit(___);}
#if 0
# 2996
{ 
# 2997
__half val; 
# 2998
float f = __half2float(a); 
# 2999
f = __float_simpl_cosf(f); 
# 3000
(val.x) = __float2half_rn(f); 
# 3001
return val; 
# 3002
} 
#endif
# 3003 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hcos(const __half a) {int volatile ___ = 1;(void)a;
# 3014
::exit(___);}
#if 0
# 3003
{ 
# 3004
__half r = __hcos_internal(a); 
# 3005
__asm__ volatile("{\n\t  .reg.b16 i,r;        \n\t  mov.b16 r, %0;       \n\t  mov.b16 i, %1;       \n\t{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X2B" "7C;\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XAB7C" ";\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16 %0, r;       \n}\n" : "+h" (r.x) : "h" (a.x)); 
# 3013
return r; 
# 3014
} 
#endif
# 3015 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2cos(const __half2 a) {int volatile ___ = 1;(void)a;
# 3028
::exit(___);}
#if 0
# 3015
{ 
# 3016
__half l = __low2half(a); 
# 3017
__half h = __high2half(a); 
# 3018
__half2 r = __halves2half2(__hcos_internal(l), __hcos_internal(h)); 
# 3019
__asm__ volatile("{\n\t  .reg.b32 i,r;   \n\t  mov.b32 r, %0;  \n\t  mov.b32 i, %1;  \n\t{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X2B7C2B7C;\n  mov." "b32 ulp,0x10001000;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XAB7CA" "B7C;\n  mov.b32 ulp,0x10001000;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32 %0, r;  \n}\n" : "+r" (r.x) : "r" (a.x)); 
# 3027
return r; 
# 3028
} 
#endif
# 3029 "/usr/local/cuda/include/cuda_fp16.h"
__attribute((always_inline)) __attribute__((unused)) static inline float __internal_trig_reduction_kernel(float a, int *quadrant) 
# 3030
{int volatile ___ = 1;(void)a;(void)quadrant;
# 3039
::exit(___);}
#if 0
# 3030
{ 
# 3031
float j, t; 
# 3032
int q; 
# 3033
q = __float2int_rn(a * (0.6366197467F)); 
# 3034
j = ((float)q); 
# 3035
t = __fmaf_rn(-j, (1.570796251F), a); 
# 3036
t = __fmaf_rn(-j, (7.549789416e-08F), t); 
# 3037
(*quadrant) = q; 
# 3038
return t; 
# 3039
} 
#endif
# 3040 "/usr/local/cuda/include/cuda_fp16.h"
__attribute((always_inline)) __attribute__((unused)) static inline float __internal_sin_cos_kernel(float x, int i) 
# 3041
{int volatile ___ = 1;(void)x;(void)i;
# 3063
::exit(___);}
#if 0
# 3041
{ 
# 3042
float x2, z; 
# 3043
x2 = (x * x); 
# 3045
if (i & 1) { 
# 3046
z = (2.44331568e-05F); 
# 3047
z = __fmaf_rn(z, x2, -(0.001388731645F)); 
# 3048
} else { 
# 3049
z = (-(0.0001951529557F)); 
# 3050
z = __fmaf_rn(z, x2, (0.008332161233F)); 
# 3051
}  
# 3052
if (i & 1) { 
# 3053
z = __fmaf_rn(z, x2, (0.04166664556F)); 
# 3054
z = __fmaf_rn(z, x2, -(0.5F)); 
# 3055
} else { 
# 3056
z = __fmaf_rn(z, x2, -(0.1666665524F)); 
# 3057
z = __fmaf_rn(z, x2, (0.0F)); 
# 3058
}  
# 3059
x = __fmaf_rn(z, x, x); 
# 3060
if (i & 1) { x = __fmaf_rn(z, x2, (1.0F)); }  
# 3061
if (i & 2) { x = __fmaf_rn(x, -(1.0F), (0.0F)); }  
# 3062
return x; 
# 3063
} 
#endif
# 3064 "/usr/local/cuda/include/cuda_fp16.h"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_sinf(float a) 
# 3065
{int volatile ___ = 1;(void)a;
# 3074
::exit(___);}
#if 0
# 3065
{ 
# 3066
float z; 
# 3067
int i; 
# 3068
if (isinf(a)) { 
# 3069
a = (a * (0.0F)); 
# 3070
}  
# 3071
a = __internal_trig_reduction_kernel(a, &i); 
# 3072
z = __internal_sin_cos_kernel(a, i); 
# 3073
return z; 
# 3074
} 
#endif
# 3075 "/usr/local/cuda/include/cuda_fp16.h"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_cosf(float a) 
# 3076
{int volatile ___ = 1;(void)a;
# 3086
::exit(___);}
#if 0
# 3076
{ 
# 3077
float z; 
# 3078
int i; 
# 3079
if (isinf(a)) { 
# 3080
a = (a * (0.0F)); 
# 3081
}  
# 3082
a = __internal_trig_reduction_kernel(a, &i); 
# 3083
i++; 
# 3084
z = __internal_sin_cos_kernel(a, i); 
# 3085
return z; 
# 3086
} 
#endif
# 3087 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp(const __half a) {int volatile ___ = 1;(void)a;
# 3104
::exit(___);}
#if 0
# 3087
{ 
# 3088
__half val; 
# 3089
__asm__ volatile("{.reg.b32         f, C;           \n .reg.b16         h,r;            \n  mov.b16         h,%1;           \n  cvt.f32.f16     f," "h;            \n  mov.b32         C, 0x3fb8aa3b;  \n  mul.f32         f,f,C;          \n  ex2.approx.f32      f,f;        \n  cv" "t.rn.f16.f32      r,f;        \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X1F79;\n  mov.b16 ulp,0x9400;\n  set.eq.f16.f16 p,h, spc;" "\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X25CF;\n  mov.b16 ulp,0x9400;\n  set.eq.f16.f16 p,h, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XC13B;\n  mov.b16 ulp,0x0400;\n  set.eq.f16.f16 p,h, spc;\n  " "fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XC1EF;\n  mov.b16 ulp,0x0200;\n  set.eq.f16.f16 p,h, spc;\n  fm" "a.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0,r;           \n}" : "=h" (val.x) : "h" (a.x)); 
# 3103
return val; 
# 3104
} 
#endif
# 3105 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp(const __half2 a) {int volatile ___ = 1;(void)a;
# 3128
::exit(___);}
#if 0
# 3105
{ 
# 3106
__half2 val; 
# 3107
__asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu, C;   \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         h," " %1;          \n  cvt.f32.f16     fl, hl;         \n  cvt.f32.f16     fu, hu;         \n  mov.b32         C, 0x3fb8aa3b;  \n  mu" "l.f32         fl,fl,C;        \n  mul.f32         fu,fu,C;        \n  ex2.approx.f32      fl, fl;     \n  ex2.approx.f32      fu" ", fu;     \n  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         r, {hl, hu};    \n{.reg.b3" "2 spc, ulp, p;\n  mov.b32 spc,0X1F791F79;\n  mov.b32 ulp,0x94009400;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n" "}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X25CF25CF;\n  mov.b32 ulp,0x94009400;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 " "r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XC13BC13B;\n  mov.b32 ulp,0x04000400;\n  set.eq.f16x2.f16x2 p,h, spc;\n  f" "ma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XC1EFC1EF;\n  mov.b32 ulp,0x02000200;\n  set.eq.f16x2.f16x2 p," "h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;  \n}" : "=r" (val.x) : "r" (a.x)); 
# 3127
return val; 
# 3128
} 
#endif
# 3129 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp2(const __half a) {int volatile ___ = 1;(void)a;
# 3142
::exit(___);}
#if 0
# 3129
{ 
# 3130
__half val; 
# 3131
__asm__ volatile("{.reg.b32         f, ULP;         \n .reg.b16         r;              \n  mov.b16         r,%1;           \n  cvt.f32.f16     f," "r;            \n  ex2.approx.f32      f,f;        \n  mov.b32         ULP, 0x33800000;\n  fma.rn.f32      f,f,ULP,f;      \n  cv" "t.rn.f16.f32      r,f;        \n  mov.b16         %0,r;           \n}" : "=h" (val.x) : "h" (a.x)); 
# 3141
return val; 
# 3142
} 
#endif
# 3143 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp2(const __half2 a) {int volatile ___ = 1;(void)a;
# 3160
::exit(___);}
#if 0
# 3143
{ 
# 3144
__half2 val; 
# 3145
__asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu, ULP;    \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  ex2.approx.f32      fl, fl;     \n  ex2.approx.f32      fu, fu;     \n  mo" "v.b32         ULP, 0x33800000;\n  fma.rn.f32      fl,fl,ULP,fl;   \n  fma.rn.f32      fu,fu,ULP,fu;   \n  cvt.rn.f16.f32      hl" ", fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (val.x) : "r" (a.x)); 
# 3159
return val; 
# 3160
} 
#endif
# 3161 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp10(const __half a) {int volatile ___ = 1;(void)a;
# 3179
::exit(___);}
#if 0
# 3161
{ 
# 3162
__half val; 
# 3163
__asm__ volatile("{.reg.b16         h,r;            \n .reg.b32         f, C;           \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  mov.b32         C, 0x40549A78;  \n  mul.f32         f,f,C;          \n  ex2.approx.f32      f, f;       \n  cv" "t.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x34DE;\n  mov.b16 ulp,0x9800;\n  set.eq.f16.f16 p,h, spc;" "\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x9766;\n  mov.b16 ulp,0x9000;\n  set.eq.f16.f16 p,h, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x9972;\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,h, spc;\n  " "fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xA5C4;\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,h, spc;\n  fm" "a.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xBF0A;\n  mov.b16 ulp,0x8100;\n  set.eq.f16.f16 p,h, spc;\n  fma." "rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (val.x) : "h" (a.x)); 
# 3178
return val; 
# 3179
} 
#endif
# 3180 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp10(const __half2 a) {int volatile ___ = 1;(void)a;
# 3204
::exit(___);}
#if 0
# 3180
{ 
# 3181
__half2 val; 
# 3182
__asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu, C;   \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         h," " %1;          \n  cvt.f32.f16     fl, hl;         \n  cvt.f32.f16     fu, hu;         \n  mov.b32         C, 0x40549A78;  \n  mu" "l.f32         fl,fl,C;        \n  mul.f32         fu,fu,C;        \n  ex2.approx.f32      fl, fl;     \n  ex2.approx.f32      fu" ", fu;     \n  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         r, {hl, hu};    \n{.reg.b3" "2 spc, ulp, p;\n  mov.b32 spc,0x34DE34DE;\n  mov.b32 ulp,0x98009800;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n" "}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x97669766;\n  mov.b32 ulp,0x90009000;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 " "r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x99729972;\n  mov.b32 ulp,0x10001000;\n  set.eq.f16x2.f16x2 p,h, spc;\n  f" "ma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0xA5C4A5C4;\n  mov.b32 ulp,0x10001000;\n  set.eq.f16x2.f16x2 p," "h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0xBF0ABF0A;\n  mov.b32 ulp,0x81008100;\n  set.eq.f1" "6x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;  \n}" : "=r" (val.x) : "r" (a.x)); 
# 3203
return val; 
# 3204
} 
#endif
# 3205 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog2(const __half a) {int volatile ___ = 1;(void)a;
# 3218
::exit(___);}
#if 0
# 3205
{ 
# 3206
__half val; 
# 3207
__asm__ volatile("{.reg.b16         h, r;           \n .reg.b32         f;              \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  lg2.approx.f32      f, f;       \n  cvt.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x" "A2E2;\n  mov.b16 ulp,0x8080;\n  set.eq.f16.f16 p,r, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xBF" "46;\n  mov.b16 ulp,0x9400;\n  set.eq.f16.f16 p,r, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (val.x) : "h" (a.x)); 
# 3217
return val; 
# 3218
} 
#endif
# 3219 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log2(const __half2 a) {int volatile ___ = 1;(void)a;
# 3236
::exit(___);}
#if 0
# 3219
{ 
# 3220
__half2 val; 
# 3221
__asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu, r, p;   \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  lg2.approx.f32      fl, fl;     \n  lg2.approx.f32      fu, fu;     \n  cv" "t.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         r, {hl, hu};    \n{.reg.b32 spc, ulp, p;\n" "  mov.b32 spc,0xA2E2A2E2;\n  mov.b32 ulp,0x80808080;\n  set.eq.f16x2.f16x2 p,r, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 sp" "c, ulp, p;\n  mov.b32 spc,0xBF46BF46;\n  mov.b32 ulp,0x94009400;\n  set.eq.f16x2.f16x2 p,r, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n" "  mov.b32         %0, r;          \n}" : "=r" (val.x) : "r" (a.x)); 
# 3235
return val; 
# 3236
} 
#endif
# 3237 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog(const __half a) {int volatile ___ = 1;(void)a;
# 3254
::exit(___);}
#if 0
# 3237
{ 
# 3238
__half val; 
# 3239
__asm__ volatile("{.reg.b32         f, C;           \n .reg.b16         r,h;            \n  mov.b16         h,%1;           \n  cvt.f32.f16     f," "h;            \n  lg2.approx.f32      f,f;        \n  mov.b32         C, 0x3f317218;  \n  mul.f32         f,f,C;          \n  cv" "t.rn.f16.f32      r,f;        \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X160D;\n  mov.b16 ulp,0x9C00;\n  set.eq.f16.f16 p,h, spc;" "\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X3BFE;\n  mov.b16 ulp,0x8010;\n  set.eq.f16.f16 p,h, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X3C0B;\n  mov.b16 ulp,0x8080;\n  set.eq.f16.f16 p,h, spc;\n  " "fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X6051;\n  mov.b16 ulp,0x1C00;\n  set.eq.f16.f16 p,h, spc;\n  fm" "a.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0,r;           \n}" : "=h" (val.x) : "h" (a.x)); 
# 3253
return val; 
# 3254
} 
#endif
# 3255 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log(const __half2 a) {int volatile ___ = 1;(void)a;
# 3278
::exit(___);}
#if 0
# 3255
{ 
# 3256
__half2 val; 
# 3257
__asm__ volatile("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  cvt.f32.f16     fl, hl;             \n  cvt.f32.f16     fu, hu;             \n  lg2.approx.f32" "      fl, fl;         \n  lg2.approx.f32      fu, fu;         \n  mov.b32         C, 0x3f317218;      \n  mul.f32         fl,fl," "C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.f16.f32      hl, fl;         \n  cvt.rn.f16.f32      hu, fu;   " "      \n  mov.b32         r, {hl, hu};        \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X160D160D;\n  mov.b32 ulp,0x9C009C00;\n  " "set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X3BFE3BFE;\n  mov.b32 ulp,0x8" "0108010;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X3C0B3C0B;\n  mov" ".b32 ulp,0x80808080;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X6051" "6051;\n  mov.b32 ulp,0x1C001C00;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;        " "      \n}" : "=r" (val.x) : "r" (a.x)); 
# 3277
return val; 
# 3278
} 
#endif
# 3279 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog10(const __half a) {int volatile ___ = 1;(void)a;
# 3296
::exit(___);}
#if 0
# 3279
{ 
# 3280
__half val; 
# 3281
__asm__ volatile("{.reg.b16         h, r;           \n .reg.b32         f, C;           \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  lg2.approx.f32      f, f;       \n  mov.b32         C, 0x3E9A209B;  \n  mul.f32         f,f,C;          \n  cv" "t.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x338F;\n  mov.b16 ulp,0x1000;\n  set.eq.f16.f16 p,h, spc;" "\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x33F8;\n  mov.b16 ulp,0x9000;\n  set.eq.f16.f16 p,h, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x57E1;\n  mov.b16 ulp,0x9800;\n  set.eq.f16.f16 p,h, spc;\n  " "fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x719D;\n  mov.b16 ulp,0x9C00;\n  set.eq.f16.f16 p,h, spc;\n  fm" "a.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (val.x) : "h" (a.x)); 
# 3295
return val; 
# 3296
} 
#endif
# 3297 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log10(const __half2 a) {int volatile ___ = 1;(void)a;
# 3320
::exit(___);}
#if 0
# 3297
{ 
# 3298
__half2 val; 
# 3299
__asm__ volatile("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  cvt.f32.f16     fl, hl;             \n  cvt.f32.f16     fu, hu;             \n  lg2.approx.f32" "      fl, fl;         \n  lg2.approx.f32      fu, fu;         \n  mov.b32         C, 0x3E9A209B;      \n  mul.f32         fl,fl," "C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.f16.f32      hl, fl;         \n  cvt.rn.f16.f32      hu, fu;   " "      \n  mov.b32         r, {hl, hu};        \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x338F338F;\n  mov.b32 ulp,0x10001000;\n  " "set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x33F833F8;\n  mov.b32 ulp,0x9" "0009000;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x57E157E1;\n  mov" ".b32 ulp,0x98009800;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x719D" "719D;\n  mov.b32 ulp,0x9C009C00;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;        " "      \n}" : "=r" (val.x) : "r" (a.x)); 
# 3319
return val; 
# 3320
} 
#endif
# 3323 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rcp(const __half2 a) {int volatile ___ = 1;(void)a;
# 3325
::exit(___);}
#if 0
# 3323
{ 
# 3324
do { __half2 val; __asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  rcp.approx.f32   fl, fl;     \n  rcp.approx.f32   fu, fu;     \n  cvt.rn.f" "16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (val.x) : "r" (a.x)); return val; } while (0); ; 
# 3325
} 
#endif
# 3326 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrcp(const __half a) {int volatile ___ = 1;(void)a;
# 3328
::exit(___);}
#if 0
# 3326
{ 
# 3327
do { __half val; __asm__ volatile("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  rcp.ap" "prox.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (val.x) : "h" (a.x)); return val; } while (0); ; 
# 3328
} 
#endif
# 3329 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rsqrt(const __half2 a) {int volatile ___ = 1;(void)a;
# 3331
::exit(___);}
#if 0
# 3329
{ 
# 3330
do { __half2 val; __asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  rsqrt.approx.f32   fl, fl;     \n  rsqrt.approx.f32   fu, fu;     \n  cvt." "rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (val.x) : "r" (a.x)); return val; } while (0); ; 
# 3331
} 
#endif
# 3332 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrsqrt(const __half a) {int volatile ___ = 1;(void)a;
# 3334
::exit(___);}
#if 0
# 3332
{ 
# 3333
do { __half val; __asm__ volatile("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  rsqrt." "approx.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (val.x) : "h" (a.x)); return val; } while (0); ; 
# 3334
} 
#endif
# 3335 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2sqrt(const __half2 a) {int volatile ___ = 1;(void)a;
# 3337
::exit(___);}
#if 0
# 3335
{ 
# 3336
do { __half2 val; __asm__ volatile("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  sqrt.approx.f32   fl, fl;     \n  sqrt.approx.f32   fu, fu;     \n  cvt.rn" ".f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (val.x) : "r" (a.x)); return val; } while (0); ; 
# 3337
} 
#endif
# 3338 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hsqrt(const __half a) {int volatile ___ = 1;(void)a;
# 3340
::exit(___);}
#if 0
# 3338
{ 
# 3339
do { __half val; __asm__ volatile("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  sqrt.a" "pprox.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (val.x) : "h" (a.x)); return val; } while (0); ; 
# 3340
} 
#endif
# 3343 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hisnan2(const __half2 a) 
# 3344
{int volatile ___ = 1;(void)a;
# 3349
::exit(___);}
#if 0
# 3344
{ 
# 3345
__half2 r; 
# 3346
__asm__("{set.nan.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (r.x) : "r" (a.x), "r" (a.x)); 
# 3348
return r; 
# 3349
} 
#endif
# 3350 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hisnan(const __half a) 
# 3351
{int volatile ___ = 1;(void)a;
# 3358
::exit(___);}
#if 0
# 3351
{ 
# 3352
__half r; 
# 3353
__asm__("{set.nan.f16.f16 %0,%1,%2;\n}" : "=h" (r.x) : "h" (a.x), "h" (a.x)); 
# 3355
if ((r.x) == 0) { 
# 3356
return false; } else { 
# 3357
return true; }  
# 3358
} 
#endif
# 3359 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hneg2(const __half2 a) 
# 3360
{int volatile ___ = 1;(void)a;
# 3363
::exit(___);}
#if 0
# 3360
{ 
# 3361
__half2 zero = __float2half2_rn((0.0)); 
# 3362
return __hsub2(zero, a); 
# 3363
} 
#endif
# 3364 "/usr/local/cuda/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hneg(const __half a) 
# 3365
{int volatile ___ = 1;(void)a;
# 3369
::exit(___);}
#if 0
# 3365
{ 
# 3366
__half zero; 
# 3367
zero = __float2half((0.0)); 
# 3368
return __hsub(zero, a); 
# 3369
} 
#endif
# 78 "/usr/local/cuda/include/cublas_api.h"
extern "C" {
# 93
typedef 
# 82
enum { 
# 83
CUBLAS_STATUS_SUCCESS, 
# 84
CUBLAS_STATUS_NOT_INITIALIZED, 
# 85
CUBLAS_STATUS_ALLOC_FAILED = 3, 
# 86
CUBLAS_STATUS_INVALID_VALUE = 7, 
# 87
CUBLAS_STATUS_ARCH_MISMATCH, 
# 88
CUBLAS_STATUS_MAPPING_ERROR = 11, 
# 89
CUBLAS_STATUS_EXECUTION_FAILED = 13, 
# 90
CUBLAS_STATUS_INTERNAL_ERROR, 
# 91
CUBLAS_STATUS_NOT_SUPPORTED, 
# 92
CUBLAS_STATUS_LICENSE_ERROR
# 93
} cublasStatus_t; 
# 99
typedef 
# 96
enum { 
# 97
CUBLAS_FILL_MODE_LOWER, 
# 98
CUBLAS_FILL_MODE_UPPER
# 99
} cublasFillMode_t; 
# 104
typedef 
# 101
enum { 
# 102
CUBLAS_DIAG_NON_UNIT, 
# 103
CUBLAS_DIAG_UNIT
# 104
} cublasDiagType_t; 
# 109
typedef 
# 106
enum { 
# 107
CUBLAS_SIDE_LEFT, 
# 108
CUBLAS_SIDE_RIGHT
# 109
} cublasSideMode_t; 
# 116
typedef 
# 112
enum { 
# 113
CUBLAS_OP_N, 
# 114
CUBLAS_OP_T, 
# 115
CUBLAS_OP_C
# 116
} cublasOperation_t; 
# 122
typedef 
# 119
enum { 
# 120
CUBLAS_POINTER_MODE_HOST, 
# 121
CUBLAS_POINTER_MODE_DEVICE
# 122
} cublasPointerMode_t; 
# 127
typedef 
# 124
enum { 
# 125
CUBLAS_ATOMICS_NOT_ALLOWED, 
# 126
CUBLAS_ATOMICS_ALLOWED
# 127
} cublasAtomicsMode_t; 
# 140
typedef 
# 130
enum { 
# 131
CUBLAS_GEMM_DFALT = (-1), 
# 132
CUBLAS_GEMM_ALGO0 = 0, 
# 133
CUBLAS_GEMM_ALGO1, 
# 134
CUBLAS_GEMM_ALGO2, 
# 135
CUBLAS_GEMM_ALGO3, 
# 136
CUBLAS_GEMM_ALGO4, 
# 137
CUBLAS_GEMM_ALGO5, 
# 138
CUBLAS_GEMM_ALGO6, 
# 139
CUBLAS_GEMM_ALGO7
# 140
} cublasGemmAlgo_t; 
# 143
typedef cudaDataType cublasDataType_t; 
# 146
struct cublasContext; 
# 147
typedef cublasContext *cublasHandle_t; 
# 149
cublasStatus_t cublasCreate_v2(cublasHandle_t * handle); 
# 150
cublasStatus_t cublasDestroy_v2(cublasHandle_t handle); 
# 152
cublasStatus_t cublasGetVersion_v2(cublasHandle_t handle, int * version); 
# 153
cublasStatus_t cublasGetProperty(libraryPropertyType type, int * value); 
# 155
cublasStatus_t cublasSetStream_v2(cublasHandle_t handle, cudaStream_t streamId); 
# 156
cublasStatus_t cublasGetStream_v2(cublasHandle_t handle, cudaStream_t * streamId); 
# 158
cublasStatus_t cublasGetPointerMode_v2(cublasHandle_t handle, cublasPointerMode_t * mode); 
# 159
cublasStatus_t cublasSetPointerMode_v2(cublasHandle_t handle, cublasPointerMode_t mode); 
# 161
cublasStatus_t cublasGetAtomicsMode(cublasHandle_t handle, cublasAtomicsMode_t * mode); 
# 162
cublasStatus_t cublasSetAtomicsMode(cublasHandle_t handle, cublasAtomicsMode_t mode); 
# 187
cublasStatus_t cublasSetVector(int n, int elemSize, const void * x, int incx, void * devicePtr, int incy); 
# 213
cublasStatus_t cublasGetVector(int n, int elemSize, const void * x, int incx, void * y, int incy); 
# 237
cublasStatus_t cublasSetMatrix(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb); 
# 261
cublasStatus_t cublasGetMatrix(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb); 
# 281
cublasStatus_t cublasSetVectorAsync(int n, int elemSize, const void * hostPtr, int incx, void * devicePtr, int incy, cudaStream_t stream); 
# 301
cublasStatus_t cublasGetVectorAsync(int n, int elemSize, const void * devicePtr, int incx, void * hostPtr, int incy, cudaStream_t stream); 
# 323
cublasStatus_t cublasSetMatrixAsync(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb, cudaStream_t stream); 
# 343
cublasStatus_t cublasGetMatrixAsync(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb, cudaStream_t stream); 
# 348
void cublasXerbla(const char * srName, int info); 
# 350
cublasStatus_t cublasNrm2Ex(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, void * result, cudaDataType resultType, cudaDataType executionType); 
# 358
cublasStatus_t cublasSnrm2_v2(cublasHandle_t handle, int n, const float * x, int incx, float * result); 
# 364
cublasStatus_t cublasDnrm2_v2(cublasHandle_t handle, int n, const double * x, int incx, double * result); 
# 370
cublasStatus_t cublasScnrm2_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result); 
# 376
cublasStatus_t cublasDznrm2_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result); 
# 382
cublasStatus_t cublasDotEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, const void * y, cudaDataType yType, int incy, void * result, cudaDataType resultType, cudaDataType executionType); 
# 394
cublasStatus_t cublasDotcEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, const void * y, cudaDataType yType, int incy, void * result, cudaDataType resultType, cudaDataType executionType); 
# 406
cublasStatus_t cublasSdot_v2(cublasHandle_t handle, int n, const float * x, int incx, const float * y, int incy, float * result); 
# 414
cublasStatus_t cublasDdot_v2(cublasHandle_t handle, int n, const double * x, int incx, const double * y, int incy, double * result); 
# 422
cublasStatus_t cublasCdotu_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result); 
# 430
cublasStatus_t cublasCdotc_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result); 
# 438
cublasStatus_t cublasZdotu_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result); 
# 446
cublasStatus_t cublasZdotc_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result); 
# 454
cublasStatus_t cublasScalEx(cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, void * x, cudaDataType xType, int incx, cudaDataType executionType); 
# 462
cublasStatus_t cublasSscal_v2(cublasHandle_t handle, int n, const float * alpha, float * x, int incx); 
# 468
cublasStatus_t cublasDscal_v2(cublasHandle_t handle, int n, const double * alpha, double * x, int incx); 
# 474
cublasStatus_t cublasCscal_v2(cublasHandle_t handle, int n, const cuComplex * alpha, cuComplex * x, int incx); 
# 480
cublasStatus_t cublasCsscal_v2(cublasHandle_t handle, int n, const float * alpha, cuComplex * x, int incx); 
# 486
cublasStatus_t cublasZscal_v2(cublasHandle_t handle, int n, const cuDoubleComplex * alpha, cuDoubleComplex * x, int incx); 
# 492
cublasStatus_t cublasZdscal_v2(cublasHandle_t handle, int n, const double * alpha, cuDoubleComplex * x, int incx); 
# 498
cublasStatus_t cublasAxpyEx(cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, const void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy, cudaDataType executiontype); 
# 510
cublasStatus_t cublasSaxpy_v2(cublasHandle_t handle, int n, const float * alpha, const float * x, int incx, float * y, int incy); 
# 518
cublasStatus_t cublasDaxpy_v2(cublasHandle_t handle, int n, const double * alpha, const double * x, int incx, double * y, int incy); 
# 526
cublasStatus_t cublasCaxpy_v2(cublasHandle_t handle, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * y, int incy); 
# 534
cublasStatus_t cublasZaxpy_v2(cublasHandle_t handle, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 542
cublasStatus_t cublasScopy_v2(cublasHandle_t handle, int n, const float * x, int incx, float * y, int incy); 
# 549
cublasStatus_t cublasDcopy_v2(cublasHandle_t handle, int n, const double * x, int incx, double * y, int incy); 
# 556
cublasStatus_t cublasCcopy_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, cuComplex * y, int incy); 
# 563
cublasStatus_t cublasZcopy_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 570
cublasStatus_t cublasSswap_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy); 
# 577
cublasStatus_t cublasDswap_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy); 
# 584
cublasStatus_t cublasCswap_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy); 
# 591
cublasStatus_t cublasZswap_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 598
cublasStatus_t cublasIsamax_v2(cublasHandle_t handle, int n, const float * x, int incx, int * result); 
# 604
cublasStatus_t cublasIdamax_v2(cublasHandle_t handle, int n, const double * x, int incx, int * result); 
# 610
cublasStatus_t cublasIcamax_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result); 
# 616
cublasStatus_t cublasIzamax_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result); 
# 622
cublasStatus_t cublasIsamin_v2(cublasHandle_t handle, int n, const float * x, int incx, int * result); 
# 628
cublasStatus_t cublasIdamin_v2(cublasHandle_t handle, int n, const double * x, int incx, int * result); 
# 634
cublasStatus_t cublasIcamin_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result); 
# 640
cublasStatus_t cublasIzamin_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result); 
# 646
cublasStatus_t cublasSasum_v2(cublasHandle_t handle, int n, const float * x, int incx, float * result); 
# 652
cublasStatus_t cublasDasum_v2(cublasHandle_t handle, int n, const double * x, int incx, double * result); 
# 658
cublasStatus_t cublasScasum_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result); 
# 664
cublasStatus_t cublasDzasum_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result); 
# 670
cublasStatus_t cublasSrot_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * c, const float * s); 
# 679
cublasStatus_t cublasDrot_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * c, const double * s); 
# 688
cublasStatus_t cublasCrot_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const cuComplex * s); 
# 697
cublasStatus_t cublasCsrot_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const float * s); 
# 706
cublasStatus_t cublasZrot_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const cuDoubleComplex * s); 
# 715
cublasStatus_t cublasZdrot_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const double * s); 
# 724
cublasStatus_t cublasSrotg_v2(cublasHandle_t handle, float * a, float * b, float * c, float * s); 
# 730
cublasStatus_t cublasDrotg_v2(cublasHandle_t handle, double * a, double * b, double * c, double * s); 
# 736
cublasStatus_t cublasCrotg_v2(cublasHandle_t handle, cuComplex * a, cuComplex * b, float * c, cuComplex * s); 
# 742
cublasStatus_t cublasZrotg_v2(cublasHandle_t handle, cuDoubleComplex * a, cuDoubleComplex * b, double * c, cuDoubleComplex * s); 
# 748
cublasStatus_t cublasSrotm_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * param); 
# 756
cublasStatus_t cublasDrotm_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * param); 
# 764
cublasStatus_t cublasSrotmg_v2(cublasHandle_t handle, float * d1, float * d2, float * x1, const float * y1, float * param); 
# 771
cublasStatus_t cublasDrotmg_v2(cublasHandle_t handle, double * d1, double * d2, double * x1, const double * y1, double * param); 
# 781
cublasStatus_t cublasSgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 794
cublasStatus_t cublasDgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 807
cublasStatus_t cublasCgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 820
cublasStatus_t cublasZgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 833
cublasStatus_t cublasSgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 848
cublasStatus_t cublasDgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 863
cublasStatus_t cublasCgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 878
cublasStatus_t cublasZgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 894
cublasStatus_t cublasStrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx); 
# 904
cublasStatus_t cublasDtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx); 
# 914
cublasStatus_t cublasCtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 924
cublasStatus_t cublasZtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 935
cublasStatus_t cublasStbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx); 
# 946
cublasStatus_t cublasDtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx); 
# 957
cublasStatus_t cublasCtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 968
cublasStatus_t cublasZtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 980
cublasStatus_t cublasStpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx); 
# 989
cublasStatus_t cublasDtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx); 
# 998
cublasStatus_t cublasCtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx); 
# 1007
cublasStatus_t cublasZtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx); 
# 1017
cublasStatus_t cublasStrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx); 
# 1027
cublasStatus_t cublasDtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx); 
# 1037
cublasStatus_t cublasCtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 1047
cublasStatus_t cublasZtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1058
cublasStatus_t cublasStpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx); 
# 1067
cublasStatus_t cublasDtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx); 
# 1076
cublasStatus_t cublasCtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx); 
# 1085
cublasStatus_t cublasZtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx); 
# 1094
cublasStatus_t cublasStbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx); 
# 1105
cublasStatus_t cublasDtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx); 
# 1116
cublasStatus_t cublasCtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 1127
cublasStatus_t cublasZtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1139
cublasStatus_t cublasSsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 1151
cublasStatus_t cublasDsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 1163
cublasStatus_t cublasCsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1175
cublasStatus_t cublasZsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1187
cublasStatus_t cublasChemv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1199
cublasStatus_t cublasZhemv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1212
cublasStatus_t cublasSsbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 1225
cublasStatus_t cublasDsbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 1238
cublasStatus_t cublasChbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1251
cublasStatus_t cublasZhbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1265
cublasStatus_t cublasSspmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * AP, const float * x, int incx, const float * beta, float * y, int incy); 
# 1276
cublasStatus_t cublasDspmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * AP, const double * x, int incx, const double * beta, double * y, int incy); 
# 1287
cublasStatus_t cublasChpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * AP, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1298
cublasStatus_t cublasZhpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * AP, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1310
cublasStatus_t cublasSger_v2(cublasHandle_t handle, int m, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda); 
# 1321
cublasStatus_t cublasDger_v2(cublasHandle_t handle, int m, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda); 
# 1332
cublasStatus_t cublasCgeru_v2(cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1343
cublasStatus_t cublasCgerc_v2(cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1354
cublasStatus_t cublasZgeru_v2(cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1365
cublasStatus_t cublasZgerc_v2(cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1377
cublasStatus_t cublasSsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * A, int lda); 
# 1386
cublasStatus_t cublasDsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * A, int lda); 
# 1395
cublasStatus_t cublasCsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * A, int lda); 
# 1404
cublasStatus_t cublasZsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda); 
# 1413
cublasStatus_t cublasCher_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * A, int lda); 
# 1422
cublasStatus_t cublasZher_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda); 
# 1432
cublasStatus_t cublasSspr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * AP); 
# 1440
cublasStatus_t cublasDspr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * AP); 
# 1448
cublasStatus_t cublasChpr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * AP); 
# 1456
cublasStatus_t cublasZhpr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * AP); 
# 1465
cublasStatus_t cublasSsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda); 
# 1476
cublasStatus_t cublasDsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda); 
# 1487
cublasStatus_t cublasCsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1497
cublasStatus_t cublasZsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1509
cublasStatus_t cublasCher2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1519
cublasStatus_t cublasZher2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1531
cublasStatus_t cublasSspr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * AP); 
# 1541
cublasStatus_t cublasDspr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * AP); 
# 1552
cublasStatus_t cublasChpr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * AP); 
# 1562
cublasStatus_t cublasZhpr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * AP); 
# 1575
cublasStatus_t cublasSgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 1590
cublasStatus_t cublasDgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 1605
cublasStatus_t cublasCgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 1620
cublasStatus_t cublasCgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 1634
cublasStatus_t cublasCgemm3mEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 1650
cublasStatus_t cublasZgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 1665
cublasStatus_t cublasZgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 1680
cublasStatus_t cublasHgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const __half * alpha, const __half * A, int lda, const __half * B, int ldb, const __half * beta, __half * C, int ldc); 
# 1695
cublasStatus_t cublasSgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 1713
cublasStatus_t cublasGemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const void * beta, void * C, cudaDataType Ctype, int ldc, cudaDataType computeType, cublasGemmAlgo_t algo); 
# 1734
cublasStatus_t cublasCgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 1749
cublasStatus_t cublasUint8gemmBias(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, cublasOperation_t transc, int m, int n, int k, const unsigned char * A, int A_bias, int lda, const unsigned char * B, int B_bias, int ldb, unsigned char * C, int C_bias, int ldc, int C_mult, int C_shift); 
# 1758
cublasStatus_t cublasSsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * beta, float * C, int ldc); 
# 1770
cublasStatus_t cublasDsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * beta, double * C, int ldc); 
# 1782
cublasStatus_t cublasCsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, cuComplex * C, int ldc); 
# 1794
cublasStatus_t cublasZsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 1806
cublasStatus_t cublasCsyrkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 1821
cublasStatus_t cublasCsyrk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 1836
cublasStatus_t cublasCherk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const cuComplex * A, int lda, const float * beta, cuComplex * C, int ldc); 
# 1848
cublasStatus_t cublasZherk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const cuDoubleComplex * A, int lda, const double * beta, cuDoubleComplex * C, int ldc); 
# 1861
cublasStatus_t cublasCherkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 1876
cublasStatus_t cublasCherk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 1892
cublasStatus_t cublasSsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 1906
cublasStatus_t cublasDsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 1920
cublasStatus_t cublasCsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 1934
cublasStatus_t cublasZsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 1948
cublasStatus_t cublasCher2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc); 
# 1962
cublasStatus_t cublasZher2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc); 
# 1976
cublasStatus_t cublasSsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 1990
cublasStatus_t cublasDsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 2004
cublasStatus_t cublasCsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2018
cublasStatus_t cublasZsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2032
cublasStatus_t cublasCherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc); 
# 2046
cublasStatus_t cublasZherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc); 
# 2060
cublasStatus_t cublasSsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 2074
cublasStatus_t cublasDsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 2088
cublasStatus_t cublasCsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2102
cublasStatus_t cublasZsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2117
cublasStatus_t cublasChemm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2131
cublasStatus_t cublasZhemm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2146
cublasStatus_t cublasStrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, float * B, int ldb); 
# 2160
cublasStatus_t cublasDtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, double * B, int ldb); 
# 2173
cublasStatus_t cublasCtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, cuComplex * B, int ldb); 
# 2186
cublasStatus_t cublasZtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, cuDoubleComplex * B, int ldb); 
# 2200
cublasStatus_t cublasStrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, float * C, int ldc); 
# 2215
cublasStatus_t cublasDtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, double * C, int ldc); 
# 2230
cublasStatus_t cublasCtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, cuComplex * C, int ldc); 
# 2245
cublasStatus_t cublasZtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc); 
# 2259
cublasStatus_t cublasSgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * Aarray[], int lda, const float * Barray[], int ldb, const float * beta, float * Carray[], int ldc, int batchCount); 
# 2275
cublasStatus_t cublasDgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * Aarray[], int lda, const double * Barray[], int ldb, const double * beta, double * Carray[], int ldc, int batchCount); 
# 2291
cublasStatus_t cublasCgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * Aarray[], int lda, const cuComplex * Barray[], int ldb, const cuComplex * beta, cuComplex * Carray[], int ldc, int batchCount); 
# 2307
cublasStatus_t cublasCgemm3mBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * Aarray[], int lda, const cuComplex * Barray[], int ldb, const cuComplex * beta, cuComplex * Carray[], int ldc, int batchCount); 
# 2323
cublasStatus_t cublasZgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * Aarray[], int lda, const cuDoubleComplex * Barray[], int ldb, const cuDoubleComplex * beta, cuDoubleComplex * Carray[], int ldc, int batchCount); 
# 2339
cublasStatus_t cublasSgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, long long strideA, const float * B, int ldb, long long strideB, const float * beta, float * C, int ldc, long long strideC, int batchCount); 
# 2358
cublasStatus_t cublasDgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, long long strideA, const double * B, int ldb, long long strideB, const double * beta, double * C, int ldc, long long strideC, int batchCount); 
# 2377
cublasStatus_t cublasCgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount); 
# 2396
cublasStatus_t cublasCgemm3mStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount); 
# 2416
cublasStatus_t cublasZgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, long long strideA, const cuDoubleComplex * B, int ldb, long long strideB, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc, long long strideC, int batchCount); 
# 2434
cublasStatus_t cublasHgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const __half * alpha, const __half * A, int lda, long long strideA, const __half * B, int ldb, long long strideB, const __half * beta, __half * C, int ldc, long long strideC, int batchCount); 
# 2455
cublasStatus_t cublasSgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const float * alpha, const float * A, int lda, const float * beta, const float * B, int ldb, float * C, int ldc); 
# 2469
cublasStatus_t cublasDgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const double * alpha, const double * A, int lda, const double * beta, const double * B, int ldb, double * C, int ldc); 
# 2483
cublasStatus_t cublasCgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, const cuComplex * B, int ldb, cuComplex * C, int ldc); 
# 2497
cublasStatus_t cublasZgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc); 
# 2512
cublasStatus_t cublasSgetrfBatched(cublasHandle_t handle, int n, float * A[], int lda, int * P, int * info, int batchSize); 
# 2520
cublasStatus_t cublasDgetrfBatched(cublasHandle_t handle, int n, double * A[], int lda, int * P, int * info, int batchSize); 
# 2528
cublasStatus_t cublasCgetrfBatched(cublasHandle_t handle, int n, cuComplex * A[], int lda, int * P, int * info, int batchSize); 
# 2536
cublasStatus_t cublasZgetrfBatched(cublasHandle_t handle, int n, cuDoubleComplex * A[], int lda, int * P, int * info, int batchSize); 
# 2545
cublasStatus_t cublasSgetriBatched(cublasHandle_t handle, int n, const float * A[], int lda, const int * P, float * C[], int ldc, int * info, int batchSize); 
# 2555
cublasStatus_t cublasDgetriBatched(cublasHandle_t handle, int n, const double * A[], int lda, const int * P, double * C[], int ldc, int * info, int batchSize); 
# 2565
cublasStatus_t cublasCgetriBatched(cublasHandle_t handle, int n, const cuComplex * A[], int lda, const int * P, cuComplex * C[], int ldc, int * info, int batchSize); 
# 2575
cublasStatus_t cublasZgetriBatched(cublasHandle_t handle, int n, const cuDoubleComplex * A[], int lda, const int * P, cuDoubleComplex * C[], int ldc, int * info, int batchSize); 
# 2587
cublasStatus_t cublasSgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const float * Aarray[], int lda, const int * devIpiv, float * Barray[], int ldb, int * info, int batchSize); 
# 2599
cublasStatus_t cublasDgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const double * Aarray[], int lda, const int * devIpiv, double * Barray[], int ldb, int * info, int batchSize); 
# 2611
cublasStatus_t cublasCgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuComplex * Aarray[], int lda, const int * devIpiv, cuComplex * Barray[], int ldb, int * info, int batchSize); 
# 2624
cublasStatus_t cublasZgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuDoubleComplex * Aarray[], int lda, const int * devIpiv, cuDoubleComplex * Barray[], int ldb, int * info, int batchSize); 
# 2639
cublasStatus_t cublasStrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A[], int lda, float * B[], int ldb, int batchCount); 
# 2653
cublasStatus_t cublasDtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A[], int lda, double * B[], int ldb, int batchCount); 
# 2667
cublasStatus_t cublasCtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A[], int lda, cuComplex * B[], int ldb, int batchCount); 
# 2681
cublasStatus_t cublasZtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A[], int lda, cuDoubleComplex * B[], int ldb, int batchCount); 
# 2696
cublasStatus_t cublasSmatinvBatched(cublasHandle_t handle, int n, const float * A[], int lda, float * Ainv[], int lda_inv, int * info, int batchSize); 
# 2705
cublasStatus_t cublasDmatinvBatched(cublasHandle_t handle, int n, const double * A[], int lda, double * Ainv[], int lda_inv, int * info, int batchSize); 
# 2714
cublasStatus_t cublasCmatinvBatched(cublasHandle_t handle, int n, const cuComplex * A[], int lda, cuComplex * Ainv[], int lda_inv, int * info, int batchSize); 
# 2723
cublasStatus_t cublasZmatinvBatched(cublasHandle_t handle, int n, const cuDoubleComplex * A[], int lda, cuDoubleComplex * Ainv[], int lda_inv, int * info, int batchSize); 
# 2733
cublasStatus_t cublasSgeqrfBatched(cublasHandle_t handle, int m, int n, float * Aarray[], int lda, float * TauArray[], int * info, int batchSize); 
# 2742
cublasStatus_t cublasDgeqrfBatched(cublasHandle_t handle, int m, int n, double * Aarray[], int lda, double * TauArray[], int * info, int batchSize); 
# 2751
cublasStatus_t cublasCgeqrfBatched(cublasHandle_t handle, int m, int n, cuComplex * Aarray[], int lda, cuComplex * TauArray[], int * info, int batchSize); 
# 2760
cublasStatus_t cublasZgeqrfBatched(cublasHandle_t handle, int m, int n, cuDoubleComplex * Aarray[], int lda, cuDoubleComplex * TauArray[], int * info, int batchSize); 
# 2769
cublasStatus_t cublasSgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, float * Aarray[], int lda, float * Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 2782
cublasStatus_t cublasDgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, double * Aarray[], int lda, double * Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 2795
cublasStatus_t cublasCgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuComplex * Aarray[], int lda, cuComplex * Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 2808
cublasStatus_t cublasZgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuDoubleComplex * Aarray[], int lda, cuDoubleComplex * Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 2821
cublasStatus_t cublasSdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const float * A, int lda, const float * x, int incx, float * C, int ldc); 
# 2832
cublasStatus_t cublasDdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const double * A, int lda, const double * x, int incx, double * C, int ldc); 
# 2843
cublasStatus_t cublasCdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuComplex * A, int lda, const cuComplex * x, int incx, cuComplex * C, int ldc); 
# 2854
cublasStatus_t cublasZdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, cuDoubleComplex * C, int ldc); 
# 2866
cublasStatus_t cublasStpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * AP, float * A, int lda); 
# 2873
cublasStatus_t cublasDtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * AP, double * A, int lda); 
# 2880
cublasStatus_t cublasCtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * AP, cuComplex * A, int lda); 
# 2887
cublasStatus_t cublasZtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * AP, cuDoubleComplex * A, int lda); 
# 2894
cublasStatus_t cublasStrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * A, int lda, float * AP); 
# 2901
cublasStatus_t cublasDtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * A, int lda, double * AP); 
# 2908
cublasStatus_t cublasCtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * A, int lda, cuComplex * AP); 
# 2915
cublasStatus_t cublasZtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * AP); 
# 2923
}
# 40 "./cuerror.cuh"
inline void _cuErrCheck(const cudaError_t err, const char *file, const int line) 
# 41
{ 
# 42
if (err != (cudaSuccess)) 
# 43
{ 
# 44
fprintf(stderr, "\n"); 
# 45
fprintf(stderr, "CUDA ERROR in file=`%s`, line=%d\n", file, line); 
# 46
fprintf(stderr, "CUDA ERROR %d: %s\n", err, cudaGetErrorString((cudaError_t)err)); 
# 47
fprintf(stderr, "\n"); 
# 48
cudaDeviceReset(); 
# 49
exit(1); 
# 50
}  
# 51
} 
# 58
static const char *cufftGetErrorEnum(cufftResult error) 
# 59
{ 
# 60
switch (error) 
# 61
{ 
# 62
case CUFFT_SUCCESS:  
# 63
return "CUFFT_SUCCESS"; 
# 64
case CUFFT_INVALID_PLAN:  
# 65
return "CUFFT_INVALID_PLAN"; 
# 66
case CUFFT_ALLOC_FAILED:  
# 67
return "CUFFT_ALLOC_FAILED"; 
# 68
case CUFFT_INVALID_TYPE:  
# 69
return "CUFFT_INVALID_TYPE"; 
# 70
case CUFFT_INVALID_VALUE:  
# 71
return "CUFFT_INVALID_VALUE"; 
# 72
case CUFFT_INTERNAL_ERROR:  
# 73
return "CUFFT_INTERNAL_ERROR"; 
# 74
case CUFFT_EXEC_FAILED:  
# 75
return "CUFFT_EXEC_FAILED"; 
# 76
case CUFFT_SETUP_FAILED:  
# 77
return "CUFFT_SETUP_FAILED"; 
# 78
case CUFFT_INVALID_SIZE:  
# 79
return "CUFFT_INVALID_SIZE"; 
# 80
case CUFFT_UNALIGNED_DATA:  
# 81
return "CUFFT_UNALIGNED_DATA"; 
# 82
case CUFFT_INCOMPLETE_PARAMETER_LIST:  
# 83
return "CUFFT_INCOMPLETE_PARAMETER_LIST"; 
# 84
case CUFFT_INVALID_DEVICE:  
# 85
return "CUFFT_INVALID_DEVICE"; 
# 86
case CUFFT_NO_WORKSPACE:  
# 87
return "CUFFT_NO_WORKSPACE"; 
# 88
case CUFFT_PARSE_ERROR:  
# 89
return "CUFFT_PARSE_ERROR"; 
# 90
case CUFFT_NOT_IMPLEMENTED:  
# 91
return "CUFFT_NOT_IMPLEMENTED"; 
# 92
case CUFFT_LICENSE_ERROR:  
# 93
return "CUFFT_LICENSE_ERROR"; 
# 94
default:  
# 95
return "UNKNOWN ERROR!"; 
# 96
}  
# 97
} 
# 99
inline void _cufftErrChk(cufftResult err, const char *file, const int line) 
# 100
{ 
# 101
if ((CUFFT_SUCCESS) != err) { 
# 102
fprintf(stderr, "\n"); 
# 103
fprintf(stderr, "CUFFT ERROR in file=`%s`, line=%d\n", file, line); 
# 104
fprintf(stderr, "CUFFT ERROR %d: %s\n", err, cufftGetErrorEnum((cufftResult)err)); 
# 105
fprintf(stderr, "\n"); 
# 106
cudaDeviceReset(); 
# 107
exit(1); 
# 108
}  
# 109
} 
# 121
static inline void CheckCublas(cublasStatus_t status, const char *
# 122
file, int 
# 123
line) { 
# 124
if (status != (CUBLAS_STATUS_SUCCESS)) { 
# 125
printf("CUBLAS error in %s at line %d\n", file, line); 
# 126
exit(1); 
# 127
}  
# 128
} 
# 42 "/usr/local/cuda/include/cub/util_arch.cuh"
namespace cub { 
# 140
}
# 47 "/usr/local/cuda/include/cub/util_debug.cuh"
namespace cub { 
# 68
__attribute((always_inline)) inline cudaError_t Debug(cudaError_t 
# 69
error, const char *
# 70
filename, int 
# 71
line) 
# 72
{ 
# 84
return error; 
# 85
} 
# 120
}
# 41 "/usr/local/cuda/include/cub/util_macro.cuh"
namespace cub { 
# 102
}
# 48 "/usr/local/cuda/include/cub/util_type.cuh"
namespace cub { 
# 65
template< bool IF, class ThenType, class ElseType> 
# 66
struct If { 
# 69
typedef ThenType Type; 
# 70
}; 
# 74
template< class ThenType, class ElseType> 
# 75
struct If< false, ThenType, ElseType>  { 
# 77
typedef ElseType Type; 
# 78
}; 
# 91
template< class A, class B> 
# 92
struct Equals { 
# 94
enum { 
# 95
VALUE, 
# 96
NEGATE = 1
# 97
}; 
# 98
}; 
# 102
template< class A> 
# 103
struct Equals< A, A>  { 
# 105
enum { 
# 106
VALUE = 1, 
# 107
NEGATE = 0
# 108
}; 
# 109
}; 
# 125
template< int N, int CURRENT_VAL = N, int COUNT = 0> 
# 126
struct Log2 { 
# 129
enum { VALUE = cub::Log2< N, (CURRENT_VAL >> 1), COUNT + 1> ::VALUE}; 
# 130
}; 
# 134
template< int N, int COUNT> 
# 135
struct Log2< N, 0, COUNT>  { 
# 137
enum { VALUE = ((1 << (COUNT - 1)) < N) ? COUNT : (COUNT - 1)
# 139
}; 
# 140
}; 
# 148
template< int N> 
# 149
struct PowerOfTwo { 
# 151
enum { VALUE = (N & (N - 1)) == 0}; 
# 152
}; 
# 163
template< class Tp> 
# 164
struct IsPointer { 
# 166
enum { VALUE}; 
# 167
}; 
# 171
template< class Tp> 
# 172
struct IsPointer< Tp *>  { 
# 174
enum { VALUE = 1}; 
# 175
}; 
# 188
template< class Tp> 
# 189
struct IsVolatile { 
# 191
enum { VALUE}; 
# 192
}; 
# 196
template< class Tp> 
# 197
struct IsVolatile< volatile Tp>  { 
# 199
enum { VALUE = 1}; 
# 200
}; 
# 215
template< class Tp, class Up = Tp> 
# 216
struct RemoveQualifiers { 
# 219
typedef Up Type; 
# 220
}; 
# 224
template< class Tp, class Up> 
# 225
struct RemoveQualifiers< Tp, volatile Up>  { 
# 227
typedef Up Type; 
# 228
}; 
# 230
template< class Tp, class Up> 
# 231
struct RemoveQualifiers< Tp, const Up>  { 
# 233
typedef Up Type; 
# 234
}; 
# 236
template< class Tp, class Up> 
# 237
struct RemoveQualifiers< Tp, const volatile Up>  { 
# 239
typedef Up Type; 
# 240
}; 
# 250
struct NullType { 
# 254
template< class T> 
# 255
__attribute((always_inline)) NullType &operator=(const T &b) { return *this; } 
# 257
__attribute((always_inline)) bool operator==(const NullType &b) { return true; } 
# 259
__attribute((always_inline)) bool operator!=(const NullType &b) { return false; } 
# 262
}; 
# 268
template< int A> 
# 269
struct Int2Type { 
# 271
enum { VALUE = A}; 
# 272
}; 
# 283
template< class T> 
# 284
struct AlignBytes { 
# 286
struct Pad { 
# 288
T val; 
# 289
char byte; 
# 290
}; 
# 293
enum { 
# 295
ALIGN_BYTES = sizeof(Pad) - sizeof(T)
# 296
}; 
# 297
}; 
# 301
template<> struct AlignBytes< short4>  { enum { ALIGN_BYTES = 8}; }; 
# 302
template<> struct AlignBytes< ushort4>  { enum { ALIGN_BYTES = 8}; }; 
# 303
template<> struct AlignBytes< int2>  { enum { ALIGN_BYTES = 8}; }; 
# 304
template<> struct AlignBytes< uint2>  { enum { ALIGN_BYTES = 8}; }; 
# 309
template<> struct AlignBytes< long long>  { enum { ALIGN_BYTES = 8}; }; 
# 310
template<> struct AlignBytes< unsigned long long>  { enum { ALIGN_BYTES = 8}; }; 
# 311
template<> struct AlignBytes< float2>  { enum { ALIGN_BYTES = 8}; }; 
# 312
template<> struct AlignBytes< double>  { enum { ALIGN_BYTES = 8}; }; 
# 314
template<> struct AlignBytes< int4>  { enum { ALIGN_BYTES = 16}; }; 
# 315
template<> struct AlignBytes< uint4>  { enum { ALIGN_BYTES = 16}; }; 
# 316
template<> struct AlignBytes< float4>  { enum { ALIGN_BYTES = 16}; }; 
# 318
template<> struct AlignBytes< long2>  { enum { ALIGN_BYTES = 16}; }; 
# 319
template<> struct AlignBytes< ulong2>  { enum { ALIGN_BYTES = 16}; }; 
# 321
template<> struct AlignBytes< long4>  { enum { ALIGN_BYTES = 16}; }; 
# 322
template<> struct AlignBytes< ulong4>  { enum { ALIGN_BYTES = 16}; }; 
# 323
template<> struct AlignBytes< longlong2>  { enum { ALIGN_BYTES = 16}; }; 
# 324
template<> struct AlignBytes< ulonglong2>  { enum { ALIGN_BYTES = 16}; }; 
# 325
template<> struct AlignBytes< double2>  { enum { ALIGN_BYTES = 16}; }; 
# 326
template<> struct AlignBytes< longlong4>  { enum { ALIGN_BYTES = 16}; }; 
# 327
template<> struct AlignBytes< ulonglong4>  { enum { ALIGN_BYTES = 16}; }; 
# 328
template<> struct AlignBytes< double4>  { enum { ALIGN_BYTES = 16}; }; 
# 330
template< class T> struct AlignBytes< volatile T>  : public AlignBytes< T>  { }; 
# 331
template< class T> struct AlignBytes< const T>  : public AlignBytes< T>  { }; 
# 332
template< class T> struct AlignBytes< const volatile T>  : public AlignBytes< T>  { }; 
# 336
template< class T> 
# 337
struct UnitWord { 
# 339
enum { 
# 340
ALIGN_BYTES = AlignBytes< T> ::ALIGN_BYTES
# 341
}; 
# 343
template< class Unit> 
# 344
struct IsMultiple { 
# 346
enum { 
# 347
UNIT_ALIGN_BYTES = AlignBytes< Unit> ::ALIGN_BYTES, 
# 348
IS_MULTIPLE = ((sizeof(T) % sizeof(Unit)) == (0)) && (((AlignBytes< T> ::ALIGN_BYTES) % (AlignBytes< Unit> ::ALIGN_BYTES)) == 0)
# 349
}; 
# 350
}; 
# 357
typedef typename If< IsMultiple< int> ::IS_MULTIPLE, unsigned, typename If< IsMultiple< short> ::IS_MULTIPLE, unsigned short, unsigned char> ::Type> ::Type ShuffleWord; 
# 362
typedef typename If< IsMultiple< long long> ::IS_MULTIPLE, unsigned long long, typename If< IsMultiple< int> ::IS_MULTIPLE, unsigned, typename If< IsMultiple< short> ::IS_MULTIPLE, unsigned short, unsigned char> ::Type> ::Type> ::Type VolatileWord; 
# 367
typedef typename If< IsMultiple< longlong2> ::IS_MULTIPLE, ulonglong2, typename If< IsMultiple< long long> ::IS_MULTIPLE, unsigned long long, typename If< IsMultiple< int> ::IS_MULTIPLE, unsigned, typename If< IsMultiple< short> ::IS_MULTIPLE, unsigned short, unsigned char> ::Type> ::Type> ::Type> ::Type DeviceWord; 
# 374
typedef typename If< IsMultiple< int4> ::IS_MULTIPLE, uint4, typename If< IsMultiple< int2> ::IS_MULTIPLE, uint2, typename If< IsMultiple< int> ::IS_MULTIPLE, unsigned, typename If< IsMultiple< short> ::IS_MULTIPLE, unsigned short, unsigned char> ::Type> ::Type> ::Type> ::Type TextureWord; 
# 375
}; 
# 380
template<> struct UnitWord< float2>  { 
# 382
typedef int ShuffleWord; 
# 387
typedef unsigned long long VolatileWord; 
# 388
typedef unsigned long long DeviceWord; 
# 390
typedef float2 TextureWord; 
# 391
}; 
# 395
template<> struct UnitWord< float4>  { 
# 397
typedef int ShuffleWord; 
# 402
typedef unsigned long long VolatileWord; 
# 403
typedef ulonglong2 DeviceWord; 
# 405
typedef float4 TextureWord; 
# 406
}; 
# 411
template<> struct UnitWord< char2>  { 
# 413
typedef unsigned short ShuffleWord; 
# 418
typedef unsigned short VolatileWord; 
# 419
typedef unsigned short DeviceWord; 
# 421
typedef unsigned short TextureWord; 
# 422
}; 
# 425
template< class T> struct UnitWord< volatile T>  : public UnitWord< T>  { }; 
# 426
template< class T> struct UnitWord< const T>  : public UnitWord< T>  { }; 
# 427
template< class T> struct UnitWord< const volatile T>  : public UnitWord< T>  { }; 
# 441
template< class T, int vec_elements> struct CubVector; 
# 446
enum { 
# 448
MAX_VEC_ELEMENTS = 4
# 449
}; 
# 455
template< class T> 
# 456
struct CubVector< T, 1>  { 
# 458
T x; 
# 460
typedef T BaseType; 
# 461
typedef cub::CubVector< T, 1>  Type; 
# 462
}; 
# 467
template< class T> 
# 468
struct CubVector< T, 2>  { 
# 470
T x; 
# 471
T y; 
# 473
typedef T BaseType; 
# 474
typedef cub::CubVector< T, 2>  Type; 
# 475
}; 
# 480
template< class T> 
# 481
struct CubVector< T, 3>  { 
# 483
T x; 
# 484
T y; 
# 485
T z; 
# 487
typedef T BaseType; 
# 488
typedef cub::CubVector< T, 3>  Type; 
# 489
}; 
# 494
template< class T> 
# 495
struct CubVector< T, 4>  { 
# 497
T x; 
# 498
T y; 
# 499
T z; 
# 500
T w; 
# 502
typedef T BaseType; 
# 503
typedef cub::CubVector< T, 4>  Type; 
# 504
}; 
# 591
template<> struct CubVector< char, 1>  : public char1 { typedef char BaseType; typedef char1 Type; __attribute((always_inline)) cub::CubVector< char, 1>  operator+(const cub::CubVector< char, 1>  &other) const { cub::CubVector< char, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< char, 1>  operator-(const cub::CubVector< char, 1>  &other) const { cub::CubVector< char, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< char, 2>  : public char2 { typedef char BaseType; typedef char2 Type; __attribute((always_inline)) cub::CubVector< char, 2>  operator+(const cub::CubVector< char, 2>  &other) const { cub::CubVector< char, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< char, 2>  operator-(const cub::CubVector< char, 2>  &other) const { cub::CubVector< char, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< char, 3>  : public char3 { typedef char BaseType; typedef char3 Type; __attribute((always_inline)) cub::CubVector< char, 3>  operator+(const cub::CubVector< char, 3>  &other) const { cub::CubVector< char, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< char, 3>  operator-(const cub::CubVector< char, 3>  &other) const { cub::CubVector< char, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< char, 4>  : public char4 { typedef char BaseType; typedef char4 Type; __attribute((always_inline)) cub::CubVector< char, 4>  operator+(const cub::CubVector< char, 4>  &other) const { cub::CubVector< char, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< char, 4>  operator-(const cub::CubVector< char, 4>  &other) const { cub::CubVector< char, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 592
template<> struct CubVector< signed char, 1>  : public char1 { typedef signed char BaseType; typedef char1 Type; __attribute((always_inline)) cub::CubVector< signed char, 1>  operator+(const cub::CubVector< signed char, 1>  &other) const { cub::CubVector< signed char, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< signed char, 1>  operator-(const cub::CubVector< signed char, 1>  &other) const { cub::CubVector< signed char, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< signed char, 2>  : public char2 { typedef signed char BaseType; typedef char2 Type; __attribute((always_inline)) cub::CubVector< signed char, 2>  operator+(const cub::CubVector< signed char, 2>  &other) const { cub::CubVector< signed char, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< signed char, 2>  operator-(const cub::CubVector< signed char, 2>  &other) const { cub::CubVector< signed char, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< signed char, 3>  : public char3 { typedef signed char BaseType; typedef char3 Type; __attribute((always_inline)) cub::CubVector< signed char, 3>  operator+(const cub::CubVector< signed char, 3>  &other) const { cub::CubVector< signed char, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< signed char, 3>  operator-(const cub::CubVector< signed char, 3>  &other) const { cub::CubVector< signed char, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< signed char, 4>  : public char4 { typedef signed char BaseType; typedef char4 Type; __attribute((always_inline)) cub::CubVector< signed char, 4>  operator+(const cub::CubVector< signed char, 4>  &other) const { cub::CubVector< signed char, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< signed char, 4>  operator-(const cub::CubVector< signed char, 4>  &other) const { cub::CubVector< signed char, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 593
template<> struct CubVector< short, 1>  : public short1 { typedef short BaseType; typedef short1 Type; __attribute((always_inline)) cub::CubVector< short, 1>  operator+(const cub::CubVector< short, 1>  &other) const { cub::CubVector< short, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< short, 1>  operator-(const cub::CubVector< short, 1>  &other) const { cub::CubVector< short, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< short, 2>  : public short2 { typedef short BaseType; typedef short2 Type; __attribute((always_inline)) cub::CubVector< short, 2>  operator+(const cub::CubVector< short, 2>  &other) const { cub::CubVector< short, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< short, 2>  operator-(const cub::CubVector< short, 2>  &other) const { cub::CubVector< short, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< short, 3>  : public short3 { typedef short BaseType; typedef short3 Type; __attribute((always_inline)) cub::CubVector< short, 3>  operator+(const cub::CubVector< short, 3>  &other) const { cub::CubVector< short, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< short, 3>  operator-(const cub::CubVector< short, 3>  &other) const { cub::CubVector< short, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< short, 4>  : public short4 { typedef short BaseType; typedef short4 Type; __attribute((always_inline)) cub::CubVector< short, 4>  operator+(const cub::CubVector< short, 4>  &other) const { cub::CubVector< short, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< short, 4>  operator-(const cub::CubVector< short, 4>  &other) const { cub::CubVector< short, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 594
template<> struct CubVector< int, 1>  : public int1 { typedef int BaseType; typedef int1 Type; __attribute((always_inline)) cub::CubVector< int, 1>  operator+(const cub::CubVector< int, 1>  &other) const { cub::CubVector< int, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< int, 1>  operator-(const cub::CubVector< int, 1>  &other) const { cub::CubVector< int, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< int, 2>  : public int2 { typedef int BaseType; typedef int2 Type; __attribute((always_inline)) cub::CubVector< int, 2>  operator+(const cub::CubVector< int, 2>  &other) const { cub::CubVector< int, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< int, 2>  operator-(const cub::CubVector< int, 2>  &other) const { cub::CubVector< int, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< int, 3>  : public int3 { typedef int BaseType; typedef int3 Type; __attribute((always_inline)) cub::CubVector< int, 3>  operator+(const cub::CubVector< int, 3>  &other) const { cub::CubVector< int, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< int, 3>  operator-(const cub::CubVector< int, 3>  &other) const { cub::CubVector< int, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< int, 4>  : public int4 { typedef int BaseType; typedef int4 Type; __attribute((always_inline)) cub::CubVector< int, 4>  operator+(const cub::CubVector< int, 4>  &other) const { cub::CubVector< int, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< int, 4>  operator-(const cub::CubVector< int, 4>  &other) const { cub::CubVector< int, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 595
template<> struct CubVector< long, 1>  : public long1 { typedef long BaseType; typedef long1 Type; __attribute((always_inline)) cub::CubVector< long, 1>  operator+(const cub::CubVector< long, 1>  &other) const { cub::CubVector< long, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< long, 1>  operator-(const cub::CubVector< long, 1>  &other) const { cub::CubVector< long, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< long, 2>  : public long2 { typedef long BaseType; typedef long2 Type; __attribute((always_inline)) cub::CubVector< long, 2>  operator+(const cub::CubVector< long, 2>  &other) const { cub::CubVector< long, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< long, 2>  operator-(const cub::CubVector< long, 2>  &other) const { cub::CubVector< long, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< long, 3>  : public long3 { typedef long BaseType; typedef long3 Type; __attribute((always_inline)) cub::CubVector< long, 3>  operator+(const cub::CubVector< long, 3>  &other) const { cub::CubVector< long, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< long, 3>  operator-(const cub::CubVector< long, 3>  &other) const { cub::CubVector< long, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< long, 4>  : public long4 { typedef long BaseType; typedef long4 Type; __attribute((always_inline)) cub::CubVector< long, 4>  operator+(const cub::CubVector< long, 4>  &other) const { cub::CubVector< long, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< long, 4>  operator-(const cub::CubVector< long, 4>  &other) const { cub::CubVector< long, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 596
template<> struct CubVector< long long, 1>  : public longlong1 { typedef long long BaseType; typedef longlong1 Type; __attribute((always_inline)) cub::CubVector< long long, 1>  operator+(const cub::CubVector< long long, 1>  &other) const { cub::CubVector< long long, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< long long, 1>  operator-(const cub::CubVector< long long, 1>  &other) const { cub::CubVector< long long, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< long long, 2>  : public longlong2 { typedef long long BaseType; typedef longlong2 Type; __attribute((always_inline)) cub::CubVector< long long, 2>  operator+(const cub::CubVector< long long, 2>  &other) const { cub::CubVector< long long, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< long long, 2>  operator-(const cub::CubVector< long long, 2>  &other) const { cub::CubVector< long long, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< long long, 3>  : public longlong3 { typedef long long BaseType; typedef longlong3 Type; __attribute((always_inline)) cub::CubVector< long long, 3>  operator+(const cub::CubVector< long long, 3>  &other) const { cub::CubVector< long long, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< long long, 3>  operator-(const cub::CubVector< long long, 3>  &other) const { cub::CubVector< long long, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< long long, 4>  : public longlong4 { typedef long long BaseType; typedef longlong4 Type; __attribute((always_inline)) cub::CubVector< long long, 4>  operator+(const cub::CubVector< long long, 4>  &other) const { cub::CubVector< long long, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< long long, 4>  operator-(const cub::CubVector< long long, 4>  &other) const { cub::CubVector< long long, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 597
template<> struct CubVector< unsigned char, 1>  : public uchar1 { typedef unsigned char BaseType; typedef uchar1 Type; __attribute((always_inline)) cub::CubVector< unsigned char, 1>  operator+(const cub::CubVector< unsigned char, 1>  &other) const { cub::CubVector< unsigned char, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned char, 1>  operator-(const cub::CubVector< unsigned char, 1>  &other) const { cub::CubVector< unsigned char, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< unsigned char, 2>  : public uchar2 { typedef unsigned char BaseType; typedef uchar2 Type; __attribute((always_inline)) cub::CubVector< unsigned char, 2>  operator+(const cub::CubVector< unsigned char, 2>  &other) const { cub::CubVector< unsigned char, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned char, 2>  operator-(const cub::CubVector< unsigned char, 2>  &other) const { cub::CubVector< unsigned char, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< unsigned char, 3>  : public uchar3 { typedef unsigned char BaseType; typedef uchar3 Type; __attribute((always_inline)) cub::CubVector< unsigned char, 3>  operator+(const cub::CubVector< unsigned char, 3>  &other) const { cub::CubVector< unsigned char, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned char, 3>  operator-(const cub::CubVector< unsigned char, 3>  &other) const { cub::CubVector< unsigned char, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< unsigned char, 4>  : public uchar4 { typedef unsigned char BaseType; typedef uchar4 Type; __attribute((always_inline)) cub::CubVector< unsigned char, 4>  operator+(const cub::CubVector< unsigned char, 4>  &other) const { cub::CubVector< unsigned char, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned char, 4>  operator-(const cub::CubVector< unsigned char, 4>  &other) const { cub::CubVector< unsigned char, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 598
template<> struct CubVector< unsigned short, 1>  : public ushort1 { typedef unsigned short BaseType; typedef ushort1 Type; __attribute((always_inline)) cub::CubVector< unsigned short, 1>  operator+(const cub::CubVector< unsigned short, 1>  &other) const { cub::CubVector< unsigned short, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned short, 1>  operator-(const cub::CubVector< unsigned short, 1>  &other) const { cub::CubVector< unsigned short, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< unsigned short, 2>  : public ushort2 { typedef unsigned short BaseType; typedef ushort2 Type; __attribute((always_inline)) cub::CubVector< unsigned short, 2>  operator+(const cub::CubVector< unsigned short, 2>  &other) const { cub::CubVector< unsigned short, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned short, 2>  operator-(const cub::CubVector< unsigned short, 2>  &other) const { cub::CubVector< unsigned short, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< unsigned short, 3>  : public ushort3 { typedef unsigned short BaseType; typedef ushort3 Type; __attribute((always_inline)) cub::CubVector< unsigned short, 3>  operator+(const cub::CubVector< unsigned short, 3>  &other) const { cub::CubVector< unsigned short, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned short, 3>  operator-(const cub::CubVector< unsigned short, 3>  &other) const { cub::CubVector< unsigned short, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< unsigned short, 4>  : public ushort4 { typedef unsigned short BaseType; typedef ushort4 Type; __attribute((always_inline)) cub::CubVector< unsigned short, 4>  operator+(const cub::CubVector< unsigned short, 4>  &other) const { cub::CubVector< unsigned short, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned short, 4>  operator-(const cub::CubVector< unsigned short, 4>  &other) const { cub::CubVector< unsigned short, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 599
template<> struct CubVector< unsigned, 1>  : public uint1 { typedef unsigned BaseType; typedef uint1 Type; __attribute((always_inline)) cub::CubVector< unsigned, 1>  operator+(const cub::CubVector< unsigned, 1>  &other) const { cub::CubVector< unsigned, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned, 1>  operator-(const cub::CubVector< unsigned, 1>  &other) const { cub::CubVector< unsigned, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< unsigned, 2>  : public uint2 { typedef unsigned BaseType; typedef uint2 Type; __attribute((always_inline)) cub::CubVector< unsigned, 2>  operator+(const cub::CubVector< unsigned, 2>  &other) const { cub::CubVector< unsigned, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned, 2>  operator-(const cub::CubVector< unsigned, 2>  &other) const { cub::CubVector< unsigned, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< unsigned, 3>  : public uint3 { typedef unsigned BaseType; typedef uint3 Type; __attribute((always_inline)) cub::CubVector< unsigned, 3>  operator+(const cub::CubVector< unsigned, 3>  &other) const { cub::CubVector< unsigned, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned, 3>  operator-(const cub::CubVector< unsigned, 3>  &other) const { cub::CubVector< unsigned, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< unsigned, 4>  : public uint4 { typedef unsigned BaseType; typedef uint4 Type; __attribute((always_inline)) cub::CubVector< unsigned, 4>  operator+(const cub::CubVector< unsigned, 4>  &other) const { cub::CubVector< unsigned, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned, 4>  operator-(const cub::CubVector< unsigned, 4>  &other) const { cub::CubVector< unsigned, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 600
template<> struct CubVector< unsigned long, 1>  : public ulong1 { typedef unsigned long BaseType; typedef ulong1 Type; __attribute((always_inline)) cub::CubVector< unsigned long, 1>  operator+(const cub::CubVector< unsigned long, 1>  &other) const { cub::CubVector< unsigned long, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long, 1>  operator-(const cub::CubVector< unsigned long, 1>  &other) const { cub::CubVector< unsigned long, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< unsigned long, 2>  : public ulong2 { typedef unsigned long BaseType; typedef ulong2 Type; __attribute((always_inline)) cub::CubVector< unsigned long, 2>  operator+(const cub::CubVector< unsigned long, 2>  &other) const { cub::CubVector< unsigned long, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long, 2>  operator-(const cub::CubVector< unsigned long, 2>  &other) const { cub::CubVector< unsigned long, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< unsigned long, 3>  : public ulong3 { typedef unsigned long BaseType; typedef ulong3 Type; __attribute((always_inline)) cub::CubVector< unsigned long, 3>  operator+(const cub::CubVector< unsigned long, 3>  &other) const { cub::CubVector< unsigned long, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long, 3>  operator-(const cub::CubVector< unsigned long, 3>  &other) const { cub::CubVector< unsigned long, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< unsigned long, 4>  : public ulong4 { typedef unsigned long BaseType; typedef ulong4 Type; __attribute((always_inline)) cub::CubVector< unsigned long, 4>  operator+(const cub::CubVector< unsigned long, 4>  &other) const { cub::CubVector< unsigned long, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long, 4>  operator-(const cub::CubVector< unsigned long, 4>  &other) const { cub::CubVector< unsigned long, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 601
template<> struct CubVector< unsigned long long, 1>  : public ulonglong1 { typedef unsigned long long BaseType; typedef ulonglong1 Type; __attribute((always_inline)) cub::CubVector< unsigned long long, 1>  operator+(const cub::CubVector< unsigned long long, 1>  &other) const { cub::CubVector< unsigned long long, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long long, 1>  operator-(const cub::CubVector< unsigned long long, 1>  &other) const { cub::CubVector< unsigned long long, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< unsigned long long, 2>  : public ulonglong2 { typedef unsigned long long BaseType; typedef ulonglong2 Type; __attribute((always_inline)) cub::CubVector< unsigned long long, 2>  operator+(const cub::CubVector< unsigned long long, 2>  &other) const { cub::CubVector< unsigned long long, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long long, 2>  operator-(const cub::CubVector< unsigned long long, 2>  &other) const { cub::CubVector< unsigned long long, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< unsigned long long, 3>  : public ulonglong3 { typedef unsigned long long BaseType; typedef ulonglong3 Type; __attribute((always_inline)) cub::CubVector< unsigned long long, 3>  operator+(const cub::CubVector< unsigned long long, 3>  &other) const { cub::CubVector< unsigned long long, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long long, 3>  operator-(const cub::CubVector< unsigned long long, 3>  &other) const { cub::CubVector< unsigned long long, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< unsigned long long, 4>  : public ulonglong4 { typedef unsigned long long BaseType; typedef ulonglong4 Type; __attribute((always_inline)) cub::CubVector< unsigned long long, 4>  operator+(const cub::CubVector< unsigned long long, 4>  &other) const { cub::CubVector< unsigned long long, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< unsigned long long, 4>  operator-(const cub::CubVector< unsigned long long, 4>  &other) const { cub::CubVector< unsigned long long, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 602
template<> struct CubVector< float, 1>  : public float1 { typedef float BaseType; typedef float1 Type; __attribute((always_inline)) cub::CubVector< float, 1>  operator+(const cub::CubVector< float, 1>  &other) const { cub::CubVector< float, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< float, 1>  operator-(const cub::CubVector< float, 1>  &other) const { cub::CubVector< float, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< float, 2>  : public float2 { typedef float BaseType; typedef float2 Type; __attribute((always_inline)) cub::CubVector< float, 2>  operator+(const cub::CubVector< float, 2>  &other) const { cub::CubVector< float, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< float, 2>  operator-(const cub::CubVector< float, 2>  &other) const { cub::CubVector< float, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< float, 3>  : public float3 { typedef float BaseType; typedef float3 Type; __attribute((always_inline)) cub::CubVector< float, 3>  operator+(const cub::CubVector< float, 3>  &other) const { cub::CubVector< float, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< float, 3>  operator-(const cub::CubVector< float, 3>  &other) const { cub::CubVector< float, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< float, 4>  : public float4 { typedef float BaseType; typedef float4 Type; __attribute((always_inline)) cub::CubVector< float, 4>  operator+(const cub::CubVector< float, 4>  &other) const { cub::CubVector< float, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< float, 4>  operator-(const cub::CubVector< float, 4>  &other) const { cub::CubVector< float, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 603
template<> struct CubVector< double, 1>  : public double1 { typedef double BaseType; typedef double1 Type; __attribute((always_inline)) cub::CubVector< double, 1>  operator+(const cub::CubVector< double, 1>  &other) const { cub::CubVector< double, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< double, 1>  operator-(const cub::CubVector< double, 1>  &other) const { cub::CubVector< double, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< double, 2>  : public double2 { typedef double BaseType; typedef double2 Type; __attribute((always_inline)) cub::CubVector< double, 2>  operator+(const cub::CubVector< double, 2>  &other) const { cub::CubVector< double, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< double, 2>  operator-(const cub::CubVector< double, 2>  &other) const { cub::CubVector< double, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< double, 3>  : public double3 { typedef double BaseType; typedef double3 Type; __attribute((always_inline)) cub::CubVector< double, 3>  operator+(const cub::CubVector< double, 3>  &other) const { cub::CubVector< double, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< double, 3>  operator-(const cub::CubVector< double, 3>  &other) const { cub::CubVector< double, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< double, 4>  : public double4 { typedef double BaseType; typedef double4 Type; __attribute((always_inline)) cub::CubVector< double, 4>  operator+(const cub::CubVector< double, 4>  &other) const { cub::CubVector< double, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< double, 4>  operator-(const cub::CubVector< double, 4>  &other) const { cub::CubVector< double, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 604
template<> struct CubVector< bool, 1>  : public uchar1 { typedef bool BaseType; typedef uchar1 Type; __attribute((always_inline)) cub::CubVector< bool, 1>  operator+(const cub::CubVector< bool, 1>  &other) const { cub::CubVector< bool, 1>  retval; (retval.x) = ((x) + (other.x)); return retval; } __attribute((always_inline)) cub::CubVector< bool, 1>  operator-(const cub::CubVector< bool, 1>  &other) const { cub::CubVector< bool, 1>  retval; (retval.x) = ((x) - (other.x)); return retval; } }; template<> struct CubVector< bool, 2>  : public uchar2 { typedef bool BaseType; typedef uchar2 Type; __attribute((always_inline)) cub::CubVector< bool, 2>  operator+(const cub::CubVector< bool, 2>  &other) const { cub::CubVector< bool, 2>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); return retval; } __attribute((always_inline)) cub::CubVector< bool, 2>  operator-(const cub::CubVector< bool, 2>  &other) const { cub::CubVector< bool, 2>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); return retval; } }; template<> struct CubVector< bool, 3>  : public uchar3 { typedef bool BaseType; typedef uchar3 Type; __attribute((always_inline)) cub::CubVector< bool, 3>  operator+(const cub::CubVector< bool, 3>  &other) const { cub::CubVector< bool, 3>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); return retval; } __attribute((always_inline)) cub::CubVector< bool, 3>  operator-(const cub::CubVector< bool, 3>  &other) const { cub::CubVector< bool, 3>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); return retval; } }; template<> struct CubVector< bool, 4>  : public uchar4 { typedef bool BaseType; typedef uchar4 Type; __attribute((always_inline)) cub::CubVector< bool, 4>  operator+(const cub::CubVector< bool, 4>  &other) const { cub::CubVector< bool, 4>  retval; (retval.x) = ((x) + (other.x)); (retval.y) = ((y) + (other.y)); (retval.z) = ((z) + (other.z)); (retval.w) = ((w) + (other.w)); return retval; } __attribute((always_inline)) cub::CubVector< bool, 4>  operator-(const cub::CubVector< bool, 4>  &other) const { cub::CubVector< bool, 4>  retval; (retval.x) = ((x) - (other.x)); (retval.y) = ((y) - (other.y)); (retval.z) = ((z) - (other.z)); (retval.w) = ((w) - (other.w)); return retval; } }; 
# 620
template< class T> 
# 621
struct Uninitialized { 
# 624
typedef typename UnitWord< T> ::DeviceWord DeviceWord; 
# 627
enum { 
# 628
WORDS = sizeof(T) / sizeof(DeviceWord)
# 629
}; 
# 632
DeviceWord storage[WORDS]; 
# 635
__attribute((always_inline)) T &Alias() 
# 636
{ 
# 637
return reinterpret_cast< T &>(*this); 
# 638
} 
# 639
}; 
# 645
template< class _Key, class _Value> 
# 646
struct KeyValuePair { 
# 648
typedef _Key Key; 
# 649
typedef _Value Value; 
# 653
union { 
# 654
Key key; 
# 655
typename UnitWord< _Value> ::DeviceWord align0; 
# 656
}; 
# 661
Value value; 
# 664
__attribute((always_inline)) bool operator!=(const KeyValuePair &b) 
# 665
{ 
# 666
return ((value) != (b.value)) || ((cub::KeyValuePair< _Key, _Value> ::key) != (b.cub::KeyValuePair< _Key, _Value> ::key)); 
# 667
} 
# 669
}; 
# 677
template< class T, int COUNT> 
# 678
struct ArrayWrapper { 
# 682
T array[COUNT]; 
# 685
__attribute((always_inline)) ArrayWrapper() { } 
# 686
}; 
# 698
template< class T> 
# 699
struct DoubleBuffer { 
# 702
T *d_buffers[2]; 
# 705
int selector; 
# 708
__attribute((always_inline)) DoubleBuffer() 
# 709
{ 
# 710
(selector) = 0; 
# 711
((d_buffers)[0]) = __null; 
# 712
((d_buffers)[1]) = __null; 
# 713
} 
# 716
__attribute((always_inline)) DoubleBuffer(T *
# 717
d_current, T *
# 718
d_alternate) 
# 719
{ 
# 720
(selector) = 0; 
# 721
((d_buffers)[0]) = d_current; 
# 722
((d_buffers)[1]) = d_alternate; 
# 723
} 
# 726
__attribute((always_inline)) T *Current() { return (d_buffers)[selector]; } 
# 729
__attribute((always_inline)) T *Alternate() { return (d_buffers)[(selector) ^ 1]; } 
# 731
}; 
# 766
template< bool Condition, class T = void> 
# 767
struct EnableIf { 
# 770
typedef T Type; 
# 771
}; 
# 774
template< class T> 
# 775
struct EnableIf< false, T>  { }; 
# 786
template< class T, class BinaryOp> 
# 787
struct BinaryOpHasIdxParam { 
# 796
private: template< class BinaryOpT, bool (BinaryOpT::*)(const T & a, const T & b, int idx) const> struct SFINAE5 { }; 
# 797
template< class BinaryOpT, bool (BinaryOpT::*)(const T & a, const T & b, int idx)> struct SFINAE6 { }; 
# 798
template< class BinaryOpT, bool (BinaryOpT::*)(T a, T b, int idx) const> struct SFINAE7 { }; 
# 799
template< class BinaryOpT, bool (BinaryOpT::*)(T a, T b, int idx)> struct SFINAE8 { }; 
# 806
template< class BinaryOpT> static char Test(SFINAE5< BinaryOpT, &BinaryOpT::operator()>  *); 
# 807
template< class BinaryOpT> static char Test(SFINAE6< BinaryOpT, &BinaryOpT::operator()>  *); 
# 808
template< class BinaryOpT> static char Test(SFINAE7< BinaryOpT, &BinaryOpT::operator()>  *); 
# 809
template< class BinaryOpT> static char Test(SFINAE8< BinaryOpT, &BinaryOpT::operator()>  *); 
# 811
template< class BinaryOpT> static int Test(...); 
# 816
public: static const bool HAS_PARAM = (sizeof(Test< BinaryOp> (__null)) == sizeof(char)); 
# 817
}; 
# 836
enum Category { 
# 838
NOT_A_NUMBER, 
# 839
SIGNED_INTEGER, 
# 840
UNSIGNED_INTEGER, 
# 841
FLOATING_POINT
# 842
}; 
# 848
template< Category _CATEGORY, bool _PRIMITIVE, bool _NULL_TYPE, class _UnsignedBits, class T> 
# 849
struct BaseTraits { 
# 852
static const Category CATEGORY = _CATEGORY; 
# 854
enum { 
# 855
PRIMITIVE = _PRIMITIVE, 
# 856
NULL_TYPE = _NULL_TYPE
# 857
}; 
# 858
}; 
# 864
template< class _UnsignedBits, class T> 
# 865
struct BaseTraits< UNSIGNED_INTEGER, true, false, _UnsignedBits, T>  { 
# 867
typedef _UnsignedBits UnsignedBits; 
# 869
static const Category CATEGORY = UNSIGNED_INTEGER; 
# 870
static const UnsignedBits LOWEST_KEY = ((UnsignedBits)0); 
# 871
static const UnsignedBits MAX_KEY = ((UnsignedBits)(-1)); 
# 874
enum { 
# 875
PRIMITIVE = true, 
# 876
NULL_TYPE = false
# 877
}; 
# 880
__attribute((always_inline)) static UnsignedBits TwiddleIn(UnsignedBits key) 
# 881
{int volatile ___ = 1;(void)key;
# 883
::exit(___);}
#if 0
# 881
{ 
# 882
return key; 
# 883
} 
#endif
# 885 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static UnsignedBits TwiddleOut(UnsignedBits key) 
# 886
{int volatile ___ = 1;(void)key;
# 888
::exit(___);}
#if 0
# 886
{ 
# 887
return key; 
# 888
} 
#endif
# 890 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static T Max() 
# 891
{ 
# 892
UnsignedBits retval = MAX_KEY; 
# 893
return reinterpret_cast< T &>(retval); 
# 894
} 
# 896
__attribute((always_inline)) static T Lowest() 
# 897
{ 
# 898
UnsignedBits retval = LOWEST_KEY; 
# 899
return reinterpret_cast< T &>(retval); 
# 900
} 
# 901
}; 
# 907
template< class _UnsignedBits, class T> 
# 908
struct BaseTraits< SIGNED_INTEGER, true, false, _UnsignedBits, T>  { 
# 910
typedef _UnsignedBits UnsignedBits; 
# 912
static const Category CATEGORY = SIGNED_INTEGER; 
# 913
static const UnsignedBits HIGH_BIT = (((UnsignedBits)1) << ((sizeof(UnsignedBits) * (8)) - (1))); 
# 914
static const UnsignedBits LOWEST_KEY = HIGH_BIT; 
# 915
static const UnsignedBits MAX_KEY = (((UnsignedBits)(-1)) ^ HIGH_BIT); 
# 918
enum { 
# 919
PRIMITIVE = true, 
# 920
NULL_TYPE = false
# 921
}; 
# 923
__attribute((always_inline)) static UnsignedBits TwiddleIn(UnsignedBits key) 
# 924
{int volatile ___ = 1;(void)key;
# 926
::exit(___);}
#if 0
# 924
{ 
# 925
return key ^ HIGH_BIT; 
# 926
} 
#endif
# 928 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static UnsignedBits TwiddleOut(UnsignedBits key) 
# 929
{int volatile ___ = 1;(void)key;
# 931
::exit(___);}
#if 0
# 929
{ 
# 930
return key ^ HIGH_BIT; 
# 931
} 
#endif
# 933 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static T Max() 
# 934
{ 
# 935
UnsignedBits retval = MAX_KEY; 
# 936
return reinterpret_cast< T &>(retval); 
# 937
} 
# 939
__attribute((always_inline)) static T Lowest() 
# 940
{ 
# 941
UnsignedBits retval = LOWEST_KEY; 
# 942
return reinterpret_cast< T &>(retval); 
# 943
} 
# 944
}; 
# 946
template< class _T> struct FpLimits; 
# 950
template<> struct FpLimits< float>  { 
# 952
__attribute((always_inline)) static float Max() { 
# 953
return (3.402823466e+38F); 
# 954
} 
# 956
__attribute((always_inline)) static float Lowest() { 
# 957
return (3.402823466e+38F) * ((float)(-1)); 
# 958
} 
# 959
}; 
# 962
template<> struct FpLimits< double>  { 
# 964
__attribute((always_inline)) static double Max() { 
# 965
return (double)(1.797693134862315708e+308L); 
# 966
} 
# 968
__attribute((always_inline)) static double Lowest() { 
# 969
return ((double)(1.797693134862315708e+308L)) * ((double)(-1)); 
# 970
} 
# 971
}; 
# 977
template< class _UnsignedBits, class T> 
# 978
struct BaseTraits< FLOATING_POINT, true, false, _UnsignedBits, T>  { 
# 980
typedef _UnsignedBits UnsignedBits; 
# 982
static const Category CATEGORY = FLOATING_POINT; 
# 983
static const UnsignedBits HIGH_BIT = (((UnsignedBits)1) << ((sizeof(UnsignedBits) * (8)) - (1))); 
# 984
static const UnsignedBits LOWEST_KEY = ((UnsignedBits)(-1)); 
# 985
static const UnsignedBits MAX_KEY = (((UnsignedBits)(-1)) ^ HIGH_BIT); 
# 988
enum { 
# 989
PRIMITIVE = true, 
# 990
NULL_TYPE = false
# 991
}; 
# 993
__attribute((always_inline)) static UnsignedBits TwiddleIn(UnsignedBits key) 
# 994
{int volatile ___ = 1;(void)key;
# 997
::exit(___);}
#if 0
# 994
{ 
# 995
UnsignedBits mask = (key & HIGH_BIT) ? (UnsignedBits)(-1) : HIGH_BIT; 
# 996
return key ^ mask; 
# 997
} 
#endif
# 999 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static UnsignedBits TwiddleOut(UnsignedBits key) 
# 1000
{int volatile ___ = 1;(void)key;
# 1003
::exit(___);}
#if 0
# 1000
{ 
# 1001
UnsignedBits mask = (key & HIGH_BIT) ? HIGH_BIT : ((UnsignedBits)(-1)); 
# 1002
return key ^ mask; 
# 1003
} 
#endif
# 1005 "/usr/local/cuda/include/cub/util_type.cuh"
__attribute((always_inline)) static T Max() { 
# 1006
return FpLimits< T> ::Max(); 
# 1007
} 
# 1009
__attribute((always_inline)) static T Lowest() { 
# 1010
return FpLimits< T> ::Lowest(); 
# 1011
} 
# 1012
}; 
# 1018
template< class T> struct NumericTraits : public BaseTraits< NOT_A_NUMBER, false, false, T, T>  { }; 
# 1020
template<> struct NumericTraits< NullType>  : public BaseTraits< NOT_A_NUMBER, false, true, NullType, NullType>  { }; 
# 1022
template<> struct NumericTraits< char>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned char, char>  { }; 
# 1023
template<> struct NumericTraits< signed char>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned char, signed char>  { }; 
# 1024
template<> struct NumericTraits< short>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned short, short>  { }; 
# 1025
template<> struct NumericTraits< int>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned, int>  { }; 
# 1026
template<> struct NumericTraits< long>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned long, long>  { }; 
# 1027
template<> struct NumericTraits< long long>  : public BaseTraits< SIGNED_INTEGER, true, false, unsigned long long, long long>  { }; 
# 1029
template<> struct NumericTraits< unsigned char>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned char, unsigned char>  { }; 
# 1030
template<> struct NumericTraits< unsigned short>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned short, unsigned short>  { }; 
# 1031
template<> struct NumericTraits< unsigned>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned, unsigned>  { }; 
# 1032
template<> struct NumericTraits< unsigned long>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned long, unsigned long>  { }; 
# 1033
template<> struct NumericTraits< unsigned long long>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned long long, unsigned long long>  { }; 
# 1035
template<> struct NumericTraits< float>  : public BaseTraits< FLOATING_POINT, true, false, unsigned, float>  { }; 
# 1036
template<> struct NumericTraits< double>  : public BaseTraits< FLOATING_POINT, true, false, unsigned long long, double>  { }; 
# 1038
template<> struct NumericTraits< bool>  : public BaseTraits< UNSIGNED_INTEGER, true, false, unsigned char, bool>  { }; 
# 1045
template< class T> 
# 1046
struct Traits : public NumericTraits< typename RemoveQualifiers< T> ::Type>  { }; 
# 1054
}
# 46 "/usr/local/cuda/include/cub/util_device.cuh"
namespace cub { 
# 60
template< int ALLOCATIONS> 
# 61
__attribute((always_inline)) inline cudaError_t 
# 62
AliasTemporaries(void *
# 63
d_temp_storage, size_t &
# 64
temp_storage_bytes, void *(&
# 65
allocations)[ALLOCATIONS], size_t (&
# 66
allocation_sizes)[ALLOCATIONS]) 
# 67
{ 
# 68
const int ALIGN_BYTES = 256; 
# 69
const int ALIGN_MASK = (~(ALIGN_BYTES - 1)); 
# 72
size_t allocation_offsets[ALLOCATIONS]; 
# 73
size_t bytes_needed = (0); 
# 74
for (int i = 0; i < ALLOCATIONS; ++i) 
# 75
{ 
# 76
size_t allocation_bytes = ((((allocation_sizes)[i]) + ALIGN_BYTES) - 1) & ALIGN_MASK; 
# 77
((allocation_offsets)[i]) = bytes_needed; 
# 78
bytes_needed += allocation_bytes; 
# 79
}  
# 80
bytes_needed += (ALIGN_BYTES - 1); 
# 83
if (!d_temp_storage) 
# 84
{ 
# 85
temp_storage_bytes = bytes_needed; 
# 86
return cudaSuccess; 
# 87
}  
# 90
if (temp_storage_bytes < bytes_needed) 
# 91
{ 
# 92
return cub::Debug(cudaErrorInvalidValue, "/usr/local/cuda/include/cub/util_device.cuh", 92); 
# 93
}  
# 96
d_temp_storage = ((void *)(((((size_t)d_temp_storage) + ALIGN_BYTES) - (1)) & ALIGN_MASK)); 
# 97
for (int i = 0; i < ALLOCATIONS; ++i) 
# 98
{ 
# 99
((allocations)[i]) = ((static_cast< char *>(d_temp_storage)) + ((allocation_offsets)[i])); 
# 100
}  
# 102
return cudaSuccess; 
# 103
} 
# 109
template< class T> static void 
# 110
__wrapper__device_stub_EmptyKernel() {exit(1);}
#if 0
# 110
{ } 
#endif
# 109 "/usr/local/cuda/include/cub/util_device.cuh"
template< class T> void 
# 110
EmptyKernel() {__wrapper__device_stub_EmptyKernel<T>();return;}
#if 0
# 110
{ } 
#endif
# 118 "/usr/local/cuda/include/cub/util_device.cuh"
__attribute((always_inline)) inline cudaError_t PtxVersion(int &ptx_version) 
# 119
{ 
# 120
struct Dummy { 
# 123
typedef void (*EmptyKernelPtr)(void); 
# 126
__attribute((always_inline)) EmptyKernelPtr 
# 127
Empty() 
# 128
{ 
# 129
return EmptyKernel< void> ; 
# 130
} 
# 131
}; 
# 146
cudaError_t error = cudaSuccess; 
# 147
do 
# 148
{ 
# 149
cudaFuncAttributes empty_kernel_attrs; 
# 150
if (cub::Debug(error = cudaFuncGetAttributes(&empty_kernel_attrs, EmptyKernel< void> ), "/usr/local/cuda/include/cub/util_device.cuh", 150)) { break; }  
# 151
ptx_version = ((empty_kernel_attrs.ptxVersion) * 10); 
# 152
} 
# 153
while (0); 
# 155
return error; 
# 158
} 
# 164
__attribute((always_inline)) inline cudaError_t SmVersion(int &sm_version, int device_ordinal) 
# 165
{ 
# 173
cudaError_t error = cudaSuccess; 
# 174
do 
# 175
{ 
# 177
int major, minor; 
# 178
if (cub::Debug(error = cudaDeviceGetAttribute(&major, cudaDevAttrComputeCapabilityMajor, device_ordinal), "/usr/local/cuda/include/cub/util_device.cuh", 178)) { break; }  
# 179
if (cub::Debug(error = cudaDeviceGetAttribute(&minor, cudaDevAttrComputeCapabilityMinor, device_ordinal), "/usr/local/cuda/include/cub/util_device.cuh", 179)) { break; }  
# 180
sm_version = ((major * 100) + (minor * 10)); 
# 181
} 
# 182
while (0); 
# 184
return error; 
# 187
} 
# 195
__attribute((always_inline)) static inline cudaError_t 
# 196
SyncStream(cudaStream_t stream) 
# 197
{ 
# 199
return cudaStreamSynchronize(stream); 
# 204
} 
# 238
template< class KernelPtr> 
# 239
__attribute((always_inline)) inline cudaError_t 
# 240
MaxSmOccupancy(int &
# 241
max_sm_occupancy, KernelPtr 
# 242
kernel_ptr, int 
# 243
block_threads, int 
# 244
dynamic_smem_bytes = 0) 
# 245
{ 
# 253
return cudaOccupancyMaxActiveBlocksPerMultiprocessor(&max_sm_occupancy, kernel_ptr, block_threads, dynamic_smem_bytes); 
# 260
} 
# 270
struct KernelConfig { 
# 272
int block_threads; 
# 273
int items_per_thread; 
# 274
int tile_size; 
# 275
int sm_occupancy; 
# 277
__attribute((always_inline)) 
# 278
KernelConfig() : block_threads(0), items_per_thread(0), tile_size(0), sm_occupancy(0) { } 
# 280
template< class AgentPolicyT, class KernelPtrT> 
# 281
__attribute((always_inline)) cudaError_t 
# 282
Init(KernelPtrT kernel_ptr) 
# 283
{ 
# 284
(block_threads) = AgentPolicyT::BLOCK_THREADS; 
# 285
(items_per_thread) = AgentPolicyT::ITEMS_PER_THREAD; 
# 286
(tile_size) = ((block_threads) * (items_per_thread)); 
# 287
cudaError_t retval = MaxSmOccupancy(sm_occupancy, kernel_ptr, block_threads); 
# 288
return retval; 
# 289
} 
# 290
}; 
# 295
template< int PTX_VERSION, class PolicyT, class PrevPolicyT> 
# 296
struct ChainedPolicy { 
# 299
typedef typename If< 0 < PTX_VERSION, typename PrevPolicyT::ActivePolicy, PolicyT> ::Type ActivePolicy; 
# 302
template< class FunctorT> 
# 303
__attribute((always_inline)) static cudaError_t 
# 304
Invoke(int ptx_version, FunctorT &op) 
# 305
{ 
# 306
if (ptx_version < PTX_VERSION) { 
# 307
return PrevPolicyT::Invoke(ptx_version, op); 
# 308
}  
# 309
return (op.template Invoke< PolicyT> ()); 
# 310
} 
# 311
}; 
# 314
template< int PTX_VERSION, class PolicyT> 
# 315
struct ChainedPolicy< PTX_VERSION, PolicyT, PolicyT>  { 
# 318
typedef PolicyT ActivePolicy; 
# 321
template< class FunctorT> 
# 322
__attribute((always_inline)) static cudaError_t 
# 323
Invoke(int ptx_version, FunctorT &op) { 
# 324
return (op.template Invoke< PolicyT> ()); 
# 325
} 
# 326
}; 
# 338
}
# 72 "/usr/include/c++/5/bits/stl_tree.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 92
enum _Rb_tree_color { _S_red, _S_black}; 
# 94
struct _Rb_tree_node_base { 
# 96
typedef _Rb_tree_node_base *_Base_ptr; 
# 97
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 99
_Rb_tree_color _M_color; 
# 100
_Base_ptr _M_parent; 
# 101
_Base_ptr _M_left; 
# 102
_Base_ptr _M_right; 
# 105
static _Base_ptr _S_minimum(_Base_ptr __x) 
# 106
{ 
# 107
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 108
return __x; 
# 109
} 
# 112
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) 
# 113
{ 
# 114
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 115
return __x; 
# 116
} 
# 119
static _Base_ptr _S_maximum(_Base_ptr __x) 
# 120
{ 
# 121
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 122
return __x; 
# 123
} 
# 126
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) 
# 127
{ 
# 128
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 129
return __x; 
# 130
} 
# 131
}; 
# 133
template< class _Val> 
# 134
struct _Rb_tree_node : public _Rb_tree_node_base { 
# 136
typedef _Rb_tree_node *_Link_type; 
# 139
_Val _M_value_field; 
# 142
_Val *_M_valptr() 
# 143
{ return std::__addressof(_M_value_field); } 
# 146
const _Val *_M_valptr() const 
# 147
{ return std::__addressof(_M_value_field); } 
# 159
}; 
# 161
__attribute((__pure__)) _Rb_tree_node_base *
# 162
_Rb_tree_increment(_Rb_tree_node_base * __x) throw(); 
# 164
__attribute((__pure__)) const _Rb_tree_node_base *
# 165
_Rb_tree_increment(const _Rb_tree_node_base * __x) throw(); 
# 167
__attribute((__pure__)) _Rb_tree_node_base *
# 168
_Rb_tree_decrement(_Rb_tree_node_base * __x) throw(); 
# 170
__attribute((__pure__)) const _Rb_tree_node_base *
# 171
_Rb_tree_decrement(const _Rb_tree_node_base * __x) throw(); 
# 173
template< class _Tp> 
# 174
struct _Rb_tree_iterator { 
# 176
typedef _Tp value_type; 
# 177
typedef _Tp &reference; 
# 178
typedef _Tp *pointer; 
# 180
typedef bidirectional_iterator_tag iterator_category; 
# 181
typedef ptrdiff_t difference_type; 
# 183
typedef _Rb_tree_iterator _Self; 
# 184
typedef _Rb_tree_node_base::_Base_ptr _Base_ptr; 
# 185
typedef _Rb_tree_node< _Tp>  *_Link_type; 
# 187
_Rb_tree_iterator() : _M_node() 
# 188
{ } 
# 191
explicit _Rb_tree_iterator(_Base_ptr __x) : _M_node(__x) 
# 192
{ } 
# 195
reference operator*() const 
# 196
{ return *((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 199
pointer operator->() const 
# 200
{ return ((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 203
_Self &operator++() 
# 204
{ 
# 205
(_M_node) = _Rb_tree_increment(_M_node); 
# 206
return *this; 
# 207
} 
# 210
_Self operator++(int) 
# 211
{ 
# 212
_Self __tmp = *this; 
# 213
(_M_node) = _Rb_tree_increment(_M_node); 
# 214
return __tmp; 
# 215
} 
# 218
_Self &operator--() 
# 219
{ 
# 220
(_M_node) = _Rb_tree_decrement(_M_node); 
# 221
return *this; 
# 222
} 
# 225
_Self operator--(int) 
# 226
{ 
# 227
_Self __tmp = *this; 
# 228
(_M_node) = _Rb_tree_decrement(_M_node); 
# 229
return __tmp; 
# 230
} 
# 233
bool operator==(const _Self &__x) const 
# 234
{ return (_M_node) == (__x._M_node); } 
# 237
bool operator!=(const _Self &__x) const 
# 238
{ return (_M_node) != (__x._M_node); } 
# 240
_Base_ptr _M_node; 
# 241
}; 
# 243
template< class _Tp> 
# 244
struct _Rb_tree_const_iterator { 
# 246
typedef _Tp value_type; 
# 247
typedef const _Tp &reference; 
# 248
typedef const _Tp *pointer; 
# 250
typedef _Rb_tree_iterator< _Tp>  iterator; 
# 252
typedef bidirectional_iterator_tag iterator_category; 
# 253
typedef ptrdiff_t difference_type; 
# 255
typedef _Rb_tree_const_iterator _Self; 
# 256
typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr; 
# 257
typedef const _Rb_tree_node< _Tp>  *_Link_type; 
# 259
_Rb_tree_const_iterator() : _M_node() 
# 260
{ } 
# 263
explicit _Rb_tree_const_iterator(_Base_ptr __x) : _M_node(__x) 
# 264
{ } 
# 266
_Rb_tree_const_iterator(const iterator &__it) : _M_node(((__it._M_node))) 
# 267
{ } 
# 270
iterator _M_const_cast() const 
# 271
{ return ((iterator)(const_cast< typename _Rb_tree_iterator< _Tp> ::_Base_ptr>(_M_node))); } 
# 274
reference operator*() const 
# 275
{ return *((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 278
pointer operator->() const 
# 279
{ return ((static_cast< _Link_type>(_M_node))->_M_valptr()); } 
# 282
_Self &operator++() 
# 283
{ 
# 284
(_M_node) = _Rb_tree_increment(_M_node); 
# 285
return *this; 
# 286
} 
# 289
_Self operator++(int) 
# 290
{ 
# 291
_Self __tmp = *this; 
# 292
(_M_node) = _Rb_tree_increment(_M_node); 
# 293
return __tmp; 
# 294
} 
# 297
_Self &operator--() 
# 298
{ 
# 299
(_M_node) = _Rb_tree_decrement(_M_node); 
# 300
return *this; 
# 301
} 
# 304
_Self operator--(int) 
# 305
{ 
# 306
_Self __tmp = *this; 
# 307
(_M_node) = _Rb_tree_decrement(_M_node); 
# 308
return __tmp; 
# 309
} 
# 312
bool operator==(const _Self &__x) const 
# 313
{ return (_M_node) == (__x._M_node); } 
# 316
bool operator!=(const _Self &__x) const 
# 317
{ return (_M_node) != (__x._M_node); } 
# 319
_Base_ptr _M_node; 
# 320
}; 
# 322
template< class _Val> inline bool 
# 324
operator==(const _Rb_tree_iterator< _Val>  &__x, const _Rb_tree_const_iterator< _Val>  &
# 325
__y) 
# 326
{ return (__x._M_node) == (__y._M_node); } 
# 328
template< class _Val> inline bool 
# 330
operator!=(const _Rb_tree_iterator< _Val>  &__x, const _Rb_tree_const_iterator< _Val>  &
# 331
__y) 
# 332
{ return (__x._M_node) != (__y._M_node); } 
# 335
void _Rb_tree_insert_and_rebalance(const bool __insert_left, _Rb_tree_node_base * __x, _Rb_tree_node_base * __p, _Rb_tree_node_base & __header) throw(); 
# 341
_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(_Rb_tree_node_base *const __z, _Rb_tree_node_base & __header) throw(); 
# 345
template< class _Key, class _Val, class _KeyOfValue, class 
# 346
_Compare, class _Alloc = allocator< _Val> > 
# 347
class _Rb_tree { 
# 350
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other _Node_allocator; 
# 352
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other>  _Alloc_traits; 
# 355
protected: typedef _Rb_tree_node_base *_Base_ptr; 
# 356
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 357
typedef _Rb_tree_node< _Val>  *_Link_type; 
# 358
typedef const _Rb_tree_node< _Val>  *_Const_Link_type; 
# 363
private: struct _Reuse_or_alloc_node { 
# 365
_Reuse_or_alloc_node(_Rb_tree &__t) : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t) 
# 367
{ 
# 368
if (_M_root) 
# 369
{ 
# 370
((_M_root)->_M_parent) = (0); 
# 372
if ((_M_nodes)->_M_left) { 
# 373
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 374
} else { 
# 376
(_M_nodes) = (0); }  
# 377
} 
# 383
~_Reuse_or_alloc_node() 
# 384
{ (_M_t)._M_erase(static_cast< _Link_type>(_M_root)); } 
# 386
template< class _Arg> _Link_type 
# 389
operator()(const _Arg &__arg) 
# 393
{ 
# 394
_Link_type __node = static_cast< _Link_type>(_M_extract()); 
# 395
if (__node) 
# 396
{ 
# 397
(_M_t)._M_destroy_node(__node); 
# 398
(_M_t)._M_construct_node(__node, __arg); 
# 399
return __node; 
# 400
}  
# 402
return (_M_t)._M_create_node(__arg); 
# 403
} 
# 407
private: _Base_ptr _M_extract() 
# 408
{ 
# 409
if (!(_M_nodes)) { 
# 410
return _M_nodes; }  
# 412
_Base_ptr __node = _M_nodes; 
# 413
(_M_nodes) = ((_M_nodes)->_M_parent); 
# 414
if (_M_nodes) 
# 415
{ 
# 416
if (((_M_nodes)->_M_right) == __node) 
# 417
{ 
# 418
((_M_nodes)->_M_right) = (0); 
# 420
if ((_M_nodes)->_M_left) 
# 421
{ 
# 422
(_M_nodes) = ((_M_nodes)->_M_left); 
# 424
while ((_M_nodes)->_M_right) { 
# 425
(_M_nodes) = ((_M_nodes)->_M_right); }  
# 427
if ((_M_nodes)->_M_left) { 
# 428
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 429
}  
# 430
} else { 
# 432
((_M_nodes)->_M_left) = (0); }  
# 433
} else { 
# 435
(_M_root) = (0); }  
# 437
return __node; 
# 438
} 
# 440
_Base_ptr _M_root; 
# 441
_Base_ptr _M_nodes; 
# 442
_Rb_tree &_M_t; 
# 443
}; 
# 447
struct _Alloc_node { 
# 449
_Alloc_node(_Rb_tree &__t) : _M_t(__t) 
# 450
{ } 
# 452
template< class _Arg> _Link_type 
# 455
operator()(const _Arg &__arg) const 
# 459
{ return (_M_t)._M_create_node(__arg); } 
# 462
private: _Rb_tree &_M_t; 
# 463
}; 
# 466
public: typedef _Key key_type; 
# 467
typedef _Val value_type; 
# 468
typedef value_type *pointer; 
# 469
typedef const value_type *const_pointer; 
# 470
typedef value_type &reference; 
# 471
typedef const value_type &const_reference; 
# 472
typedef size_t size_type; 
# 473
typedef ptrdiff_t difference_type; 
# 474
typedef _Alloc allocator_type; 
# 477
_Node_allocator &_M_get_Node_allocator() 
# 478
{ return *(static_cast< _Node_allocator *>(&(this->_M_impl))); } 
# 481
const _Node_allocator &_M_get_Node_allocator() const 
# 482
{ return *(static_cast< const _Node_allocator *>(&(this->_M_impl))); } 
# 485
allocator_type get_allocator() const 
# 486
{ return (allocator_type)this->_M_get_Node_allocator(); } 
# 490
protected: _Link_type _M_get_node() 
# 491
{ return _Alloc_traits::allocate(this->_M_get_Node_allocator(), 1); } 
# 494
void _M_put_node(_Link_type __p) 
# 495
{ _Alloc_traits::deallocate(this->_M_get_Node_allocator(), __p, 1); } 
# 499
void _M_construct_node(_Link_type __node, const value_type &__x) 
# 500
{ 
# 501
try 
# 502
{ (get_allocator().construct((__node->_M_valptr()), __x)); } 
# 503
catch (...) 
# 504
{ 
# 505
_M_put_node(__node); 
# 506
throw; 
# 507
}  
# 508
} 
# 511
_Link_type _M_create_node(const value_type &__x) 
# 512
{ 
# 513
_Link_type __tmp = _M_get_node(); 
# 514
_M_construct_node(__tmp, __x); 
# 515
return __tmp; 
# 516
} 
# 519
void _M_destroy_node(_Link_type __p) 
# 520
{ (get_allocator().destroy((__p->_M_valptr()))); } 
# 559
void _M_drop_node(_Link_type __p) 
# 560
{ 
# 561
_M_destroy_node(__p); 
# 562
_M_put_node(__p); 
# 563
} 
# 565
template< class _NodeGen> _Link_type 
# 567
_M_clone_node(_Const_Link_type __x, _NodeGen &__node_gen) 
# 568
{ 
# 569
_Link_type __tmp = __node_gen(*(__x->_M_valptr())); 
# 570
(__tmp->_M_color) = (__x->_M_color); 
# 571
(__tmp->_M_left) = 0; 
# 572
(__tmp->_M_right) = 0; 
# 573
return __tmp; 
# 574
} 
# 578
template< class _Key_compare, bool 
# 579
 = __is_pod(_Key_compare)> 
# 580
struct _Rb_tree_impl : public _Node_allocator { 
# 582
_Key_compare _M_key_compare; 
# 583
::std::_Rb_tree_node_base _M_header; 
# 584
typename ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type _M_node_count; 
# 586
_Rb_tree_impl() : ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(), _M_key_compare(), _M_header(), _M_node_count((0)) 
# 589
{ _M_initialize(); } 
# 591
_Rb_tree_impl(const _Key_compare &__comp, const typename ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &__a) : ::std::_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(__a), _M_key_compare(__comp), _M_header(), _M_node_count((0)) 
# 594
{ _M_initialize(); } 
# 604
void _M_reset() 
# 605
{ 
# 606
((this->_M_header)._M_parent) = (0); 
# 607
((this->_M_header)._M_left) = (&(this->_M_header)); 
# 608
((this->_M_header)._M_right) = (&(this->_M_header)); 
# 609
(this->_M_node_count) = (0); 
# 610
} 
# 614
private: void _M_initialize() 
# 615
{ 
# 616
((this->_M_header)._M_color) = _S_red; 
# 617
((this->_M_header)._M_parent) = (0); 
# 618
((this->_M_header)._M_left) = (&(this->_M_header)); 
# 619
((this->_M_header)._M_right) = (&(this->_M_header)); 
# 620
} 
# 621
}; 
# 623
_Rb_tree_impl< _Compare>  _M_impl; 
# 627
_Base_ptr &_M_root() 
# 628
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 631
_Const_Base_ptr _M_root() const 
# 632
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 635
_Base_ptr &_M_leftmost() 
# 636
{ return ((this->_M_impl)._M_header)._M_left; } 
# 639
_Const_Base_ptr _M_leftmost() const 
# 640
{ return ((this->_M_impl)._M_header)._M_left; } 
# 643
_Base_ptr &_M_rightmost() 
# 644
{ return ((this->_M_impl)._M_header)._M_right; } 
# 647
_Const_Base_ptr _M_rightmost() const 
# 648
{ return ((this->_M_impl)._M_header)._M_right; } 
# 651
_Link_type _M_begin() 
# 652
{ return static_cast< _Link_type>(((this->_M_impl)._M_header)._M_parent); } 
# 655
_Const_Link_type _M_begin() const 
# 656
{ 
# 657
return static_cast< _Const_Link_type>(((this->_M_impl)._M_header)._M_parent); 
# 659
} 
# 662
_Link_type _M_end() 
# 663
{ return reinterpret_cast< _Link_type>(&((this->_M_impl)._M_header)); } 
# 666
_Const_Link_type _M_end() const 
# 667
{ return reinterpret_cast< _Const_Link_type>(&((this->_M_impl)._M_header)); } 
# 670
static const_reference _S_value(_Const_Link_type __x) 
# 671
{ return *(__x->_M_valptr()); } 
# 674
static const _Key &_S_key(_Const_Link_type __x) 
# 675
{ return _KeyOfValue()(_S_value(__x)); } 
# 678
static _Link_type _S_left(_Base_ptr __x) 
# 679
{ return static_cast< _Link_type>(__x->_M_left); } 
# 682
static _Const_Link_type _S_left(_Const_Base_ptr __x) 
# 683
{ return static_cast< _Const_Link_type>(__x->_M_left); } 
# 686
static _Link_type _S_right(_Base_ptr __x) 
# 687
{ return static_cast< _Link_type>(__x->_M_right); } 
# 690
static _Const_Link_type _S_right(_Const_Base_ptr __x) 
# 691
{ return static_cast< _Const_Link_type>(__x->_M_right); } 
# 694
static const_reference _S_value(_Const_Base_ptr __x) 
# 695
{ return *((static_cast< _Const_Link_type>(__x))->_M_valptr()); } 
# 698
static const _Key &_S_key(_Const_Base_ptr __x) 
# 699
{ return _KeyOfValue()(_S_value(__x)); } 
# 702
static _Base_ptr _S_minimum(_Base_ptr __x) 
# 703
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 706
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) 
# 707
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 710
static _Base_ptr _S_maximum(_Base_ptr __x) 
# 711
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 714
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) 
# 715
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 718
public: typedef _Rb_tree_iterator< _Val>  iterator; 
# 719
typedef _Rb_tree_const_iterator< _Val>  const_iterator; 
# 721
typedef std::reverse_iterator< _Rb_tree_iterator< _Val> >  reverse_iterator; 
# 722
typedef std::reverse_iterator< _Rb_tree_const_iterator< _Val> >  const_reverse_iterator; 
# 726
private: pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_unique_pos(const key_type & __k); 
# 729
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_equal_pos(const key_type & __k); 
# 732
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_unique_pos(const_iterator __pos, const key_type & __k); 
# 736
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_equal_pos(const_iterator __pos, const key_type & __k); 
# 761
template< class _NodeGen> iterator _M_insert_(_Base_ptr __x, _Base_ptr __y, const value_type & __v, _NodeGen &); 
# 769
iterator _M_insert_lower(_Base_ptr __y, const value_type & __v); 
# 772
iterator _M_insert_equal_lower(const value_type & __x); 
# 775
template< class _NodeGen> _Link_type _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen &); 
# 780
_Link_type _M_copy(_Const_Link_type __x, _Link_type __p) 
# 781
{ 
# 782
_Alloc_node __an(*this); 
# 783
return _M_copy(__x, __p, __an); 
# 784
} 
# 787
void _M_erase(_Link_type __x); 
# 790
iterator _M_lower_bound(_Link_type __x, _Link_type __y, const _Key & __k); 
# 794
const_iterator _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const; 
# 798
iterator _M_upper_bound(_Link_type __x, _Link_type __y, const _Key & __k); 
# 802
const_iterator _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key & __k) const; 
# 807
public: _Rb_tree() { } 
# 809
_Rb_tree(const _Compare &__comp, const allocator_type &
# 810
__a = allocator_type()) : _M_impl(__comp, (_Node_allocator)__a) 
# 811
{ } 
# 813
_Rb_tree(const _Rb_tree &__x) : _M_impl(((__x._M_impl)._M_key_compare), _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator())) 
# 816
{ 
# 817
if (__x._M_root() != (0)) 
# 818
{ 
# 819
this->_M_root() = _M_copy(__x._M_begin(), this->_M_end()); 
# 820
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 821
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 822
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 823
}  
# 824
} 
# 857
~_Rb_tree() 
# 858
{ _M_erase(this->_M_begin()); } 
# 861
_Rb_tree &operator=(const _Rb_tree & __x); 
# 865
_Compare key_comp() const 
# 866
{ return (_M_impl)._M_key_compare; } 
# 869
iterator begin() 
# 870
{ return ((iterator)((((this->_M_impl)._M_header)._M_left))); } 
# 873
const_iterator begin() const 
# 874
{ return ((const_iterator)((((this->_M_impl)._M_header)._M_left))); } 
# 877
iterator end() 
# 878
{ return ((iterator)(&((this->_M_impl)._M_header))); } 
# 881
const_iterator end() const 
# 882
{ return ((const_iterator)(&((this->_M_impl)._M_header))); } 
# 885
reverse_iterator rbegin() 
# 886
{ return ((reverse_iterator)(this->end())); } 
# 889
const_reverse_iterator rbegin() const 
# 890
{ return ((const_reverse_iterator)(this->end())); } 
# 893
reverse_iterator rend() 
# 894
{ return ((reverse_iterator)(this->begin())); } 
# 897
const_reverse_iterator rend() const 
# 898
{ return ((const_reverse_iterator)(this->begin())); } 
# 901
bool empty() const 
# 902
{ return ((_M_impl)._M_node_count) == 0; } 
# 905
size_type size() const 
# 906
{ return (_M_impl)._M_node_count; } 
# 909
size_type max_size() const 
# 910
{ return _Alloc_traits::max_size(this->_M_get_Node_allocator()); } 
# 916
void swap(_Rb_tree & __t); 
# 970
pair< _Rb_tree_iterator< _Val> , bool>  _M_insert_unique(const value_type & __x); 
# 973
iterator _M_insert_equal(const value_type & __x); 
# 975
template< class _NodeGen> iterator _M_insert_unique_(const_iterator __pos, const value_type & __x, _NodeGen &); 
# 981
iterator _M_insert_unique_(const_iterator __pos, const value_type &__x) 
# 982
{ 
# 983
_Alloc_node __an(*this); 
# 984
return _M_insert_unique_(__pos, __x, __an); 
# 985
} 
# 987
template< class _NodeGen> iterator _M_insert_equal_(const_iterator __pos, const value_type & __x, _NodeGen &); 
# 992
iterator _M_insert_equal_(const_iterator __pos, const value_type &__x) 
# 993
{ 
# 994
_Alloc_node __an(*this); 
# 995
return _M_insert_equal_(__pos, __x, __an); 
# 996
} 
# 999
template< class _InputIterator> void _M_insert_unique(_InputIterator __first, _InputIterator __last); 
# 1003
template< class _InputIterator> void _M_insert_equal(_InputIterator __first, _InputIterator __last); 
# 1009
private: void _M_erase_aux(const_iterator __position); 
# 1012
void _M_erase_aux(const_iterator __first, const_iterator __last); 
# 1040
public: void erase(iterator __position) 
# 1041
{ _M_erase_aux(__position); } 
# 1044
void erase(const_iterator __position) 
# 1045
{ _M_erase_aux(__position); } 
# 1048
size_type erase(const key_type & __x); 
# 1062
void erase(iterator __first, iterator __last) 
# 1063
{ _M_erase_aux(__first, __last); } 
# 1066
void erase(const_iterator __first, const_iterator __last) 
# 1067
{ _M_erase_aux(__first, __last); } 
# 1070
void erase(const key_type * __first, const key_type * __last); 
# 1073
void clear() 
# 1074
{ 
# 1075
_M_erase(this->_M_begin()); 
# 1076
((_M_impl)._M_reset()); 
# 1077
} 
# 1081
iterator find(const key_type & __k); 
# 1084
const_iterator find(const key_type & __k) const; 
# 1087
size_type count(const key_type & __k) const; 
# 1090
iterator lower_bound(const key_type &__k) 
# 1091
{ return _M_lower_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1094
const_iterator lower_bound(const key_type &__k) const 
# 1095
{ return _M_lower_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1098
iterator upper_bound(const key_type &__k) 
# 1099
{ return _M_upper_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1102
const_iterator upper_bound(const key_type &__k) const 
# 1103
{ return _M_upper_bound(this->_M_begin(), this->_M_end(), __k); } 
# 1106
pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  equal_range(const key_type & __k); 
# 1109
pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  equal_range(const key_type & __k) const; 
# 1244
bool __rb_verify() const; 
# 1268
}; 
# 1270
template< class _Key, class _Val, class _KeyOfValue, class 
# 1271
_Compare, class _Alloc> inline bool 
# 1273
operator==(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1274
__y) 
# 1275
{ 
# 1276
return ((__x.size()) == (__y.size())) && std::equal((__x.begin()), (__x.end()), (__y.begin())); 
# 1278
} 
# 1280
template< class _Key, class _Val, class _KeyOfValue, class 
# 1281
_Compare, class _Alloc> inline bool 
# 1283
operator<(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1284
__y) 
# 1285
{ 
# 1286
return std::lexicographical_compare((__x.begin()), (__x.end()), (__y.begin()), (__y.end())); 
# 1288
} 
# 1290
template< class _Key, class _Val, class _KeyOfValue, class 
# 1291
_Compare, class _Alloc> inline bool 
# 1293
operator!=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1294
__y) 
# 1295
{ return !(__x == __y); } 
# 1297
template< class _Key, class _Val, class _KeyOfValue, class 
# 1298
_Compare, class _Alloc> inline bool 
# 1300
operator>(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1301
__y) 
# 1302
{ return __y < __x; } 
# 1304
template< class _Key, class _Val, class _KeyOfValue, class 
# 1305
_Compare, class _Alloc> inline bool 
# 1307
operator<=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1308
__y) 
# 1309
{ return !(__y < __x); } 
# 1311
template< class _Key, class _Val, class _KeyOfValue, class 
# 1312
_Compare, class _Alloc> inline bool 
# 1314
operator>=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1315
__y) 
# 1316
{ return !(__x < __y); } 
# 1318
template< class _Key, class _Val, class _KeyOfValue, class 
# 1319
_Compare, class _Alloc> inline void 
# 1321
swap(_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1322
__y) 
# 1323
{ (__x.swap(__y)); } 
# 1448
template< class _Key, class _Val, class _KeyOfValue, class 
# 1449
_Compare, class _Alloc> _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1452
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::operator=(const _Rb_tree &__x) 
# 1453
{ 
# 1454
if (this != (&__x)) 
# 1455
{ 
# 1473
_Reuse_or_alloc_node __roan(*this); 
# 1474
((_M_impl)._M_reset()); 
# 1475
((_M_impl)._M_key_compare) = ((__x._M_impl)._M_key_compare); 
# 1476
if (__x._M_root() != (0)) 
# 1477
{ 
# 1478
this->_M_root() = _M_copy(__x._M_begin(), this->_M_end(), __roan); 
# 1479
this->_M_leftmost() = _S_minimum(this->_M_root()); 
# 1480
this->_M_rightmost() = _S_maximum(this->_M_root()); 
# 1481
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 1482
}  
# 1483
}  
# 1485
return *this; 
# 1486
} 
# 1488
template< class _Key, class _Val, class _KeyOfValue, class 
# 1489
_Compare, class _Alloc> 
# 1493
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1497
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val &
# 1501
__v, _NodeGen &
# 1503
__node_gen) 
# 1504
{ 
# 1505
bool __insert_left = ((__x != (0)) || (__p == this->_M_end())) || ((_M_impl)._M_key_compare(_KeyOfValue()(__v), _S_key(__p))); 
# 1509
_Link_type __z = __node_gen(__v); 
# 1511
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1513
++((_M_impl)._M_node_count); 
# 1514
return ((iterator)(__z)); 
# 1515
} 
# 1517
template< class _Key, class _Val, class _KeyOfValue, class 
# 1518
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1527
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_lower(_Base_ptr __p, const _Val &__v) 
# 1529
{ 
# 1530
bool __insert_left = (__p == this->_M_end()) || (!((_M_impl)._M_key_compare(_S_key(__p), _KeyOfValue()(__v)))); 
# 1534
_Link_type __z = _M_create_node(__v); 
# 1536
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1538
++((_M_impl)._M_node_count); 
# 1539
return ((iterator)(__z)); 
# 1540
} 
# 1542
template< class _Key, class _Val, class _KeyOfValue, class 
# 1543
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1552
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_lower(const _Val &__v) 
# 1554
{ 
# 1555
_Link_type __x = this->_M_begin(); 
# 1556
_Link_type __y = this->_M_end(); 
# 1557
while (__x != 0) 
# 1558
{ 
# 1559
__y = __x; 
# 1560
__x = ((!((_M_impl)._M_key_compare(_S_key(__x), _KeyOfValue()(__v)))) ? _S_left(__x) : _S_right(__x)); 
# 1562
}  
# 1563
return _M_insert_lower(__y, __v); 
# 1564
} 
# 1566
template< class _Key, class _Val, class _KoV, class 
# 1567
_Compare, class _Alloc> 
# 1568
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_Link_type 
# 1571
_Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen &__node_gen) 
# 1572
{ 
# 1574
_Link_type __top = _M_clone_node(__x, __node_gen); 
# 1575
(__top->_M_parent) = __p; 
# 1577
try 
# 1578
{ 
# 1579
if (__x->_M_right) { 
# 1580
(__top->_M_right) = _M_copy(_S_right(__x), __top, __node_gen); }  
# 1581
__p = __top; 
# 1582
__x = _S_left(__x); 
# 1584
while (__x != 0) 
# 1585
{ 
# 1586
_Link_type __y = _M_clone_node(__x, __node_gen); 
# 1587
(__p->_M_left) = __y; 
# 1588
(__y->_M_parent) = __p; 
# 1589
if (__x->_M_right) { 
# 1590
(__y->_M_right) = _M_copy(_S_right(__x), __y, __node_gen); }  
# 1591
__p = __y; 
# 1592
__x = _S_left(__x); 
# 1593
}  
# 1594
} 
# 1595
catch (...) 
# 1596
{ 
# 1597
_M_erase(__top); 
# 1598
throw; 
# 1599
}  
# 1600
return __top; 
# 1601
} 
# 1603
template< class _Key, class _Val, class _KeyOfValue, class 
# 1604
_Compare, class _Alloc> void 
# 1607
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase(_Link_type __x) 
# 1608
{ 
# 1610
while (__x != 0) 
# 1611
{ 
# 1612
_M_erase(_S_right(__x)); 
# 1613
_Link_type __y = _S_left(__x); 
# 1614
_M_drop_node(__x); 
# 1615
__x = __y; 
# 1616
}  
# 1617
} 
# 1619
template< class _Key, class _Val, class _KeyOfValue, class 
# 1620
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1624
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Link_type __x, _Link_type __y, const _Key &
# 1625
__k) 
# 1626
{ 
# 1627
while (__x != 0) { 
# 1628
if (!((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1629
(__y = __x), (__x = _S_left(__x)); } else { 
# 1631
__x = _S_right(__x); }  }  
# 1632
return ((iterator)(__y)); 
# 1633
} 
# 1635
template< class _Key, class _Val, class _KeyOfValue, class 
# 1636
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1640
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key &
# 1641
__k) const 
# 1642
{ 
# 1643
while (__x != 0) { 
# 1644
if (!((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1645
(__y = __x), (__x = _S_left(__x)); } else { 
# 1647
__x = _S_right(__x); }  }  
# 1648
return ((const_iterator)(__y)); 
# 1649
} 
# 1651
template< class _Key, class _Val, class _KeyOfValue, class 
# 1652
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1656
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Link_type __x, _Link_type __y, const _Key &
# 1657
__k) 
# 1658
{ 
# 1659
while (__x != 0) { 
# 1660
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1661
(__y = __x), (__x = _S_left(__x)); } else { 
# 1663
__x = _S_right(__x); }  }  
# 1664
return ((iterator)(__y)); 
# 1665
} 
# 1667
template< class _Key, class _Val, class _KeyOfValue, class 
# 1668
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1672
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Const_Link_type __x, _Const_Link_type __y, const _Key &
# 1673
__k) const 
# 1674
{ 
# 1675
while (__x != 0) { 
# 1676
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1677
(__y = __x), (__x = _S_left(__x)); } else { 
# 1679
__x = _S_right(__x); }  }  
# 1680
return ((const_iterator)(__y)); 
# 1681
} 
# 1683
template< class _Key, class _Val, class _KeyOfValue, class 
# 1684
_Compare, class _Alloc> pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  
# 1690
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) 
# 1691
{ 
# 1692
_Link_type __x = this->_M_begin(); 
# 1693
_Link_type __y = this->_M_end(); 
# 1694
while (__x != 0) 
# 1695
{ 
# 1696
if (((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1697
__x = _S_right(__x); } else { 
# 1698
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1699
(__y = __x), (__x = _S_left(__x)); } else 
# 1701
{ 
# 1702
_Link_type __xu(__x), __yu(__y); 
# 1703
(__y = __x), (__x = _S_left(__x)); 
# 1704
__xu = _S_right(__xu); 
# 1705
return pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 1708
}  }  
# 1709
}  
# 1710
return pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> > (((iterator)(__y)), ((iterator)(__y))); 
# 1712
} 
# 1714
template< class _Key, class _Val, class _KeyOfValue, class 
# 1715
_Compare, class _Alloc> pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  
# 1721
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) const 
# 1722
{ 
# 1723
_Const_Link_type __x = this->_M_begin(); 
# 1724
_Const_Link_type __y = this->_M_end(); 
# 1725
while (__x != 0) 
# 1726
{ 
# 1727
if (((_M_impl)._M_key_compare(_S_key(__x), __k))) { 
# 1728
__x = _S_right(__x); } else { 
# 1729
if (((_M_impl)._M_key_compare(__k, _S_key(__x)))) { 
# 1730
(__y = __x), (__x = _S_left(__x)); } else 
# 1732
{ 
# 1733
_Const_Link_type __xu(__x), __yu(__y); 
# 1734
(__y = __x), (__x = _S_left(__x)); 
# 1735
__xu = _S_right(__xu); 
# 1736
return pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 1739
}  }  
# 1740
}  
# 1741
return pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> > (((const_iterator)(__y)), ((const_iterator)(__y))); 
# 1743
} 
# 1745
template< class _Key, class _Val, class _KeyOfValue, class 
# 1746
_Compare, class _Alloc> void 
# 1749
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::swap(_Rb_tree &__t) 
# 1753
{ 
# 1754
if (this->_M_root() == (0)) 
# 1755
{ 
# 1756
if (__t._M_root() != (0)) 
# 1757
{ 
# 1758
this->_M_root() = __t._M_root(); 
# 1759
this->_M_leftmost() = __t._M_leftmost(); 
# 1760
this->_M_rightmost() = __t._M_rightmost(); 
# 1761
(this->_M_root()->_M_parent) = this->_M_end(); 
# 1762
((_M_impl)._M_node_count) = ((__t._M_impl)._M_node_count); 
# 1764
((__t._M_impl)._M_reset()); 
# 1765
}  
# 1766
} else { 
# 1767
if (__t._M_root() == (0)) 
# 1768
{ 
# 1769
__t._M_root() = this->_M_root(); 
# 1770
__t._M_leftmost() = this->_M_leftmost(); 
# 1771
__t._M_rightmost() = this->_M_rightmost(); 
# 1772
(__t._M_root()->_M_parent) = __t._M_end(); 
# 1773
((__t._M_impl)._M_node_count) = ((_M_impl)._M_node_count); 
# 1775
((_M_impl)._M_reset()); 
# 1776
} else 
# 1778
{ 
# 1779
std::swap(this->_M_root(), __t._M_root()); 
# 1780
std::swap(this->_M_leftmost(), __t._M_leftmost()); 
# 1781
std::swap(this->_M_rightmost(), __t._M_rightmost()); 
# 1783
(this->_M_root()->_M_parent) = this->_M_end(); 
# 1784
(__t._M_root()->_M_parent) = __t._M_end(); 
# 1785
std::swap(((this->_M_impl)._M_node_count), ((__t._M_impl)._M_node_count)); 
# 1786
}  }  
# 1788
std::swap(((this->_M_impl)._M_key_compare), ((__t._M_impl)._M_key_compare)); 
# 1790
_Alloc_traits::_S_on_swap(this->_M_get_Node_allocator(), __t._M_get_Node_allocator()); 
# 1792
} 
# 1794
template< class _Key, class _Val, class _KeyOfValue, class 
# 1795
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1801
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_unique_pos(const key_type &__k) 
# 1802
{ 
# 1803
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1804
_Link_type __x = this->_M_begin(); 
# 1805
_Link_type __y = this->_M_end(); 
# 1806
bool __comp = true; 
# 1807
while (__x != 0) 
# 1808
{ 
# 1809
__y = __x; 
# 1810
__comp = ((_M_impl)._M_key_compare(__k, _S_key(__x))); 
# 1811
__x = (__comp ? _S_left(__x) : _S_right(__x)); 
# 1812
}  
# 1813
iterator __j = ((iterator)(__y)); 
# 1814
if (__comp) 
# 1815
{ 
# 1816
if (__j == this->begin()) { 
# 1817
return _Res(__x, __y); } else { 
# 1819
--__j; }  
# 1820
}  
# 1821
if (((_M_impl)._M_key_compare(_S_key((__j._M_node)), __k))) { 
# 1822
return _Res(__x, __y); }  
# 1823
return _Res((__j._M_node), 0); 
# 1824
} 
# 1826
template< class _Key, class _Val, class _KeyOfValue, class 
# 1827
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1833
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_equal_pos(const key_type &__k) 
# 1834
{ 
# 1835
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1836
_Link_type __x = this->_M_begin(); 
# 1837
_Link_type __y = this->_M_end(); 
# 1838
while (__x != 0) 
# 1839
{ 
# 1840
__y = __x; 
# 1841
__x = ((((_M_impl)._M_key_compare(__k, _S_key(__x)))) ? _S_left(__x) : _S_right(__x)); 
# 1843
}  
# 1844
return _Res(__x, __y); 
# 1845
} 
# 1847
template< class _Key, class _Val, class _KeyOfValue, class 
# 1848
_Compare, class _Alloc> pair< _Rb_tree_iterator< _Val> , bool>  
# 1858
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique(const _Val &__v) 
# 1860
{ 
# 1861
typedef pair< _Rb_tree_iterator< _Val> , bool>  _Res; 
# 1862
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_unique_pos(_KeyOfValue()(__v)); 
# 1865
if (__res.second) 
# 1866
{ 
# 1867
_Alloc_node __an(*this); 
# 1868
return _Res(_M_insert_(__res.first, __res.second, __v, __an), true); 
# 1871
}  
# 1873
return _Res(((iterator)(static_cast< _Link_type>(__res.first))), false); 
# 1874
} 
# 1876
template< class _Key, class _Val, class _KeyOfValue, class 
# 1877
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1886
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal(const _Val &__v) 
# 1888
{ 
# 1889
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_equal_pos(_KeyOfValue()(__v)); 
# 1891
_Alloc_node __an(*this); 
# 1892
return _M_insert_(__res.first, __res.second, __v, __an); 
# 1894
} 
# 1896
template< class _Key, class _Val, class _KeyOfValue, class 
# 1897
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1903
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_unique_pos(const_iterator __position, const key_type &
# 1904
__k) 
# 1905
{ 
# 1906
iterator __pos = (__position._M_const_cast()); 
# 1907
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1910
if ((__pos._M_node) == this->_M_end()) 
# 1911
{ 
# 1912
if ((size() > 0) && ((_M_impl)._M_key_compare(_S_key(this->_M_rightmost()), __k))) { 
# 1914
return _Res(0, this->_M_rightmost()); } else { 
# 1916
return _M_get_insert_unique_pos(__k); }  
# 1917
} else { 
# 1918
if (((_M_impl)._M_key_compare(__k, _S_key((__pos._M_node))))) 
# 1919
{ 
# 1921
iterator __before = __pos; 
# 1922
if ((__pos._M_node) == this->_M_leftmost()) { 
# 1923
return _Res(this->_M_leftmost(), this->_M_leftmost()); } else { 
# 1924
if (((_M_impl)._M_key_compare(_S_key(((--__before)._M_node)), __k))) 
# 1925
{ 
# 1926
if (_S_right((__before._M_node)) == 0) { 
# 1927
return _Res(0, (__before._M_node)); } else { 
# 1929
return _Res((__pos._M_node), (__pos._M_node)); }  
# 1930
} else { 
# 1932
return _M_get_insert_unique_pos(__k); }  }  
# 1933
} else { 
# 1934
if (((_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k))) 
# 1935
{ 
# 1937
iterator __after = __pos; 
# 1938
if ((__pos._M_node) == this->_M_rightmost()) { 
# 1939
return _Res(0, this->_M_rightmost()); } else { 
# 1940
if (((_M_impl)._M_key_compare(__k, _S_key(((++__after)._M_node))))) 
# 1941
{ 
# 1942
if (_S_right((__pos._M_node)) == 0) { 
# 1943
return _Res(0, (__pos._M_node)); } else { 
# 1945
return _Res((__after._M_node), (__after._M_node)); }  
# 1946
} else { 
# 1948
return _M_get_insert_unique_pos(__k); }  }  
# 1949
} else { 
# 1952
return _Res((__pos._M_node), 0); }  }  }  
# 1953
} 
# 1955
template< class _Key, class _Val, class _KeyOfValue, class 
# 1956
_Compare, class _Alloc> 
# 1960
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1964
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique_(const_iterator __position, const _Val &
# 1968
__v, _NodeGen &
# 1970
__node_gen) 
# 1971
{ 
# 1972
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v)); 
# 1975
if (__res.second) { 
# 1976
return _M_insert_(__res.first, __res.second, __v, __node_gen); }  
# 1979
return ((iterator)(static_cast< _Link_type>(__res.first))); 
# 1980
} 
# 1982
template< class _Key, class _Val, class _KeyOfValue, class 
# 1983
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 1989
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_equal_pos(const_iterator __position, const key_type &__k) 
# 1990
{ 
# 1991
iterator __pos = (__position._M_const_cast()); 
# 1992
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 1995
if ((__pos._M_node) == this->_M_end()) 
# 1996
{ 
# 1997
if ((size() > 0) && (!((_M_impl)._M_key_compare(__k, _S_key(this->_M_rightmost()))))) { 
# 1999
return _Res(0, this->_M_rightmost()); } else { 
# 2001
return _M_get_insert_equal_pos(__k); }  
# 2002
} else { 
# 2003
if (!((_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k))) 
# 2004
{ 
# 2006
iterator __before = __pos; 
# 2007
if ((__pos._M_node) == this->_M_leftmost()) { 
# 2008
return _Res(this->_M_leftmost(), this->_M_leftmost()); } else { 
# 2009
if (!((_M_impl)._M_key_compare(__k, _S_key(((--__before)._M_node))))) 
# 2010
{ 
# 2011
if (_S_right((__before._M_node)) == 0) { 
# 2012
return _Res(0, (__before._M_node)); } else { 
# 2014
return _Res((__pos._M_node), (__pos._M_node)); }  
# 2015
} else { 
# 2017
return _M_get_insert_equal_pos(__k); }  }  
# 2018
} else 
# 2020
{ 
# 2022
iterator __after = __pos; 
# 2023
if ((__pos._M_node) == this->_M_rightmost()) { 
# 2024
return _Res(0, this->_M_rightmost()); } else { 
# 2025
if (!((_M_impl)._M_key_compare(_S_key(((++__after)._M_node)), __k))) 
# 2026
{ 
# 2027
if (_S_right((__pos._M_node)) == 0) { 
# 2028
return _Res(0, (__pos._M_node)); } else { 
# 2030
return _Res((__after._M_node), (__after._M_node)); }  
# 2031
} else { 
# 2033
return _Res(0, 0); }  }  
# 2034
}  }  
# 2035
} 
# 2037
template< class _Key, class _Val, class _KeyOfValue, class 
# 2038
_Compare, class _Alloc> 
# 2042
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2046
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_(const_iterator __position, const _Val &
# 2050
__v, _NodeGen &
# 2052
__node_gen) 
# 2053
{ 
# 2054
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v)); 
# 2057
if (__res.second) { 
# 2058
return _M_insert_(__res.first, __res.second, __v, __node_gen); }  
# 2062
return _M_insert_equal_lower(__v); 
# 2063
} 
# 2215
template< class _Key, class _Val, class _KoV, class 
# 2216
_Cmp, class _Alloc> 
# 2217
template< class _II> void 
# 2220
_Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc> ::_M_insert_unique(_II __first, _II __last) 
# 2221
{ 
# 2222
_Alloc_node __an(*this); 
# 2223
for (; __first != __last; ++__first) { 
# 2224
_M_insert_unique_(this->end(), *__first, __an); }  
# 2225
} 
# 2227
template< class _Key, class _Val, class _KoV, class 
# 2228
_Cmp, class _Alloc> 
# 2229
template< class _II> void 
# 2232
_Rb_tree< _Key, _Val, _KoV, _Cmp, _Alloc> ::_M_insert_equal(_II __first, _II __last) 
# 2233
{ 
# 2234
_Alloc_node __an(*this); 
# 2235
for (; __first != __last; ++__first) { 
# 2236
_M_insert_equal_(this->end(), *__first, __an); }  
# 2237
} 
# 2239
template< class _Key, class _Val, class _KeyOfValue, class 
# 2240
_Compare, class _Alloc> void 
# 2243
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __position) 
# 2244
{ 
# 2245
_Link_type __y = static_cast< _Link_type>(_Rb_tree_rebalance_for_erase(const_cast< _Base_ptr>(__position._M_node), ((this->_M_impl)._M_header))); 
# 2249
_M_drop_node(__y); 
# 2250
--((_M_impl)._M_node_count); 
# 2251
} 
# 2253
template< class _Key, class _Val, class _KeyOfValue, class 
# 2254
_Compare, class _Alloc> void 
# 2257
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __first, const_iterator __last) 
# 2258
{ 
# 2259
if ((__first == this->begin()) && (__last == this->end())) { 
# 2260
clear(); } else { 
# 2262
while (__first != __last) { 
# 2263
erase(__first++); }  }  
# 2264
} 
# 2266
template< class _Key, class _Val, class _KeyOfValue, class 
# 2267
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2270
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key &__x) 
# 2271
{ 
# 2272
pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  __p = equal_range(__x); 
# 2273
const size_type __old_size = size(); 
# 2274
erase((__p.first), (__p.second)); 
# 2275
return __old_size - size(); 
# 2276
} 
# 2278
template< class _Key, class _Val, class _KeyOfValue, class 
# 2279
_Compare, class _Alloc> void 
# 2282
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key *__first, const _Key *__last) 
# 2283
{ 
# 2284
while (__first != __last) { 
# 2285
erase(*(__first++)); }  
# 2286
} 
# 2288
template< class _Key, class _Val, class _KeyOfValue, class 
# 2289
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2293
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) 
# 2294
{ 
# 2295
iterator __j = _M_lower_bound(this->_M_begin(), this->_M_end(), __k); 
# 2296
return ((__j == this->end()) || ((_M_impl)._M_key_compare(__k, _S_key((__j._M_node))))) ? this->end() : __j; 
# 2299
} 
# 2301
template< class _Key, class _Val, class _KeyOfValue, class 
# 2302
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 2306
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) const 
# 2307
{ 
# 2308
const_iterator __j = _M_lower_bound(this->_M_begin(), this->_M_end(), __k); 
# 2309
return ((__j == this->end()) || ((_M_impl)._M_key_compare(__k, _S_key((__j._M_node))))) ? this->end() : __j; 
# 2312
} 
# 2314
template< class _Key, class _Val, class _KeyOfValue, class 
# 2315
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2318
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::count(const _Key &__k) const 
# 2319
{ 
# 2320
pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  __p = equal_range(__k); 
# 2321
const size_type __n = std::distance((__p.first), (__p.second)); 
# 2322
return __n; 
# 2323
} 
# 2325
__attribute((__pure__)) unsigned 
# 2326
_Rb_tree_black_count(const _Rb_tree_node_base * __node, const _Rb_tree_node_base * __root) throw(); 
# 2329
template< class _Key, class _Val, class _KeyOfValue, class 
# 2330
_Compare, class _Alloc> bool 
# 2332
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::__rb_verify() const 
# 2333
{ 
# 2334
if ((((_M_impl)._M_node_count) == 0) || (this->begin() == this->end())) { 
# 2335
return (((_M_impl)._M_node_count) == 0) && (this->begin() == this->end()) && ((((this->_M_impl)._M_header)._M_left) == this->_M_end()) && ((((this->_M_impl)._M_header)._M_right) == this->_M_end()); }  
# 2339
unsigned __len = _Rb_tree_black_count(this->_M_leftmost(), this->_M_root()); 
# 2340
for (const_iterator __it = this->begin(); __it != this->end(); ++__it) 
# 2341
{ 
# 2342
_Const_Link_type __x = static_cast< _Const_Link_type>(__it._M_node); 
# 2343
_Const_Link_type __L = _S_left(__x); 
# 2344
_Const_Link_type __R = _S_right(__x); 
# 2346
if ((__x->_M_color) == _S_red) { 
# 2347
if ((__L && ((__L->_M_color) == _S_red)) || (__R && ((__R->_M_color) == _S_red))) { 
# 2349
return false; }  }  
# 2351
if (__L && ((_M_impl)._M_key_compare(_S_key(__x), _S_key(__L)))) { 
# 2352
return false; }  
# 2353
if (__R && ((_M_impl)._M_key_compare(_S_key(__R), _S_key(__x)))) { 
# 2354
return false; }  
# 2356
if ((!__L) && (!__R) && (_Rb_tree_black_count(__x, this->_M_root()) != __len)) { 
# 2357
return false; }  
# 2358
}  
# 2360
if (this->_M_leftmost() != _Rb_tree_node_base::_S_minimum(this->_M_root())) { 
# 2361
return false; }  
# 2362
if (this->_M_rightmost() != _Rb_tree_node_base::_S_maximum(this->_M_root())) { 
# 2363
return false; }  
# 2364
return true; 
# 2365
} 
# 2368
}
# 64 "/usr/include/c++/5/bits/stl_set.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 88
template< class _Key, class _Compare = less< _Key> , class 
# 89
_Alloc = allocator< _Key> > 
# 90
class set { 
# 93
typedef typename _Alloc::value_type _Alloc_value_type; 
# 103
public: typedef _Key key_type; 
# 104
typedef _Key value_type; 
# 105
typedef _Compare key_compare; 
# 106
typedef _Compare value_compare; 
# 107
typedef _Alloc allocator_type; 
# 112
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 115
typedef _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Rep_type; 
# 116
_Rep_type _M_t; 
# 118
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Alloc_traits; 
# 123
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::pointer pointer; 
# 124
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_pointer const_pointer; 
# 125
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::reference reference; 
# 126
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reference const_reference; 
# 130
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator iterator; 
# 131
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator const_iterator; 
# 132
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator reverse_iterator; 
# 133
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator const_reverse_iterator; 
# 134
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::size_type size_type; 
# 135
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::difference_type difference_type; 
# 142
set() : _M_t() 
# 146
{ } 
# 154
explicit set(const _Compare &__comp, const allocator_type &
# 155
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 156
{ } 
# 168
template< class _InputIterator> 
# 169
set(_InputIterator __first, _InputIterator __last) : _M_t() 
# 171
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 185
template< class _InputIterator> 
# 186
set(_InputIterator __first, _InputIterator __last, const _Compare &
# 187
__comp, const allocator_type &
# 188
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 190
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 199
set(const set &__x) : _M_t(__x._M_t) 
# 200
{ } 
# 266
set &operator=(const set &__x) 
# 267
{ 
# 268
(_M_t) = (__x._M_t); 
# 269
return *this; 
# 270
} 
# 300
key_compare key_comp() const 
# 301
{ return ((_M_t).key_comp()); } 
# 304
value_compare value_comp() const 
# 305
{ return ((_M_t).key_comp()); } 
# 308
allocator_type get_allocator() const 
# 309
{ return (allocator_type)((_M_t).get_allocator()); } 
# 317
iterator begin() const 
# 318
{ return ((_M_t).begin()); } 
# 326
iterator end() const 
# 327
{ return ((_M_t).end()); } 
# 335
reverse_iterator rbegin() const 
# 336
{ return ((_M_t).rbegin()); } 
# 344
reverse_iterator rend() const 
# 345
{ return ((_M_t).rend()); } 
# 387
bool empty() const 
# 388
{ return ((_M_t).empty()); } 
# 392
size_type size() const 
# 393
{ return ((_M_t).size()); } 
# 397
size_type max_size() const 
# 398
{ return ((_M_t).max_size()); } 
# 412
void swap(set &__x) 
# 416
{ ((_M_t).swap(__x._M_t)); } 
# 482
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool>  insert(const value_type &__x) 
# 483
{ 
# 484
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::iterator, bool>  __p = ((_M_t)._M_insert_unique(__x)); 
# 486
return pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, bool> ((__p.first), (__p.second)); 
# 487
} 
# 519
iterator insert(const_iterator __position, const value_type &__x) 
# 520
{ return ((_M_t)._M_insert_unique_(__position, __x)); } 
# 537
template< class _InputIterator> void 
# 539
insert(_InputIterator __first, _InputIterator __last) 
# 540
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 587
void erase(iterator __position) 
# 588
{ ((_M_t).erase(__position)); } 
# 603
size_type erase(const key_type &__x) 
# 604
{ return ((_M_t).erase(__x)); } 
# 641
void erase(iterator __first, iterator __last) 
# 642
{ ((_M_t).erase(__first, __last)); } 
# 652
void clear() 
# 653
{ ((_M_t).clear()); } 
# 667
size_type count(const key_type &__x) const 
# 668
{ return (((_M_t).find(__x)) == ((_M_t).end())) ? 0 : 1; } 
# 694
iterator find(const key_type &__x) 
# 695
{ return ((_M_t).find(__x)); } 
# 698
const_iterator find(const key_type &__x) const 
# 699
{ return ((_M_t).find(__x)); } 
# 729
iterator lower_bound(const key_type &__x) 
# 730
{ return ((_M_t).lower_bound(__x)); } 
# 733
const_iterator lower_bound(const key_type &__x) const 
# 734
{ return ((_M_t).lower_bound(__x)); } 
# 759
iterator upper_bound(const key_type &__x) 
# 760
{ return ((_M_t).upper_bound(__x)); } 
# 763
const_iterator upper_bound(const key_type &__x) const 
# 764
{ return ((_M_t).upper_bound(__x)); } 
# 798
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) 
# 799
{ return ((_M_t).equal_range(__x)); } 
# 802
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 803
{ return ((_M_t).equal_range(__x)); } 
# 820
template< class _K1, class _C1, class _A1> friend bool operator==(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 824
template< class _K1, class _C1, class _A1> friend bool operator<(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 827
}; 
# 840
template< class _Key, class _Compare, class _Alloc> inline bool 
# 842
operator==(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 843
__y) 
# 844
{ return (__x._M_t) == (__y._M_t); } 
# 857
template< class _Key, class _Compare, class _Alloc> inline bool 
# 859
operator<(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 860
__y) 
# 861
{ return (__x._M_t) < (__y._M_t); } 
# 864
template< class _Key, class _Compare, class _Alloc> inline bool 
# 866
operator!=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 867
__y) 
# 868
{ return !(__x == __y); } 
# 871
template< class _Key, class _Compare, class _Alloc> inline bool 
# 873
operator>(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 874
__y) 
# 875
{ return __y < __x; } 
# 878
template< class _Key, class _Compare, class _Alloc> inline bool 
# 880
operator<=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 881
__y) 
# 882
{ return !(__y < __x); } 
# 885
template< class _Key, class _Compare, class _Alloc> inline bool 
# 887
operator>=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 888
__y) 
# 889
{ return !(__x < __y); } 
# 892
template< class _Key, class _Compare, class _Alloc> inline void 
# 894
swap(set< _Key, _Compare, _Alloc>  &__x, set< _Key, _Compare, _Alloc>  &__y) 
# 895
{ (__x.swap(__y)); } 
# 898
}
# 64 "/usr/include/c++/5/bits/stl_multiset.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 90
template< class _Key, class _Compare = less< _Key> , class 
# 91
_Alloc = allocator< _Key> > 
# 92
class multiset { 
# 95
typedef typename _Alloc::value_type _Alloc_value_type; 
# 103
public: typedef _Key key_type; 
# 104
typedef _Key value_type; 
# 105
typedef _Compare key_compare; 
# 106
typedef _Compare value_compare; 
# 107
typedef _Alloc allocator_type; 
# 112
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 115
typedef _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Rep_type; 
# 117
_Rep_type _M_t; 
# 119
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other>  _Alloc_traits; 
# 122
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::pointer pointer; 
# 123
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_pointer const_pointer; 
# 124
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::reference reference; 
# 125
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reference const_reference; 
# 129
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator iterator; 
# 130
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator const_iterator; 
# 131
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator reverse_iterator; 
# 132
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_reverse_iterator const_reverse_iterator; 
# 133
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::size_type size_type; 
# 134
typedef typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::difference_type difference_type; 
# 140
multiset() : _M_t() 
# 144
{ } 
# 152
explicit multiset(const _Compare &__comp, const allocator_type &
# 153
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 154
{ } 
# 165
template< class _InputIterator> 
# 166
multiset(_InputIterator __first, _InputIterator __last) : _M_t() 
# 168
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 181
template< class _InputIterator> 
# 182
multiset(_InputIterator __first, _InputIterator __last, const _Compare &
# 183
__comp, const allocator_type &
# 184
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 186
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 195
multiset(const multiset &__x) : _M_t(__x._M_t) 
# 196
{ } 
# 262
multiset &operator=(const multiset &__x) 
# 263
{ 
# 264
(_M_t) = (__x._M_t); 
# 265
return *this; 
# 266
} 
# 296
key_compare key_comp() const 
# 297
{ return ((_M_t).key_comp()); } 
# 300
value_compare value_comp() const 
# 301
{ return ((_M_t).key_comp()); } 
# 304
allocator_type get_allocator() const 
# 305
{ return (allocator_type)((_M_t).get_allocator()); } 
# 313
iterator begin() const 
# 314
{ return ((_M_t).begin()); } 
# 322
iterator end() const 
# 323
{ return ((_M_t).end()); } 
# 331
reverse_iterator rbegin() const 
# 332
{ return ((_M_t).rbegin()); } 
# 340
reverse_iterator rend() const 
# 341
{ return ((_M_t).rend()); } 
# 383
bool empty() const 
# 384
{ return ((_M_t).empty()); } 
# 388
size_type size() const 
# 389
{ return ((_M_t).size()); } 
# 393
size_type max_size() const 
# 394
{ return ((_M_t).max_size()); } 
# 408
void swap(multiset &__x) 
# 412
{ ((_M_t).swap(__x._M_t)); } 
# 475
iterator insert(const value_type &__x) 
# 476
{ return ((_M_t)._M_insert_equal(__x)); } 
# 505
iterator insert(const_iterator __position, const value_type &__x) 
# 506
{ return ((_M_t)._M_insert_equal_(__position, __x)); } 
# 522
template< class _InputIterator> void 
# 524
insert(_InputIterator __first, _InputIterator __last) 
# 525
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 572
void erase(iterator __position) 
# 573
{ ((_M_t).erase(__position)); } 
# 588
size_type erase(const key_type &__x) 
# 589
{ return ((_M_t).erase(__x)); } 
# 626
void erase(iterator __first, iterator __last) 
# 627
{ ((_M_t).erase(__first, __last)); } 
# 637
void clear() 
# 638
{ ((_M_t).clear()); } 
# 649
size_type count(const key_type &__x) const 
# 650
{ return ((_M_t).count(__x)); } 
# 675
iterator find(const key_type &__x) 
# 676
{ return ((_M_t).find(__x)); } 
# 679
const_iterator find(const key_type &__x) const 
# 680
{ return ((_M_t).find(__x)); } 
# 710
iterator lower_bound(const key_type &__x) 
# 711
{ return ((_M_t).lower_bound(__x)); } 
# 714
const_iterator lower_bound(const key_type &__x) const 
# 715
{ return ((_M_t).lower_bound(__x)); } 
# 740
iterator upper_bound(const key_type &__x) 
# 741
{ return ((_M_t).upper_bound(__x)); } 
# 744
const_iterator upper_bound(const key_type &__x) const 
# 745
{ return ((_M_t).upper_bound(__x)); } 
# 779
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) 
# 780
{ return ((_M_t).equal_range(__x)); } 
# 783
pair< typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator, typename _Rb_tree< _Key, _Key, _Identity< _Key> , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 784
{ return ((_M_t).equal_range(__x)); } 
# 801
template< class _K1, class _C1, class _A1> friend bool operator==(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 806
template< class _K1, class _C1, class _A1> friend bool operator<(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 810
}; 
# 823
template< class _Key, class _Compare, class _Alloc> inline bool 
# 825
operator==(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 826
__y) 
# 827
{ return (__x._M_t) == (__y._M_t); } 
# 840
template< class _Key, class _Compare, class _Alloc> inline bool 
# 842
operator<(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 843
__y) 
# 844
{ return (__x._M_t) < (__y._M_t); } 
# 847
template< class _Key, class _Compare, class _Alloc> inline bool 
# 849
operator!=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 850
__y) 
# 851
{ return !(__x == __y); } 
# 854
template< class _Key, class _Compare, class _Alloc> inline bool 
# 856
operator>(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 857
__y) 
# 858
{ return __y < __x; } 
# 861
template< class _Key, class _Compare, class _Alloc> inline bool 
# 863
operator<=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 864
__y) 
# 865
{ return !(__y < __x); } 
# 868
template< class _Key, class _Compare, class _Alloc> inline bool 
# 870
operator>=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 871
__y) 
# 872
{ return !(__x < __y); } 
# 875
template< class _Key, class _Compare, class _Alloc> inline void 
# 877
swap(multiset< _Key, _Compare, _Alloc>  &__x, multiset< _Key, _Compare, _Alloc>  &
# 878
__y) 
# 879
{ (__x.swap(__y)); } 
# 882
}
# 66 "/usr/include/c++/5/bits/stl_map.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 94
template< class _Key, class _Tp, class _Compare = less< _Key> , class 
# 95
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 96
class map { 
# 99
public: typedef _Key key_type; 
# 100
typedef _Tp mapped_type; 
# 101
typedef pair< const _Key, _Tp>  value_type; 
# 102
typedef _Compare key_compare; 
# 103
typedef _Alloc allocator_type; 
# 107
private: typedef typename _Alloc::value_type _Alloc_value_type; 
# 114
public: class value_compare : public binary_function< pair< const _Key, _Tp> , pair< const _Key, _Tp> , bool>  { 
# 117
friend class map; 
# 119
protected: _Compare comp; 
# 121
value_compare(_Compare __c) : comp(__c) 
# 122
{ } 
# 125
public: bool operator()(const typename ::std::map< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename ::std::map< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 126
{ return (comp)((__x.first), (__y.first)); } 
# 127
}; 
# 132
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other _Pair_alloc_type; 
# 135
typedef _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Rep_type; 
# 138
_Rep_type _M_t; 
# 140
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Alloc_traits; 
# 145
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::pointer pointer; 
# 146
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_pointer const_pointer; 
# 147
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reference reference; 
# 148
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reference const_reference; 
# 149
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator iterator; 
# 150
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator const_iterator; 
# 151
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::size_type size_type; 
# 152
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::difference_type difference_type; 
# 153
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reverse_iterator reverse_iterator; 
# 154
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reverse_iterator const_reverse_iterator; 
# 162
map() : _M_t() 
# 166
{ } 
# 174
explicit map(const _Compare &__comp, const allocator_type &
# 175
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 176
{ } 
# 185
map(const map &__x) : _M_t(__x._M_t) 
# 186
{ } 
# 255
template< class _InputIterator> 
# 256
map(_InputIterator __first, _InputIterator __last) : _M_t() 
# 258
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 272
template< class _InputIterator> 
# 273
map(_InputIterator __first, _InputIterator __last, const _Compare &
# 274
__comp, const allocator_type &
# 275
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 277
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 296
map &operator=(const map &__x) 
# 297
{ 
# 298
(_M_t) = (__x._M_t); 
# 299
return *this; 
# 300
} 
# 328
allocator_type get_allocator() const 
# 329
{ return (allocator_type)((_M_t).get_allocator()); } 
# 338
iterator begin() 
# 339
{ return ((_M_t).begin()); } 
# 347
const_iterator begin() const 
# 348
{ return ((_M_t).begin()); } 
# 356
iterator end() 
# 357
{ return ((_M_t).end()); } 
# 365
const_iterator end() const 
# 366
{ return ((_M_t).end()); } 
# 374
reverse_iterator rbegin() 
# 375
{ return ((_M_t).rbegin()); } 
# 383
const_reverse_iterator rbegin() const 
# 384
{ return ((_M_t).rbegin()); } 
# 392
reverse_iterator rend() 
# 393
{ return ((_M_t).rend()); } 
# 401
const_reverse_iterator rend() const 
# 402
{ return ((_M_t).rend()); } 
# 447
bool empty() const 
# 448
{ return ((_M_t).empty()); } 
# 452
size_type size() const 
# 453
{ return ((_M_t).size()); } 
# 457
size_type max_size() const 
# 458
{ return ((_M_t).max_size()); } 
# 474
mapped_type &operator[](const key_type &__k) 
# 475
{ 
# 479
iterator __i = lower_bound(__k); 
# 481
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 487
__i = insert(__i, value_type(__k, mapped_type())); }  
# 489
return (*__i).second; 
# 490
} 
# 519
mapped_type &at(const key_type &__k) 
# 520
{ 
# 521
iterator __i = lower_bound(__k); 
# 522
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 523
__throw_out_of_range("map::at"); }  
# 524
return (*__i).second; 
# 525
} 
# 528
const mapped_type &at(const key_type &__k) const 
# 529
{ 
# 530
const_iterator __i = lower_bound(__k); 
# 531
if ((__i == this->end()) || key_comp()(__k, ((*__i).first))) { 
# 532
__throw_out_of_range("map::at"); }  
# 533
return (*__i).second; 
# 534
} 
# 612
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, bool>  insert(const value_type &__x) 
# 613
{ return ((_M_t)._M_insert_unique(__x)); } 
# 664
iterator insert(iterator __position, const value_type &__x) 
# 666
{ return ((_M_t)._M_insert_unique_(__position, __x)); } 
# 686
template< class _InputIterator> void 
# 688
insert(_InputIterator __first, _InputIterator __last) 
# 689
{ ((_M_t)._M_insert_unique(__first, __last)); } 
# 728
void erase(iterator __position) 
# 729
{ ((_M_t).erase(__position)); } 
# 744
size_type erase(const key_type &__x) 
# 745
{ return ((_M_t).erase(__x)); } 
# 780
void erase(iterator __first, iterator __last) 
# 781
{ ((_M_t).erase(__first, __last)); } 
# 796
void swap(map &__x) 
# 800
{ ((_M_t).swap(__x._M_t)); } 
# 809
void clear() 
# 810
{ ((_M_t).clear()); } 
# 818
key_compare key_comp() const 
# 819
{ return ((_M_t).key_comp()); } 
# 826
value_compare value_comp() const 
# 827
{ return (value_compare)((_M_t).key_comp()); } 
# 845
iterator find(const key_type &__x) 
# 846
{ return ((_M_t).find(__x)); } 
# 870
const_iterator find(const key_type &__x) const 
# 871
{ return ((_M_t).find(__x)); } 
# 891
size_type count(const key_type &__x) const 
# 892
{ return (((_M_t).find(__x)) == ((_M_t).end())) ? 0 : 1; } 
# 915
iterator lower_bound(const key_type &__x) 
# 916
{ return ((_M_t).lower_bound(__x)); } 
# 940
const_iterator lower_bound(const key_type &__x) const 
# 941
{ return ((_M_t).lower_bound(__x)); } 
# 960
iterator upper_bound(const key_type &__x) 
# 961
{ return ((_M_t).upper_bound(__x)); } 
# 980
const_iterator upper_bound(const key_type &__x) const 
# 981
{ return ((_M_t).upper_bound(__x)); } 
# 1009
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator>  equal_range(const key_type &__x) 
# 1010
{ return ((_M_t).equal_range(__x)); } 
# 1038
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 1039
{ return ((_M_t).equal_range(__x)); } 
# 1050
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1055
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1059
}; 
# 1071
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1073
operator==(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1074
__y) 
# 1075
{ return (__x._M_t) == (__y._M_t); } 
# 1088
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1090
operator<(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1091
__y) 
# 1092
{ return (__x._M_t) < (__y._M_t); } 
# 1095
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1097
operator!=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1098
__y) 
# 1099
{ return !(__x == __y); } 
# 1102
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1104
operator>(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1105
__y) 
# 1106
{ return __y < __x; } 
# 1109
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1111
operator<=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1112
__y) 
# 1113
{ return !(__y < __x); } 
# 1116
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1118
operator>=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1119
__y) 
# 1120
{ return !(__x < __y); } 
# 1123
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1125
swap(map< _Key, _Tp, _Compare, _Alloc>  &__x, map< _Key, _Tp, _Compare, _Alloc>  &
# 1126
__y) 
# 1127
{ (__x.swap(__y)); } 
# 1130
}
# 64 "/usr/include/c++/5/bits/stl_multimap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 92
template< class _Key, class _Tp, class 
# 93
_Compare = less< _Key> , class 
# 94
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 95
class multimap { 
# 98
public: typedef _Key key_type; 
# 99
typedef _Tp mapped_type; 
# 100
typedef pair< const _Key, _Tp>  value_type; 
# 101
typedef _Compare key_compare; 
# 102
typedef _Alloc allocator_type; 
# 106
private: typedef typename _Alloc::value_type _Alloc_value_type; 
# 113
public: class value_compare : public binary_function< pair< const _Key, _Tp> , pair< const _Key, _Tp> , bool>  { 
# 116
friend class multimap; 
# 118
protected: _Compare comp; 
# 120
value_compare(_Compare __c) : comp(__c) 
# 121
{ } 
# 124
public: bool operator()(const typename ::std::multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename ::std::multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 125
{ return (comp)((__x.first), (__y.first)); } 
# 126
}; 
# 131
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other _Pair_alloc_type; 
# 134
typedef _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Rep_type; 
# 136
_Rep_type _M_t; 
# 138
typedef __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other>  _Alloc_traits; 
# 143
public: typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::pointer pointer; 
# 144
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_pointer const_pointer; 
# 145
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reference reference; 
# 146
typedef typename __gnu_cxx::__alloc_traits< typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reference const_reference; 
# 147
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator iterator; 
# 148
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator const_iterator; 
# 149
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::size_type size_type; 
# 150
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::difference_type difference_type; 
# 151
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::reverse_iterator reverse_iterator; 
# 152
typedef typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_reverse_iterator const_reverse_iterator; 
# 160
multimap() : _M_t() 
# 164
{ } 
# 172
explicit multimap(const _Compare &__comp, const allocator_type &
# 173
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 174
{ } 
# 183
multimap(const multimap &__x) : _M_t(__x._M_t) 
# 184
{ } 
# 251
template< class _InputIterator> 
# 252
multimap(_InputIterator __first, _InputIterator __last) : _M_t() 
# 254
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 267
template< class _InputIterator> 
# 268
multimap(_InputIterator __first, _InputIterator __last, const _Compare &
# 269
__comp, const allocator_type &
# 270
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 272
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 291
multimap &operator=(const multimap &__x) 
# 292
{ 
# 293
(_M_t) = (__x._M_t); 
# 294
return *this; 
# 295
} 
# 323
allocator_type get_allocator() const 
# 324
{ return (allocator_type)((_M_t).get_allocator()); } 
# 333
iterator begin() 
# 334
{ return ((_M_t).begin()); } 
# 342
const_iterator begin() const 
# 343
{ return ((_M_t).begin()); } 
# 351
iterator end() 
# 352
{ return ((_M_t).end()); } 
# 360
const_iterator end() const 
# 361
{ return ((_M_t).end()); } 
# 369
reverse_iterator rbegin() 
# 370
{ return ((_M_t).rbegin()); } 
# 378
const_reverse_iterator rbegin() const 
# 379
{ return ((_M_t).rbegin()); } 
# 387
reverse_iterator rend() 
# 388
{ return ((_M_t).rend()); } 
# 396
const_reverse_iterator rend() const 
# 397
{ return ((_M_t).rend()); } 
# 440
bool empty() const 
# 441
{ return ((_M_t).empty()); } 
# 445
size_type size() const 
# 446
{ return ((_M_t).size()); } 
# 450
size_type max_size() const 
# 451
{ return ((_M_t).max_size()); } 
# 520
iterator insert(const value_type &__x) 
# 521
{ return ((_M_t)._M_insert_equal(__x)); } 
# 556
iterator insert(iterator __position, const value_type &__x) 
# 558
{ return ((_M_t)._M_insert_equal_(__position, __x)); } 
# 579
template< class _InputIterator> void 
# 581
insert(_InputIterator __first, _InputIterator __last) 
# 582
{ ((_M_t)._M_insert_equal(__first, __last)); } 
# 634
void erase(iterator __position) 
# 635
{ ((_M_t).erase(__position)); } 
# 650
size_type erase(const key_type &__x) 
# 651
{ return ((_M_t).erase(__x)); } 
# 690
void erase(iterator __first, iterator __last) 
# 691
{ ((_M_t).erase(__first, __last)); } 
# 706
void swap(multimap &__x) 
# 710
{ ((_M_t).swap(__x._M_t)); } 
# 719
void clear() 
# 720
{ ((_M_t).clear()); } 
# 728
key_compare key_comp() const 
# 729
{ return ((_M_t).key_comp()); } 
# 736
value_compare value_comp() const 
# 737
{ return (value_compare)((_M_t).key_comp()); } 
# 754
iterator find(const key_type &__x) 
# 755
{ return ((_M_t).find(__x)); } 
# 778
const_iterator find(const key_type &__x) const 
# 779
{ return ((_M_t).find(__x)); } 
# 796
size_type count(const key_type &__x) const 
# 797
{ return ((_M_t).count(__x)); } 
# 820
iterator lower_bound(const key_type &__x) 
# 821
{ return ((_M_t).lower_bound(__x)); } 
# 845
const_iterator lower_bound(const key_type &__x) const 
# 846
{ return ((_M_t).lower_bound(__x)); } 
# 865
iterator upper_bound(const key_type &__x) 
# 866
{ return ((_M_t).upper_bound(__x)); } 
# 885
const_iterator upper_bound(const key_type &__x) const 
# 886
{ return ((_M_t).upper_bound(__x)); } 
# 912
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::iterator>  equal_range(const key_type &__x) 
# 913
{ return ((_M_t).equal_range(__x)); } 
# 939
pair< typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator, typename _Rb_tree< _Key, pair< const _Key, _Tp> , _Select1st< pair< const _Key, _Tp> > , _Compare, typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< pair< const _Key, _Tp> > ::other> ::const_iterator>  equal_range(const key_type &__x) const 
# 940
{ return ((_M_t).equal_range(__x)); } 
# 951
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 956
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 960
}; 
# 972
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 974
operator==(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 975
__y) 
# 976
{ return (__x._M_t) == (__y._M_t); } 
# 989
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 991
operator<(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 992
__y) 
# 993
{ return (__x._M_t) < (__y._M_t); } 
# 996
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 998
operator!=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 999
__y) 
# 1000
{ return !(__x == __y); } 
# 1003
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1005
operator>(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1006
__y) 
# 1007
{ return __y < __x; } 
# 1010
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1012
operator<=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1013
__y) 
# 1014
{ return !(__y < __x); } 
# 1017
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1019
operator>=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1020
__y) 
# 1021
{ return !(__x < __y); } 
# 1024
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1026
swap(multimap< _Key, _Tp, _Compare, _Alloc>  &__x, multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1027
__y) 
# 1028
{ (__x.swap(__y)); } 
# 1031
}
# 60 "/usr/local/cuda/include/cub/host/mutex.cuh"
namespace cub { 
# 68
struct Mutex { 
# 99
typedef int Spinlock; 
# 104
__attribute((always_inline)) void _ReadWriteBarrier() 
# 105
{ 
# 106
__sync_synchronize(); 
# 107
} 
# 112
__attribute((always_inline)) long _InterlockedExchange(volatile int *const Target, const int Value) 
# 113
{ 
# 115
this->_ReadWriteBarrier(); 
# 116
return __sync_lock_test_and_set(Target, Value); 
# 117
} 
# 122
__attribute((always_inline)) void YieldProcessor() 
# 123
{ 
# 125
__asm__ volatile("pause\n" : : : "memory"); 
# 127
} 
# 132
volatile Spinlock lock; 
# 137
Mutex() : lock(0) { } 
# 142
__attribute((always_inline)) void Lock() 
# 143
{ 
# 144
while (1) 
# 145
{ 
# 146
if (!(this->_InterlockedExchange(&(lock), 1))) { return; }  
# 147
while (lock) { this->YieldProcessor(); }  
# 148
}  
# 149
} 
# 155
__attribute((always_inline)) void Unlock() 
# 156
{ 
# 157
this->_ReadWriteBarrier(); 
# 158
(lock) = 0; 
# 159
} 
# 163
}; 
# 168
}
# 49 "/usr/local/cuda/include/cub/util_allocator.cuh"
namespace cub { 
# 101
struct CachingDeviceAllocator { 
# 109
static const unsigned INVALID_BIN = ((unsigned)(-1)); 
# 112
static const size_t INVALID_SIZE = ((size_t)(-1)); 
# 117
static const int INVALID_DEVICE_ORDINAL = (-1); 
# 126
struct BlockDescriptor { 
# 128
void *d_ptr; 
# 129
size_t bytes; 
# 130
unsigned bin; 
# 131
int device; 
# 132
cudaStream_t associated_stream; 
# 133
cudaEvent_t ready_event; 
# 136
BlockDescriptor(void *d_ptr, int device) : d_ptr(d_ptr), bytes((0)), bin(INVALID_BIN), device(device), associated_stream((0)), ready_event((0)) 
# 143
{ } 
# 146
BlockDescriptor(int device) : d_ptr((__null)), bytes((0)), bin(INVALID_BIN), device(device), associated_stream((0)), ready_event((0)) 
# 153
{ } 
# 156
static bool PtrCompare(const BlockDescriptor &a, const BlockDescriptor &b) 
# 157
{ 
# 158
if ((a.device) == (b.device)) { 
# 159
return (a.d_ptr) < (b.d_ptr); } else { 
# 161
return (a.device) < (b.device); }  
# 162
} 
# 165
static bool SizeCompare(const BlockDescriptor &a, const BlockDescriptor &b) 
# 166
{ 
# 167
if ((a.device) == (b.device)) { 
# 168
return (a.bytes) < (b.bytes); } else { 
# 170
return (a.device) < (b.device); }  
# 171
} 
# 172
}; 
# 175
typedef bool (*Compare)(const BlockDescriptor &, const BlockDescriptor &); 
# 177
class TotalBytes { 
# 179
public: size_t free; 
# 180
size_t live; 
# 181
TotalBytes() { (free) = ((live) = (0)); } 
# 182
}; 
# 185
typedef std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)>  CachedBlocks; 
# 188
typedef std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)>  BusyBlocks; 
# 191
typedef std::map< int, TotalBytes>  GpuCachedBytes; 
# 201
static unsigned IntPow(unsigned 
# 202
base, unsigned 
# 203
exp) 
# 204
{ 
# 205
unsigned retval = (1); 
# 206
while (exp > (0)) 
# 207
{ 
# 208
if (exp & (1)) { 
# 209
retval = (retval * base); 
# 210
}  
# 211
base = (base * base); 
# 212
exp = (exp >> 1); 
# 213
}  
# 214
return retval; 
# 215
} 
# 221
void NearestPowerOf(unsigned &
# 222
power, size_t &
# 223
rounded_bytes, unsigned 
# 224
base, size_t 
# 225
value) 
# 226
{ 
# 227
power = (0); 
# 228
rounded_bytes = (1); 
# 230
if ((value * base) < value) 
# 231
{ 
# 233
power = (sizeof(size_t) * (8)); 
# 234
rounded_bytes = (((size_t)0) - (1)); 
# 235
return; 
# 236
}  
# 238
while (rounded_bytes < value) 
# 239
{ 
# 240
rounded_bytes *= base; 
# 241
power++; 
# 242
}  
# 243
} 
# 250
Mutex mutex; 
# 252
unsigned bin_growth; 
# 253
unsigned min_bin; 
# 254
unsigned max_bin; 
# 256
size_t min_bin_bytes; 
# 257
size_t max_bin_bytes; 
# 258
size_t max_cached_bytes; 
# 260
const bool skip_cleanup; 
# 261
bool debug; 
# 263
GpuCachedBytes cached_bytes; 
# 264
CachedBlocks cached_blocks; 
# 265
BusyBlocks live_blocks; 
# 276
CachingDeviceAllocator(unsigned 
# 277
bin_growth, unsigned 
# 278
min_bin = 1, unsigned 
# 279
max_bin = INVALID_BIN, size_t 
# 280
max_cached_bytes = INVALID_SIZE, bool 
# 281
skip_cleanup = false, bool 
# 282
debug = false) : bin_growth(bin_growth), min_bin(min_bin), max_bin(max_bin), min_bin_bytes(IntPow(bin_growth, min_bin)), max_bin_bytes(IntPow(bin_growth, max_bin)), max_cached_bytes(max_cached_bytes), skip_cleanup(skip_cleanup), debug(debug), cached_blocks(BlockDescriptor::SizeCompare), live_blocks(BlockDescriptor::PtrCompare) 
# 294
{ } 
# 310
CachingDeviceAllocator(bool 
# 311
skip_cleanup = false, bool 
# 312
debug = false) : bin_growth((8)), min_bin((3)), max_bin((7)), min_bin_bytes(IntPow(bin_growth, min_bin)), max_bin_bytes(IntPow(bin_growth, max_bin)), max_cached_bytes(((max_bin_bytes) * (3)) - (1)), skip_cleanup(skip_cleanup), debug(debug), cached_blocks(BlockDescriptor::SizeCompare), live_blocks(BlockDescriptor::PtrCompare) 
# 324
{ } 
# 333
cudaError_t SetMaxCachedBytes(size_t 
# 334
max_cached_bytes) 
# 335
{ 
# 337
(mutex).Lock(); 
# 339
if (debug) { printf("Changing max_cached_bytes (%lld -> %lld)\n", (long long)(this->max_cached_bytes), (long long)max_cached_bytes); }  ; 
# 341
(this->max_cached_bytes) = max_cached_bytes; 
# 344
(mutex).Unlock(); 
# 346
return cudaSuccess; 
# 347
} 
# 357
cudaError_t DeviceAllocate(int 
# 358
device, void **
# 359
d_ptr, size_t 
# 360
bytes, cudaStream_t 
# 361
active_stream = 0) 
# 362
{ 
# 363
(*d_ptr) = (__null); 
# 364
int entrypoint_device = INVALID_DEVICE_ORDINAL; 
# 365
cudaError_t error = cudaSuccess; 
# 367
if (device == INVALID_DEVICE_ORDINAL) 
# 368
{ 
# 369
if (cub::Debug(error = cudaGetDevice(&entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 369)) { return error; }  
# 370
device = entrypoint_device; 
# 371
}  
# 374
bool found = false; 
# 375
BlockDescriptor search_key(device); 
# 376
(search_key.associated_stream) = active_stream; 
# 377
this->NearestPowerOf(search_key.bin, search_key.bytes, bin_growth, bytes); 
# 379
if ((search_key.bin) > (max_bin)) 
# 380
{ 
# 384
(search_key.bin) = INVALID_BIN; 
# 385
(search_key.bytes) = bytes; 
# 386
} else 
# 388
{ 
# 390
(mutex).Lock(); 
# 392
if ((search_key.bin) < (min_bin)) 
# 393
{ 
# 395
(search_key.bin) = (min_bin); 
# 396
(search_key.bytes) = (min_bin_bytes); 
# 397
}  
# 400
std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)> ::iterator block_itr = (cached_blocks).lower_bound(search_key); 
# 401
while ((block_itr != ((cached_blocks).end())) && ((block_itr->device) == device) && ((block_itr->bin) == (search_key.bin))) 
# 404
{ 
# 408
if ((active_stream == (block_itr->associated_stream)) || ((cudaEventQuery(block_itr->ready_event)) != (cudaErrorNotReady))) 
# 410
{ 
# 412
found = true; 
# 413
search_key = (*block_itr); 
# 414
(search_key.associated_stream) = active_stream; 
# 415
(live_blocks).insert(search_key); 
# 418
((cached_bytes)[device].free) -= (search_key.bytes); 
# 419
((cached_bytes)[device].live) += (search_key.bytes); 
# 421
if (debug) { printf("\tDevice %d reused cached block at %p (%lld bytes) for stream %lld (previously associated with stream %lld).\n", device, search_key.d_ptr, (long long)(search_key.bytes), (long long)(search_key.associated_stream), (long long)(block_itr->associated_stream)); }  
# 422
; 
# 424
(cached_blocks).erase(block_itr); 
# 426
break; 
# 427
}  
# 428
block_itr++; 
# 429
}  
# 432
(mutex).Unlock(); 
# 433
}  
# 436
if (!found) 
# 437
{ 
# 439
if (device != entrypoint_device) 
# 440
{ 
# 441
if (cub::Debug(error = cudaGetDevice(&entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 441)) { return error; }  
# 442
if (cub::Debug(error = cudaSetDevice(device), "/usr/local/cuda/include/cub/util_allocator.cuh", 442)) { return error; }  
# 443
}  
# 446
if ((cub::Debug(error = cudaMalloc(&(search_key.d_ptr), search_key.bytes), "/usr/local/cuda/include/cub/util_allocator.cuh", 446)) == (cudaErrorMemoryAllocation)) 
# 447
{ 
# 449
if (debug) { printf("\tDevice %d failed to allocate %lld bytes for stream %lld, retrying after freeing cached allocations", device, (long long)(search_key.bytes), (long long)(search_key.associated_stream)); }  
# 450
; 
# 452
error = cudaSuccess; 
# 453
cudaGetLastError(); 
# 456
(mutex).Lock(); 
# 459
BlockDescriptor free_key(device); 
# 460
std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)> ::iterator block_itr = (cached_blocks).lower_bound(free_key); 
# 462
while ((block_itr != ((cached_blocks).end())) && ((block_itr->device) == device)) 
# 463
{ 
# 469
if (cub::Debug(error = cudaFree(block_itr->d_ptr), "/usr/local/cuda/include/cub/util_allocator.cuh", 469)) { break; }  
# 470
if (cub::Debug(error = cudaEventDestroy(block_itr->ready_event), "/usr/local/cuda/include/cub/util_allocator.cuh", 470)) { break; }  
# 473
((cached_bytes)[device].free) -= (block_itr->bytes); 
# 475
if (debug) { printf("\tDevice %d freed %lld bytes.\n\t\t  %lld available blocks cached (%lld bytes), %lld live blocks (%lld bytes) outstanding.\n", device, (long long)(block_itr->bytes), (long long)(cached_blocks).size(), (long long)((cached_bytes)[device].free), (long long)(live_blocks).size(), (long long)((cached_bytes)[device].live)); }  
# 476
; 
# 478
(cached_blocks).erase(block_itr); 
# 480
block_itr++; 
# 481
}  
# 484
(mutex).Unlock(); 
# 487
if (error) { return error; }  
# 490
if (cub::Debug(error = cudaMalloc(&(search_key.d_ptr), search_key.bytes), "/usr/local/cuda/include/cub/util_allocator.cuh", 490)) { return error; }  
# 491
}  
# 494
if (cub::Debug(error = cudaEventCreateWithFlags(&(search_key.ready_event), 2), "/usr/local/cuda/include/cub/util_allocator.cuh", 494)) { 
# 495
return error; }  
# 498
(mutex).Lock(); 
# 499
(live_blocks).insert(search_key); 
# 500
((cached_bytes)[device].live) += (search_key.bytes); 
# 501
(mutex).Unlock(); 
# 503
if (debug) { printf("\tDevice %d allocated new device block at %p (%lld bytes associated with stream %lld).\n", device, search_key.d_ptr, (long long)(search_key.bytes), (long long)(search_key.associated_stream)); }  
# 504
; 
# 507
if ((entrypoint_device != INVALID_DEVICE_ORDINAL) && (entrypoint_device != device)) 
# 508
{ 
# 509
if (cub::Debug(error = cudaSetDevice(entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 509)) { return error; }  
# 510
}  
# 511
}  
# 514
(*d_ptr) = (search_key.d_ptr); 
# 516
if (debug) { printf("\t\t%lld available blocks cached (%lld bytes), %lld live blocks outstanding(%lld bytes).\n", (long long)(cached_blocks).size(), (long long)((cached_bytes)[device].free), (long long)(live_blocks).size(), (long long)((cached_bytes)[device].live)); }  
# 517
; 
# 519
return error; 
# 520
} 
# 530
cudaError_t DeviceAllocate(void **
# 531
d_ptr, size_t 
# 532
bytes, cudaStream_t 
# 533
active_stream = 0) 
# 534
{ 
# 535
return this->DeviceAllocate(INVALID_DEVICE_ORDINAL, d_ptr, bytes, active_stream); 
# 536
} 
# 546
cudaError_t DeviceFree(int 
# 547
device, void *
# 548
d_ptr) 
# 549
{ 
# 550
int entrypoint_device = INVALID_DEVICE_ORDINAL; 
# 551
cudaError_t error = cudaSuccess; 
# 553
if (device == INVALID_DEVICE_ORDINAL) 
# 554
{ 
# 555
if (cub::Debug(error = cudaGetDevice(&entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 555)) { 
# 556
return error; }  
# 557
device = entrypoint_device; 
# 558
}  
# 561
(mutex).Lock(); 
# 564
bool recached = false; 
# 565
BlockDescriptor search_key(d_ptr, device); 
# 566
std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)> ::iterator block_itr = (live_blocks).find(search_key); 
# 567
if ((block_itr != ((live_blocks).end()))) 
# 568
{ 
# 570
search_key = (*block_itr); 
# 571
(live_blocks).erase(block_itr); 
# 572
((cached_bytes)[device].live) -= (search_key.bytes); 
# 575
if (((search_key.bin) != INVALID_BIN) && ((((cached_bytes)[device].free) + (search_key.bytes)) <= (max_cached_bytes))) 
# 576
{ 
# 578
recached = true; 
# 579
(cached_blocks).insert(search_key); 
# 580
((cached_bytes)[device].free) += (search_key.bytes); 
# 582
if (debug) { printf("\tDevice %d returned %lld bytes from associated stream %lld.\n\t\t %lld available blocks cached (%lld bytes), %lld live blocks o" "utstanding. (%lld bytes)\n", device, (long long)(search_key.bytes), (long long)(search_key.associated_stream), (long long)(cached_blocks).size(), (long long)((cached_bytes)[device].free), (long long)(live_blocks).size(), (long long)((cached_bytes)[device].live)); }  
# 584
; 
# 585
}  
# 586
}  
# 589
(mutex).Unlock(); 
# 592
if (device != entrypoint_device) 
# 593
{ 
# 594
if (cub::Debug(error = cudaGetDevice(&entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 594)) { return error; }  
# 595
if (cub::Debug(error = cudaSetDevice(device), "/usr/local/cuda/include/cub/util_allocator.cuh", 595)) { return error; }  
# 596
}  
# 598
if (recached) 
# 599
{ 
# 601
if (cub::Debug(error = cudaEventRecord(search_key.ready_event, search_key.associated_stream), "/usr/local/cuda/include/cub/util_allocator.cuh", 601)) { return error; }  
# 602
} else 
# 604
{ 
# 606
if (cub::Debug(error = cudaFree(d_ptr), "/usr/local/cuda/include/cub/util_allocator.cuh", 606)) { return error; }  
# 607
if (cub::Debug(error = cudaEventDestroy(search_key.ready_event), "/usr/local/cuda/include/cub/util_allocator.cuh", 607)) { return error; }  
# 609
if (debug) { printf("\tDevice %d freed %lld bytes from associated stream %lld.\n\t\t  %lld available blocks cached (%lld bytes), %lld live blocks (%l" "ld bytes) outstanding.\n", device, (long long)(search_key.bytes), (long long)(search_key.associated_stream), (long long)(cached_blocks).size(), (long long)((cached_bytes)[device].free), (long long)(live_blocks).size(), (long long)((cached_bytes)[device].live)); }  
# 610
; 
# 611
}  
# 614
if ((entrypoint_device != INVALID_DEVICE_ORDINAL) && (entrypoint_device != device)) 
# 615
{ 
# 616
if (cub::Debug(error = cudaSetDevice(entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 616)) { return error; }  
# 617
}  
# 619
return error; 
# 620
} 
# 630
cudaError_t DeviceFree(void *
# 631
d_ptr) 
# 632
{ 
# 633
return this->DeviceFree(INVALID_DEVICE_ORDINAL, d_ptr); 
# 634
} 
# 640
cudaError_t FreeAllCached() 
# 641
{ 
# 642
cudaError_t error = cudaSuccess; 
# 643
int entrypoint_device = INVALID_DEVICE_ORDINAL; 
# 644
int current_device = INVALID_DEVICE_ORDINAL; 
# 646
(mutex).Lock(); 
# 648
while (!(cached_blocks).empty()) 
# 649
{ 
# 651
std::multiset< BlockDescriptor, bool (*)(const BlockDescriptor &, const BlockDescriptor &)> ::iterator begin = (cached_blocks).begin(); 
# 654
if (entrypoint_device == INVALID_DEVICE_ORDINAL) 
# 655
{ 
# 656
if (cub::Debug(error = cudaGetDevice(&entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 656)) { break; }  
# 657
}  
# 660
if ((begin->device) != current_device) 
# 661
{ 
# 662
if (cub::Debug(error = cudaSetDevice(begin->device), "/usr/local/cuda/include/cub/util_allocator.cuh", 662)) { break; }  
# 663
current_device = (begin->device); 
# 664
}  
# 667
if (cub::Debug(error = cudaFree(begin->d_ptr), "/usr/local/cuda/include/cub/util_allocator.cuh", 667)) { break; }  
# 668
if (cub::Debug(error = cudaEventDestroy(begin->ready_event), "/usr/local/cuda/include/cub/util_allocator.cuh", 668)) { break; }  
# 671
((cached_bytes)[current_device].free) -= (begin->bytes); 
# 673
if (debug) { printf("\tDevice %d freed %lld bytes.\n\t\t  %lld available blocks cached (%lld bytes), %lld live blocks (%lld bytes) outstanding.\n", current_device, (long long)(begin->bytes), (long long)(cached_blocks).size(), (long long)((cached_bytes)[current_device].free), (long long)(live_blocks).size(), (long long)((cached_bytes)[current_device].live)); }  
# 674
; 
# 676
(cached_blocks).erase(begin); 
# 677
}  
# 679
(mutex).Unlock(); 
# 682
if (entrypoint_device != INVALID_DEVICE_ORDINAL) 
# 683
{ 
# 684
if (cub::Debug(error = cudaSetDevice(entrypoint_device), "/usr/local/cuda/include/cub/util_allocator.cuh", 684)) { return error; }  
# 685
}  
# 687
return error; 
# 688
} 
# 694
virtual ~CachingDeviceAllocator() 
# 695
{ 
# 696
if (!(skip_cleanup)) { 
# 697
this->FreeAllCached(); }  
# 698
} 
# 700
}; 
# 707
}
# 47 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
namespace cub { 
# 87
__attribute((always_inline)) __attribute__((unused)) inline unsigned SHR_ADD(unsigned 
# 88
x, unsigned 
# 89
shift, unsigned 
# 90
addend) 
# 91
{int volatile ___ = 1;(void)x;(void)shift;(void)addend;
# 100
::exit(___);}
#if 0
# 91
{ 
# 92
unsigned ret; 
# 97
ret = ((x >> shift) + addend); 
# 99
return ret; 
# 100
} 
#endif
# 106 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned SHL_ADD(unsigned 
# 107
x, unsigned 
# 108
shift, unsigned 
# 109
addend) 
# 110
{int volatile ___ = 1;(void)x;(void)shift;(void)addend;
# 119
::exit(___);}
#if 0
# 110
{ 
# 111
unsigned ret; 
# 116
ret = ((x << shift) + addend); 
# 118
return ret; 
# 119
} 
#endif
# 126 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class UnsignedBits, int BYTE_LEN> 
# 127
__attribute((always_inline)) __attribute__((unused)) inline unsigned BFE(UnsignedBits 
# 128
source, unsigned 
# 129
bit_start, unsigned 
# 130
num_bits, Int2Type< BYTE_LEN>  
# 131
byte_len) 
# 132
{int volatile ___ = 1;(void)source;(void)bit_start;(void)num_bits;(void)byte_len;
# 141
::exit(___);}
#if 0
# 132
{ 
# 133
unsigned bits; 
# 137
const unsigned MASK = (1 << num_bits) - 1; 
# 138
bits = ((source >> bit_start) & MASK); 
# 140
return bits; 
# 141
} 
#endif
# 147 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class UnsignedBits> 
# 148
__attribute((always_inline)) __attribute__((unused)) inline unsigned BFE(UnsignedBits 
# 149
source, unsigned 
# 150
bit_start, unsigned 
# 151
num_bits, Int2Type< 8>  
# 152
byte_len) 
# 153
{int volatile ___ = 1;(void)source;(void)bit_start;(void)num_bits;(void)byte_len;
# 156
::exit(___);}
#if 0
# 153
{ 
# 154
const unsigned long long MASK = (1ULL << num_bits) - (1); 
# 155
return (source >> bit_start) & MASK; 
# 156
} 
#endif
# 163 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class UnsignedBits> 
# 164
__attribute((always_inline)) __attribute__((unused)) inline unsigned BFE(UnsignedBits 
# 165
source, unsigned 
# 166
bit_start, unsigned 
# 167
num_bits) 
# 168
{int volatile ___ = 1;(void)source;(void)bit_start;(void)num_bits;
# 170
::exit(___);}
#if 0
# 168
{ 
# 169
return BFE(source, bit_start, num_bits, Int2Type< sizeof(UnsignedBits)> ()); 
# 170
} 
#endif
# 176 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline void BFI(unsigned &
# 177
ret, unsigned 
# 178
x, unsigned 
# 179
y, unsigned 
# 180
bit_start, unsigned 
# 181
num_bits) 
# 182
{int volatile ___ = 1;(void)ret;(void)x;(void)y;(void)bit_start;(void)num_bits;
# 192
::exit(___);}
#if 0
# 182
{ 
# 187
x <<= bit_start; 
# 188
unsigned MASK_X = ((1 << num_bits) - 1) << bit_start; 
# 189
unsigned MASK_Y = ~MASK_X; 
# 190
ret = ((y & MASK_Y) | (x & MASK_X)); 
# 192
} 
#endif
# 198 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned IADD3(unsigned x, unsigned y, unsigned z) 
# 199
{int volatile ___ = 1;(void)x;(void)y;(void)z;
# 206
::exit(___);}
#if 0
# 199
{ 
# 203
x = ((x + y) + z); 
# 205
return x; 
# 206
} 
#endif
# 235 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline int PRMT(unsigned a, unsigned b, unsigned index) 
# 236
{int volatile ___ = 1;(void)a;(void)b;(void)index;
# 240
::exit(___);}
#if 0
# 236
{ 
# 237
int ret; 
# 238
__asm__ volatile("prmt.b32 %0, %1, %2, %3;" : "=r" (ret) : "r" (a), "r" (b), "r" (index)); 
# 239
return ret; 
# 240
} 
#endif
# 247 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline void BAR(int count) 
# 248
{int volatile ___ = 1;(void)count;
# 250
::exit(___);}
#if 0
# 248
{ 
# 249
__asm__ volatile("bar.sync 1, %0;" : : "r" (count)); 
# 250
} 
#endif
# 256 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline float FMUL_RZ(float a, float b) 
# 257
{int volatile ___ = 1;(void)a;(void)b;
# 261
::exit(___);}
#if 0
# 257
{ 
# 258
float d; 
# 259
__asm__ volatile("mul.rz.f32 %0, %1, %2;" : "=f" (d) : "f" (a), "f" (b)); 
# 260
return d; 
# 261
} 
#endif
# 267 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline float FFMA_RZ(float a, float b, float c) 
# 268
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 272
::exit(___);}
#if 0
# 268
{ 
# 269
float d; 
# 270
__asm__ volatile("fma.rz.f32 %0, %1, %2, %3;" : "=f" (d) : "f" (a), "f" (b), "f" (c)); 
# 271
return d; 
# 272
} 
#endif
# 279 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline void ThreadExit() {int volatile ___ = 1;
# 281
::exit(___);}
#if 0
# 279
{ 
# 280
__asm__ volatile("exit;"); 
# 281
} 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline int RowMajorTid(int block_dim_x, int block_dim_y, int block_dim_z) 
# 288
{int volatile ___ = 1;(void)block_dim_x;(void)block_dim_y;(void)block_dim_z;
# 292
::exit(___);}
#if 0
# 288
{ 
# 289
return (((block_dim_z == 1) ? 0 : (((__device_builtin_variable_threadIdx.z) * block_dim_x) * block_dim_y)) + ((block_dim_y == 1) ? 0 : ((__device_builtin_variable_threadIdx.y) * block_dim_x))) + (__device_builtin_variable_threadIdx.x); 
# 292
} 
#endif
# 298 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned LaneId() 
# 299
{int volatile ___ = 1;
# 303
::exit(___);}
#if 0
# 299
{ 
# 300
unsigned ret; 
# 301
__asm__ volatile("mov.u32 %0, %laneid;" : "=r" (ret) :); 
# 302
return ret; 
# 303
} 
#endif
# 309 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned WarpId() 
# 310
{int volatile ___ = 1;
# 314
::exit(___);}
#if 0
# 310
{ 
# 311
unsigned ret; 
# 312
__asm__ volatile("mov.u32 %0, %warpid;" : "=r" (ret) :); 
# 313
return ret; 
# 314
} 
#endif
# 319 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned LaneMaskLt() 
# 320
{int volatile ___ = 1;
# 324
::exit(___);}
#if 0
# 320
{ 
# 321
unsigned ret; 
# 322
__asm__ volatile("mov.u32 %0, %lanemask_lt;" : "=r" (ret) :); 
# 323
return ret; 
# 324
} 
#endif
# 329 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned LaneMaskLe() 
# 330
{int volatile ___ = 1;
# 334
::exit(___);}
#if 0
# 330
{ 
# 331
unsigned ret; 
# 332
__asm__ volatile("mov.u32 %0, %lanemask_le;" : "=r" (ret) :); 
# 333
return ret; 
# 334
} 
#endif
# 339 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned LaneMaskGt() 
# 340
{int volatile ___ = 1;
# 344
::exit(___);}
#if 0
# 340
{ 
# 341
unsigned ret; 
# 342
__asm__ volatile("mov.u32 %0, %lanemask_gt;" : "=r" (ret) :); 
# 343
return ret; 
# 344
} 
#endif
# 349 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline unsigned LaneMaskGe() 
# 350
{int volatile ___ = 1;
# 354
::exit(___);}
#if 0
# 350
{ 
# 351
unsigned ret; 
# 352
__asm__ volatile("mov.u32 %0, %lanemask_ge;" : "=r" (ret) :); 
# 353
return ret; 
# 354
} 
#endif
# 366 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT, int STEP> 
# 367
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleUp(ShuffleWordT *
# 368
input, ShuffleWordT *
# 369
output, int 
# 370
src_offset, int 
# 371
first_lane, Int2Type< STEP>  
# 372
step) 
# 373
{int volatile ___ = 1;(void)input;(void)output;(void)src_offset;(void)first_lane;(void)step;
# 380
::exit(___);}
#if 0
# 373
{ 
# 374
unsigned word = input[STEP]; 
# 375
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=r" (word) : "r" (word), "r" (src_offset), "r" (first_lane)); 
# 377
(output[STEP]) = ((ShuffleWordT)word); 
# 379
ShuffleUp(input, output, src_offset, first_lane, Int2Type< STEP - 1> ()); 
# 380
} 
#endif
# 386 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT> 
# 387
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleUp(ShuffleWordT *
# 388
input, ShuffleWordT *
# 389
output, int 
# 390
src_offset, int 
# 391
first_lane, Int2Type< -1>  
# 392
step) 
# 393
{int volatile ___ = 1;(void)input;(void)output;(void)src_offset;(void)first_lane;(void)step;::exit(___);}
#if 0
# 393
{ } 
#endif
# 400 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT, int STEP> 
# 401
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleDown(ShuffleWordT *
# 402
input, ShuffleWordT *
# 403
output, int 
# 404
src_offset, int 
# 405
last_lane, Int2Type< STEP>  
# 406
step) 
# 407
{int volatile ___ = 1;(void)input;(void)output;(void)src_offset;(void)last_lane;(void)step;
# 414
::exit(___);}
#if 0
# 407
{ 
# 408
unsigned word = input[STEP]; 
# 409
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=r" (word) : "r" (word), "r" (src_offset), "r" (last_lane)); 
# 411
(output[STEP]) = ((ShuffleWordT)word); 
# 413
ShuffleDown(input, output, src_offset, last_lane, Int2Type< STEP - 1> ()); 
# 414
} 
#endif
# 420 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT> 
# 421
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleDown(ShuffleWordT *
# 422
input, ShuffleWordT *
# 423
output, int 
# 424
src_offset, int 
# 425
last_lane, Int2Type< -1>  
# 426
step) 
# 427
{int volatile ___ = 1;(void)input;(void)output;(void)src_offset;(void)last_lane;(void)step;::exit(___);}
#if 0
# 427
{ } 
#endif
# 433 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT, int STEP> 
# 434
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleIdx(ShuffleWordT *
# 435
input, ShuffleWordT *
# 436
output, int 
# 437
src_lane, int 
# 438
last_lane, Int2Type< STEP>  
# 439
step) 
# 440
{int volatile ___ = 1;(void)input;(void)output;(void)src_lane;(void)last_lane;(void)step;
# 447
::exit(___);}
#if 0
# 440
{ 
# 441
unsigned word = input[STEP]; 
# 442
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=r" (word) : "r" (word), "r" (src_lane), "r" (last_lane)); 
# 444
(output[STEP]) = ((ShuffleWordT)word); 
# 446
ShuffleIdx(input, output, src_lane, last_lane, Int2Type< STEP - 1> ()); 
# 447
} 
#endif
# 453 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class ShuffleWordT> 
# 454
__attribute((always_inline)) __attribute__((unused)) inline void ShuffleIdx(ShuffleWordT *
# 455
input, ShuffleWordT *
# 456
output, int 
# 457
src_lane, int 
# 458
last_lane, Int2Type< -1>  
# 459
step) 
# 460
{int volatile ___ = 1;(void)input;(void)output;(void)src_lane;(void)last_lane;(void)step;::exit(___);}
#if 0
# 460
{ } 
#endif
# 497 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class T> 
# 498
__attribute((always_inline)) __attribute__((unused)) inline T ShuffleUp(T 
# 499
input, int 
# 500
src_offset, int 
# 501
first_lane = 0) 
# 502
{int volatile ___ = 1;(void)input;(void)src_offset;(void)first_lane;
# 527
::exit(___);}
#if 0
# 502
{ 
# 503
typedef typename UnitWord< T> ::ShuffleWord ShuffleWord; 
# 505
const int WORDS = (((sizeof(T) + sizeof(ShuffleWord)) - (1)) / sizeof(ShuffleWord)); 
# 507
T output; 
# 508
ShuffleWord *output_alias = (reinterpret_cast< ShuffleWord *>(&output)); 
# 509
ShuffleWord *input_alias = (reinterpret_cast< ShuffleWord *>(&input)); 
# 511
unsigned shuffle_word; 
# 512
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[0])), "r" (src_offset), "r" (first_lane)); 
# 514
(output_alias[0]) = shuffle_word; 
# 517
#pragma unroll
for (
# 517
int WORD = 1; WORD < WORDS; ++WORD) 
# 518
{ 
# 519
__asm__ volatile("shfl.up.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[WORD])), "r" (src_offset), "r" (first_lane)); 
# 521
(output_alias[WORD]) = shuffle_word; 
# 522
}  
# 526
return output; 
# 527
} 
#endif
# 558 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class T> 
# 559
__attribute((always_inline)) __attribute__((unused)) inline T ShuffleDown(T 
# 560
input, int 
# 561
src_offset, int 
# 562
last_lane = (1 << 5) - 1) 
# 563
{int volatile ___ = 1;(void)input;(void)src_offset;(void)last_lane;
# 588
::exit(___);}
#if 0
# 563
{ 
# 564
typedef typename UnitWord< T> ::ShuffleWord ShuffleWord; 
# 566
const int WORDS = (((sizeof(T) + sizeof(ShuffleWord)) - (1)) / sizeof(ShuffleWord)); 
# 568
T output; 
# 569
ShuffleWord *output_alias = (reinterpret_cast< ShuffleWord *>(&output)); 
# 570
ShuffleWord *input_alias = (reinterpret_cast< ShuffleWord *>(&input)); 
# 572
unsigned shuffle_word; 
# 573
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[0])), "r" (src_offset), "r" (last_lane)); 
# 575
(output_alias[0]) = shuffle_word; 
# 578
#pragma unroll
for (
# 578
int WORD = 1; WORD < WORDS; ++WORD) 
# 579
{ 
# 580
__asm__ volatile("shfl.down.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[WORD])), "r" (src_offset), "r" (last_lane)); 
# 582
(output_alias[WORD]) = shuffle_word; 
# 583
}  
# 587
return output; 
# 588
} 
#endif
# 599 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class T> 
# 600
__attribute((always_inline)) __attribute__((unused)) inline T ShuffleIndex(T 
# 601
input, int 
# 602
src_lane, int 
# 603
logical_warp_threads) 
# 604
{int volatile ___ = 1;(void)input;(void)src_lane;(void)logical_warp_threads;
# 629
::exit(___);}
#if 0
# 604
{ 
# 605
typedef typename UnitWord< T> ::ShuffleWord ShuffleWord; 
# 607
const int WORDS = (((sizeof(T) + sizeof(ShuffleWord)) - (1)) / sizeof(ShuffleWord)); 
# 609
T output; 
# 610
ShuffleWord *output_alias = (reinterpret_cast< ShuffleWord *>(&output)); 
# 611
ShuffleWord *input_alias = (reinterpret_cast< ShuffleWord *>(&input)); 
# 613
unsigned shuffle_word; 
# 614
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[0])), "r" (src_lane), "r" (logical_warp_threads - 1)); 
# 616
(output_alias[0]) = shuffle_word; 
# 619
#pragma unroll
for (
# 619
int WORD = 1; WORD < WORDS; ++WORD) 
# 620
{ 
# 621
__asm__ volatile("shfl.idx.b32 %0, %1, %2, %3;" : "=r" (shuffle_word) : "r" ((unsigned)(input_alias[WORD])), "r" (src_lane), "r" (logical_warp_threads - 1)); 
# 623
(output_alias[WORD]) = shuffle_word; 
# 624
}  
# 628
return output; 
# 629
} 
#endif
# 662 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
template< class T> 
# 663
__attribute((always_inline)) __attribute__((unused)) inline T ShuffleIndex(T 
# 664
input, int 
# 665
src_lane) 
# 666
{int volatile ___ = 1;(void)input;(void)src_lane;
# 668
::exit(___);}
#if 0
# 666
{ 
# 667
return ShuffleIndex(input, src_lane, 1 << 5); 
# 668
} 
#endif
# 678 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline int WarpAll(int cond) 
# 679
{int volatile ___ = 1;(void)cond;
# 697
::exit(___);}
#if 0
# 679
{ 
# 682
__attribute__((unused)) static volatile int warp_signals[32]; 
# 684
if (LaneId() == (0)) { 
# 685
((warp_signals)[WarpId()]) = 1; }  
# 687
if (cond == 0) { 
# 688
((warp_signals)[WarpId()]) = 0; }  
# 690
return (warp_signals)[WarpId()]; 
# 697
} 
#endif
# 704 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
__attribute((always_inline)) __attribute__((unused)) inline int WarpAny(int cond) 
# 705
{int volatile ___ = 1;(void)cond;
# 723
::exit(___);}
#if 0
# 705
{ 
# 708
__attribute__((unused)) static volatile int warp_signals[32]; 
# 710
if (LaneId() == (0)) { 
# 711
((warp_signals)[WarpId()]) = 0; }  
# 713
if (cond) { 
# 714
((warp_signals)[WarpId()]) = 1; }  
# 716
return (warp_signals)[WarpId()]; 
# 723
} 
#endif
# 726 "/usr/local/cuda/include/cub/device/../iterator/../thread/../util_ptx.cuh"
}
# 48 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
namespace cub { 
# 62
enum CacheLoadModifier { 
# 64
LOAD_DEFAULT, 
# 65
LOAD_CA, 
# 66
LOAD_CG, 
# 67
LOAD_CS, 
# 68
LOAD_CV, 
# 69
LOAD_LDG, 
# 70
LOAD_VOLATILE
# 71
}; 
# 107
template< CacheLoadModifier 
# 108
MODIFIER, class 
# 109
InputIteratorT> 
# 110
__attribute((always_inline)) __attribute__((unused)) inline typename std::iterator_traits< InputIteratorT> ::value_type 
# 107
ThreadLoad(InputIteratorT itr); 
# 120
template< int COUNT, int MAX> 
# 121
struct IterateThreadLoad { 
# 123
template< CacheLoadModifier MODIFIER, class T> 
# 124
__attribute((always_inline)) static void Load(const T *ptr, T *vals) 
# 125
{int volatile ___ = 1;(void)ptr;(void)vals;
# 128
::exit(___);}
#if 0
# 125
{ 
# 126
(vals[COUNT]) = ThreadLoad< MODIFIER> (ptr + COUNT); 
# 127
cub::IterateThreadLoad< COUNT + 1, MAX> ::template Load< MODIFIER> (ptr, vals); 
# 128
} 
#endif
# 130 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class InputIteratorT, class T> 
# 131
__attribute((always_inline)) static void Dereference(InputIteratorT itr, T *vals) 
# 132
{int volatile ___ = 1;(void)itr;(void)vals;
# 135
::exit(___);}
#if 0
# 132
{ 
# 133
(vals[COUNT]) = (itr[COUNT]); 
# 134
IterateThreadLoad< COUNT + 1, MAX> ::Dereference(itr, vals); 
# 135
} 
#endif
# 136 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
}; 
# 140
template< int MAX> 
# 141
struct IterateThreadLoad< MAX, MAX>  { 
# 143
template< CacheLoadModifier MODIFIER, class T> 
# 144
__attribute((always_inline)) static void Load(const T *ptr, T *vals) {int volatile ___ = 1;(void)ptr;(void)vals;::exit(___);}
#if 0
# 144
{ } 
#endif
# 146 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class InputIteratorT, class T> 
# 147
__attribute((always_inline)) static void Dereference(InputIteratorT itr, T *vals) {int volatile ___ = 1;(void)itr;(void)vals;::exit(___);}
#if 0
# 147
{ } 
#endif
# 148 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
}; 
# 284
template<> __attribute((always_inline)) __attribute__((unused)) inline uint4 ThreadLoad< LOAD_CA, const uint4 *> (const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ uint4 retval; __asm__ volatile("ld.global.v4.u32 {%0, %1, %2, %3}, [%4];" : "=r" (retval.x), "=r" (retval.y), "=r" (retval.z), "=r" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ulonglong2 ThreadLoad< LOAD_CA, const ulonglong2 *> (const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ ulonglong2 retval; __asm__ volatile("ld.global.v2.u64 {%0, %1}, [%2];" : "=l" (retval.x), "=l" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ushort4 ThreadLoad< LOAD_CA, const ushort4 *> (const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ ushort4 retval; __asm__ volatile("ld.global.v4.u16 {%0, %1, %2, %3}, [%4];" : "=h" (retval.x), "=h" (retval.y), "=h" (retval.z), "=h" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint2 ThreadLoad< LOAD_CA, const uint2 *> (const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ uint2 retval; __asm__ volatile("ld.global.v2.u32 {%0, %1}, [%2];" : "=r" (retval.x), "=r" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned long long ThreadLoad< LOAD_CA, const unsigned long long *> (const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ unsigned long long retval; __asm__ volatile("ld.global.u64 %0, [%1];" : "=l" (retval) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned ThreadLoad< LOAD_CA, const unsigned *> (const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ unsigned retval; __asm__ volatile("ld.global.u32 %0, [%1];" : "=r" (retval) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned short ThreadLoad< LOAD_CA, const unsigned short *> (const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ unsigned short retval; __asm__ volatile("ld.global.u16 %0, [%1];" : "=h" (retval) : "l" (ptr)); return retval; } 
#endif
# 284 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned char ThreadLoad< LOAD_CA, const unsigned char *> (const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ unsigned short retval; __asm__ volatile("{   .reg .u8 datum;    ld.global.u8 datum, [%1];    cvt.u16.u8 %0, datum;}" : "=h" (retval) : "l" (ptr)); return (unsigned char)retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint4 ThreadLoad< LOAD_CG, const uint4 *> (const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ uint4 retval; __asm__ volatile("ld.volatile.global.v4.u32 {%0, %1, %2, %3}, [%4];" : "=r" (retval.x), "=r" (retval.y), "=r" (retval.z), "=r" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ulonglong2 ThreadLoad< LOAD_CG, const ulonglong2 *> (const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ ulonglong2 retval; __asm__ volatile("ld.volatile.global.v2.u64 {%0, %1}, [%2];" : "=l" (retval.x), "=l" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ushort4 ThreadLoad< LOAD_CG, const ushort4 *> (const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ ushort4 retval; __asm__ volatile("ld.volatile.global.v4.u16 {%0, %1, %2, %3}, [%4];" : "=h" (retval.x), "=h" (retval.y), "=h" (retval.z), "=h" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint2 ThreadLoad< LOAD_CG, const uint2 *> (const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ uint2 retval; __asm__ volatile("ld.volatile.global.v2.u32 {%0, %1}, [%2];" : "=r" (retval.x), "=r" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned long long ThreadLoad< LOAD_CG, const unsigned long long *> (const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ unsigned long long retval; __asm__ volatile("ld.volatile.global.u64 %0, [%1];" : "=l" (retval) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned ThreadLoad< LOAD_CG, const unsigned *> (const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ unsigned retval; __asm__ volatile("ld.volatile.global.u32 %0, [%1];" : "=r" (retval) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned short ThreadLoad< LOAD_CG, const unsigned short *> (const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ unsigned short retval; __asm__ volatile("ld.volatile.global.u16 %0, [%1];" : "=h" (retval) : "l" (ptr)); return retval; } 
#endif
# 286 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned char ThreadLoad< LOAD_CG, const unsigned char *> (const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ unsigned short retval; __asm__ volatile("{   .reg .u8 datum;    ld.volatile.global.u8 datum, [%1];    cvt.u16.u8 %0, datum;}" : "=h" (retval) : "l" (ptr)); return (unsigned char)retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint4 ThreadLoad< LOAD_CS, const uint4 *> (const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ uint4 retval; __asm__ volatile("ld.global.v4.u32 {%0, %1, %2, %3}, [%4];" : "=r" (retval.x), "=r" (retval.y), "=r" (retval.z), "=r" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ulonglong2 ThreadLoad< LOAD_CS, const ulonglong2 *> (const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ ulonglong2 retval; __asm__ volatile("ld.global.v2.u64 {%0, %1}, [%2];" : "=l" (retval.x), "=l" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ushort4 ThreadLoad< LOAD_CS, const ushort4 *> (const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ ushort4 retval; __asm__ volatile("ld.global.v4.u16 {%0, %1, %2, %3}, [%4];" : "=h" (retval.x), "=h" (retval.y), "=h" (retval.z), "=h" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint2 ThreadLoad< LOAD_CS, const uint2 *> (const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ uint2 retval; __asm__ volatile("ld.global.v2.u32 {%0, %1}, [%2];" : "=r" (retval.x), "=r" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned long long ThreadLoad< LOAD_CS, const unsigned long long *> (const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ unsigned long long retval; __asm__ volatile("ld.global.u64 %0, [%1];" : "=l" (retval) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned ThreadLoad< LOAD_CS, const unsigned *> (const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ unsigned retval; __asm__ volatile("ld.global.u32 %0, [%1];" : "=r" (retval) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned short ThreadLoad< LOAD_CS, const unsigned short *> (const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ unsigned short retval; __asm__ volatile("ld.global.u16 %0, [%1];" : "=h" (retval) : "l" (ptr)); return retval; } 
#endif
# 287 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned char ThreadLoad< LOAD_CS, const unsigned char *> (const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ unsigned short retval; __asm__ volatile("{   .reg .u8 datum;    ld.global.u8 datum, [%1];    cvt.u16.u8 %0, datum;}" : "=h" (retval) : "l" (ptr)); return (unsigned char)retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint4 ThreadLoad< LOAD_CV, const uint4 *> (const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ uint4 retval; __asm__ volatile("ld.volatile.global.v4.u32 {%0, %1, %2, %3}, [%4];" : "=r" (retval.x), "=r" (retval.y), "=r" (retval.z), "=r" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ulonglong2 ThreadLoad< LOAD_CV, const ulonglong2 *> (const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ ulonglong2 retval; __asm__ volatile("ld.volatile.global.v2.u64 {%0, %1}, [%2];" : "=l" (retval.x), "=l" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ushort4 ThreadLoad< LOAD_CV, const ushort4 *> (const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ ushort4 retval; __asm__ volatile("ld.volatile.global.v4.u16 {%0, %1, %2, %3}, [%4];" : "=h" (retval.x), "=h" (retval.y), "=h" (retval.z), "=h" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint2 ThreadLoad< LOAD_CV, const uint2 *> (const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ uint2 retval; __asm__ volatile("ld.volatile.global.v2.u32 {%0, %1}, [%2];" : "=r" (retval.x), "=r" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned long long ThreadLoad< LOAD_CV, const unsigned long long *> (const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ unsigned long long retval; __asm__ volatile("ld.volatile.global.u64 %0, [%1];" : "=l" (retval) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned ThreadLoad< LOAD_CV, const unsigned *> (const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ unsigned retval; __asm__ volatile("ld.volatile.global.u32 %0, [%1];" : "=r" (retval) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned short ThreadLoad< LOAD_CV, const unsigned short *> (const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ unsigned short retval; __asm__ volatile("ld.volatile.global.u16 %0, [%1];" : "=h" (retval) : "l" (ptr)); return retval; } 
#endif
# 288 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned char ThreadLoad< LOAD_CV, const unsigned char *> (const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ unsigned short retval; __asm__ volatile("{   .reg .u8 datum;    ld.volatile.global.u8 datum, [%1];    cvt.u16.u8 %0, datum;}" : "=h" (retval) : "l" (ptr)); return (unsigned char)retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint4 ThreadLoad< LOAD_LDG, const uint4 *> (const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ uint4 retval; __asm__ volatile("ld.global.v4.u32 {%0, %1, %2, %3}, [%4];" : "=r" (retval.x), "=r" (retval.y), "=r" (retval.z), "=r" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ulonglong2 ThreadLoad< LOAD_LDG, const ulonglong2 *> (const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ ulonglong2 retval; __asm__ volatile("ld.global.v2.u64 {%0, %1}, [%2];" : "=l" (retval.x), "=l" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline ushort4 ThreadLoad< LOAD_LDG, const ushort4 *> (const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ ushort4 retval; __asm__ volatile("ld.global.v4.u16 {%0, %1, %2, %3}, [%4];" : "=h" (retval.x), "=h" (retval.y), "=h" (retval.z), "=h" (retval.w) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline uint2 ThreadLoad< LOAD_LDG, const uint2 *> (const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ uint2 retval; __asm__ volatile("ld.global.v2.u32 {%0, %1}, [%2];" : "=r" (retval.x), "=r" (retval.y) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned long long ThreadLoad< LOAD_LDG, const unsigned long long *> (const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ unsigned long long retval; __asm__ volatile("ld.global.u64 %0, [%1];" : "=l" (retval) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned ThreadLoad< LOAD_LDG, const unsigned *> (const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ unsigned retval; __asm__ volatile("ld.global.u32 %0, [%1];" : "=r" (retval) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned short ThreadLoad< LOAD_LDG, const unsigned short *> (const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ unsigned short retval; __asm__ volatile("ld.global.u16 %0, [%1];" : "=h" (retval) : "l" (ptr)); return retval; } 
#endif
# 294 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline unsigned char ThreadLoad< LOAD_LDG, const unsigned char *> (const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 294
{ unsigned short retval; __asm__ volatile("{   .reg .u8 datum;    ld.global.u8 datum, [%1];    cvt.u16.u8 %0, datum;}" : "=h" (retval) : "l" (ptr)); return (unsigned char)retval; } 
#endif
# 311 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class InputIteratorT> 
# 312
__attribute((always_inline)) __attribute__((unused)) inline typename std::iterator_traits< InputIteratorT> ::value_type ThreadLoad(InputIteratorT 
# 313
itr, Int2Type< LOAD_DEFAULT>  
# 314
modifier, Int2Type< 0>  
# 315
is_pointer) 
# 316
{int volatile ___ = 1;(void)itr;(void)modifier;(void)is_pointer;
# 318
::exit(___);}
#if 0
# 316
{ 
# 317
return *itr; 
# 318
} 
#endif
# 324 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class T> 
# 325
__attribute((always_inline)) __attribute__((unused)) inline T ThreadLoad(T *
# 326
ptr, Int2Type< 0>  
# 327
modifier, Int2Type< true>  
# 328
is_pointer) 
# 329
{int volatile ___ = 1;(void)ptr;(void)modifier;(void)is_pointer;
# 331
::exit(___);}
#if 0
# 329
{ 
# 330
return *ptr; 
# 331
} 
#endif
# 337 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class T> 
# 338
__attribute((always_inline)) __attribute__((unused)) inline T ThreadLoadVolatilePointer(T *
# 339
ptr, Int2Type< 1>  
# 340
is_primitive) 
# 341
{int volatile ___ = 1;(void)ptr;(void)is_primitive;
# 349
::exit(___);}
#if 0
# 341
{ 
# 342
T retval = *(reinterpret_cast< volatile T *>(ptr)); 
# 345
if (sizeof(T) == (1)) { __threadfence_block(); }  
# 348
return retval; 
# 349
} 
#endif
# 355 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class T> 
# 356
__attribute((always_inline)) __attribute__((unused)) inline T ThreadLoadVolatilePointer(T *
# 357
ptr, Int2Type< 0>  
# 358
is_primitive) 
# 359
{int volatile ___ = 1;(void)ptr;(void)is_primitive;
# 390
::exit(___);}
#if 0
# 359
{ 
# 363
T retval = *ptr; 
# 364
__threadfence_block(); 
# 365
return retval; 
# 390
} 
#endif
# 396 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class T> 
# 397
__attribute((always_inline)) __attribute__((unused)) inline T ThreadLoad(T *
# 398
ptr, Int2Type< LOAD_VOLATILE>  
# 399
modifier, Int2Type< 1>  
# 400
is_pointer) 
# 401
{int volatile ___ = 1;(void)ptr;(void)modifier;(void)is_pointer;
# 404
::exit(___);}
#if 0
# 401
{ 
# 403
return ThreadLoadVolatilePointer(ptr, Int2Type< Traits< T> ::PRIMITIVE> ()); 
# 404
} 
#endif
# 410 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< class T, int MODIFIER> 
# 411
__attribute((always_inline)) __attribute__((unused)) inline T ThreadLoad(const T *
# 412
ptr, Int2Type< MODIFIER>  
# 413
modifier, Int2Type< 1>  
# 414
is_pointer) 
# 415
{int volatile ___ = 1;(void)ptr;(void)modifier;(void)is_pointer;
# 427
::exit(___);}
#if 0
# 415
{ 
# 416
typedef typename UnitWord< T> ::DeviceWord DeviceWord; 
# 418
const int DEVICE_MULTIPLE = (sizeof(T) / sizeof(DeviceWord)); 
# 420
DeviceWord words[DEVICE_MULTIPLE]; 
# 422
IterateThreadLoad< 0, DEVICE_MULTIPLE> ::template Load< (CacheLoadModifier)MODIFIER> (reinterpret_cast< DeviceWord *>(const_cast< T *>(ptr)), words); 
# 426
return *(reinterpret_cast< T *>(words)); 
# 427
} 
#endif
# 433 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
template< CacheLoadModifier 
# 434
MODIFIER, class 
# 435
InputIteratorT> 
# 436
__attribute((always_inline)) __attribute__((unused)) inline typename std::iterator_traits< InputIteratorT> ::value_type ThreadLoad(InputIteratorT itr) 
# 437
{int volatile ___ = 1;(void)itr;
# 443
::exit(___);}
#if 0
# 437
{ 
# 439
return ThreadLoad(itr, Int2Type< MODIFIER> (), Int2Type< IsPointer< InputIteratorT> ::VALUE> ()); 
# 443
} 
#endif
# 453 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_load.cuh"
}
# 46 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
namespace cub { 
# 61
enum CacheStoreModifier { 
# 63
STORE_DEFAULT, 
# 64
STORE_WB, 
# 65
STORE_CG, 
# 66
STORE_CS, 
# 67
STORE_WT, 
# 68
STORE_VOLATILE
# 69
}; 
# 110
template< CacheStoreModifier 
# 111
MODIFIER, class 
# 112
OutputIteratorT, class 
# 113
T> 
# 114
__attribute((always_inline)) __attribute__((unused)) inline void 
# 110
ThreadStore(OutputIteratorT itr, T val); 
# 124
template< int COUNT, int MAX> 
# 125
struct IterateThreadStore { 
# 127
template< CacheStoreModifier MODIFIER, class T> 
# 128
__attribute((always_inline)) static void Store(T *ptr, T *vals) 
# 129
{int volatile ___ = 1;(void)ptr;(void)vals;
# 132
::exit(___);}
#if 0
# 129
{ 
# 130
ThreadStore< MODIFIER> (ptr + COUNT, vals[COUNT]); 
# 131
cub::IterateThreadStore< COUNT + 1, MAX> ::template Store< MODIFIER> (ptr, vals); 
# 132
} 
#endif
# 134 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class OutputIteratorT, class T> 
# 135
__attribute((always_inline)) static void Dereference(OutputIteratorT ptr, T *vals) 
# 136
{int volatile ___ = 1;(void)ptr;(void)vals;
# 139
::exit(___);}
#if 0
# 136
{ 
# 137
(ptr[COUNT]) = (vals[COUNT]); 
# 138
IterateThreadStore< COUNT + 1, MAX> ::Dereference(ptr, vals); 
# 139
} 
#endif
# 141 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
}; 
# 144
template< int MAX> 
# 145
struct IterateThreadStore< MAX, MAX>  { 
# 147
template< CacheStoreModifier MODIFIER, class T> 
# 148
__attribute((always_inline)) static void Store(T *ptr, T *vals) {int volatile ___ = 1;(void)ptr;(void)vals;::exit(___);}
#if 0
# 148
{ } 
#endif
# 150 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class OutputIteratorT, class T> 
# 151
__attribute((always_inline)) static void Dereference(OutputIteratorT ptr, T *vals) {int volatile ___ = 1;(void)ptr;(void)vals;::exit(___);}
#if 0
# 151
{ } 
#endif
# 152 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
}; 
# 272
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, uint4 *, uint4> (uint4 *ptr, uint4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.v4.u32 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "r" (val.x), "r" (val.y), "r" (val.z), "r" (val.w)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, ulonglong2 *, ulonglong2> (ulonglong2 *ptr, ulonglong2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.v2.u64 [%0], {%1, %2};" : : "l" (ptr), "l" (val.x), "l" (val.y)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, ushort4 *, ushort4> (ushort4 *ptr, ushort4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.v4.u16 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "h" (val.x), "h" (val.y), "h" (val.z), "h" (val.w)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, uint2 *, uint2> (uint2 *ptr, uint2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.v2.u32 [%0], {%1, %2};" : : "l" (ptr), "r" (val.x), "r" (val.y)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, unsigned long long *, unsigned long long> (unsigned long long *ptr, unsigned long long val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.u64 [%0], %1;" : : "l" (ptr), "l" (val)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, unsigned *, unsigned> (unsigned *ptr, unsigned val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.u32 [%0], %1;" : : "l" (ptr), "r" (val)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, unsigned short *, unsigned short> (unsigned short *ptr, unsigned short val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("st.global.u16 [%0], %1;" : : "l" (ptr), "h" (val)); } 
#endif
# 272 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WB, unsigned char *, unsigned char> (unsigned char *ptr, unsigned char val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 272
{ __asm__ volatile("{   .reg .u8 datum;   cvt.u8.u16 datum, %1;   st.global.u8 [%0], datum;}" : : "l" (ptr), "h" ((unsigned short)val)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, uint4 *, uint4> (uint4 *ptr, uint4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.v4.u32 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "r" (val.x), "r" (val.y), "r" (val.z), "r" (val.w)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, ulonglong2 *, ulonglong2> (ulonglong2 *ptr, ulonglong2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.v2.u64 [%0], {%1, %2};" : : "l" (ptr), "l" (val.x), "l" (val.y)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, ushort4 *, ushort4> (ushort4 *ptr, ushort4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.v4.u16 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "h" (val.x), "h" (val.y), "h" (val.z), "h" (val.w)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, uint2 *, uint2> (uint2 *ptr, uint2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.v2.u32 [%0], {%1, %2};" : : "l" (ptr), "r" (val.x), "r" (val.y)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, unsigned long long *, unsigned long long> (unsigned long long *ptr, unsigned long long val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.u64 [%0], %1;" : : "l" (ptr), "l" (val)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, unsigned *, unsigned> (unsigned *ptr, unsigned val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.u32 [%0], %1;" : : "l" (ptr), "r" (val)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, unsigned short *, unsigned short> (unsigned short *ptr, unsigned short val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("st.global.u16 [%0], %1;" : : "l" (ptr), "h" (val)); } 
#endif
# 273 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CG, unsigned char *, unsigned char> (unsigned char *ptr, unsigned char val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 273
{ __asm__ volatile("{   .reg .u8 datum;   cvt.u8.u16 datum, %1;   st.global.u8 [%0], datum;}" : : "l" (ptr), "h" ((unsigned short)val)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, uint4 *, uint4> (uint4 *ptr, uint4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.v4.u32 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "r" (val.x), "r" (val.y), "r" (val.z), "r" (val.w)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, ulonglong2 *, ulonglong2> (ulonglong2 *ptr, ulonglong2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.v2.u64 [%0], {%1, %2};" : : "l" (ptr), "l" (val.x), "l" (val.y)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, ushort4 *, ushort4> (ushort4 *ptr, ushort4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.v4.u16 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "h" (val.x), "h" (val.y), "h" (val.z), "h" (val.w)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, uint2 *, uint2> (uint2 *ptr, uint2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.v2.u32 [%0], {%1, %2};" : : "l" (ptr), "r" (val.x), "r" (val.y)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, unsigned long long *, unsigned long long> (unsigned long long *ptr, unsigned long long val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.u64 [%0], %1;" : : "l" (ptr), "l" (val)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, unsigned *, unsigned> (unsigned *ptr, unsigned val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.u32 [%0], %1;" : : "l" (ptr), "r" (val)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, unsigned short *, unsigned short> (unsigned short *ptr, unsigned short val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("st.global.u16 [%0], %1;" : : "l" (ptr), "h" (val)); } 
#endif
# 274 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_CS, unsigned char *, unsigned char> (unsigned char *ptr, unsigned char val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 274
{ __asm__ volatile("{   .reg .u8 datum;   cvt.u8.u16 datum, %1;   st.global.u8 [%0], datum;}" : : "l" (ptr), "h" ((unsigned short)val)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, uint4 *, uint4> (uint4 *ptr, uint4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.v4.u32 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "r" (val.x), "r" (val.y), "r" (val.z), "r" (val.w)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, ulonglong2 *, ulonglong2> (ulonglong2 *ptr, ulonglong2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.v2.u64 [%0], {%1, %2};" : : "l" (ptr), "l" (val.x), "l" (val.y)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, ushort4 *, ushort4> (ushort4 *ptr, ushort4 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.v4.u16 [%0], {%1, %2, %3, %4};" : : "l" (ptr), "h" (val.x), "h" (val.y), "h" (val.z), "h" (val.w)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, uint2 *, uint2> (uint2 *ptr, uint2 val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.v2.u32 [%0], {%1, %2};" : : "l" (ptr), "r" (val.x), "r" (val.y)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, unsigned long long *, unsigned long long> (unsigned long long *ptr, unsigned long long val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.u64 [%0], %1;" : : "l" (ptr), "l" (val)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, unsigned *, unsigned> (unsigned *ptr, unsigned val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.u32 [%0], %1;" : : "l" (ptr), "r" (val)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, unsigned short *, unsigned short> (unsigned short *ptr, unsigned short val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("st.volatile.global.u16 [%0], %1;" : : "l" (ptr), "h" (val)); } 
#endif
# 275 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template<> __attribute((always_inline)) __attribute__((unused)) inline void ThreadStore< STORE_WT, unsigned char *, unsigned char> (unsigned char *ptr, unsigned char val) {int volatile ___ = 1;(void)ptr;(void)val;::exit(___);}
#if 0
# 275
{ __asm__ volatile("{   .reg .u8 datum;   cvt.u8.u16 datum, %1;   st.volatile.global.u8 [%0], datum;}" : : "l" (ptr), "h" ((unsigned short)val)); } 
#endif
# 291 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class OutputIteratorT, class T> 
# 292
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStore(OutputIteratorT 
# 293
itr, T 
# 294
val, Int2Type< 0>  
# 295
modifier, Int2Type< 0>  
# 296
is_pointer) 
# 297
{int volatile ___ = 1;(void)itr;(void)val;(void)modifier;(void)is_pointer;
# 299
::exit(___);}
#if 0
# 297
{ 
# 298
(*itr) = val; 
# 299
} 
#endif
# 305 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class T> 
# 306
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStore(T *
# 307
ptr, T 
# 308
val, Int2Type< 0>  
# 309
modifier, Int2Type< 1>  
# 310
is_pointer) 
# 311
{int volatile ___ = 1;(void)ptr;(void)val;(void)modifier;(void)is_pointer;
# 313
::exit(___);}
#if 0
# 311
{ 
# 312
(*ptr) = val; 
# 313
} 
#endif
# 319 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class T> 
# 320
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStoreVolatilePtr(T *
# 321
ptr, T 
# 322
val, Int2Type< 1>  
# 323
is_primitive) 
# 324
{int volatile ___ = 1;(void)ptr;(void)val;(void)is_primitive;
# 326
::exit(___);}
#if 0
# 324
{ 
# 325
(*(reinterpret_cast< volatile T *>(ptr))) = val; 
# 326
} 
#endif
# 332 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class T> 
# 333
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStoreVolatilePtr(T *
# 334
ptr, T 
# 335
val, Int2Type< 0>  
# 336
is_primitive) 
# 337
{int volatile ___ = 1;(void)ptr;(void)val;(void)is_primitive;
# 364
::exit(___);}
#if 0
# 337
{ 
# 340
(*ptr) = val; 
# 341
__threadfence_block(); 
# 364
} 
#endif
# 370 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class T> 
# 371
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStore(T *
# 372
ptr, T 
# 373
val, Int2Type< STORE_VOLATILE>  
# 374
modifier, Int2Type< 1>  
# 375
is_pointer) 
# 376
{int volatile ___ = 1;(void)ptr;(void)val;(void)modifier;(void)is_pointer;
# 378
::exit(___);}
#if 0
# 376
{ 
# 377
ThreadStoreVolatilePtr(ptr, val, Int2Type< Traits< T> ::PRIMITIVE> ()); 
# 378
} 
#endif
# 384 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< class T, int MODIFIER> 
# 385
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStore(T *
# 386
ptr, T 
# 387
val, Int2Type< MODIFIER>  
# 388
modifier, Int2Type< 1>  
# 389
is_pointer) 
# 390
{int volatile ___ = 1;(void)ptr;(void)val;(void)modifier;(void)is_pointer;
# 407
::exit(___);}
#if 0
# 390
{ 
# 392
typedef typename UnitWord< T> ::DeviceWord DeviceWord; 
# 393
typedef typename UnitWord< T> ::ShuffleWord ShuffleWord; 
# 395
const int DEVICE_MULTIPLE = (sizeof(T) / sizeof(DeviceWord)); 
# 396
const int SHUFFLE_MULTIPLE = (sizeof(T) / sizeof(ShuffleWord)); 
# 398
DeviceWord words[DEVICE_MULTIPLE]; 
# 401
#pragma unroll
for (
# 401
int i = 0; i < SHUFFLE_MULTIPLE; ++i) { 
# 402
((reinterpret_cast< ShuffleWord *>(words))[i]) = ((reinterpret_cast< ShuffleWord *>(&val))[i]); }  
# 404
IterateThreadStore< 0, DEVICE_MULTIPLE> ::template Store< (CacheStoreModifier)MODIFIER> (reinterpret_cast< DeviceWord *>(ptr), words); 
# 407
} 
#endif
# 413 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
template< CacheStoreModifier MODIFIER, class OutputIteratorT, class T> 
# 414
__attribute((always_inline)) __attribute__((unused)) inline void ThreadStore(OutputIteratorT itr, T val) 
# 415
{int volatile ___ = 1;(void)itr;(void)val;
# 421
::exit(___);}
#if 0
# 415
{ 
# 416
ThreadStore(itr, val, Int2Type< MODIFIER> (), Int2Type< IsPointer< OutputIteratorT> ::VALUE> ()); 
# 421
} 
#endif
# 431 "/usr/local/cuda/include/cub/device/../iterator/../thread/thread_store.cuh"
}
# 56 "/usr/local/cuda/include/cub/device/../iterator/arg_index_input_iterator.cuh"
namespace cub { 
# 109
template< class 
# 110
InputIteratorT, class 
# 111
OffsetT = ptrdiff_t, class 
# 112
OutputValueT = typename std::iterator_traits< InputIteratorT> ::value_type> 
# 113
class ArgIndexInputIterator { 
# 118
public: typedef ArgIndexInputIterator self_type; 
# 119
typedef OffsetT difference_type; 
# 120
typedef KeyValuePair< OffsetT, OutputValueT>  value_type; 
# 121
typedef value_type *pointer; 
# 122
typedef value_type reference; 
# 131
typedef typename thrust::detail::iterator_facade_category< thrust::any_system_tag, thrust::random_access_traversal_tag, KeyValuePair< OffsetT, OutputValueT> , KeyValuePair< OffsetT, OutputValueT> > ::type iterator_category; 
# 138
private: InputIteratorT itr; 
# 139
difference_type offset; 
# 144
public: __attribute((always_inline)) ArgIndexInputIterator(InputIteratorT 
# 145
itr, difference_type 
# 146
offset = 0) : itr(itr), offset(offset) 
# 150
{ } 
# 153
__attribute((always_inline)) self_type operator++(int) 
# 154
{ 
# 155
self_type retval = *this; 
# 156
(offset)++; 
# 157
return retval; 
# 158
} 
# 161
__attribute((always_inline)) self_type operator++() 
# 162
{ 
# 163
(offset)++; 
# 164
return *this; 
# 165
} 
# 168
__attribute((always_inline)) reference operator*() const 
# 169
{ 
# 170
value_type retval; 
# 171
(retval.value) = ((itr)[offset]); 
# 172
(retval.key) = (offset); 
# 173
return retval; 
# 174
} 
# 177
template< class Distance> 
# 178
__attribute((always_inline)) self_type operator+(Distance n) const 
# 179
{ 
# 180
self_type retval(itr, (offset) + n); 
# 181
return retval; 
# 182
} 
# 185
template< class Distance> 
# 186
__attribute((always_inline)) self_type &operator+=(Distance n) 
# 187
{ 
# 188
(offset) += n; 
# 189
return *this; 
# 190
} 
# 193
template< class Distance> 
# 194
__attribute((always_inline)) self_type operator-(Distance n) const 
# 195
{ 
# 196
self_type retval(itr, (offset) - n); 
# 197
return retval; 
# 198
} 
# 201
template< class Distance> 
# 202
__attribute((always_inline)) self_type &operator-=(Distance n) 
# 203
{ 
# 204
(offset) -= n; 
# 205
return *this; 
# 206
} 
# 209
__attribute((always_inline)) difference_type operator-(self_type other) const 
# 210
{ 
# 211
return (offset) - (other.offset); 
# 212
} 
# 215
template< class Distance> 
# 216
__attribute((always_inline)) reference operator[](Distance n) const 
# 217
{ 
# 218
self_type offset = (*this) + n; 
# 219
return *offset; 
# 220
} 
# 223
__attribute((always_inline)) pointer operator->() 
# 224
{ 
# 225
return &(*(*this)); 
# 226
} 
# 229
__attribute((always_inline)) bool operator==(const self_type &rhs) 
# 230
{ 
# 231
return ((itr) == (rhs.itr)) && ((offset) == (rhs.offset)); 
# 232
} 
# 235
__attribute((always_inline)) bool operator!=(const self_type &rhs) 
# 236
{ 
# 237
return ((itr) != (rhs.itr)) || ((offset) != (rhs.offset)); 
# 238
} 
# 241
__attribute((always_inline)) void normalize() 
# 242
{ 
# 243
(itr) += (offset); 
# 244
(offset) = 0; 
# 245
} 
# 248
friend inline std::ostream &operator<<(std::ostream &os, const self_type &itr) 
# 249
{ 
# 250
return os; 
# 251
} 
# 252
}; 
# 258
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
namespace cub { 
# 108
template< class 
# 109
InputT, int 
# 110
BLOCK_DIM_X, int 
# 111
ITEMS_PER_THREAD, bool 
# 112
WARP_TIME_SLICING = false, int 
# 113
BLOCK_DIM_Y = 1, int 
# 114
BLOCK_DIM_Z = 1, int 
# 115
PTX_ARCH = 0> 
# 116
class BlockExchange { 
# 126
enum { 
# 128
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, 
# 130
LOG_WARP_THREADS = 5, 
# 131
WARP_THREADS = 1 << (5), 
# 132
WARPS = ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) + (1 << (5))) - 1) / (1 << (5)), 
# 134
LOG_SMEM_BANKS = (PTX_ARCH >= 200) ? 5 : 4, 
# 135
SMEM_BANKS = 1 << ((PTX_ARCH >= 200) ? 5 : 4), 
# 137
TILE_ITEMS = ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) * ITEMS_PER_THREAD, 
# 139
TIME_SLICES = WARP_TIME_SLICING ? ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) + (1 << (5))) - 1) / (1 << (5)) : 1, 
# 141
TIME_SLICED_THREADS = WARP_TIME_SLICING ? ((1 << (5)) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << (5) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z), 
# 142
TIME_SLICED_ITEMS = (WARP_TIME_SLICING ? ((1 << (5)) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << (5) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) * ITEMS_PER_THREAD, 
# 144
WARP_TIME_SLICED_THREADS = ((1 << (5)) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << (5) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z), 
# 145
WARP_TIME_SLICED_ITEMS = (((1 << (5)) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << (5) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) * ITEMS_PER_THREAD, 
# 148
INSERT_PADDING = PowerOfTwo< ITEMS_PER_THREAD> ::VALUE, 
# 150
PADDING_ITEMS = (PowerOfTwo< ITEMS_PER_THREAD> ::VALUE) ? ((WARP_TIME_SLICING ? ((1 << (5)) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << (5) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) * ITEMS_PER_THREAD) >> ((PTX_ARCH >= 200) ? 5 : 4) : 0
# 151
}; 
# 158
typedef InputT _TempStorage[(TIME_SLICED_ITEMS) + (PADDING_ITEMS)]; 
# 163
public: struct TempStorage : public Uninitialized< InputT [(TIME_SLICED_ITEMS) + (PADDING_ITEMS)]>  { }; 
# 173
private: _TempStorage &temp_storage; 
# 176
unsigned linear_tid; 
# 177
unsigned lane_id; 
# 178
unsigned warp_id; 
# 179
unsigned warp_offset; 
# 187
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 188
{int volatile ___ = 1;
# 191
::exit(___);}
#if 0
# 188
{ 
# 189
__attribute__((unused)) static _TempStorage private_storage; 
# 190
return private_storage; 
# 191
} 
#endif
# 197 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 198
__attribute((always_inline)) void BlockedToStriped(InputT 
# 199
input_items[], OutputT 
# 200
output_items[], Int2Type< 0>  
# 201
time_slicing) 
# 202
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 220
::exit(___);}
#if 0
# 202
{ 
# 204
#pragma unroll
for (
# 204
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 205
{ 
# 206
int item_offset = ((linear_tid) * (ITEMS_PER_THREAD)) + ITEM; 
# 207
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 208
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 209
}  
# 211
__syncthreads(); 
# 214
#pragma unroll
for (
# 214
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 215
{ 
# 216
int item_offset = ((int)(ITEM * (BLOCK_THREADS))) + (linear_tid); 
# 217
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 218
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 219
}  
# 220
} 
#endif
# 226 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 227
__attribute((always_inline)) void BlockedToStriped(InputT 
# 228
input_items[], OutputT 
# 229
output_items[], Int2Type< 1>  
# 230
time_slicing) 
# 231
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 280
::exit(___);}
#if 0
# 231
{ 
# 232
InputT temp_items[ITEMS_PER_THREAD]; 
# 235
#pragma unroll
for (
# 235
int SLICE = 0; SLICE < (TIME_SLICES); SLICE++) 
# 236
{ 
# 237
const int SLICE_OFFSET = SLICE * (TIME_SLICED_ITEMS); 
# 238
const int SLICE_OOB = SLICE_OFFSET + (TIME_SLICED_ITEMS); 
# 240
__syncthreads(); 
# 242
if ((warp_id) == SLICE) 
# 243
{ 
# 245
#pragma unroll
for (
# 245
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 246
{ 
# 247
int item_offset = ((lane_id) * (ITEMS_PER_THREAD)) + ITEM; 
# 248
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 249
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 250
}  
# 251
}  
# 253
__syncthreads(); 
# 256
#pragma unroll
for (
# 256
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 257
{ 
# 259
const int STRIP_OFFSET = ITEM * (BLOCK_THREADS); 
# 260
const int STRIP_OOB = STRIP_OFFSET + (BLOCK_THREADS); 
# 262
if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET)) 
# 263
{ 
# 264
int item_offset = (STRIP_OFFSET + (linear_tid)) - SLICE_OFFSET; 
# 265
if ((item_offset >= 0) && (item_offset < (TIME_SLICED_ITEMS))) 
# 266
{ 
# 267
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 268
((temp_items)[ITEM]) = ((temp_storage)[item_offset]); 
# 269
}  
# 270
}  
# 271
}  
# 272
}  
# 276
#pragma unroll
for (
# 276
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 277
{ 
# 278
(output_items[ITEM]) = ((temp_items)[ITEM]); 
# 279
}  
# 280
} 
#endif
# 286 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 287
__attribute((always_inline)) void BlockedToWarpStriped(InputT 
# 288
input_items[], OutputT 
# 289
output_items[], Int2Type< 0>  
# 290
time_slicing) 
# 291
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 309
::exit(___);}
#if 0
# 291
{ 
# 293
#pragma unroll
for (
# 293
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 294
{ 
# 295
int item_offset = ((warp_offset) + ITEM) + ((lane_id) * (ITEMS_PER_THREAD)); 
# 296
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 297
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 298
}  
# 300
__threadfence_block(); 
# 303
#pragma unroll
for (
# 303
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 304
{ 
# 305
int item_offset = ((warp_offset) + (ITEM * (WARP_TIME_SLICED_THREADS))) + (lane_id); 
# 306
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 307
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 308
}  
# 309
} 
#endif
# 314 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 315
__attribute((always_inline)) void BlockedToWarpStriped(InputT 
# 316
input_items[], OutputT 
# 317
output_items[], Int2Type< 1>  
# 318
time_slicing) 
# 319
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 367
::exit(___);}
#if 0
# 319
{ 
# 320
if ((warp_id) == (0)) 
# 321
{ 
# 323
#pragma unroll
for (
# 323
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 324
{ 
# 325
int item_offset = ITEM + ((lane_id) * (ITEMS_PER_THREAD)); 
# 326
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 327
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 328
}  
# 330
__threadfence_block(); 
# 333
#pragma unroll
for (
# 333
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 334
{ 
# 335
int item_offset = (ITEM * (WARP_TIME_SLICED_THREADS)) + (lane_id); 
# 336
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 337
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 338
}  
# 339
}  
# 342
#pragma unroll
for (
# 342
int SLICE = 1; SLICE < (TIME_SLICES); ++SLICE) 
# 343
{ 
# 344
__syncthreads(); 
# 346
if ((warp_id) == SLICE) 
# 347
{ 
# 349
#pragma unroll
for (
# 349
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 350
{ 
# 351
int item_offset = ITEM + ((lane_id) * (ITEMS_PER_THREAD)); 
# 352
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 353
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 354
}  
# 356
__threadfence_block(); 
# 359
#pragma unroll
for (
# 359
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 360
{ 
# 361
int item_offset = (ITEM * (WARP_TIME_SLICED_THREADS)) + (lane_id); 
# 362
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 363
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 364
}  
# 365
}  
# 366
}  
# 367
} 
#endif
# 373 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 374
__attribute((always_inline)) void StripedToBlocked(InputT 
# 375
input_items[], OutputT 
# 376
output_items[], Int2Type< 0>  
# 377
time_slicing) 
# 378
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 397
::exit(___);}
#if 0
# 378
{ 
# 380
#pragma unroll
for (
# 380
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 381
{ 
# 382
int item_offset = ((int)(ITEM * (BLOCK_THREADS))) + (linear_tid); 
# 383
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 384
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 385
}  
# 387
__syncthreads(); 
# 391
#pragma unroll
for (
# 391
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 392
{ 
# 393
int item_offset = ((linear_tid) * (ITEMS_PER_THREAD)) + ITEM; 
# 394
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 395
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 396
}  
# 397
} 
#endif
# 403 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 404
__attribute((always_inline)) void StripedToBlocked(InputT 
# 405
input_items[], OutputT 
# 406
output_items[], Int2Type< 1>  
# 407
time_slicing) 
# 408
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 458
::exit(___);}
#if 0
# 408
{ 
# 410
InputT temp_items[ITEMS_PER_THREAD]; 
# 413
#pragma unroll
for (
# 413
int SLICE = 0; SLICE < (TIME_SLICES); SLICE++) 
# 414
{ 
# 415
const int SLICE_OFFSET = SLICE * (TIME_SLICED_ITEMS); 
# 416
const int SLICE_OOB = SLICE_OFFSET + (TIME_SLICED_ITEMS); 
# 418
__syncthreads(); 
# 421
#pragma unroll
for (
# 421
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 422
{ 
# 424
const int STRIP_OFFSET = ITEM * (BLOCK_THREADS); 
# 425
const int STRIP_OOB = STRIP_OFFSET + (BLOCK_THREADS); 
# 427
if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET)) 
# 428
{ 
# 429
int item_offset = (STRIP_OFFSET + (linear_tid)) - SLICE_OFFSET; 
# 430
if ((item_offset >= 0) && (item_offset < (TIME_SLICED_ITEMS))) 
# 431
{ 
# 432
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 433
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 434
}  
# 435
}  
# 436
}  
# 438
__syncthreads(); 
# 440
if ((warp_id) == SLICE) 
# 441
{ 
# 443
#pragma unroll
for (
# 443
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 444
{ 
# 445
int item_offset = ((lane_id) * (ITEMS_PER_THREAD)) + ITEM; 
# 446
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 447
((temp_items)[ITEM]) = ((temp_storage)[item_offset]); 
# 448
}  
# 449
}  
# 450
}  
# 454
#pragma unroll
for (
# 454
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 455
{ 
# 456
(output_items[ITEM]) = ((temp_items)[ITEM]); 
# 457
}  
# 458
} 
#endif
# 464 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 465
__attribute((always_inline)) void WarpStripedToBlocked(InputT 
# 466
input_items[], OutputT 
# 467
output_items[], Int2Type< 0>  
# 468
time_slicing) 
# 469
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 487
::exit(___);}
#if 0
# 469
{ 
# 471
#pragma unroll
for (
# 471
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 472
{ 
# 473
int item_offset = ((warp_offset) + (ITEM * (WARP_TIME_SLICED_THREADS))) + (lane_id); 
# 474
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 475
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 476
}  
# 478
__threadfence_block(); 
# 481
#pragma unroll
for (
# 481
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 482
{ 
# 483
int item_offset = ((warp_offset) + ITEM) + ((lane_id) * (ITEMS_PER_THREAD)); 
# 484
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 485
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 486
}  
# 487
} 
#endif
# 493 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 494
__attribute((always_inline)) void WarpStripedToBlocked(InputT 
# 495
input_items[], OutputT 
# 496
output_items[], Int2Type< 1>  
# 497
time_slicing) 
# 498
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)time_slicing;
# 525
::exit(___);}
#if 0
# 498
{ 
# 500
#pragma unroll
for (
# 500
int SLICE = 0; SLICE < (TIME_SLICES); ++SLICE) 
# 501
{ 
# 502
__syncthreads(); 
# 504
if ((warp_id) == SLICE) 
# 505
{ 
# 507
#pragma unroll
for (
# 507
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 508
{ 
# 509
int item_offset = (ITEM * (WARP_TIME_SLICED_THREADS)) + (lane_id); 
# 510
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 511
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 512
}  
# 514
__threadfence_block(); 
# 517
#pragma unroll
for (
# 517
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 518
{ 
# 519
int item_offset = ITEM + ((lane_id) * (ITEMS_PER_THREAD)); 
# 520
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 521
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 522
}  
# 523
}  
# 524
}  
# 525
} 
#endif
# 531 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 532
__attribute((always_inline)) void ScatterToBlocked(InputT 
# 533
input_items[], OutputT 
# 534
output_items[], OffsetT 
# 535
ranks[], Int2Type< 0>  
# 536
time_slicing) 
# 537
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;(void)time_slicing;
# 555
::exit(___);}
#if 0
# 537
{ 
# 539
#pragma unroll
for (
# 539
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 540
{ 
# 541
int item_offset = ranks[ITEM]; 
# 542
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 543
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 544
}  
# 546
__syncthreads(); 
# 549
#pragma unroll
for (
# 549
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 550
{ 
# 551
int item_offset = ((linear_tid) * (ITEMS_PER_THREAD)) + ITEM; 
# 552
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 553
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 554
}  
# 555
} 
#endif
# 560 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 561
__attribute((always_inline)) void ScatterToBlocked(InputT 
# 562
input_items[], OutputT 
# 563
output_items[], OffsetT 
# 564
ranks[], Int2Type< 1>  
# 565
time_slicing) 
# 566
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;(void)time_slicing;
# 607
::exit(___);}
#if 0
# 566
{ 
# 567
InputT temp_items[ITEMS_PER_THREAD]; 
# 570
#pragma unroll
for (
# 570
int SLICE = 0; SLICE < (TIME_SLICES); SLICE++) 
# 571
{ 
# 572
__syncthreads(); 
# 574
const int SLICE_OFFSET = (TIME_SLICED_ITEMS) * SLICE; 
# 577
#pragma unroll
for (
# 577
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 578
{ 
# 579
int item_offset = (ranks[ITEM]) - SLICE_OFFSET; 
# 580
if ((item_offset >= 0) && (item_offset < (WARP_TIME_SLICED_ITEMS))) 
# 581
{ 
# 582
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 583
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 584
}  
# 585
}  
# 587
__syncthreads(); 
# 589
if ((warp_id) == SLICE) 
# 590
{ 
# 592
#pragma unroll
for (
# 592
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 593
{ 
# 594
int item_offset = ((lane_id) * (ITEMS_PER_THREAD)) + ITEM; 
# 595
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 596
((temp_items)[ITEM]) = ((temp_storage)[item_offset]); 
# 597
}  
# 598
}  
# 599
}  
# 603
#pragma unroll
for (
# 603
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 604
{ 
# 605
(output_items[ITEM]) = ((temp_items)[ITEM]); 
# 606
}  
# 607
} 
#endif
# 613 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 614
__attribute((always_inline)) void ScatterToStriped(InputT 
# 615
input_items[], OutputT 
# 616
output_items[], OffsetT 
# 617
ranks[], Int2Type< 0>  
# 618
time_slicing) 
# 619
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;(void)time_slicing;
# 637
::exit(___);}
#if 0
# 619
{ 
# 621
#pragma unroll
for (
# 621
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 622
{ 
# 623
int item_offset = ranks[ITEM]; 
# 624
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 625
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 626
}  
# 628
__syncthreads(); 
# 631
#pragma unroll
for (
# 631
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 632
{ 
# 633
int item_offset = ((int)(ITEM * (BLOCK_THREADS))) + (linear_tid); 
# 634
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 635
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 636
}  
# 637
} 
#endif
# 643 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 644
__attribute((always_inline)) void ScatterToStriped(InputT 
# 645
input_items[], OutputT 
# 646
output_items[], OffsetT 
# 647
ranks[], Int2Type< 1>  
# 648
time_slicing) 
# 649
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;(void)time_slicing;
# 698
::exit(___);}
#if 0
# 649
{ 
# 650
InputT temp_items[ITEMS_PER_THREAD]; 
# 653
#pragma unroll
for (
# 653
int SLICE = 0; SLICE < (TIME_SLICES); SLICE++) 
# 654
{ 
# 655
const int SLICE_OFFSET = SLICE * (TIME_SLICED_ITEMS); 
# 656
const int SLICE_OOB = SLICE_OFFSET + (TIME_SLICED_ITEMS); 
# 658
__syncthreads(); 
# 661
#pragma unroll
for (
# 661
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 662
{ 
# 663
int item_offset = (ranks[ITEM]) - SLICE_OFFSET; 
# 664
if ((item_offset >= 0) && (item_offset < (WARP_TIME_SLICED_ITEMS))) 
# 665
{ 
# 666
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 667
((temp_storage)[item_offset]) = (input_items[ITEM]); 
# 668
}  
# 669
}  
# 671
__syncthreads(); 
# 674
#pragma unroll
for (
# 674
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 675
{ 
# 677
const int STRIP_OFFSET = ITEM * (BLOCK_THREADS); 
# 678
const int STRIP_OOB = STRIP_OFFSET + (BLOCK_THREADS); 
# 680
if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET)) 
# 681
{ 
# 682
int item_offset = (STRIP_OFFSET + (linear_tid)) - SLICE_OFFSET; 
# 683
if ((item_offset >= 0) && (item_offset < (TIME_SLICED_ITEMS))) 
# 684
{ 
# 685
if (INSERT_PADDING) { item_offset += (item_offset >> (LOG_SMEM_BANKS)); }  
# 686
((temp_items)[ITEM]) = ((temp_storage)[item_offset]); 
# 687
}  
# 688
}  
# 689
}  
# 690
}  
# 694
#pragma unroll
for (
# 694
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 695
{ 
# 696
(output_items[ITEM]) = ((temp_items)[ITEM]); 
# 697
}  
# 698
} 
#endif
# 711 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
public: __attribute((always_inline)) BlockExchange() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)), lane_id(LaneId()), warp_id(((WARPS) == 1) ? 0 : ((linear_tid) / (WARP_THREADS))), warp_offset((warp_id) * (WARP_TIME_SLICED_ITEMS)) 
# 718
{int *volatile ___ = 0;::free(___);}
#if 0
# 718
{ } 
#endif
# 724 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
__attribute((always_inline)) BlockExchange(TempStorage &
# 725
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)), lane_id(LaneId()), warp_id(((WARPS) == 1) ? 0 : ((linear_tid) / (WARP_THREADS))), warp_offset((warp_id) * (WARP_TIME_SLICED_ITEMS)) 
# 732
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 732
{ } 
#endif
# 777 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 778
__attribute((always_inline)) void StripedToBlocked(InputT 
# 779
input_items[], OutputT 
# 780
output_items[]) 
# 781
{int volatile ___ = 1;(void)input_items;(void)output_items;
# 783
::exit(___);}
#if 0
# 781
{ 
# 782
StripedToBlocked(input_items, output_items, Int2Type< WARP_TIME_SLICING> ()); 
# 783
} 
#endif
# 826 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 827
__attribute((always_inline)) void BlockedToStriped(InputT 
# 828
input_items[], OutputT 
# 829
output_items[]) 
# 830
{int volatile ___ = 1;(void)input_items;(void)output_items;
# 832
::exit(___);}
#if 0
# 830
{ 
# 831
BlockedToStriped(input_items, output_items, Int2Type< WARP_TIME_SLICING> ()); 
# 832
} 
#endif
# 874 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 875
__attribute((always_inline)) void WarpStripedToBlocked(InputT 
# 876
input_items[], OutputT 
# 877
output_items[]) 
# 878
{int volatile ___ = 1;(void)input_items;(void)output_items;
# 880
::exit(___);}
#if 0
# 878
{ 
# 879
WarpStripedToBlocked(input_items, output_items, Int2Type< WARP_TIME_SLICING> ()); 
# 880
} 
#endif
# 925 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT> 
# 926
__attribute((always_inline)) void BlockedToWarpStriped(InputT 
# 927
input_items[], OutputT 
# 928
output_items[]) 
# 929
{int volatile ___ = 1;(void)input_items;(void)output_items;
# 931
::exit(___);}
#if 0
# 929
{ 
# 930
BlockedToWarpStriped(input_items, output_items, Int2Type< WARP_TIME_SLICING> ()); 
# 931
} 
#endif
# 950 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 951
__attribute((always_inline)) void ScatterToBlocked(InputT 
# 952
input_items[], OutputT 
# 953
output_items[], OffsetT 
# 954
ranks[]) 
# 955
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;
# 957
::exit(___);}
#if 0
# 955
{ 
# 956
ScatterToBlocked(input_items, output_items, ranks, Int2Type< WARP_TIME_SLICING> ()); 
# 957
} 
#endif
# 969 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 970
__attribute((always_inline)) void ScatterToStriped(InputT 
# 971
input_items[], OutputT 
# 972
output_items[], OffsetT 
# 973
ranks[]) 
# 974
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;
# 976
::exit(___);}
#if 0
# 974
{ 
# 975
ScatterToStriped(input_items, output_items, ranks, Int2Type< WARP_TIME_SLICING> ()); 
# 976
} 
#endif
# 988 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT> 
# 989
__attribute((always_inline)) void ScatterToStripedGuarded(InputT 
# 990
input_items[], OutputT 
# 991
output_items[], OffsetT 
# 992
ranks[]) 
# 993
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;
# 1012
::exit(___);}
#if 0
# 993
{ 
# 995
#pragma unroll
for (
# 995
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 996
{ 
# 997
int item_offset = ranks[ITEM]; 
# 998
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 999
if ((ranks[ITEM]) >= 0) { 
# 1000
((temp_storage)[item_offset]) = (input_items[ITEM]); }  
# 1001
}  
# 1003
__syncthreads(); 
# 1006
#pragma unroll
for (
# 1006
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 1007
{ 
# 1008
int item_offset = ((int)(ITEM * (BLOCK_THREADS))) + (linear_tid); 
# 1009
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 1010
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 1011
}  
# 1012
} 
#endif
# 1026 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OutputT, class OffsetT, class ValidFlag> 
# 1027
__attribute((always_inline)) void ScatterToStripedFlagged(InputT 
# 1028
input_items[], OutputT 
# 1029
output_items[], OffsetT 
# 1030
ranks[], ValidFlag 
# 1031
is_valid[]) 
# 1032
{int volatile ___ = 1;(void)input_items;(void)output_items;(void)ranks;(void)is_valid;
# 1051
::exit(___);}
#if 0
# 1032
{ 
# 1034
#pragma unroll
for (
# 1034
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 1035
{ 
# 1036
int item_offset = ranks[ITEM]; 
# 1037
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 1038
if (is_valid[ITEM]) { 
# 1039
((temp_storage)[item_offset]) = (input_items[ITEM]); }  
# 1040
}  
# 1042
__syncthreads(); 
# 1045
#pragma unroll
for (
# 1045
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 1046
{ 
# 1047
int item_offset = ((int)(ITEM * (BLOCK_THREADS))) + (linear_tid); 
# 1048
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 1049
(output_items[ITEM]) = ((temp_storage)[item_offset]); 
# 1050
}  
# 1051
} 
#endif
# 1061 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
__attribute((always_inline)) void StripedToBlocked(InputT 
# 1062
items[]) 
# 1063
{int volatile ___ = 1;(void)items;
# 1065
::exit(___);}
#if 0
# 1063
{ 
# 1064
StripedToBlocked(items, items); 
# 1065
} 
#endif
# 1067 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
__attribute((always_inline)) void BlockedToStriped(InputT 
# 1068
items[]) 
# 1069
{int volatile ___ = 1;(void)items;
# 1071
::exit(___);}
#if 0
# 1069
{ 
# 1070
BlockedToStriped(items, items); 
# 1071
} 
#endif
# 1073 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
__attribute((always_inline)) void WarpStripedToBlocked(InputT 
# 1074
items[]) 
# 1075
{int volatile ___ = 1;(void)items;
# 1077
::exit(___);}
#if 0
# 1075
{ 
# 1076
WarpStripedToBlocked(items, items); 
# 1077
} 
#endif
# 1079 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
__attribute((always_inline)) void BlockedToWarpStriped(InputT 
# 1080
items[]) 
# 1081
{int volatile ___ = 1;(void)items;
# 1083
::exit(___);}
#if 0
# 1081
{ 
# 1082
BlockedToWarpStriped(items, items); 
# 1083
} 
#endif
# 1085 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OffsetT> 
# 1086
__attribute((always_inline)) void ScatterToBlocked(InputT 
# 1087
items[], OffsetT 
# 1088
ranks[]) 
# 1089
{int volatile ___ = 1;(void)items;(void)ranks;
# 1091
::exit(___);}
#if 0
# 1089
{ 
# 1090
ScatterToBlocked(items, items, ranks); 
# 1091
} 
#endif
# 1093 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OffsetT> 
# 1094
__attribute((always_inline)) void ScatterToStriped(InputT 
# 1095
items[], OffsetT 
# 1096
ranks[]) 
# 1097
{int volatile ___ = 1;(void)items;(void)ranks;
# 1099
::exit(___);}
#if 0
# 1097
{ 
# 1098
ScatterToStriped(items, items, ranks); 
# 1099
} 
#endif
# 1101 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OffsetT> 
# 1102
__attribute((always_inline)) void ScatterToStripedGuarded(InputT 
# 1103
items[], OffsetT 
# 1104
ranks[]) 
# 1105
{int volatile ___ = 1;(void)items;(void)ranks;
# 1107
::exit(___);}
#if 0
# 1105
{ 
# 1106
ScatterToStripedGuarded(items, items, ranks); 
# 1107
} 
#endif
# 1109 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OffsetT, class ValidFlag> 
# 1110
__attribute((always_inline)) void ScatterToStripedFlagged(InputT 
# 1111
items[], OffsetT 
# 1112
ranks[], ValidFlag 
# 1113
is_valid[]) 
# 1114
{int volatile ___ = 1;(void)items;(void)ranks;(void)is_valid;
# 1116
::exit(___);}
#if 0
# 1114
{ 
# 1115
ScatterToStriped(items, items, ranks, is_valid); 
# 1116
} 
#endif
# 1121 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
}; 
# 1127
template< class 
# 1128
T, int 
# 1129
ITEMS_PER_THREAD, int 
# 1130
LOGICAL_WARP_THREADS = 32, int 
# 1131
PTX_ARCH = 0> 
# 1132
class WarpExchange { 
# 1142
enum { 
# 1144
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 1146
WARP_ITEMS = (ITEMS_PER_THREAD * LOGICAL_WARP_THREADS) + 1, 
# 1148
LOG_SMEM_BANKS = (PTX_ARCH >= 200) ? 5 : 4, 
# 1149
SMEM_BANKS = 1 << ((PTX_ARCH >= 200) ? 5 : 4), 
# 1152
INSERT_PADDING = 0, 
# 1153
PADDING_ITEMS = (0) ? ((ITEMS_PER_THREAD * LOGICAL_WARP_THREADS) + 1) >> ((PTX_ARCH >= 200) ? 5 : 4) : 0
# 1154
}; 
# 1161
typedef T _TempStorage[(WARP_ITEMS) + (PADDING_ITEMS)]; 
# 1166
public: struct TempStorage : public Uninitialized< T [(WARP_ITEMS) + (PADDING_ITEMS)]>  { }; 
# 1175
private: _TempStorage &temp_storage; 
# 1176
int lane_id; 
# 1185
public: __attribute((always_inline)) WarpExchange(TempStorage &
# 1186
temp_storage) : temp_storage((temp_storage.Alias())), lane_id((IS_ARCH_WARP) ? LaneId() : (LaneId() % (LOGICAL_WARP_THREADS))) 
# 1192
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 1192
{ } 
#endif
# 1207 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
template< class OffsetT> 
# 1208
__attribute((always_inline)) void ScatterToStriped(T 
# 1209
items[], OffsetT 
# 1210
ranks[]) 
# 1211
{int volatile ___ = 1;(void)items;(void)ranks;
# 1228
::exit(___);}
#if 0
# 1211
{ 
# 1213
#pragma unroll
for (
# 1213
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 1214
{ 
# 1215
if (INSERT_PADDING) { (ranks[ITEM]) = SHR_ADD(ranks[ITEM], LOG_SMEM_BANKS, ranks[ITEM]); }  
# 1216
((temp_storage)[ranks[ITEM]]) = (items[ITEM]); 
# 1217
}  
# 1219
__threadfence_block(); 
# 1222
#pragma unroll
for (
# 1222
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 1223
{ 
# 1224
int item_offset = (ITEM * LOGICAL_WARP_THREADS) + (lane_id); 
# 1225
if (INSERT_PADDING) { item_offset = SHR_ADD(item_offset, LOG_SMEM_BANKS, item_offset); }  
# 1226
(items[ITEM]) = ((temp_storage)[item_offset]); 
# 1227
}  
# 1228
} 
#endif
# 1230 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_exchange.cuh"
}; 
# 1241
}
# 55 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/../iterator/cache_modified_input_iterator.cuh"
namespace cub { 
# 103
template< CacheLoadModifier 
# 104
MODIFIER, class 
# 105
ValueType, class 
# 106
OffsetT = ptrdiff_t> 
# 107
class CacheModifiedInputIterator { 
# 112
public: typedef CacheModifiedInputIterator self_type; 
# 113
typedef OffsetT difference_type; 
# 114
typedef ValueType value_type; 
# 115
typedef ValueType *pointer; 
# 116
typedef ValueType reference; 
# 125
typedef typename thrust::detail::iterator_facade_category< thrust::system::cuda::detail::tag, thrust::random_access_traversal_tag, ValueType, ValueType> ::type iterator_category; 
# 134
ValueType *ptr; 
# 137
template< class QualifiedValueType> 
# 138
__attribute((always_inline)) CacheModifiedInputIterator(QualifiedValueType *
# 139
ptr) : ptr(const_cast< typename RemoveQualifiers< QualifiedValueType> ::Type *>(ptr)) 
# 142
{ } 
# 145
__attribute((always_inline)) self_type operator++(int) 
# 146
{ 
# 147
self_type retval = *this; 
# 148
(ptr)++; 
# 149
return retval; 
# 150
} 
# 153
__attribute((always_inline)) self_type operator++() 
# 154
{ 
# 155
(ptr)++; 
# 156
return *this; 
# 157
} 
# 160
__attribute((always_inline)) reference operator*() const 
# 161
{int volatile ___ = 1;
# 163
::exit(___);}
#if 0
# 161
{ 
# 162
return ThreadLoad< MODIFIER> (ptr); 
# 163
} 
#endif
# 166 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/../iterator/cache_modified_input_iterator.cuh"
template< class Distance> 
# 167
__attribute((always_inline)) self_type operator+(Distance n) const 
# 168
{ 
# 169
self_type retval((ptr) + n); 
# 170
return retval; 
# 171
} 
# 174
template< class Distance> 
# 175
__attribute((always_inline)) self_type &operator+=(Distance n) 
# 176
{ 
# 177
(ptr) += n; 
# 178
return *this; 
# 179
} 
# 182
template< class Distance> 
# 183
__attribute((always_inline)) self_type operator-(Distance n) const 
# 184
{ 
# 185
self_type retval((ptr) - n); 
# 186
return retval; 
# 187
} 
# 190
template< class Distance> 
# 191
__attribute((always_inline)) self_type &operator-=(Distance n) 
# 192
{ 
# 193
(ptr) -= n; 
# 194
return *this; 
# 195
} 
# 198
__attribute((always_inline)) difference_type operator-(self_type other) const 
# 199
{ 
# 200
return (ptr) - (other.ptr); 
# 201
} 
# 204
template< class Distance> 
# 205
__attribute((always_inline)) reference operator[](Distance n) const 
# 206
{int volatile ___ = 1;(void)n;
# 208
::exit(___);}
#if 0
# 206
{ 
# 207
return ThreadLoad< MODIFIER> ((ptr) + n); 
# 208
} 
#endif
# 211 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/../iterator/cache_modified_input_iterator.cuh"
__attribute((always_inline)) pointer operator->() 
# 212
{int volatile ___ = 1;
# 214
::exit(___);}
#if 0
# 212
{ 
# 213
return &ThreadLoad< MODIFIER> (ptr); 
# 214
} 
#endif
# 217 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/../iterator/cache_modified_input_iterator.cuh"
__attribute((always_inline)) bool operator==(const self_type &rhs) 
# 218
{ 
# 219
return (ptr) == (rhs.ptr); 
# 220
} 
# 223
__attribute((always_inline)) bool operator!=(const self_type &rhs) 
# 224
{ 
# 225
return (ptr) != (rhs.ptr); 
# 226
} 
# 229
friend inline std::ostream &operator<<(std::ostream &os, const self_type &itr) 
# 230
{ 
# 231
return os; 
# 232
} 
# 233
}; 
# 239
}
# 49 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
namespace cub { 
# 72
template< class 
# 73
OutputT, int 
# 74
ITEMS_PER_THREAD, class 
# 75
InputIteratorT> 
# 76
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectBlocked(unsigned 
# 77
linear_tid, InputIteratorT 
# 78
block_itr, OutputT (&
# 79
items)[ITEMS_PER_THREAD]) 
# 80
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 88
::exit(___);}
#if 0
# 80
{ 
# 83
#pragma unroll
for (
# 83
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 84
{ 
# 86
((items)[ITEM]) = (*((block_itr + (linear_tid * (ITEMS_PER_THREAD))) + ITEM)); 
# 87
}  
# 88
} 
#endif
# 100 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 101
OutputT, int 
# 102
ITEMS_PER_THREAD, class 
# 103
InputIteratorT> 
# 104
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectBlocked(unsigned 
# 105
linear_tid, InputIteratorT 
# 106
block_itr, OutputT (&
# 107
items)[ITEMS_PER_THREAD], int 
# 108
valid_items) 
# 109
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 118
::exit(___);}
#if 0
# 109
{ 
# 111
#pragma unroll
for (
# 111
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 112
{ 
# 113
if (((linear_tid * (ITEMS_PER_THREAD)) + ITEM) < valid_items) 
# 114
{ 
# 115
((items)[ITEM]) = (*((block_itr + (linear_tid * (ITEMS_PER_THREAD))) + ITEM)); 
# 116
}  
# 117
}  
# 118
} 
#endif
# 130 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 131
InputT, class 
# 132
OutputT, int 
# 133
ITEMS_PER_THREAD, class 
# 134
InputIteratorT> 
# 135
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectBlocked(unsigned 
# 136
linear_tid, InputIteratorT 
# 137
block_itr, OutputT (&
# 138
items)[ITEMS_PER_THREAD], int 
# 139
valid_items, InputT 
# 140
oob_default) 
# 141
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 149
::exit(___);}
#if 0
# 141
{ 
# 143
#pragma unroll
for (
# 143
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 144
{ 
# 145
((items)[ITEM]) = ((((linear_tid * (ITEMS_PER_THREAD)) + ITEM) < valid_items) ? *((block_itr + (linear_tid * (ITEMS_PER_THREAD))) + ITEM) : oob_default); 
# 148
}  
# 149
} 
#endif
# 157 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< CacheLoadModifier 
# 158
MODIFIER, class 
# 159
T, int 
# 160
ITEMS_PER_THREAD> 
# 161
__attribute((always_inline)) __attribute__((unused)) inline void InternalLoadDirectBlockedVectorized(unsigned 
# 162
linear_tid, T *
# 163
block_ptr, T (&
# 164
items)[ITEMS_PER_THREAD]) 
# 165
{int volatile ___ = 1;(void)linear_tid;(void)block_ptr;(void)items;
# 205
::exit(___);}
#if 0
# 165
{ 
# 167
typedef typename UnitWord< T> ::DeviceWord DeviceWord; 
# 170
enum { 
# 171
TOTAL_WORDS = sizeof(items) / sizeof(DeviceWord), 
# 173
VECTOR_SIZE = (((sizeof(items) / sizeof(DeviceWord)) % (4)) == (0)) ? 4 : ((((sizeof(items) / sizeof(DeviceWord)) % (2)) == (0)) ? 2 : 1), 
# 179
VECTORS_PER_THREAD = (sizeof(items) / sizeof(DeviceWord)) / ((((sizeof(items) / sizeof(DeviceWord)) % (4)) == (0)) ? 4 : ((((sizeof(items) / sizeof(DeviceWord)) % (2)) == (0)) ? 2 : 1))
# 180
}; 
# 183
typedef typename CubVector< typename UnitWord< T> ::DeviceWord, VECTOR_SIZE> ::Type Vector; 
# 186
Vector vec_items[VECTORS_PER_THREAD]; 
# 189
Vector *vec_ptr = (reinterpret_cast< Vector *>(block_ptr)) + (linear_tid * (VECTORS_PER_THREAD)); 
# 193
#pragma unroll
for (
# 193
int ITEM = 0; ITEM < (VECTORS_PER_THREAD); ITEM++) 
# 194
{ 
# 195
((vec_items)[ITEM]) = ThreadLoad< MODIFIER> (vec_ptr + ITEM); 
# 196
}  
# 200
#pragma unroll
for (
# 200
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 201
{ 
# 203
((items)[ITEM]) = (*((reinterpret_cast< T *>(vec_items)) + ITEM)); 
# 204
}  
# 205
} 
#endif
# 224 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 225
T, int 
# 226
ITEMS_PER_THREAD> 
# 227
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectBlockedVectorized(unsigned 
# 228
linear_tid, T *
# 229
block_ptr, T (&
# 230
items)[ITEMS_PER_THREAD]) 
# 231
{int volatile ___ = 1;(void)linear_tid;(void)block_ptr;(void)items;
# 233
::exit(___);}
#if 0
# 231
{ 
# 232
InternalLoadDirectBlockedVectorized< LOAD_DEFAULT> (linear_tid, block_ptr, items); 
# 233
} 
#endif
# 245 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< int 
# 246
BLOCK_THREADS, class 
# 247
OutputT, int 
# 248
ITEMS_PER_THREAD, class 
# 249
InputIteratorT, int 
# 250
ITEM> 
# 251
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectStriped(unsigned 
# 252
linear_tid, InputIteratorT 
# 253
block_itr, OutputT (&
# 254
items)[ITEMS_PER_THREAD], Int2Type< ITEM>  
# 255
item) 
# 256
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)item;
# 259
::exit(___);}
#if 0
# 256
{ 
# 257
((items)[ITEM]) = (block_itr[(ITEM * BLOCK_THREADS) + linear_tid]); 
# 258
LoadDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, items, Int2Type< ITEM + 1> ()); 
# 259
} 
#endif
# 262 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< int 
# 263
BLOCK_THREADS, class 
# 264
OutputT, int 
# 265
ITEMS_PER_THREAD, class 
# 266
InputIteratorT> 
# 267
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectStriped(unsigned 
# 268
linear_tid, InputIteratorT 
# 269
block_itr, OutputT (&
# 270
items)[ITEMS_PER_THREAD], Int2Type< ITEMS_PER_THREAD>  
# 271
item) 
# 272
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)item;::exit(___);}
#if 0
# 272
{ } 
#endif
# 289 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< int 
# 290
BLOCK_THREADS, class 
# 291
OutputT, int 
# 292
ITEMS_PER_THREAD, class 
# 293
InputIteratorT> 
# 294
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectStriped(unsigned 
# 295
linear_tid, InputIteratorT 
# 296
block_itr, OutputT (&
# 297
items)[ITEMS_PER_THREAD]) 
# 298
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 307
::exit(___);}
#if 0
# 298
{ 
# 300
#pragma unroll
for (
# 300
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 301
{ 
# 303
((items)[ITEM]) = (*((block_itr + linear_tid) + (ITEM * BLOCK_THREADS))); 
# 304
}  
# 307
} 
#endif
# 320 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< int 
# 321
BLOCK_THREADS, class 
# 322
OutputT, int 
# 323
ITEMS_PER_THREAD, class 
# 324
InputIteratorT> 
# 325
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectStriped(unsigned 
# 326
linear_tid, InputIteratorT 
# 327
block_itr, OutputT (&
# 328
items)[ITEMS_PER_THREAD], int 
# 329
valid_items) 
# 330
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 339
::exit(___);}
#if 0
# 330
{ 
# 332
#pragma unroll
for (
# 332
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 333
{ 
# 334
if ((linear_tid + (ITEM * BLOCK_THREADS)) < valid_items) 
# 335
{ 
# 336
((items)[ITEM]) = (*((block_itr + linear_tid) + (ITEM * BLOCK_THREADS))); 
# 337
}  
# 338
}  
# 339
} 
#endif
# 352 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< int 
# 353
BLOCK_THREADS, class 
# 354
InputT, class 
# 355
OutputT, int 
# 356
ITEMS_PER_THREAD, class 
# 357
InputIteratorT> 
# 358
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectStriped(unsigned 
# 359
linear_tid, InputIteratorT 
# 360
block_itr, OutputT (&
# 361
items)[ITEMS_PER_THREAD], int 
# 362
valid_items, InputT 
# 363
oob_default) 
# 364
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 372
::exit(___);}
#if 0
# 364
{ 
# 366
#pragma unroll
for (
# 366
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 367
{ 
# 368
((items)[ITEM]) = (((linear_tid + (ITEM * BLOCK_THREADS)) < valid_items) ? *((block_itr + linear_tid) + (ITEM * BLOCK_THREADS)) : oob_default); 
# 371
}  
# 372
} 
#endif
# 395 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 396
OutputT, int 
# 397
ITEMS_PER_THREAD, class 
# 398
InputIteratorT> 
# 399
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectWarpStriped(unsigned 
# 400
linear_tid, InputIteratorT 
# 401
block_itr, OutputT (&
# 402
items)[ITEMS_PER_THREAD]) 
# 403
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 414
::exit(___);}
#if 0
# 403
{ 
# 404
unsigned tid = linear_tid & ((1 << 5) - 1); 
# 405
unsigned wid = linear_tid >> 5; 
# 406
unsigned warp_offset = (wid * (1 << 5)) * (ITEMS_PER_THREAD); 
# 410
#pragma unroll
for (
# 410
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 411
{ 
# 412
((items)[ITEM]) = (*(((block_itr + warp_offset) + tid) + (ITEM * (1 << 5)))); 
# 413
}  
# 414
} 
#endif
# 429 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 430
OutputT, int 
# 431
ITEMS_PER_THREAD, class 
# 432
InputIteratorT> 
# 433
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectWarpStriped(unsigned 
# 434
linear_tid, InputIteratorT 
# 435
block_itr, OutputT (&
# 436
items)[ITEMS_PER_THREAD], int 
# 437
valid_items) 
# 438
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 454
::exit(___);}
#if 0
# 438
{ 
# 439
unsigned tid = linear_tid & ((1 << 5) - 1); 
# 440
unsigned wid = linear_tid >> 5; 
# 441
unsigned warp_offset = (wid * (1 << 5)) * (ITEMS_PER_THREAD); 
# 443
int bounds = (valid_items - warp_offset) - tid; 
# 447
#pragma unroll
for (
# 447
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 448
{ 
# 449
if ((ITEM * (1 << 5)) < bounds) 
# 450
{ 
# 451
((items)[ITEM]) = (*(((block_itr + warp_offset) + tid) + (ITEM * (1 << 5)))); 
# 452
}  
# 453
}  
# 454
} 
#endif
# 469 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 470
InputT, class 
# 471
OutputT, int 
# 472
ITEMS_PER_THREAD, class 
# 473
InputIteratorT> 
# 474
__attribute((always_inline)) __attribute__((unused)) inline void LoadDirectWarpStriped(unsigned 
# 475
linear_tid, InputIteratorT 
# 476
block_itr, OutputT (&
# 477
items)[ITEMS_PER_THREAD], int 
# 478
valid_items, InputT 
# 479
oob_default) 
# 480
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 495
::exit(___);}
#if 0
# 480
{ 
# 481
unsigned tid = linear_tid & ((1 << 5) - 1); 
# 482
unsigned wid = linear_tid >> 5; 
# 483
unsigned warp_offset = (wid * (1 << 5)) * (ITEMS_PER_THREAD); 
# 485
int bounds = (valid_items - warp_offset) - tid; 
# 489
#pragma unroll
for (
# 489
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 490
{ 
# 491
((items)[ITEM]) = (((ITEM * (1 << 5)) < bounds) ? *(((block_itr + warp_offset) + tid) + (ITEM * (1 << 5))) : oob_default); 
# 494
}  
# 495
} 
#endif
# 516 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
enum BlockLoadAlgorithm { 
# 528
BLOCK_LOAD_DIRECT, 
# 548
BLOCK_LOAD_VECTORIZE, 
# 563
BLOCK_LOAD_TRANSPOSE, 
# 584
BLOCK_LOAD_WARP_TRANSPOSE, 
# 605
BLOCK_LOAD_WARP_TRANSPOSE_TIMESLICED
# 606
}; 
# 675
template< class 
# 676
InputIteratorT, int 
# 677
BLOCK_DIM_X, int 
# 678
ITEMS_PER_THREAD, BlockLoadAlgorithm 
# 679
ALGORITHM = BLOCK_LOAD_DIRECT, int 
# 680
BLOCK_DIM_Y = 1, int 
# 681
BLOCK_DIM_Z = 1, int 
# 682
PTX_ARCH = 0> 
# 683
class BlockLoad { 
# 693
enum { 
# 695
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 696
}; 
# 699
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputT; 
# 707
template< BlockLoadAlgorithm _POLICY, int DUMMY> struct LoadInternal; 
# 714
template< int DUMMY> 
# 715
struct LoadInternal< BLOCK_LOAD_DIRECT, DUMMY>  { 
# 718
typedef NullType TempStorage; 
# 721
unsigned linear_tid; 
# 724
__attribute((always_inline)) LoadInternal(TempStorage &
# 725
temp_storage, unsigned 
# 726
linear_tid) : linear_tid(linear_tid) 
# 729
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 729
{ } 
#endif
# 732 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 733
__attribute((always_inline)) void Load(InputIteratorT 
# 734
block_itr, OutputT (&
# 735
items)[ITEMS_PER_THREAD]) 
# 736
{int volatile ___ = 1;(void)block_itr;(void)items;
# 738
::exit(___);}
#if 0
# 736
{ 
# 737
LoadDirectBlocked(linear_tid, block_itr, items); 
# 738
} 
#endif
# 741 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 742
__attribute((always_inline)) void Load(InputIteratorT 
# 743
block_itr, OutputT (&
# 744
items)[ITEMS_PER_THREAD], int 
# 745
valid_items) 
# 746
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 748
::exit(___);}
#if 0
# 746
{ 
# 747
LoadDirectBlocked(linear_tid, block_itr, items, valid_items); 
# 748
} 
#endif
# 751 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 752
__attribute((always_inline)) void Load(InputIteratorT 
# 753
block_itr, OutputT (&
# 754
items)[ITEMS_PER_THREAD], int 
# 755
valid_items, InputT 
# 756
oob_default) 
# 757
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 759
::exit(___);}
#if 0
# 757
{ 
# 758
LoadDirectBlocked(linear_tid, block_itr, items, valid_items, oob_default); 
# 759
} 
#endif
# 761 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 767
template< int DUMMY> 
# 768
struct LoadInternal< BLOCK_LOAD_VECTORIZE, DUMMY>  { 
# 771
typedef NullType TempStorage; 
# 774
unsigned linear_tid; 
# 777
__attribute((always_inline)) LoadInternal(TempStorage &
# 778
temp_storage, unsigned 
# 779
linear_tid) : linear_tid(linear_tid) 
# 782
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 782
{ } 
#endif
# 785 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 786
__attribute((always_inline)) void Load(OutputT *
# 787
block_ptr, OutputT (&
# 788
items)[ITEMS_PER_THREAD]) 
# 789
{int volatile ___ = 1;(void)block_ptr;(void)items;
# 791
::exit(___);}
#if 0
# 789
{ 
# 790
InternalLoadDirectBlockedVectorized< LOAD_DEFAULT> (linear_tid, block_ptr, items); 
# 791
} 
#endif
# 794 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< CacheLoadModifier 
# 795
MODIFIER, class 
# 796
ValueType, class 
# 797
OffsetT, class 
# 798
OutputT> 
# 799
__attribute((always_inline)) void Load(CacheModifiedInputIterator< MODIFIER, ValueType, OffsetT>  
# 800
block_itr, OutputT (&
# 801
items)[ITEMS_PER_THREAD]) 
# 802
{int volatile ___ = 1;(void)block_itr;(void)items;
# 804
::exit(___);}
#if 0
# 802
{ 
# 803
InternalLoadDirectBlockedVectorized< MODIFIER> (linear_tid, (block_itr.ptr), items); 
# 804
} 
#endif
# 807 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class 
# 808
_InputIteratorT, class 
# 809
OutputT> 
# 810
__attribute((always_inline)) void Load(_InputIteratorT 
# 811
block_itr, OutputT (&
# 812
items)[ITEMS_PER_THREAD]) 
# 813
{int volatile ___ = 1;(void)block_itr;(void)items;
# 815
::exit(___);}
#if 0
# 813
{ 
# 814
LoadDirectBlocked(linear_tid, block_itr, items); 
# 815
} 
#endif
# 818 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 819
__attribute((always_inline)) void Load(InputIteratorT 
# 820
block_itr, OutputT (&
# 821
items)[ITEMS_PER_THREAD], int 
# 822
valid_items) 
# 823
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 825
::exit(___);}
#if 0
# 823
{ 
# 824
LoadDirectBlocked(linear_tid, block_itr, items, valid_items); 
# 825
} 
#endif
# 828 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 829
__attribute((always_inline)) void Load(InputIteratorT 
# 830
block_itr, OutputT (&
# 831
items)[ITEMS_PER_THREAD], int 
# 832
valid_items, InputT 
# 833
oob_default) 
# 834
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 836
::exit(___);}
#if 0
# 834
{ 
# 835
LoadDirectBlocked(linear_tid, block_itr, items, valid_items, oob_default); 
# 836
} 
#endif
# 838 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 844
template< int DUMMY> 
# 845
struct LoadInternal< BLOCK_LOAD_TRANSPOSE, DUMMY>  { 
# 848
typedef cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 851
typedef typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 854
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 857
_TempStorage &temp_storage; 
# 860
unsigned linear_tid; 
# 863
__attribute((always_inline)) LoadInternal(TempStorage &
# 864
temp_storage, unsigned 
# 865
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 869
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 869
{ } 
#endif
# 872 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 873
__attribute((always_inline)) void Load(InputIteratorT 
# 874
block_itr, OutputT (&
# 875
items)[ITEMS_PER_THREAD]) 
# 876
{int volatile ___ = 1;(void)block_itr;(void)items;
# 880
::exit(___);}
#if 0
# 876
{ 
# 877
InputT input_items[ITEMS_PER_THREAD]; 
# 878
LoadDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, input_items); 
# 879
(((BlockExchange)(temp_storage)).StripedToBlocked(input_items, items)); 
# 880
} 
#endif
# 883 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 884
__attribute((always_inline)) void Load(InputIteratorT 
# 885
block_itr, OutputT (&
# 886
items)[ITEMS_PER_THREAD], int 
# 887
valid_items) 
# 888
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 892
::exit(___);}
#if 0
# 888
{ 
# 889
InputT input_items[ITEMS_PER_THREAD]; 
# 890
LoadDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, input_items, valid_items); 
# 891
(((BlockExchange)(temp_storage)).StripedToBlocked(input_items, items)); 
# 892
} 
#endif
# 895 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 896
__attribute((always_inline)) void Load(InputIteratorT 
# 897
block_itr, OutputT (&
# 898
items)[ITEMS_PER_THREAD], int 
# 899
valid_items, InputT 
# 900
oob_default) 
# 901
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 905
::exit(___);}
#if 0
# 901
{ 
# 902
InputT input_items[ITEMS_PER_THREAD]; 
# 903
LoadDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, input_items, valid_items, oob_default); 
# 904
(((BlockExchange)(temp_storage)).StripedToBlocked(input_items, items)); 
# 905
} 
#endif
# 907 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 913
template< int DUMMY> 
# 914
struct LoadInternal< BLOCK_LOAD_WARP_TRANSPOSE, DUMMY>  { 
# 917
enum { 
# 918
WARP_THREADS = 1 << 5
# 919
}; 
# 922
typedef int cub_static_assert922[(((BLOCK_THREADS) % (WARP_THREADS)) == 0) ? 1 : (-1)]; 
# 925
typedef cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 928
typedef typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 931
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 934
_TempStorage &temp_storage; 
# 937
unsigned linear_tid; 
# 940
__attribute((always_inline)) LoadInternal(TempStorage &
# 941
temp_storage, unsigned 
# 942
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 946
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 946
{ } 
#endif
# 949 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 950
__attribute((always_inline)) void Load(InputIteratorT 
# 951
block_itr, OutputT (&
# 952
items)[ITEMS_PER_THREAD]) 
# 953
{int volatile ___ = 1;(void)block_itr;(void)items;
# 957
::exit(___);}
#if 0
# 953
{ 
# 954
InputT input_items[ITEMS_PER_THREAD]; 
# 955
LoadDirectWarpStriped(linear_tid, block_itr, input_items); 
# 956
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 957
} 
#endif
# 960 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 961
__attribute((always_inline)) void Load(InputIteratorT 
# 962
block_itr, OutputT (&
# 963
items)[ITEMS_PER_THREAD], int 
# 964
valid_items) 
# 965
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 969
::exit(___);}
#if 0
# 965
{ 
# 966
InputT input_items[ITEMS_PER_THREAD]; 
# 967
LoadDirectWarpStriped(linear_tid, block_itr, input_items, valid_items); 
# 968
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 969
} 
#endif
# 973 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 974
__attribute((always_inline)) void Load(InputIteratorT 
# 975
block_itr, OutputT (&
# 976
items)[ITEMS_PER_THREAD], int 
# 977
valid_items, InputT 
# 978
oob_default) 
# 979
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 983
::exit(___);}
#if 0
# 979
{ 
# 980
InputT input_items[ITEMS_PER_THREAD]; 
# 981
LoadDirectWarpStriped(linear_tid, block_itr, input_items, valid_items, oob_default); 
# 982
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 983
} 
#endif
# 984 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 990
template< int DUMMY> 
# 991
struct LoadInternal< BLOCK_LOAD_WARP_TRANSPOSE_TIMESLICED, DUMMY>  { 
# 994
enum { 
# 995
WARP_THREADS = 1 << 5
# 996
}; 
# 999
typedef int cub_static_assert999[(((BLOCK_THREADS) % (WARP_THREADS)) == 0) ? 1 : (-1)]; 
# 1002
typedef cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 1005
typedef typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 1008
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< InputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 1011
_TempStorage &temp_storage; 
# 1014
unsigned linear_tid; 
# 1017
__attribute((always_inline)) LoadInternal(TempStorage &
# 1018
temp_storage, unsigned 
# 1019
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 1023
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 1023
{ } 
#endif
# 1026 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1027
__attribute((always_inline)) void Load(InputIteratorT 
# 1028
block_itr, OutputT (&
# 1029
items)[ITEMS_PER_THREAD]) 
# 1030
{int volatile ___ = 1;(void)block_itr;(void)items;
# 1034
::exit(___);}
#if 0
# 1030
{ 
# 1031
InputT input_items[ITEMS_PER_THREAD]; 
# 1032
LoadDirectWarpStriped(linear_tid, block_itr, input_items); 
# 1033
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 1034
} 
#endif
# 1037 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1038
__attribute((always_inline)) void Load(InputIteratorT 
# 1039
block_itr, OutputT (&
# 1040
items)[ITEMS_PER_THREAD], int 
# 1041
valid_items) 
# 1042
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 1046
::exit(___);}
#if 0
# 1042
{ 
# 1043
InputT input_items[ITEMS_PER_THREAD]; 
# 1044
LoadDirectWarpStriped(linear_tid, block_itr, input_items, valid_items); 
# 1045
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 1046
} 
#endif
# 1050 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1051
__attribute((always_inline)) void Load(InputIteratorT 
# 1052
block_itr, OutputT (&
# 1053
items)[ITEMS_PER_THREAD], int 
# 1054
valid_items, InputT 
# 1055
oob_default) 
# 1056
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 1060
::exit(___);}
#if 0
# 1056
{ 
# 1057
InputT input_items[ITEMS_PER_THREAD]; 
# 1058
LoadDirectWarpStriped(linear_tid, block_itr, input_items, valid_items, oob_default); 
# 1059
(((BlockExchange)(temp_storage)).WarpStripedToBlocked(input_items, items)); 
# 1060
} 
#endif
# 1061 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 1069
typedef LoadInternal< ALGORITHM, 0>  InternalLoad; 
# 1073
typedef typename LoadInternal< ALGORITHM, 0> ::TempStorage _TempStorage; 
# 1081
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 1082
{int volatile ___ = 1;
# 1085
::exit(___);}
#if 0
# 1082
{ 
# 1083
__attribute__((unused)) static _TempStorage private_storage; 
# 1084
return private_storage; 
# 1085
} 
#endif
# 1093 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
_TempStorage &temp_storage; 
# 1096
unsigned linear_tid; 
# 1101
public: struct TempStorage : public Uninitialized< typename LoadInternal< ALGORITHM, 0> ::TempStorage>  { }; 
# 1112
__attribute((always_inline)) BlockLoad() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 1116
{int *volatile ___ = 0;::free(___);}
#if 0
# 1116
{ } 
#endif
# 1122 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
__attribute((always_inline)) BlockLoad(TempStorage &
# 1123
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 1127
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 1127
{ } 
#endif
# 1175 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1176
__attribute((always_inline)) void Load(InputIteratorT 
# 1177
block_itr, OutputT (&
# 1178
items)[ITEMS_PER_THREAD]) 
# 1179
{int volatile ___ = 1;(void)block_itr;(void)items;
# 1181
::exit(___);}
#if 0
# 1179
{ 
# 1180
(InternalLoad(temp_storage, linear_tid).Load(block_itr, items)); 
# 1181
} 
#endif
# 1221 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1222
__attribute((always_inline)) void Load(InputIteratorT 
# 1223
block_itr, OutputT (&
# 1224
items)[ITEMS_PER_THREAD], int 
# 1225
valid_items) 
# 1226
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 1228
::exit(___);}
#if 0
# 1226
{ 
# 1227
(InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items)); 
# 1228
} 
#endif
# 1269 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
template< class OutputT> 
# 1270
__attribute((always_inline)) void Load(InputIteratorT 
# 1271
block_itr, OutputT (&
# 1272
items)[ITEMS_PER_THREAD], int 
# 1273
valid_items, InputT 
# 1274
oob_default) 
# 1275
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;(void)oob_default;
# 1277
::exit(___);}
#if 0
# 1275
{ 
# 1276
(InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items, oob_default)); 
# 1277
} 
#endif
# 1282 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_load.cuh"
}; 
# 1285
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../block/block_raking_layout.cuh"
namespace cub { 
# 63
template< class 
# 64
T, int 
# 65
BLOCK_THREADS, int 
# 66
PTX_ARCH = 0> 
# 67
struct BlockRakingLayout { 
# 74
enum { 
# 76
SHARED_ELEMENTS = BLOCK_THREADS, 
# 79
MAX_RAKING_THREADS = ((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS, 
# 82
SEGMENT_LENGTH = (((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS), 
# 85
RAKING_THREADS = (((BLOCK_THREADS) + ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) - 1) / ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)), 
# 88
HAS_CONFLICTS = ((1 << ((PTX_ARCH >= 200) ? 5 : 4)) % ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) == 0, 
# 91
CONFLICT_DEGREE = (((1 << ((PTX_ARCH >= 200) ? 5 : 4)) % ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) == 0) ? ((((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS) * ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) / (1 << ((PTX_ARCH >= 200) ? 5 : 4)) : 1, 
# 96
SEGMENT_PADDING = (((((1 << ((PTX_ARCH >= 200) ? 5 : 4)) % ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) == 0) ? ((((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS) * ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) / (1 << ((PTX_ARCH >= 200) ? 5 : 4)) : 1) > ((PTX_ARCH >= 300) ? 1 : 4)) ? 1 : 0, 
# 100
GRID_ELEMENTS = ((((BLOCK_THREADS) + ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) - 1) / ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) * (((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) + ((((((1 << ((PTX_ARCH >= 200) ? 5 : 4)) % ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) == 0) ? ((((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS) * ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) / (1 << ((PTX_ARCH >= 200) ? 5 : 4)) : 1) > ((PTX_ARCH >= 300) ? 1 : 4)) ? 1 : 0)), 
# 103
UNGUARDED = ((BLOCK_THREADS) % ((((BLOCK_THREADS) + ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS))) - 1) / ((((BLOCK_THREADS) + (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)) - 1) / (((1 << 5) < BLOCK_THREADS) ? 1 << 5 : BLOCK_THREADS)))) == 0
# 104
}; 
# 110
typedef T _TempStorage[GRID_ELEMENTS]; 
# 113
struct TempStorage : public Uninitialized< T [GRID_ELEMENTS]>  { }; 
# 119
__attribute((always_inline)) static T *PlacementPtr(TempStorage &
# 120
temp_storage, unsigned 
# 121
linear_tid) 
# 122
{int volatile ___ = 1;(void)temp_storage;(void)linear_tid;
# 134
::exit(___);}
#if 0
# 122
{ 
# 124
unsigned offset = linear_tid; 
# 127
if ((SEGMENT_PADDING) > 0) 
# 128
{ 
# 129
offset += (offset / (SEGMENT_LENGTH)); 
# 130
}  
# 133
return (temp_storage.Alias()) + offset; 
# 134
} 
#endif
# 140 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../block/block_raking_layout.cuh"
__attribute((always_inline)) static T *RakingPtr(TempStorage &
# 141
temp_storage, unsigned 
# 142
linear_tid) 
# 143
{int volatile ___ = 1;(void)temp_storage;(void)linear_tid;
# 145
::exit(___);}
#if 0
# 143
{ 
# 144
return (temp_storage.Alias()) + (linear_tid * ((SEGMENT_LENGTH) + (SEGMENT_PADDING))); 
# 145
} 
#endif
# 146 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../block/block_raking_layout.cuh"
}; 
# 148
}
# 48 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/../../thread/thread_operators.cuh"
namespace cub { 
# 59
struct Equality { 
# 62
template< class T> 
# 63
__attribute((always_inline)) bool operator()(const T &a, const T &b) const 
# 64
{ 
# 65
return a == b; 
# 66
} 
# 67
}; 
# 73
struct Inequality { 
# 76
template< class T> 
# 77
__attribute((always_inline)) bool operator()(const T &a, const T &b) const 
# 78
{ 
# 79
return a != b; 
# 80
} 
# 81
}; 
# 87
template< class EqualityOp> 
# 88
struct InequalityWrapper { 
# 91
EqualityOp op; 
# 94
__attribute((always_inline)) 
# 95
InequalityWrapper(EqualityOp op) : op(op) { } 
# 98
template< class T> 
# 99
__attribute((always_inline)) bool operator()(const T &a, const T &b) const 
# 100
{ 
# 101
return !(op)(a, b); 
# 102
} 
# 103
}; 
# 109
struct Sum { 
# 112
template< class T> 
# 113
__attribute((always_inline)) T operator()(const T &a, const T &b) const 
# 114
{ 
# 115
return a + b; 
# 116
} 
# 117
}; 
# 123
struct Max { 
# 126
template< class T> 
# 127
__attribute((always_inline)) T operator()(const T &a, const T &b) const 
# 128
{ 
# 129
return (b > a) ? b : a; 
# 130
} 
# 131
}; 
# 137
struct ArgMax { 
# 140
template< class T, class OffsetT> 
# 141
__attribute((always_inline)) KeyValuePair< OffsetT, T>  operator()(const KeyValuePair< OffsetT, T>  &
# 142
a, const KeyValuePair< OffsetT, T>  &
# 143
b) const 
# 144
{ 
# 148
if (((b.value) > (a.value)) || (((a.value) == (b.value)) && ((b.key) < (a.key)))) { 
# 149
return b; }  
# 150
return a; 
# 151
} 
# 152
}; 
# 158
struct Min { 
# 161
template< class T> 
# 162
__attribute((always_inline)) T operator()(const T &a, const T &b) const 
# 163
{ 
# 164
return (b < a) ? b : a; 
# 165
} 
# 166
}; 
# 172
struct ArgMin { 
# 175
template< class T, class OffsetT> 
# 176
__attribute((always_inline)) KeyValuePair< OffsetT, T>  operator()(const KeyValuePair< OffsetT, T>  &
# 177
a, const KeyValuePair< OffsetT, T>  &
# 178
b) const 
# 179
{ 
# 183
if (((b.value) < (a.value)) || (((a.value) == (b.value)) && ((b.key) < (a.key)))) { 
# 184
return b; }  
# 185
return a; 
# 186
} 
# 187
}; 
# 193
template< class B> 
# 194
struct Cast { 
# 197
template< class A> 
# 198
__attribute((always_inline)) B operator()(const A &a) const 
# 199
{ 
# 200
return (B)a; 
# 201
} 
# 202
}; 
# 208
template< class ScanOp> 
# 209
class SwizzleScanOp { 
# 214
ScanOp scan_op; 
# 220
public: 
# 219
__attribute((always_inline)) 
# 220
SwizzleScanOp(ScanOp scan_op) : scan_op(scan_op) { } 
# 223
template< class T> 
# 224
__attribute((always_inline)) T 
# 225
operator()(const T &a, const T &b) 
# 226
{ 
# 227
return (scan_op)(b, a); 
# 228
} 
# 229
}; 
# 248
template< class ReductionOpT> 
# 249
struct ReduceBySegmentOp { 
# 252
ReductionOpT op; 
# 255
__attribute((always_inline)) ReduceBySegmentOp() { } 
# 258
__attribute((always_inline)) ReduceBySegmentOp(ReductionOpT op) : op(op) { } 
# 261
template< class KeyValuePairT> 
# 262
__attribute((always_inline)) KeyValuePairT operator()(const KeyValuePairT &
# 263
first, const KeyValuePairT &
# 264
second) 
# 265
{ 
# 266
KeyValuePairT retval; 
# 267
(retval.key) = ((first.key) + (second.key)); 
# 268
(retval.value) = ((second.key) ? second.value : (op)((first.value), (second.value))); 
# 271
return retval; 
# 272
} 
# 273
}; 
# 277
template< class ReductionOpT> 
# 278
struct ReduceByKeyOp { 
# 281
ReductionOpT op; 
# 284
__attribute((always_inline)) ReduceByKeyOp() { } 
# 287
__attribute((always_inline)) ReduceByKeyOp(ReductionOpT op) : op(op) { } 
# 290
template< class KeyValuePairT> 
# 291
__attribute((always_inline)) KeyValuePairT operator()(const KeyValuePairT &
# 292
first, const KeyValuePairT &
# 293
second) 
# 294
{ 
# 295
KeyValuePairT retval = second; 
# 297
if ((first.key) == (second.key)) { 
# 298
(retval.value) = (op)((first.value), (retval.value)); }  
# 300
return retval; 
# 301
} 
# 302
}; 
# 313
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
namespace cub { 
# 52
template< class 
# 53
T, int 
# 54
LOGICAL_WARP_THREADS, int 
# 55
PTX_ARCH> 
# 56
struct WarpReduceShfl { 
# 63
enum { 
# 65
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 68
STEPS = Log2< LOGICAL_WARP_THREADS> ::VALUE, 
# 71
LOGICAL_WARPS = (1 << 5) / LOGICAL_WARP_THREADS
# 72
}; 
# 74
template< class S> 
# 75
struct IsInteger { 
# 77
enum { 
# 79
IS_SMALL_UNSIGNED = (Traits< S> ::CATEGORY == UNSIGNED_INTEGER) && (sizeof(S) <= sizeof(unsigned))
# 80
}; 
# 81
}; 
# 85
template< int WARP, int WARPS> 
# 86
struct LastLaneMask { 
# 88
enum { 
# 89
BASE_MASK = 1 << (LOGICAL_WARP_THREADS - 1), 
# 90
MASK = (LastLaneMask< WARP + 1, WARPS> ::MASK << LOGICAL_WARP_THREADS) | (1 << (LOGICAL_WARP_THREADS - 1))
# 91
}; 
# 92
}; 
# 95
template< int WARP> 
# 96
struct LastLaneMask< WARP, WARP>  { 
# 98
enum { 
# 99
MASK = 1 << (LOGICAL_WARP_THREADS - 1)
# 100
}; 
# 101
}; 
# 106
typedef NullType TempStorage; 
# 113
unsigned lane_id; 
# 121
__attribute((always_inline)) WarpReduceShfl(TempStorage &
# 122
temp_storage) : lane_id(LaneId()) 
# 125
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 125
{ } 
#endif
# 133 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
__attribute((always_inline)) unsigned ReduceStep(unsigned 
# 134
input, Sum 
# 135
reduction_op, int 
# 136
last_lane, int 
# 137
offset) 
# 138
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 153
::exit(___);}
#if 0
# 138
{ 
# 139
unsigned output; 
# 142
__asm__ volatile("{  .reg .u32 r0;  .reg .pred p;  shfl.down.b32 r0|p, %1, %2, %3;  @p add.u32 r0, r0, %4;  mov.u32 %0, r0;}" : "=r" (output) : "r" (input), "r" (offset), "r" (last_lane), "r" (input)); 
# 152
return output; 
# 153
} 
#endif
# 157 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
__attribute((always_inline)) float ReduceStep(float 
# 158
input, Sum 
# 159
reduction_op, int 
# 160
last_lane, int 
# 161
offset) 
# 162
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 177
::exit(___);}
#if 0
# 162
{ 
# 163
float output; 
# 166
__asm__ volatile("{  .reg .f32 r0;  .reg .pred p;  shfl.down.b32 r0|p, %1, %2, %3;  @p add.f32 r0, r0, %4;  mov.f32 %0, r0;}" : "=f" (output) : "f" (input), "r" (offset), "r" (last_lane), "f" (input)); 
# 176
return output; 
# 177
} 
#endif
# 181 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
__attribute((always_inline)) unsigned long long ReduceStep(unsigned long long 
# 182
input, Sum 
# 183
reduction_op, int 
# 184
last_lane, int 
# 185
offset) 
# 186
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 203
::exit(___);}
#if 0
# 186
{ 
# 187
unsigned long long output; 
# 189
__asm__ volatile("{  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  mov.b64 {lo, hi}, %1;  shfl.down.b32 lo|p, lo, %2, %3;  shfl.down.b32 hi|p, hi, " "%2, %3;  mov.b64 %0, {lo, hi};  @p add.u64 %0, %0, %1;}" : "=l" (output) : "l" (input), "r" (offset), "r" (last_lane)); 
# 202
return output; 
# 203
} 
#endif
# 207 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
__attribute((always_inline)) long long ReduceStep(long long 
# 208
input, Sum 
# 209
reduction_op, int 
# 210
last_lane, int 
# 211
offset) 
# 212
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 230
::exit(___);}
#if 0
# 212
{ 
# 213
long long output; 
# 216
__asm__ volatile("{  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  mov.b64 {lo, hi}, %1;  shfl.down.b32 lo|p, lo, %2, %3;  shfl.down.b32 hi|p, hi, " "%2, %3;  mov.b64 %0, {lo, hi};  @p add.s64 %0, %0, %1;}" : "=l" (output) : "l" (input), "r" (offset), "r" (last_lane)); 
# 229
return output; 
# 230
} 
#endif
# 234 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
__attribute((always_inline)) double ReduceStep(double 
# 235
input, Sum 
# 236
reduction_op, int 
# 237
last_lane, int 
# 238
offset) 
# 239
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 259
::exit(___);}
#if 0
# 239
{ 
# 240
double output; 
# 243
__asm__ volatile("{  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  .reg .f64 r0;  mov.b64 %0, %1;  mov.b64 {lo, hi}, %1;  shfl.down.b32 lo|p, lo, %" "2, %3;  shfl.down.b32 hi|p, hi, %2, %3;  mov.b64 r0, {lo, hi};  @p add.f64 %0, %0, r0;}" : "=d" (output) : "d" (input), "r" (offset), "r" (last_lane)); 
# 258
return output; 
# 259
} 
#endif
# 263 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class ValueT, class KeyT> 
# 264
__attribute((always_inline)) KeyValuePair< KeyT, ValueT>  ReduceStep(KeyValuePair< KeyT, ValueT>  
# 265
input, SwizzleScanOp< ReduceByKeyOp< Sum> >  
# 266
reduction_op, int 
# 267
last_lane, int 
# 268
offset) 
# 269
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 286
::exit(___);}
#if 0
# 269
{ 
# 270
KeyValuePair< KeyT, ValueT>  output; 
# 272
KeyT other_key = ShuffleDown((input.key), offset, last_lane); 
# 274
(output.key) = (input.key); 
# 275
(output.value) = ReduceStep((input.value), Sum(), last_lane, offset, Int2Type< IsInteger< ValueT> ::IS_SMALL_UNSIGNED> ()); 
# 282
if ((input.key) != other_key) { 
# 283
(output.value) = (input.value); }  
# 285
return output; 
# 286
} 
#endif
# 291 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class ValueT, class OffsetT> 
# 292
__attribute((always_inline)) KeyValuePair< OffsetT, ValueT>  ReduceStep(KeyValuePair< OffsetT, ValueT>  
# 293
input, SwizzleScanOp< ReduceBySegmentOp< Sum> >  
# 294
reduction_op, int 
# 295
last_lane, int 
# 296
offset) 
# 297
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 307
::exit(___);}
#if 0
# 297
{ 
# 298
KeyValuePair< OffsetT, ValueT>  output; 
# 300
(output.value) = ReduceStep((input.value), Sum(), last_lane, offset, Int2Type< IsInteger< ValueT> ::IS_SMALL_UNSIGNED> ()); 
# 301
(output.key) = ReduceStep((input.key), Sum(), last_lane, offset, Int2Type< IsInteger< OffsetT> ::IS_SMALL_UNSIGNED> ()); 
# 303
if ((input.key) > 0) { 
# 304
(output.value) = (input.value); }  
# 306
return output; 
# 307
} 
#endif
# 311 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class _T, class ReductionOp> 
# 312
__attribute((always_inline)) _T ReduceStep(_T 
# 313
input, ReductionOp 
# 314
reduction_op, int 
# 315
last_lane, int 
# 316
offset) 
# 317
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;
# 327
::exit(___);}
#if 0
# 317
{ 
# 318
_T output = input; 
# 320
_T temp = ShuffleDown(output, offset); 
# 323
if (offset <= (last_lane - (lane_id))) { 
# 324
output = reduction_op(input, temp); }  
# 326
return output; 
# 327
} 
#endif
# 331 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class _T, class ReductionOp> 
# 332
__attribute((always_inline)) _T ReduceStep(_T 
# 333
input, ReductionOp 
# 334
reduction_op, int 
# 335
last_lane, int 
# 336
offset, Int2Type< 1>  
# 337
is_small_unsigned) 
# 338
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;(void)is_small_unsigned;
# 343
::exit(___);}
#if 0
# 338
{ 
# 340
unsigned temp = reinterpret_cast< unsigned &>(input); 
# 341
temp = ReduceStep(temp, reduction_op, last_lane, offset); 
# 342
return reinterpret_cast< _T &>(temp); 
# 343
} 
#endif
# 347 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class _T, class ReductionOp> 
# 348
__attribute((always_inline)) _T ReduceStep(_T 
# 349
input, ReductionOp 
# 350
reduction_op, int 
# 351
last_lane, int 
# 352
offset, Int2Type< 0>  
# 353
is_small_unsigned) 
# 354
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)offset;(void)is_small_unsigned;
# 356
::exit(___);}
#if 0
# 354
{ 
# 355
return ReduceStep(input, reduction_op, last_lane, offset); 
# 356
} 
#endif
# 363 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class ReductionOp, int STEP> 
# 364
__attribute((always_inline)) void ReduceStep(T &
# 365
input, ReductionOp 
# 366
reduction_op, int 
# 367
last_lane, Int2Type< STEP>  
# 368
step) 
# 369
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)step;
# 373
::exit(___);}
#if 0
# 369
{ 
# 370
input = ReduceStep(input, reduction_op, last_lane, 1 << STEP, Int2Type< IsInteger< T> ::IS_SMALL_UNSIGNED> ()); 
# 372
ReduceStep(input, reduction_op, last_lane, Int2Type< STEP + 1> ()); 
# 373
} 
#endif
# 375 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< class ReductionOp> 
# 376
__attribute((always_inline)) void ReduceStep(T &
# 377
input, ReductionOp 
# 378
reduction_op, int 
# 379
last_lane, Int2Type< STEPS>  
# 380
step) 
# 381
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)last_lane;(void)step;::exit(___);}
#if 0
# 381
{ } 
#endif
# 389 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< bool 
# 390
ALL_LANES_VALID, int 
# 391
FOLDED_ITEMS_PER_LANE, class 
# 392
ReductionOp> 
# 393
__attribute((always_inline)) T Reduce(T 
# 394
input, int 
# 395
folded_items_per_warp, ReductionOp 
# 396
reduction_op) 
# 397
{int volatile ___ = 1;(void)input;(void)folded_items_per_warp;(void)reduction_op;
# 428
::exit(___);}
#if 0
# 397
{ 
# 399
int first_warp_thread = 0; 
# 400
int last_warp_thread = (LOGICAL_WARP_THREADS - 1); 
# 401
if (!(IS_ARCH_WARP)) 
# 402
{ 
# 403
first_warp_thread = ((lane_id) & (~(LOGICAL_WARP_THREADS - 1))); 
# 404
last_warp_thread |= (lane_id); 
# 405
}  
# 408
int lanes_with_valid_data = (folded_items_per_warp - 1) / FOLDED_ITEMS_PER_LANE; 
# 411
int last_lane = ALL_LANES_VALID ? last_warp_thread : (((first_warp_thread + lanes_with_valid_data) < last_warp_thread) ? first_warp_thread + lanes_with_valid_data : last_warp_thread); 
# 415
T output = input; 
# 425
ReduceStep(output, reduction_op, last_lane, Int2Type< 0> ()); 
# 427
return output; 
# 428
} 
#endif
# 432 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
template< bool 
# 433
HEAD_SEGMENTED, class 
# 434
FlagT, class 
# 435
ReductionOp> 
# 436
__attribute((always_inline)) T SegmentedReduce(T 
# 437
input, FlagT 
# 438
flag, ReductionOp 
# 439
reduction_op) 
# 440
{int volatile ___ = 1;(void)input;(void)flag;(void)reduction_op;
# 468
::exit(___);}
#if 0
# 440
{ 
# 442
int warp_flags = __ballot(flag); 
# 444
if (HEAD_SEGMENTED) { 
# 445
warp_flags >>= 1; }  
# 448
warp_flags |= LastLaneMask< 1, LOGICAL_WARPS> ::MASK; 
# 451
warp_flags &= LaneMaskGe(); 
# 454
int last_lane = __clz(__brev(warp_flags)); 
# 456
T output = input; 
# 465
ReduceStep(output, reduction_op, last_lane, Int2Type< 0> ()); 
# 467
return output; 
# 468
} 
#endif
# 469 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_shfl.cuh"
}; 
# 472
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
namespace cub { 
# 51
template< class 
# 52
T, int 
# 53
LOGICAL_WARP_THREADS, int 
# 54
PTX_ARCH> 
# 55
struct WarpReduceSmem { 
# 62
enum { 
# 64
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 67
IS_POW_OF_TWO = (LOGICAL_WARP_THREADS & (LOGICAL_WARP_THREADS - 1)) == 0, 
# 70
STEPS = Log2< LOGICAL_WARP_THREADS> ::VALUE, 
# 73
HALF_WARP_THREADS = 1 << ((Log2< LOGICAL_WARP_THREADS> ::VALUE) - 1), 
# 76
WARP_SMEM_ELEMENTS = LOGICAL_WARP_THREADS + (1 << ((Log2< LOGICAL_WARP_THREADS> ::VALUE) - 1)), 
# 79
UNSET = 0, 
# 80
SET = 1, 
# 81
SEEN = 2
# 82
}; 
# 85
typedef unsigned char SmemFlag; 
# 88
struct _TempStorage { 
# 90
T reduce[WARP_SMEM_ELEMENTS]; 
# 91
SmemFlag flags[WARP_SMEM_ELEMENTS]; 
# 92
}; 
# 95
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 102
_TempStorage &temp_storage; 
# 103
unsigned lane_id; 
# 111
__attribute((always_inline)) WarpReduceSmem(TempStorage &
# 112
temp_storage) : temp_storage((temp_storage.Alias())), lane_id((IS_ARCH_WARP) ? LaneId() : (LaneId() % (LOGICAL_WARP_THREADS))) 
# 118
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 118
{ } 
#endif
# 131 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 132
ALL_LANES_VALID, int 
# 133
FOLDED_ITEMS_PER_LANE, class 
# 134
ReductionOp, int 
# 135
STEP> 
# 136
__attribute((always_inline)) T ReduceStep(T 
# 137
input, int 
# 138
folded_items_per_warp, ReductionOp 
# 139
reduction_op, Int2Type< STEP>  
# 140
step) 
# 141
{int volatile ___ = 1;(void)input;(void)folded_items_per_warp;(void)reduction_op;(void)step;
# 155
::exit(___);}
#if 0
# 141
{ 
# 142
const int OFFSET = (1 << STEP); 
# 145
ThreadStore< STORE_VOLATILE> (&(((temp_storage).reduce)[lane_id]), input); 
# 148
if ((ALL_LANES_VALID && (IS_POW_OF_TWO)) || ((((lane_id) + OFFSET) * (FOLDED_ITEMS_PER_LANE)) < folded_items_per_warp)) 
# 149
{ 
# 150
T peer_addend = ThreadLoad< LOAD_VOLATILE> (&(((temp_storage).reduce)[(lane_id) + OFFSET])); 
# 151
input = reduction_op(input, peer_addend); 
# 152
}  
# 154
return ReduceStep< ALL_LANES_VALID, FOLDED_ITEMS_PER_LANE> (input, folded_items_per_warp, reduction_op, Int2Type< STEP + 1> ()); 
# 155
} 
#endif
# 161 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 162
ALL_LANES_VALID, int 
# 163
FOLDED_ITEMS_PER_LANE, class 
# 164
ReductionOp> 
# 165
__attribute((always_inline)) T ReduceStep(T 
# 166
input, int 
# 167
folded_items_per_warp, ReductionOp 
# 168
reduction_op, Int2Type< STEPS>  
# 169
step) 
# 170
{int volatile ___ = 1;(void)input;(void)folded_items_per_warp;(void)reduction_op;(void)step;
# 172
::exit(___);}
#if 0
# 170
{ 
# 171
return input; 
# 172
} 
#endif
# 183 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 184
HEAD_SEGMENTED, class 
# 185
FlagT, class 
# 186
ReductionOp> 
# 187
__attribute((always_inline)) T SegmentedReduce(T 
# 188
input, FlagT 
# 189
flag, ReductionOp 
# 190
reduction_op, Int2Type< 1>  
# 191
has_ballot) 
# 192
{int volatile ___ = 1;(void)input;(void)flag;(void)reduction_op;(void)has_ballot;
# 232
::exit(___);}
#if 0
# 192
{ 
# 194
int warp_flags = __ballot(flag); 
# 196
if (!HEAD_SEGMENTED) { 
# 197
warp_flags <<= 1; }  
# 200
warp_flags &= LaneMaskGt(); 
# 203
if (!(IS_ARCH_WARP)) 
# 204
{ 
# 205
warp_flags >>= ((LaneId() / (LOGICAL_WARP_THREADS)) * (LOGICAL_WARP_THREADS)); 
# 206
}  
# 209
int next_flag = __clz(__brev(warp_flags)); 
# 212
if (LOGICAL_WARP_THREADS != 32) { 
# 213
next_flag = ((LOGICAL_WARP_THREADS < next_flag) ? LOGICAL_WARP_THREADS : next_flag); }  
# 216
#pragma unroll
for (
# 216
int STEP = 0; STEP < (STEPS); STEP++) 
# 217
{ 
# 218
const int OFFSET = 1 << STEP; 
# 221
ThreadStore< STORE_VOLATILE> (&(((temp_storage).reduce)[lane_id]), input); 
# 224
if (OFFSET < (next_flag - (lane_id))) 
# 225
{ 
# 226
T peer_addend = ThreadLoad< LOAD_VOLATILE> (&(((temp_storage).reduce)[(lane_id) + OFFSET])); 
# 227
input = reduction_op(input, peer_addend); 
# 228
}  
# 229
}  
# 231
return input; 
# 232
} 
#endif
# 238 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 239
HEAD_SEGMENTED, class 
# 240
FlagT, class 
# 241
ReductionOp> 
# 242
__attribute((always_inline)) T SegmentedReduce(T 
# 243
input, FlagT 
# 244
flag, ReductionOp 
# 245
reduction_op, Int2Type< 0>  
# 246
has_ballot) 
# 247
{int volatile ___ = 1;(void)input;(void)flag;(void)reduction_op;(void)has_ballot;
# 314
::exit(___);}
#if 0
# 247
{ 
# 249
enum { 
# 250
UNSET, 
# 251
SET, 
# 252
SEEN
# 253
}; 
# 256
volatile SmemFlag *flag_storage = (((temp_storage).flags)); 
# 258
SmemFlag flag_status = (flag) ? SET : UNSET; 
# 260
for (int STEP = 0; STEP < (STEPS); STEP++) 
# 261
{ 
# 262
const int OFFSET = 1 << STEP; 
# 265
ThreadStore< STORE_VOLATILE> (&(((temp_storage).reduce)[lane_id]), input); 
# 268
T peer_addend = ThreadLoad< LOAD_VOLATILE> (&(((temp_storage).reduce)[(lane_id) + OFFSET])); 
# 271
(flag_storage[lane_id]) = flag_status; 
# 274
SmemFlag peer_flag_status = flag_storage[(lane_id) + OFFSET]; 
# 277
if ((lane_id) < (LOGICAL_WARP_THREADS - OFFSET)) 
# 278
{ 
# 279
if (HEAD_SEGMENTED) 
# 280
{ 
# 282
if ((flag_status & SEEN) == 0) 
# 283
{ 
# 285
if (peer_flag_status & SET) 
# 286
{ 
# 288
flag_status |= SEEN; 
# 289
} else 
# 291
{ 
# 293
input = reduction_op(input, peer_addend); 
# 294
}  
# 297
flag_status |= (peer_flag_status & SEEN); 
# 298
}  
# 299
} else 
# 301
{ 
# 303
if (!flag_status) 
# 304
{ 
# 305
input = reduction_op(input, peer_addend); 
# 306
flag_status |= peer_flag_status; 
# 307
}  
# 309
}  
# 310
}  
# 311
}  
# 313
return input; 
# 314
} 
#endif
# 324 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 325
ALL_LANES_VALID, int 
# 326
FOLDED_ITEMS_PER_LANE, class 
# 327
ReductionOp> 
# 328
__attribute((always_inline)) T Reduce(T 
# 329
input, int 
# 330
folded_items_per_warp, ReductionOp 
# 331
reduction_op) 
# 332
{int volatile ___ = 1;(void)input;(void)folded_items_per_warp;(void)reduction_op;
# 334
::exit(___);}
#if 0
# 332
{ 
# 333
return ReduceStep< ALL_LANES_VALID, FOLDED_ITEMS_PER_LANE> (input, folded_items_per_warp, reduction_op, Int2Type< 0> ()); 
# 334
} 
#endif
# 340 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
template< bool 
# 341
HEAD_SEGMENTED, class 
# 342
FlagT, class 
# 343
ReductionOp> 
# 344
__attribute((always_inline)) T SegmentedReduce(T 
# 345
input, FlagT 
# 346
flag, ReductionOp 
# 347
reduction_op) 
# 348
{int volatile ___ = 1;(void)input;(void)flag;(void)reduction_op;
# 350
::exit(___);}
#if 0
# 348
{ 
# 349
return SegmentedReduce< HEAD_SEGMENTED> (input, flag, reduction_op, Int2Type< PTX_ARCH >= 200> ()); 
# 350
} 
#endif
# 353 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_reduce_smem.cuh"
}; 
# 356
}
# 47 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
namespace cub { 
# 137
template< class 
# 138
T, int 
# 139
LOGICAL_WARP_THREADS = 32, int 
# 140
PTX_ARCH = 0> 
# 141
class WarpReduce { 
# 150
enum { 
# 152
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 155
IS_POW_OF_TWO = PowerOfTwo< LOGICAL_WARP_THREADS> ::VALUE
# 156
}; 
# 165
public: typedef typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpReduceShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpReduceSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type InternalWarpReduce; 
# 173
private: typedef typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpReduceShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpReduceSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type::TempStorage _TempStorage; 
# 181
_TempStorage &temp_storage; 
# 191
public: struct TempStorage : public Uninitialized< typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpReduceShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpReduceSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type::TempStorage>  { }; 
# 203
__attribute((always_inline)) WarpReduce(TempStorage &
# 204
temp_storage) : temp_storage((temp_storage.Alias())) 
# 207
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 207
{ } 
#endif
# 251 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
__attribute((always_inline)) T Sum(T 
# 252
input) 
# 253
{int volatile ___ = 1;(void)input;
# 255
::exit(___);}
#if 0
# 253
{ 
# 254
return (((InternalWarpReduce)(temp_storage)).template Reduce< true, 1> (input, LOGICAL_WARP_THREADS, cub::Sum())); 
# 255
} 
#endif
# 295 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
__attribute((always_inline)) T Sum(T 
# 296
input, int 
# 297
valid_items) 
# 298
{int volatile ___ = 1;(void)input;(void)valid_items;
# 301
::exit(___);}
#if 0
# 298
{ 
# 300
return (((InternalWarpReduce)(temp_storage)).template Reduce< false, 1> (input, valid_items, cub::Sum())); 
# 301
} 
#endif
# 342 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class 
# 343
FlagT> 
# 344
__attribute((always_inline)) T HeadSegmentedSum(T 
# 345
input, FlagT 
# 346
head_flag) 
# 347
{int volatile ___ = 1;(void)input;(void)head_flag;
# 349
::exit(___);}
#if 0
# 347
{ 
# 348
return HeadSegmentedReduce(input, head_flag, cub::Sum()); 
# 349
} 
#endif
# 389 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class 
# 390
FlagT> 
# 391
__attribute((always_inline)) T TailSegmentedSum(T 
# 392
input, FlagT 
# 393
tail_flag) 
# 394
{int volatile ___ = 1;(void)input;(void)tail_flag;
# 396
::exit(___);}
#if 0
# 394
{ 
# 395
return TailSegmentedReduce(input, tail_flag, cub::Sum()); 
# 396
} 
#endif
# 444 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class ReductionOp> 
# 445
__attribute((always_inline)) T Reduce(T 
# 446
input, ReductionOp 
# 447
reduction_op) 
# 448
{int volatile ___ = 1;(void)input;(void)reduction_op;
# 450
::exit(___);}
#if 0
# 448
{ 
# 449
return (((InternalWarpReduce)(temp_storage)).template Reduce< true, 1> (input, LOGICAL_WARP_THREADS, reduction_op)); 
# 450
} 
#endif
# 493 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class ReductionOp> 
# 494
__attribute((always_inline)) T Reduce(T 
# 495
input, ReductionOp 
# 496
reduction_op, int 
# 497
valid_items) 
# 498
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)valid_items;
# 500
::exit(___);}
#if 0
# 498
{ 
# 499
return (((InternalWarpReduce)(temp_storage)).template Reduce< false, 1> (input, valid_items, reduction_op)); 
# 500
} 
#endif
# 542 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class 
# 543
ReductionOp, class 
# 544
FlagT> 
# 545
__attribute((always_inline)) T HeadSegmentedReduce(T 
# 546
input, FlagT 
# 547
head_flag, ReductionOp 
# 548
reduction_op) 
# 549
{int volatile ___ = 1;(void)input;(void)head_flag;(void)reduction_op;
# 551
::exit(___);}
#if 0
# 549
{ 
# 550
return (((InternalWarpReduce)(temp_storage)).template SegmentedReduce< true> (input, head_flag, reduction_op)); 
# 551
} 
#endif
# 593 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
template< class 
# 594
ReductionOp, class 
# 595
FlagT> 
# 596
__attribute((always_inline)) T TailSegmentedReduce(T 
# 597
input, FlagT 
# 598
tail_flag, ReductionOp 
# 599
reduction_op) 
# 600
{int volatile ___ = 1;(void)input;(void)tail_flag;(void)reduction_op;
# 602
::exit(___);}
#if 0
# 600
{ 
# 601
return (((InternalWarpReduce)(temp_storage)).template SegmentedReduce< false> (input, tail_flag, reduction_op)); 
# 602
} 
#endif
# 607 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_reduce.cuh"
}; 
# 611
}
# 43 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
namespace cub { 
# 56
template< int 
# 57
LENGTH, class 
# 58
T, class 
# 59
ReductionOp> 
# 60
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T *
# 61
input, ReductionOp 
# 62
reduction_op, T 
# 63
prefix, Int2Type< LENGTH>  
# 64
length) 
# 65
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)prefix;(void)length;
# 70
::exit(___);}
#if 0
# 65
{ 
# 66
T addend = *input; 
# 67
prefix = reduction_op(prefix, addend); 
# 69
return ThreadReduce(input + 1, reduction_op, prefix, Int2Type< LENGTH - 1> ()); 
# 70
} 
#endif
# 72 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
template< class 
# 73
T, class 
# 74
ReductionOp> 
# 75
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T *
# 76
input, ReductionOp 
# 77
reduction_op, T 
# 78
prefix, Int2Type< 0>  
# 79
length) 
# 80
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)prefix;(void)length;
# 82
::exit(___);}
#if 0
# 80
{ 
# 81
return prefix; 
# 82
} 
#endif
# 92 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
template< int 
# 93
LENGTH, class 
# 94
T, class 
# 95
ReductionOp> 
# 96
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T *
# 97
input, ReductionOp 
# 98
reduction_op, T 
# 99
prefix) 
# 100
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)prefix;
# 102
::exit(___);}
#if 0
# 100
{ 
# 101
return ThreadReduce(input, reduction_op, prefix, Int2Type< LENGTH> ()); 
# 102
} 
#endif
# 112 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
template< int 
# 113
LENGTH, class 
# 114
T, class 
# 115
ReductionOp> 
# 116
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T *
# 117
input, ReductionOp 
# 118
reduction_op) 
# 119
{int volatile ___ = 1;(void)input;(void)reduction_op;
# 122
::exit(___);}
#if 0
# 119
{ 
# 120
T prefix = input[0]; 
# 121
return ThreadReduce< LENGTH - 1> (input + 1, reduction_op, prefix); 
# 122
} 
#endif
# 132 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
template< int 
# 133
LENGTH, class 
# 134
T, class 
# 135
ReductionOp> 
# 136
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T (&
# 137
input)[LENGTH], ReductionOp 
# 138
reduction_op, T 
# 139
prefix) 
# 140
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)prefix;
# 142
::exit(___);}
#if 0
# 140
{ 
# 141
return ThreadReduce(input, reduction_op, prefix, Int2Type< LENGTH> ()); 
# 142
} 
#endif
# 152 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
template< int 
# 153
LENGTH, class 
# 154
T, class 
# 155
ReductionOp> 
# 156
__attribute((always_inline)) __attribute__((unused)) inline T ThreadReduce(T (&
# 157
input)[LENGTH], ReductionOp 
# 158
reduction_op) 
# 159
{int volatile ___ = 1;(void)input;(void)reduction_op;
# 161
::exit(___);}
#if 0
# 159
{ 
# 160
return ThreadReduce< LENGTH> ((T *)(input), reduction_op); 
# 161
} 
#endif
# 168 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_reduce.cuh"
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
namespace cub { 
# 62
template< class 
# 63
T, int 
# 64
BLOCK_DIM_X, int 
# 65
BLOCK_DIM_Y, int 
# 66
BLOCK_DIM_Z, int 
# 67
PTX_ARCH> 
# 68
struct BlockReduceRaking { 
# 72
enum { 
# 74
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 75
}; 
# 78
typedef cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH>  BlockRakingLayout; 
# 81
typedef typename cub::WarpReduce< T, cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH> ::RAKING_THREADS, PTX_ARCH> ::InternalWarpReduce WarpReduce; 
# 85
enum { 
# 87
RAKING_THREADS = cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::RAKING_THREADS, 
# 90
SEGMENT_LENGTH = cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::SEGMENT_LENGTH, 
# 93
WARP_SYNCHRONOUS = (cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::RAKING_THREADS) == ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z), 
# 96
WARP_SYNCHRONOUS_UNGUARDED = PowerOfTwo< cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::RAKING_THREADS> ::VALUE, 
# 99
RAKING_UNGUARDED = cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::UNGUARDED
# 101
}; 
# 105
union _TempStorage { 
# 107
typename cub::WarpReduce< T, cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH> ::RAKING_THREADS, PTX_ARCH> ::InternalWarpReduce::TempStorage warp_storage; 
# 108
typename cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH> ::TempStorage raking_grid; 
# 109
}; 
# 113
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 117
_TempStorage &temp_storage; 
# 118
unsigned linear_tid; 
# 122
__attribute((always_inline)) BlockReduceRaking(TempStorage &
# 123
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 127
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 127
{ } 
#endif
# 130 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
template< bool IS_FULL_TILE, class ReductionOp, int ITERATION> 
# 131
__attribute((always_inline)) T RakingReduction(ReductionOp 
# 132
reduction_op, T *
# 133
raking_segment, T 
# 134
partial, int 
# 135
num_valid, Int2Type< ITERATION>  
# 136
iteration) 
# 137
{int volatile ___ = 1;(void)reduction_op;(void)raking_segment;(void)partial;(void)num_valid;(void)iteration;
# 145
::exit(___);}
#if 0
# 137
{ 
# 139
if ((IS_FULL_TILE && (RAKING_UNGUARDED)) || ((((linear_tid) * (SEGMENT_LENGTH)) + ITERATION) < num_valid)) 
# 140
{ 
# 141
T addend = raking_segment[ITERATION]; 
# 142
partial = reduction_op(partial, addend); 
# 143
}  
# 144
return RakingReduction< IS_FULL_TILE> (reduction_op, raking_segment, partial, num_valid, Int2Type< ITERATION + 1> ()); 
# 145
} 
#endif
# 147 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
template< bool IS_FULL_TILE, class ReductionOp> 
# 148
__attribute((always_inline)) T RakingReduction(ReductionOp 
# 149
reduction_op, T *
# 150
raking_segment, T 
# 151
partial, int 
# 152
num_valid, Int2Type< SEGMENT_LENGTH>  
# 153
iteration) 
# 154
{int volatile ___ = 1;(void)reduction_op;(void)raking_segment;(void)partial;(void)num_valid;(void)iteration;
# 156
::exit(___);}
#if 0
# 154
{ 
# 155
return partial; 
# 156
} 
#endif
# 161 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
template< bool 
# 162
IS_FULL_TILE, class 
# 163
ReductionOp> 
# 164
__attribute((always_inline)) T Reduce(T 
# 165
partial, int 
# 166
num_valid, ReductionOp 
# 167
reduction_op) 
# 168
{int volatile ___ = 1;(void)partial;(void)num_valid;(void)reduction_op;
# 202
::exit(___);}
#if 0
# 168
{ 
# 169
if (WARP_SYNCHRONOUS) 
# 170
{ 
# 172
partial = (((WarpReduce)((temp_storage).warp_storage)).template Reduce< IS_FULL_TILE, SEGMENT_LENGTH> (partial, num_valid, reduction_op)); 
# 176
} else 
# 178
{ 
# 180
(*BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid)) = partial; 
# 182
__syncthreads(); 
# 185
if ((linear_tid) < (RAKING_THREADS)) 
# 186
{ 
# 188
T *raking_segment = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 189
partial = (raking_segment[0]); 
# 191
partial = RakingReduction< IS_FULL_TILE> (reduction_op, raking_segment, partial, num_valid, Int2Type< 1> ()); 
# 193
partial = (((WarpReduce)((temp_storage).warp_storage)).template Reduce< IS_FULL_TILE && (RAKING_UNGUARDED), SEGMENT_LENGTH> (partial, num_valid, reduction_op)); 
# 198
}  
# 199
}  
# 201
return partial; 
# 202
} 
#endif
# 206 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
template< bool IS_FULL_TILE> 
# 207
__attribute((always_inline)) T Sum(T 
# 208
partial, int 
# 209
num_valid) 
# 210
{int volatile ___ = 1;(void)partial;(void)num_valid;
# 214
::exit(___);}
#if 0
# 210
{ 
# 211
cub::Sum reduction_op; 
# 213
return Reduce< IS_FULL_TILE> (partial, num_valid, reduction_op); 
# 214
} 
#endif
# 218 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking.cuh"
}; 
# 220
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking_commutative_only.cuh"
namespace cub { 
# 52
template< class 
# 53
T, int 
# 54
BLOCK_DIM_X, int 
# 55
BLOCK_DIM_Y, int 
# 56
BLOCK_DIM_Z, int 
# 57
PTX_ARCH> 
# 58
struct BlockReduceRakingCommutativeOnly { 
# 62
enum { 
# 64
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 65
}; 
# 68
typedef BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  FallBack; 
# 72
enum { 
# 74
WARP_THREADS = 1 << 5, 
# 77
USE_FALLBACK = ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) % (1 << 5)) != 0) || (((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) <= (1 << 5)), 
# 80
RAKING_THREADS = 1 << 5, 
# 83
SHARING_THREADS = ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) - (1 << 5)) > 1) ? ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) - (1 << 5) : 1, 
# 86
SEGMENT_LENGTH = (((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) - (1 << 5)) > 1) ? ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) - (1 << 5) : 1) / (1 << 5)
# 87
}; 
# 90
typedef cub::WarpReduce< T, RAKING_THREADS, PTX_ARCH>  WarpReduce; 
# 93
typedef cub::BlockRakingLayout< T, (SHARING_THREADS), PTX_ARCH>  BlockRakingLayout; 
# 96
struct _TempStorage { 
# 99
union { 
# 101
struct { 
# 102
typename cub::WarpReduce< T, RAKING_THREADS, PTX_ARCH> ::TempStorage warp_storage; 
# 103
typename cub::BlockRakingLayout< T, (SHARING_THREADS), PTX_ARCH> ::TempStorage raking_grid; 
# 104
}; 
# 105
typename BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage fallback_storage; 
# 106
}; 
# 107
}; 
# 111
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 115
_TempStorage &temp_storage; 
# 116
unsigned linear_tid; 
# 120
__attribute((always_inline)) BlockReduceRakingCommutativeOnly(TempStorage &
# 121
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 125
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 125
{ } 
#endif
# 129 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking_commutative_only.cuh"
template< bool FULL_TILE> 
# 130
__attribute((always_inline)) T Sum(T 
# 131
partial, int 
# 132
num_valid) 
# 133
{int volatile ___ = 1;(void)partial;(void)num_valid;
# 159
::exit(___);}
#if 0
# 133
{ 
# 134
if ((USE_FALLBACK) || (!FULL_TILE)) 
# 135
{ 
# 136
return (((FallBack)(((temp_storage).fallback_storage))).template Sum< FULL_TILE> (partial, num_valid)); 
# 137
} else 
# 139
{ 
# 141
if ((linear_tid) >= (RAKING_THREADS)) { 
# 142
(*BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), (linear_tid) - (RAKING_THREADS))) = partial; }  
# 144
__syncthreads(); 
# 147
if ((linear_tid) < (RAKING_THREADS)) 
# 148
{ 
# 150
T *raking_segment = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 151
partial = ThreadReduce< SEGMENT_LENGTH> (raking_segment, cub::Sum(), partial); 
# 154
partial = (((WarpReduce)(((temp_storage).warp_storage))).Sum(partial)); 
# 155
}  
# 156
}  
# 158
return partial; 
# 159
} 
#endif
# 163 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking_commutative_only.cuh"
template< bool 
# 164
FULL_TILE, class 
# 165
ReductionOp> 
# 166
__attribute((always_inline)) T Reduce(T 
# 167
partial, int 
# 168
num_valid, ReductionOp 
# 169
reduction_op) 
# 170
{int volatile ___ = 1;(void)partial;(void)num_valid;(void)reduction_op;
# 196
::exit(___);}
#if 0
# 170
{ 
# 171
if ((USE_FALLBACK) || (!FULL_TILE)) 
# 172
{ 
# 173
return (((FallBack)(((temp_storage).fallback_storage))).template Reduce< FULL_TILE> (partial, num_valid, reduction_op)); 
# 174
} else 
# 176
{ 
# 178
if ((linear_tid) >= (RAKING_THREADS)) { 
# 179
(*BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), (linear_tid) - (RAKING_THREADS))) = partial; }  
# 181
__syncthreads(); 
# 184
if ((linear_tid) < (RAKING_THREADS)) 
# 185
{ 
# 187
T *raking_segment = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 188
partial = ThreadReduce< SEGMENT_LENGTH> (raking_segment, reduction_op, partial); 
# 191
partial = (((WarpReduce)(((temp_storage).warp_storage))).Reduce(partial, reduction_op)); 
# 192
}  
# 193
}  
# 195
return partial; 
# 196
} 
#endif
# 198 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_raking_commutative_only.cuh"
}; 
# 200
}
# 45 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
namespace cub { 
# 51
template< class 
# 52
T, int 
# 53
BLOCK_DIM_X, int 
# 54
BLOCK_DIM_Y, int 
# 55
BLOCK_DIM_Z, int 
# 56
PTX_ARCH> 
# 57
struct BlockReduceWarpReductions { 
# 61
enum { 
# 63
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, 
# 66
WARP_THREADS = 1 << 5, 
# 69
WARPS = ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) + (1 << 5)) - 1) / (1 << 5), 
# 72
LOGICAL_WARP_SIZE = ((1 << 5) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << 5 : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z), 
# 75
EVEN_WARP_MULTIPLE = (((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) % (((1 << 5) < ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z)) ? 1 << 5 : ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z))) == 0
# 76
}; 
# 80
typedef typename cub::WarpReduce< T, LOGICAL_WARP_SIZE, PTX_ARCH> ::InternalWarpReduce WarpReduce; 
# 84
struct _TempStorage { 
# 86
typename cub::WarpReduce< T, LOGICAL_WARP_SIZE, PTX_ARCH> ::InternalWarpReduce::TempStorage warp_reduce[WARPS]; 
# 87
T warp_aggregates[WARPS]; 
# 88
T block_prefix; 
# 89
}; 
# 92
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 96
_TempStorage &temp_storage; 
# 97
unsigned linear_tid; 
# 98
unsigned warp_id; 
# 99
unsigned lane_id; 
# 103
__attribute((always_inline)) BlockReduceWarpReductions(TempStorage &
# 104
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)), warp_id(((WARPS) == 1) ? 0 : ((linear_tid) / (WARP_THREADS))), lane_id(LaneId()) 
# 110
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 110
{ } 
#endif
# 113 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
template< bool FULL_TILE, class ReductionOp, int SUCCESSOR_WARP> 
# 114
__attribute((always_inline)) T ApplyWarpAggregates(ReductionOp 
# 115
reduction_op, T 
# 116
warp_aggregate, int 
# 117
num_valid, Int2Type< SUCCESSOR_WARP>  
# 118
successor_warp) 
# 119
{int volatile ___ = 1;(void)reduction_op;(void)warp_aggregate;(void)num_valid;(void)successor_warp;
# 126
::exit(___);}
#if 0
# 119
{ 
# 120
if (FULL_TILE || ((SUCCESSOR_WARP * (LOGICAL_WARP_SIZE)) < num_valid)) 
# 121
{ 
# 122
T addend = ((temp_storage).warp_aggregates)[SUCCESSOR_WARP]; 
# 123
warp_aggregate = reduction_op(warp_aggregate, addend); 
# 124
}  
# 125
return ApplyWarpAggregates< FULL_TILE> (reduction_op, warp_aggregate, num_valid, Int2Type< SUCCESSOR_WARP + 1> ()); 
# 126
} 
#endif
# 128 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
template< bool FULL_TILE, class ReductionOp> 
# 129
__attribute((always_inline)) T ApplyWarpAggregates(ReductionOp 
# 130
reduction_op, T 
# 131
warp_aggregate, int 
# 132
num_valid, Int2Type< WARPS>  
# 133
successor_warp) 
# 134
{int volatile ___ = 1;(void)reduction_op;(void)warp_aggregate;(void)num_valid;(void)successor_warp;
# 136
::exit(___);}
#if 0
# 134
{ 
# 135
return warp_aggregate; 
# 136
} 
#endif
# 140 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
template< bool 
# 141
FULL_TILE, class 
# 142
ReductionOp> 
# 143
__attribute((always_inline)) T ApplyWarpAggregates(ReductionOp 
# 144
reduction_op, T 
# 145
warp_aggregate, int 
# 146
num_valid) 
# 147
{int volatile ___ = 1;(void)reduction_op;(void)warp_aggregate;(void)num_valid;
# 163
::exit(___);}
#if 0
# 147
{ 
# 149
if ((lane_id) == (0)) 
# 150
{ 
# 151
(((temp_storage).warp_aggregates)[warp_id]) = warp_aggregate; 
# 152
}  
# 154
__syncthreads(); 
# 157
if ((linear_tid) == (0)) 
# 158
{ 
# 159
warp_aggregate = ApplyWarpAggregates< FULL_TILE> (reduction_op, warp_aggregate, num_valid, Int2Type< 1> ()); 
# 160
}  
# 162
return warp_aggregate; 
# 163
} 
#endif
# 167 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
template< bool FULL_TILE> 
# 168
__attribute((always_inline)) T Sum(T 
# 169
input, int 
# 170
num_valid) 
# 171
{int volatile ___ = 1;(void)input;(void)num_valid;
# 188
::exit(___);}
#if 0
# 171
{ 
# 172
cub::Sum reduction_op; 
# 173
unsigned warp_offset = (warp_id) * (LOGICAL_WARP_SIZE); 
# 174
unsigned warp_num_valid = (FULL_TILE && (EVEN_WARP_MULTIPLE)) ? LOGICAL_WARP_SIZE : ((warp_offset < num_valid) ? num_valid - warp_offset : (0)); 
# 181
T warp_aggregate = (((WarpReduce)(((temp_storage).warp_reduce)[warp_id])).template Reduce< FULL_TILE && (EVEN_WARP_MULTIPLE), 1> (input, warp_num_valid, cub::Sum())); 
# 187
return ApplyWarpAggregates< FULL_TILE> (reduction_op, warp_aggregate, num_valid); 
# 188
} 
#endif
# 192 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
template< bool 
# 193
FULL_TILE, class 
# 194
ReductionOp> 
# 195
__attribute((always_inline)) T Reduce(T 
# 196
input, int 
# 197
num_valid, ReductionOp 
# 198
reduction_op) 
# 199
{int volatile ___ = 1;(void)input;(void)num_valid;(void)reduction_op;
# 215
::exit(___);}
#if 0
# 199
{ 
# 200
unsigned warp_offset = (warp_id) * (LOGICAL_WARP_SIZE); 
# 201
unsigned warp_num_valid = (FULL_TILE && (EVEN_WARP_MULTIPLE)) ? LOGICAL_WARP_SIZE : ((warp_offset < num_valid) ? num_valid - warp_offset : (0)); 
# 208
T warp_aggregate = (((WarpReduce)(((temp_storage).warp_reduce)[warp_id])).template Reduce< FULL_TILE && (EVEN_WARP_MULTIPLE), 1> (input, warp_num_valid, reduction_op)); 
# 214
return ApplyWarpAggregates< FULL_TILE> (reduction_op, warp_aggregate, num_valid); 
# 215
} 
#endif
# 217 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_reduce_warp_reductions.cuh"
}; 
# 220
}
# 48 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
namespace cub { 
# 60
enum BlockReduceAlgorithm { 
# 89
BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY, 
# 119
BLOCK_REDUCE_RAKING, 
# 148
BLOCK_REDUCE_WARP_REDUCTIONS
# 149
}; 
# 214
template< class 
# 215
T, int 
# 216
BLOCK_DIM_X, BlockReduceAlgorithm 
# 217
ALGORITHM = BLOCK_REDUCE_WARP_REDUCTIONS, int 
# 218
BLOCK_DIM_Y = 1, int 
# 219
BLOCK_DIM_Z = 1, int 
# 220
PTX_ARCH = 0> 
# 221
class BlockReduce { 
# 231
enum { 
# 233
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 234
}; 
# 236
typedef BlockReduceWarpReductions< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  WarpReductions; 
# 237
typedef BlockReduceRakingCommutativeOnly< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  RakingCommutativeOnly; 
# 238
typedef BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  Raking; 
# 245
typedef typename If< (ALGORITHM) == (BLOCK_REDUCE_WARP_REDUCTIONS), BlockReduceWarpReductions< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , typename If< (ALGORITHM) == (BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY), BlockReduceRakingCommutativeOnly< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> > ::Type> ::Type InternalBlockReduce; 
# 248
typedef typename If< (ALGORITHM) == (BLOCK_REDUCE_WARP_REDUCTIONS), BlockReduceWarpReductions< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , typename If< (ALGORITHM) == (BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY), BlockReduceRakingCommutativeOnly< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> > ::Type> ::Type::TempStorage _TempStorage; 
# 256
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 257
{int volatile ___ = 1;
# 260
::exit(___);}
#if 0
# 257
{ 
# 258
__attribute__((unused)) static _TempStorage private_storage; 
# 259
return private_storage; 
# 260
} 
#endif
# 268 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
_TempStorage &temp_storage; 
# 271
unsigned linear_tid; 
# 277
public: struct TempStorage : public Uninitialized< typename If< (ALGORITHM) == (BLOCK_REDUCE_WARP_REDUCTIONS), BlockReduceWarpReductions< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , typename If< (ALGORITHM) == (BLOCK_REDUCE_RAKING_COMMUTATIVE_ONLY), BlockReduceRakingCommutativeOnly< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockReduceRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> > ::Type> ::Type::TempStorage>  { }; 
# 288
__attribute((always_inline)) BlockReduce() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 292
{int *volatile ___ = 0;::free(___);}
#if 0
# 292
{ } 
#endif
# 298 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
__attribute((always_inline)) BlockReduce(TempStorage &
# 299
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 303
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 303
{ } 
#endif
# 347 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
template< class ReductionOp> 
# 348
__attribute((always_inline)) T Reduce(T 
# 349
input, ReductionOp 
# 350
reduction_op) 
# 351
{int volatile ___ = 1;(void)input;(void)reduction_op;
# 353
::exit(___);}
#if 0
# 351
{ 
# 352
return (((InternalBlockReduce)(temp_storage)).template Reduce< true> (input, BLOCK_THREADS, reduction_op)); 
# 353
} 
#endif
# 392 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
template< int 
# 393
ITEMS_PER_THREAD, class 
# 394
ReductionOp> 
# 395
__attribute((always_inline)) T Reduce(T (&
# 396
inputs)[ITEMS_PER_THREAD], ReductionOp 
# 397
reduction_op) 
# 398
{int volatile ___ = 1;(void)inputs;(void)reduction_op;
# 402
::exit(___);}
#if 0
# 398
{ 
# 400
T partial = ThreadReduce(inputs, reduction_op); 
# 401
return Reduce(partial, reduction_op); 
# 402
} 
#endif
# 439 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
template< class ReductionOp> 
# 440
__attribute((always_inline)) T Reduce(T 
# 441
input, ReductionOp 
# 442
reduction_op, int 
# 443
num_valid) 
# 444
{int volatile ___ = 1;(void)input;(void)reduction_op;(void)num_valid;
# 454
::exit(___);}
#if 0
# 444
{ 
# 446
if (num_valid >= (BLOCK_THREADS)) 
# 447
{ 
# 448
return (((InternalBlockReduce)(temp_storage)).template Reduce< true> (input, num_valid, reduction_op)); 
# 449
} else 
# 451
{ 
# 452
return (((InternalBlockReduce)(temp_storage)).template Reduce< false> (input, num_valid, reduction_op)); 
# 453
}  
# 454
} 
#endif
# 497 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
__attribute((always_inline)) T Sum(T 
# 498
input) 
# 499
{int volatile ___ = 1;(void)input;
# 501
::exit(___);}
#if 0
# 499
{ 
# 500
return (((InternalBlockReduce)(temp_storage)).template Sum< true> (input, BLOCK_THREADS)); 
# 501
} 
#endif
# 538 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
template< int ITEMS_PER_THREAD> 
# 539
__attribute((always_inline)) T Sum(T (&
# 540
inputs)[ITEMS_PER_THREAD]) 
# 541
{int volatile ___ = 1;(void)inputs;
# 545
::exit(___);}
#if 0
# 541
{ 
# 543
T partial = ThreadReduce(inputs, cub::Sum()); 
# 544
return Sum(partial); 
# 545
} 
#endif
# 582 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
__attribute((always_inline)) T Sum(T 
# 583
input, int 
# 584
num_valid) 
# 585
{int volatile ___ = 1;(void)input;(void)num_valid;
# 595
::exit(___);}
#if 0
# 585
{ 
# 587
if (num_valid >= (BLOCK_THREADS)) 
# 588
{ 
# 589
return (((InternalBlockReduce)(temp_storage)).template Sum< true> (input, num_valid)); 
# 590
} else 
# 592
{ 
# 593
return (((InternalBlockReduce)(temp_storage)).template Sum< false> (input, num_valid)); 
# 594
}  
# 595
} 
#endif
# 599 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_reduce.cuh"
}; 
# 605
}
# 42 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_mapping.cuh"
namespace cub { 
# 59
enum GridMappingStrategy { 
# 74
GRID_MAPPING_EVEN_SHARE, 
# 87
GRID_MAPPING_DYNAMIC
# 88
}; 
# 93
}
# 43 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh"
namespace cub { 
# 81
template< class OffsetT> 
# 82
class GridQueue { 
# 88
enum { 
# 89
FILL, 
# 90
DRAIN = 1
# 91
}; 
# 94
OffsetT *d_counters; 
# 100
public: 
# 99
__attribute((always_inline)) static size_t 
# 100
AllocationSize() 
# 101
{ 
# 102
return sizeof(OffsetT) * (2); 
# 103
} 
# 107
__attribute((always_inline)) GridQueue() : d_counters((__null)) 
# 110
{ } 
# 114
__attribute((always_inline)) GridQueue(void *
# 115
d_storage) : d_counters((OffsetT *)d_storage) 
# 118
{ } 
# 122
__attribute((always_inline)) cudaError_t FillAndResetDrain(OffsetT 
# 123
fill_size, cudaStream_t 
# 124
stream = 0) 
# 125
{ 
# 131
OffsetT counters[2]; 
# 132
(counters[FILL]) = fill_size; 
# 133
(counters[DRAIN]) = 0; 
# 134
return cub::Debug(cudaMemcpyAsync(d_counters, counters, sizeof(OffsetT) * (2), cudaMemcpyHostToDevice, stream), "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh", 134); 
# 136
} 
# 140
__attribute((always_inline)) cudaError_t ResetDrain(cudaStream_t stream = 0) 
# 141
{ 
# 146
return cub::Debug(cudaMemsetAsync((d_counters) + (DRAIN), 0, sizeof(OffsetT), stream), "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh", 146); 
# 148
} 
# 152
__attribute((always_inline)) cudaError_t ResetFill(cudaStream_t stream = 0) 
# 153
{ 
# 158
return cub::Debug(cudaMemsetAsync((d_counters) + (FILL), 0, sizeof(OffsetT), stream), "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh", 158); 
# 160
} 
# 164
__attribute((always_inline)) cudaError_t FillSize(OffsetT &
# 165
fill_size, cudaStream_t 
# 166
stream = 0) 
# 167
{ 
# 172
return cub::Debug(cudaMemcpyAsync(&fill_size, (d_counters) + (FILL), sizeof(OffsetT), cudaMemcpyDeviceToHost, stream), "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh", 172); 
# 174
} 
# 178
__attribute((always_inline)) OffsetT Drain(OffsetT num_items) 
# 179
{int volatile ___ = 1;(void)num_items;
# 181
::exit(___);}
#if 0
# 179
{ 
# 180
return atomicAdd((d_counters) + (DRAIN), num_items); 
# 181
} 
#endif
# 185 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh"
__attribute((always_inline)) OffsetT Fill(OffsetT num_items) 
# 186
{int volatile ___ = 1;(void)num_items;
# 188
::exit(___);}
#if 0
# 186
{ 
# 187
return atomicAdd((d_counters) + (FILL), num_items); 
# 188
} 
#endif
# 189 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh"
}; 
# 198
template< class OffsetT> static void 
# 199
__wrapper__device_stub_FillAndResetDrainKernel(GridQueue< OffsetT>  &
# 200
grid_queue, OffsetT &
# 201
num_items) {exit(1);}
#if 0
# 202
{ 
# 203
(grid_queue.FillAndResetDrain(num_items)); 
# 204
} 
#endif
# 198 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh"
template< class OffsetT> void 
# 199
FillAndResetDrainKernel(GridQueue< OffsetT>  
# 200
grid_queue, OffsetT 
# 201
num_items) 
# 202
{__wrapper__device_stub_FillAndResetDrainKernel<OffsetT>(grid_queue,num_items);
# 204
return;}
#if 0
# 202
{ 
# 203
(grid_queue.FillAndResetDrain(num_items)); 
# 204
} 
#endif
# 213 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_queue.cuh"
}
# 44 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_even_share.cuh"
namespace cub { 
# 70
template< class OffsetT> 
# 71
struct GridEvenShare { 
# 73
OffsetT total_grains; 
# 74
int big_blocks; 
# 75
OffsetT big_share; 
# 76
OffsetT normal_share; 
# 77
OffsetT normal_base_offset; 
# 80
OffsetT num_items; 
# 83
int grid_size; 
# 86
OffsetT block_offset; 
# 89
OffsetT block_end; 
# 94
__attribute((always_inline)) GridEvenShare() : num_items(0), grid_size(0), block_offset(0), block_end(0) 
# 98
{ } 
# 103
__attribute((always_inline)) GridEvenShare(OffsetT 
# 104
num_items, int 
# 105
max_grid_size, int 
# 106
schedule_granularity) 
# 107
{ 
# 108
(this->num_items) = num_items; 
# 109
(this->block_offset) = num_items; 
# 110
(this->block_end) = num_items; 
# 111
(this->total_grains) = (((num_items + schedule_granularity) - 1) / schedule_granularity); 
# 112
(this->grid_size) = ((max_grid_size < (total_grains)) ? max_grid_size : (total_grains)); 
# 113
OffsetT grains_per_block = (total_grains) / (grid_size); 
# 114
(this->big_blocks) = ((total_grains) - (grains_per_block * (grid_size))); 
# 115
(this->normal_share) = (grains_per_block * schedule_granularity); 
# 116
(this->normal_base_offset) = ((big_blocks) * schedule_granularity); 
# 117
(this->big_share) = ((normal_share) + schedule_granularity); 
# 118
} 
# 125
__attribute((always_inline)) void Init(int partition_id) 
# 126
{int volatile ___ = 1;(void)partition_id;
# 139
::exit(___);}
#if 0
# 126
{ 
# 127
if (partition_id < (big_blocks)) 
# 128
{ 
# 130
(block_offset) = (partition_id * (big_share)); 
# 131
(block_end) = ((block_offset) + (big_share)); 
# 132
} else { 
# 133
if (partition_id < (total_grains)) 
# 134
{ 
# 136
(block_offset) = ((normal_base_offset) + (partition_id * (normal_share))); 
# 137
(block_end) = ((((block_offset) + (normal_share)) < (num_items)) ? (block_offset) + (normal_share) : (num_items)); 
# 138
}  }  
# 139
} 
#endif
# 145 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_even_share.cuh"
__attribute((always_inline)) void BlockInit() 
# 146
{int volatile ___ = 1;
# 148
::exit(___);}
#if 0
# 146
{ 
# 147
Init(__device_builtin_variable_blockIdx.x); 
# 148
} 
#endif
# 154 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../grid/grid_even_share.cuh"
__attribute((always_inline)) void Print() 
# 155
{ 
# 156
printf("num_items(%lu)  total_grains(%lu)  big_blocks(%lu)  big_share(%lu)  normal_share(%lu)\n", (unsigned long)(num_items), (unsigned long)(total_grains), (unsigned long)(big_blocks), (unsigned long)(big_share), (unsigned long)(normal_share)); 
# 177
} 
# 178
}; 
# 184
}
# 52 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
namespace cub { 
# 62
template< int 
# 63
_BLOCK_THREADS, int 
# 64
_ITEMS_PER_THREAD, int 
# 65
_VECTOR_LOAD_LENGTH, BlockReduceAlgorithm 
# 66
_BLOCK_ALGORITHM, CacheLoadModifier 
# 67
_LOAD_MODIFIER, GridMappingStrategy 
# 68
_GRID_MAPPING> 
# 69
struct AgentReducePolicy { 
# 72
enum { 
# 73
BLOCK_THREADS = _BLOCK_THREADS, 
# 74
ITEMS_PER_THREAD = _ITEMS_PER_THREAD, 
# 75
VECTOR_LOAD_LENGTH = _VECTOR_LOAD_LENGTH
# 76
}; 
# 78
static const BlockReduceAlgorithm BLOCK_ALGORITHM = _BLOCK_ALGORITHM; 
# 79
static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER; 
# 80
static const GridMappingStrategy GRID_MAPPING = _GRID_MAPPING; 
# 81
}; 
# 96
template< class 
# 97
AgentReducePolicy, class 
# 98
InputIteratorT, class 
# 99
OutputIteratorT, class 
# 100
OffsetT, class 
# 101
ReductionOp> 
# 102
struct AgentReduce { 
# 110
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputT; 
# 111
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 114
typedef typename CubVector< typename std::iterator_traits< InputIteratorT> ::value_type, AgentReducePolicy::VECTOR_LOAD_LENGTH> ::Type VectorT; 
# 120
typedef typename If< IsPointer< InputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReducePolicy::LOAD_MODIFIER, typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT> , InputIteratorT> ::Type WrappedInputIteratorT; 
# 124
enum { 
# 125
BLOCK_THREADS = AgentReducePolicy::BLOCK_THREADS, 
# 126
ITEMS_PER_THREAD = AgentReducePolicy::ITEMS_PER_THREAD, 
# 127
VECTOR_LOAD_LENGTH = (AgentReducePolicy::VECTOR_LOAD_LENGTH < (AgentReducePolicy::ITEMS_PER_THREAD)) ? AgentReducePolicy::VECTOR_LOAD_LENGTH : (AgentReducePolicy::ITEMS_PER_THREAD), 
# 128
TILE_ITEMS = (AgentReducePolicy::BLOCK_THREADS) * (AgentReducePolicy::ITEMS_PER_THREAD), 
# 131
ATTEMPT_VECTORIZATION = (((AgentReducePolicy::VECTOR_LOAD_LENGTH < (AgentReducePolicy::ITEMS_PER_THREAD)) ? AgentReducePolicy::VECTOR_LOAD_LENGTH : (AgentReducePolicy::ITEMS_PER_THREAD)) > 1) && (((AgentReducePolicy::ITEMS_PER_THREAD) % ((AgentReducePolicy::VECTOR_LOAD_LENGTH < (AgentReducePolicy::ITEMS_PER_THREAD)) ? AgentReducePolicy::VECTOR_LOAD_LENGTH : (AgentReducePolicy::ITEMS_PER_THREAD))) == 0) && IsPointer< InputIteratorT> ::VALUE && Traits< typename std::iterator_traits< InputIteratorT> ::value_type> ::PRIMITIVE
# 135
}; 
# 137
static const CacheLoadModifier LOAD_MODIFIER = (AgentReducePolicy::LOAD_MODIFIER); 
# 138
static const BlockReduceAlgorithm BLOCK_ALGORITHM = (AgentReducePolicy::BLOCK_ALGORITHM); 
# 141
typedef BlockReduce< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_THREADS, AgentReducePolicy::BLOCK_ALGORITHM>  BlockReduceT; 
# 144
struct _TempStorage { 
# 146
typename BlockReduce< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_THREADS, AgentReducePolicy::BLOCK_ALGORITHM> ::TempStorage reduce; 
# 147
OffsetT dequeue_offset; 
# 148
}; 
# 151
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 158
_TempStorage &temp_storage; 
# 159
InputIteratorT d_in; 
# 160
WrappedInputIteratorT d_wrapped_in; 
# 161
ReductionOp reduction_op; 
# 170
template< class Iterator> 
# 171
__attribute((always_inline)) static bool IsAligned(Iterator 
# 172
d_in, Int2Type< 1>  
# 173
can_vectorize) 
# 174
{int volatile ___ = 1;(void)d_in;(void)can_vectorize;
# 176
::exit(___);}
#if 0
# 174
{ 
# 175
return (((size_t)d_in) & (sizeof(VectorT) - (1))) == (0); 
# 176
} 
#endif
# 179 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< class Iterator> 
# 180
__attribute((always_inline)) static bool IsAligned(Iterator 
# 181
d_in, Int2Type< 0>  
# 182
can_vectorize) 
# 183
{int volatile ___ = 1;(void)d_in;(void)can_vectorize;
# 185
::exit(___);}
#if 0
# 183
{ 
# 184
return false; 
# 185
} 
#endif
# 195 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
__attribute((always_inline)) AgentReduce(TempStorage &
# 196
temp_storage, InputIteratorT 
# 197
d_in, ReductionOp 
# 198
reduction_op) : temp_storage((temp_storage.Alias())), d_in(d_in), d_wrapped_in(d_in), reduction_op(reduction_op) 
# 204
{int *volatile ___ = 0;(void)temp_storage;(void)d_in;(void)reduction_op;::free(___);}
#if 0
# 204
{ } 
#endif
# 214 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< int IS_FIRST_TILE> 
# 215
__attribute((always_inline)) void ConsumeTile(OutputT &
# 216
thread_aggregate, OffsetT 
# 217
block_offset, int 
# 218
valid_items, Int2Type< 1>  
# 219
is_full_tile, Int2Type< 0>  
# 220
can_vectorize) 
# 221
{int volatile ___ = 1;(void)thread_aggregate;(void)block_offset;(void)valid_items;(void)is_full_tile;(void)can_vectorize;
# 231
::exit(___);}
#if 0
# 221
{ 
# 222
OutputT items[ITEMS_PER_THREAD]; 
# 225
LoadDirectStriped< BLOCK_THREADS> (__device_builtin_variable_threadIdx.x, (d_wrapped_in) + block_offset, items); 
# 228
thread_aggregate = ((IS_FIRST_TILE) ? ThreadReduce(items, reduction_op) : ThreadReduce(items, reduction_op, thread_aggregate)); 
# 231
} 
#endif
# 237 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< int IS_FIRST_TILE> 
# 238
__attribute((always_inline)) void ConsumeTile(OutputT &
# 239
thread_aggregate, OffsetT 
# 240
block_offset, int 
# 241
valid_items, Int2Type< 1>  
# 242
is_full_tile, Int2Type< 1>  
# 243
can_vectorize) 
# 244
{int volatile ___ = 1;(void)thread_aggregate;(void)block_offset;(void)valid_items;(void)is_full_tile;(void)can_vectorize;
# 270
::exit(___);}
#if 0
# 244
{ 
# 246
enum { WORDS = (AgentReducePolicy::ITEMS_PER_THREAD) / ((AgentReducePolicy::VECTOR_LOAD_LENGTH < (AgentReducePolicy::ITEMS_PER_THREAD)) ? AgentReducePolicy::VECTOR_LOAD_LENGTH : (AgentReducePolicy::ITEMS_PER_THREAD))}; 
# 249
InputT *d_in_unqualified = ((const_cast< InputT *>(d_in)) + block_offset) + ((__device_builtin_variable_threadIdx.x) * (VECTOR_LOAD_LENGTH)); 
# 250
CacheModifiedInputIterator< AgentReducePolicy::LOAD_MODIFIER, typename CubVector< typename std::iterator_traits< InputIteratorT> ::value_type, AgentReducePolicy::VECTOR_LOAD_LENGTH> ::Type, OffsetT>  d_vec_in(reinterpret_cast< VectorT *>(d_in_unqualified)); 
# 254
InputT input_items[ITEMS_PER_THREAD]; 
# 255
VectorT *vec_items = reinterpret_cast< VectorT *>(input_items); 
# 257
#pragma unroll
for (
# 257
int i = 0; i < (WORDS); ++i) { 
# 258
(vec_items[i]) = (d_vec_in[(BLOCK_THREADS) * i]); }  
# 261
OutputT items[ITEMS_PER_THREAD]; 
# 263
#pragma unroll
for (
# 263
int i = 0; i < (ITEMS_PER_THREAD); ++i) { 
# 264
((items)[i]) = ((input_items)[i]); }  
# 267
thread_aggregate = ((IS_FIRST_TILE) ? ThreadReduce(items, reduction_op) : ThreadReduce(items, reduction_op, thread_aggregate)); 
# 270
} 
#endif
# 276 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< int IS_FIRST_TILE, int CAN_VECTORIZE> 
# 277
__attribute((always_inline)) void ConsumeTile(OutputT &
# 278
thread_aggregate, OffsetT 
# 279
block_offset, int 
# 280
valid_items, Int2Type< 0>  
# 281
is_full_tile, Int2Type< CAN_VECTORIZE>  
# 282
can_vectorize) 
# 283
{int volatile ___ = 1;(void)thread_aggregate;(void)block_offset;(void)valid_items;(void)is_full_tile;(void)can_vectorize;
# 301
::exit(___);}
#if 0
# 283
{ 
# 285
int thread_offset = __device_builtin_variable_threadIdx.x; 
# 288
if ((IS_FIRST_TILE) && (thread_offset < valid_items)) 
# 289
{ 
# 290
thread_aggregate = ((d_wrapped_in)[block_offset + thread_offset]); 
# 291
thread_offset += (BLOCK_THREADS); 
# 292
}  
# 295
while (thread_offset < valid_items) 
# 296
{ 
# 297
OutputT item = (d_wrapped_in)[block_offset + thread_offset]; 
# 298
thread_aggregate = (reduction_op)(thread_aggregate, item); 
# 299
thread_offset += (BLOCK_THREADS); 
# 300
}  
# 301
} 
#endif
# 311 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< int CAN_VECTORIZE> 
# 312
__attribute((always_inline)) OutputT ConsumeRange(OffsetT 
# 313
block_offset, OffsetT 
# 314
block_end, Int2Type< CAN_VECTORIZE>  
# 315
can_vectorize) 
# 316
{int volatile ___ = 1;(void)block_offset;(void)block_end;(void)can_vectorize;
# 347
::exit(___);}
#if 0
# 316
{ 
# 317
OutputT thread_aggregate; 
# 319
if ((block_offset + (TILE_ITEMS)) > block_end) 
# 320
{ 
# 322
int valid_items = block_end - block_offset; 
# 323
ConsumeTile< true> (thread_aggregate, block_offset, valid_items, Int2Type< 0> (), can_vectorize); 
# 324
return (((BlockReduceT)(((temp_storage).reduce))).Reduce(thread_aggregate, reduction_op, valid_items)); 
# 325
}  
# 328
ConsumeTile< true> (thread_aggregate, block_offset, TILE_ITEMS, Int2Type< 1> (), can_vectorize); 
# 329
block_offset += (TILE_ITEMS); 
# 332
while ((block_offset + (TILE_ITEMS)) <= block_end) 
# 333
{ 
# 334
ConsumeTile< false> (thread_aggregate, block_offset, TILE_ITEMS, Int2Type< 1> (), can_vectorize); 
# 335
block_offset += (TILE_ITEMS); 
# 336
}  
# 339
if (block_offset < block_end) 
# 340
{ 
# 341
int valid_items = block_end - block_offset; 
# 342
ConsumeTile< false> (thread_aggregate, block_offset, valid_items, Int2Type< 0> (), can_vectorize); 
# 343
}  
# 346
return (((BlockReduceT)(((temp_storage).reduce))).Reduce(thread_aggregate, reduction_op)); 
# 347
} 
#endif
# 353 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
__attribute((always_inline)) OutputT ConsumeRange(OffsetT 
# 354
block_offset, OffsetT 
# 355
block_end) 
# 356
{int volatile ___ = 1;(void)block_offset;(void)block_end;
# 360
::exit(___);}
#if 0
# 356
{ 
# 357
return (IsAligned((d_in) + block_offset, Int2Type< (ATTEMPT_VECTORIZATION)> ())) ? ConsumeRange(block_offset, block_end, Int2Type< (true && (ATTEMPT_VECTORIZATION))> ()) : ConsumeRange(block_offset, block_end, Int2Type< (false && (ATTEMPT_VECTORIZATION))> ()); 
# 360
} 
#endif
# 366 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
__attribute((always_inline)) OutputT ConsumeTiles(OffsetT 
# 367
num_items, GridEvenShare< OffsetT>  &
# 368
even_share, GridQueue< OffsetT>  &
# 369
queue, Int2Type< 0>  
# 370
is_even_share) 
# 371
{int volatile ___ = 1;(void)num_items;(void)even_share;(void)queue;(void)is_even_share;
# 379
::exit(___);}
#if 0
# 371
{ 
# 373
(even_share.BlockInit()); 
# 375
return (IsAligned(d_in, Int2Type< (ATTEMPT_VECTORIZATION)> ())) ? ConsumeRange((even_share.block_offset), (even_share.block_end), Int2Type< (true && (ATTEMPT_VECTORIZATION))> ()) : ConsumeRange((even_share.block_offset), (even_share.block_end), Int2Type< (false && (ATTEMPT_VECTORIZATION))> ()); 
# 379
} 
#endif
# 389 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
template< int CAN_VECTORIZE> 
# 390
__attribute((always_inline)) OutputT ConsumeTiles(int 
# 391
num_items, GridQueue< OffsetT>  
# 392
queue, Int2Type< CAN_VECTORIZE>  
# 393
can_vectorize) 
# 394
{int volatile ___ = 1;(void)num_items;(void)queue;(void)can_vectorize;
# 450
::exit(___);}
#if 0
# 394
{ 
# 396
OutputT thread_aggregate; 
# 397
OffsetT block_offset = (__device_builtin_variable_blockIdx.x) * (TILE_ITEMS); 
# 398
OffsetT even_share_base = (__device_builtin_variable_gridDim.x) * (TILE_ITEMS); 
# 400
if ((block_offset + (TILE_ITEMS)) > num_items) 
# 401
{ 
# 403
int valid_items = num_items - block_offset; 
# 404
ConsumeTile< true> (thread_aggregate, block_offset, valid_items, Int2Type< 0> (), can_vectorize); 
# 405
return (((BlockReduceT)(((temp_storage).reduce))).Reduce(thread_aggregate, reduction_op, valid_items)); 
# 406
}  
# 409
ConsumeTile< true> (thread_aggregate, block_offset, TILE_ITEMS, Int2Type< 1> (), can_vectorize); 
# 411
if (num_items > even_share_base) 
# 412
{ 
# 414
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 415
((temp_storage).dequeue_offset) = ((queue.Drain(TILE_ITEMS)) + even_share_base); }  
# 417
__syncthreads(); 
# 420
block_offset = ((temp_storage).dequeue_offset); 
# 423
while ((block_offset + (TILE_ITEMS)) <= num_items) 
# 424
{ 
# 425
ConsumeTile< false> (thread_aggregate, block_offset, TILE_ITEMS, Int2Type< 1> (), can_vectorize); 
# 427
__syncthreads(); 
# 430
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 431
((temp_storage).dequeue_offset) = ((queue.Drain(TILE_ITEMS)) + even_share_base); }  
# 433
__syncthreads(); 
# 436
block_offset = ((temp_storage).dequeue_offset); 
# 437
}  
# 440
if (block_offset < num_items) 
# 441
{ 
# 442
int valid_items = num_items - block_offset; 
# 443
ConsumeTile< false> (thread_aggregate, block_offset, valid_items, Int2Type< 0> (), can_vectorize); 
# 444
}  
# 445
}  
# 448
return (((BlockReduceT)(((temp_storage).reduce))).Reduce(thread_aggregate, reduction_op)); 
# 450
} 
#endif
# 455 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
__attribute((always_inline)) OutputT ConsumeTiles(OffsetT 
# 456
num_items, GridEvenShare< OffsetT>  &
# 457
even_share, GridQueue< OffsetT>  &
# 458
queue, Int2Type< 1>  
# 459
is_dynamic) 
# 460
{int volatile ___ = 1;(void)num_items;(void)even_share;(void)queue;(void)is_dynamic;
# 464
::exit(___);}
#if 0
# 460
{ 
# 461
return (IsAligned(d_in, Int2Type< (ATTEMPT_VECTORIZATION)> ())) ? ConsumeTiles(num_items, queue, Int2Type< (true && (ATTEMPT_VECTORIZATION))> ()) : ConsumeTiles(num_items, queue, Int2Type< (false && (ATTEMPT_VECTORIZATION))> ()); 
# 464
} 
#endif
# 466 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce.cuh"
}; 
# 469
}
# 54 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
namespace cub { 
# 63
template< class 
# 64
ChainedPolicyT, class 
# 65
InputIteratorT, class 
# 66
OutputIteratorT, class 
# 67
OffsetT, class 
# 68
ReductionOpT> static void 
# 70
__wrapper__device_stub_DeviceReduceKernel(InputIteratorT &
# 71
d_in, OutputIteratorT &
# 72
d_out, OffsetT &
# 73
num_items, GridEvenShare< OffsetT>  &
# 74
even_share, GridQueue< OffsetT>  &
# 75
queue, ReductionOpT &
# 76
reduction_op) {exit(1);}
#if 0
# 77
{ 
# 79
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OuputT; 
# 88
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 91
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 94
OuputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeTiles(num_items, even_share, queue, Int2Type< ChainedPolicyT::ActivePolicy::ReducePolicy::GRID_MAPPING> ())); 
# 101
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 102
(d_out[__device_builtin_variable_blockIdx.x]) = block_aggregate; }  
# 103
} 
#endif
# 63 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 64
ChainedPolicyT, class 
# 65
InputIteratorT, class 
# 66
OutputIteratorT, class 
# 67
OffsetT, class 
# 68
ReductionOpT> void 
# 70
DeviceReduceKernel(InputIteratorT 
# 71
d_in, OutputIteratorT 
# 72
d_out, OffsetT 
# 73
num_items, GridEvenShare< OffsetT>  
# 74
even_share, GridQueue< OffsetT>  
# 75
queue, ReductionOpT 
# 76
reduction_op) 
# 77
{__wrapper__device_stub_DeviceReduceKernel<ChainedPolicyT,InputIteratorT,OutputIteratorT,OffsetT,ReductionOpT>(d_in,d_out,num_items,even_share,queue,reduction_op);
# 103
return;}
#if 0
# 77
{ 
# 79
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OuputT; 
# 88
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 91
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 94
OuputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeTiles(num_items, even_share, queue, Int2Type< ChainedPolicyT::ActivePolicy::ReducePolicy::GRID_MAPPING> ())); 
# 101
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 102
(d_out[__device_builtin_variable_blockIdx.x]) = block_aggregate; }  
# 103
} 
#endif
# 109 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 110
ChainedPolicyT, class 
# 111
InputIteratorT, class 
# 112
OutputIteratorT, class 
# 113
OffsetT, class 
# 114
ReductionOpT, class 
# 115
OuputT> static void 
# 117
__wrapper__device_stub_DeviceReduceSingleTileKernel(InputIteratorT &
# 118
d_in, OutputIteratorT &
# 119
d_out, OffsetT &
# 120
num_items, ReductionOpT &
# 121
reduction_op, OuputT &
# 122
init) {exit(1);}
#if 0
# 123
{ 
# 131
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::SingleTilePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 134
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::SingleTilePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 137
if (num_items == 0) 
# 138
{ 
# 139
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 140
(*d_out) = init; }  
# 141
return; 
# 142
}  
# 145
OuputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeRange((OffsetT)0, num_items)); 
# 150
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 151
(*d_out) = reduction_op(init, block_aggregate); }  
# 152
} 
#endif
# 109 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 110
ChainedPolicyT, class 
# 111
InputIteratorT, class 
# 112
OutputIteratorT, class 
# 113
OffsetT, class 
# 114
ReductionOpT, class 
# 115
OuputT> void 
# 117
DeviceReduceSingleTileKernel(InputIteratorT 
# 118
d_in, OutputIteratorT 
# 119
d_out, OffsetT 
# 120
num_items, ReductionOpT 
# 121
reduction_op, OuputT 
# 122
init) 
# 123
{__wrapper__device_stub_DeviceReduceSingleTileKernel<ChainedPolicyT,InputIteratorT,OutputIteratorT,OffsetT,ReductionOpT,OuputT>(d_in,d_out,num_items,reduction_op,init);
# 152
return;}
#if 0
# 123
{ 
# 131
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::SingleTilePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 134
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::SingleTilePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 137
if (num_items == 0) 
# 138
{ 
# 139
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 140
(*d_out) = init; }  
# 141
return; 
# 142
}  
# 145
OuputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeRange((OffsetT)0, num_items)); 
# 150
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 151
(*d_out) = reduction_op(init, block_aggregate); }  
# 152
} 
#endif
# 156 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class T, class OffsetT, class IteratorT> 
# 157
__attribute((always_inline)) __attribute__((unused)) inline void 
# 158
NormalizeReductionOutput(T &
# 159
val, OffsetT 
# 160
base_offset, IteratorT 
# 161
itr) 
# 162
{int volatile ___ = 1;(void)val;(void)base_offset;(void)itr;::exit(___);}
#if 0
# 162
{ } 
#endif
# 166 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class KeyValuePairT, class OffsetT, class WrappedIteratorT, class OutputValueT> 
# 167
__attribute((always_inline)) __attribute__((unused)) inline void 
# 168
NormalizeReductionOutput(KeyValuePairT &
# 169
val, OffsetT 
# 170
base_offset, ArgIndexInputIterator< WrappedIteratorT, OffsetT, OutputValueT>  
# 171
itr) 
# 172
{int volatile ___ = 1;(void)val;(void)base_offset;(void)itr;
# 174
::exit(___);}
#if 0
# 172
{ 
# 173
(val.key) -= base_offset; 
# 174
} 
#endif
# 180 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 181
ChainedPolicyT, class 
# 182
InputIteratorT, class 
# 183
OutputIteratorT, class 
# 184
OffsetT, class 
# 185
ReductionOpT, class 
# 186
OutputT> static void 
# 188
__wrapper__device_stub_DeviceSegmentedReduceKernel(InputIteratorT &
# 189
d_in, OutputIteratorT &
# 190
d_out, int *&
# 191
d_begin_offsets, int *&
# 192
d_end_offsets, int &
# 193
num_segments, ReductionOpT &
# 194
reduction_op, OutputT &
# 195
init) {exit(1);}
#if 0
# 196
{ 
# 204
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 207
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 209
OffsetT segment_begin = d_begin_offsets[__device_builtin_variable_blockIdx.x]; 
# 210
OffsetT segment_end = d_end_offsets[__device_builtin_variable_blockIdx.x]; 
# 213
if (segment_begin == segment_end) 
# 214
{ 
# 215
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 216
(d_out[__device_builtin_variable_blockIdx.x]) = init; }  
# 217
return; 
# 218
}  
# 221
OutputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeRange(segment_begin, segment_end)); 
# 226
NormalizeReductionOutput(block_aggregate, segment_begin, d_in); 
# 228
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 229
(d_out[__device_builtin_variable_blockIdx.x]) = reduction_op(init, block_aggregate); }  ; 
# 230
} 
#endif
# 180 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 181
ChainedPolicyT, class 
# 182
InputIteratorT, class 
# 183
OutputIteratorT, class 
# 184
OffsetT, class 
# 185
ReductionOpT, class 
# 186
OutputT> void 
# 188
DeviceSegmentedReduceKernel(InputIteratorT 
# 189
d_in, OutputIteratorT 
# 190
d_out, int *
# 191
d_begin_offsets, int *
# 192
d_end_offsets, int 
# 193
num_segments, ReductionOpT 
# 194
reduction_op, OutputT 
# 195
init) 
# 196
{__wrapper__device_stub_DeviceSegmentedReduceKernel<ChainedPolicyT,InputIteratorT,OutputIteratorT,OffsetT,ReductionOpT,OutputT>(d_in,d_out,d_begin_offsets,d_end_offsets,num_segments,reduction_op,init);
# 230
return;}
#if 0
# 196
{ 
# 204
typedef AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT>  AgentReduceT; 
# 207
__attribute__((unused)) static typename AgentReduce< typename ChainedPolicyT::ActivePolicy::ReducePolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::TempStorage temp_storage; 
# 209
OffsetT segment_begin = d_begin_offsets[__device_builtin_variable_blockIdx.x]; 
# 210
OffsetT segment_end = d_end_offsets[__device_builtin_variable_blockIdx.x]; 
# 213
if (segment_begin == segment_end) 
# 214
{ 
# 215
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 216
(d_out[__device_builtin_variable_blockIdx.x]) = init; }  
# 217
return; 
# 218
}  
# 221
OutputT block_aggregate = (AgentReduceT(temp_storage, d_in, reduction_op).ConsumeRange(segment_begin, segment_end)); 
# 226
NormalizeReductionOutput(block_aggregate, segment_begin, d_in); 
# 228
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
# 229
(d_out[__device_builtin_variable_blockIdx.x]) = reduction_op(init, block_aggregate); }  ; 
# 230
} 
#endif
# 239 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh"
template< class 
# 240
OuputT, class 
# 241
OffsetT, class 
# 242
ReductionOpT> 
# 243
struct DeviceReducePolicy { 
# 250
struct Policy130 : public ChainedPolicy< 130, Policy130, Policy130>  { 
# 259
typedef AgentReducePolicy< (((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2), ((((((((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1)) < (8 * 2)) ? (((((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1) : (8 * 2)), 2, BLOCK_REDUCE_RAKING, LOAD_DEFAULT, GRID_MAPPING_EVEN_SHARE>  ReducePolicy; 
# 262
typedef ReducePolicy SingleTilePolicy; 
# 265
typedef ReducePolicy SegmentedReducePolicy; 
# 266
}; 
# 270
struct Policy200 : public ChainedPolicy< 200, Policy200, Policy130>  { 
# 279
typedef AgentReducePolicy< (((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2), ((((((((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1)) < (8 * 2)) ? (((((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((8 * 128) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(OuputT)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(OuputT) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1) : (8 * 2)), 4, BLOCK_REDUCE_RAKING, LOAD_DEFAULT, GRID_MAPPING_DYNAMIC>  ReducePolicy; 
# 282
typedef ReducePolicy SingleTilePolicy; 
# 285
typedef ReducePolicy SegmentedReducePolicy; 
# 286
}; 
# 290
struct Policy300 : public ChainedPolicy< 300, Policy300, Policy200>  { 
# 299
typedef AgentReducePolicy< (((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2), ((((((((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1)) < (20 * 2)) ? (((((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1) : (20 * 2)), 2, BLOCK_REDUCE_WARP_REDUCTIONS, LOAD_DEFAULT, GRID_MAPPING_EVEN_SHARE>  ReducePolicy; 
# 302
typedef ReducePolicy SingleTilePolicy; 
# 305
typedef ReducePolicy SegmentedReducePolicy; 
# 306
}; 
# 310
struct Policy350 : public ChainedPolicy< 350, Policy350, Policy300>  { 
# 319
typedef AgentReducePolicy< (((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2), ((((((((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1)) < (20 * 2)) ? (((((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((20 * 256) * 4) / sizeof(OuputT)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(OuputT)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(OuputT) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1) : (20 * 2)), 4, BLOCK_REDUCE_WARP_REDUCTIONS, LOAD_LDG, GRID_MAPPING_DYNAMIC>  ReducePolicy; 
# 322
typedef ReducePolicy SingleTilePolicy; 
# 325
typedef ReducePolicy SegmentedReducePolicy; 
# 326
}; 
# 330
typedef Policy350 MaxPolicy; 
# 332
}; 
# 343
template< class 
# 344
InputIteratorT, class 
# 345
OutputIteratorT, class 
# 346
OffsetT, class 
# 347
ReductionOpT> 
# 348
struct DispatchReduce : public DeviceReducePolicy< typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT, ReductionOpT>  { 
# 359
typedef typename ::std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 366
void *d_temp_storage; 
# 367
::size_t &temp_storage_bytes; 
# 368
InputIteratorT d_in; 
# 369
OutputIteratorT d_out; 
# 370
OffsetT num_items; 
# 371
ReductionOpT reduction_op; 
# 372
OutputT init; 
# 373
::cudaStream_t stream; 
# 374
bool debug_synchronous; 
# 375
int ptx_version; 
# 382
__attribute((always_inline)) 
# 383
DispatchReduce(void *
# 384
d_temp_storage, ::size_t &
# 385
temp_storage_bytes, InputIteratorT 
# 386
d_in, OutputIteratorT 
# 387
d_out, OffsetT 
# 388
num_items, ReductionOpT 
# 389
reduction_op, OutputT 
# 390
init, ::cudaStream_t 
# 391
stream, bool 
# 392
debug_synchronous, int 
# 393
ptx_version) : d_temp_storage(d_temp_storage), temp_storage_bytes(temp_storage_bytes), d_in(d_in), d_out(d_out), num_items(num_items), reduction_op(reduction_op), init(init), stream(stream), debug_synchronous(debug_synchronous), ptx_version(ptx_version) 
# 405
{ } 
# 413
template< class 
# 414
ActivePolicyT, class 
# 415
SingleTileKernelT> 
# 416
__attribute((always_inline)) ::cudaError_t 
# 417
InvokeSingleTile(SingleTileKernelT 
# 418
single_tile_kernel) 
# 419
{ 
# 425
::cudaError error = cudaSuccess; 
# 426
do 
# 427
{ 
# 429
if ((d_temp_storage) == (__null)) 
# 430
{ 
# 431
(temp_storage_bytes) = (1); 
# 432
break; 
# 433
}  
# 436
if (debug_synchronous) { printf("Invoking DeviceReduceSingleTileKernel<<<1, %d, 0, %lld>>>(), %d items per thread\n", ActivePolicyT::SingleTilePolicy::BLOCK_THREADS, (long long)(stream), ActivePolicyT::SingleTilePolicy::ITEMS_PER_THREAD); }  
# 439
; 
# 442
(::cudaConfigureCall(1, ActivePolicyT::SingleTilePolicy::BLOCK_THREADS, 0, stream)) ? (void)0 : single_tile_kernel(d_in, d_out, num_items, reduction_op, init); 
# 450
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 450)) { break; }  
# 453
if ((debug_synchronous) && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 453))) { break; }  
# 454
} 
# 455
while (0); 
# 457
return error; 
# 460
} 
# 468
template< class 
# 469
ActivePolicyT, class 
# 470
ReduceKernelT, class 
# 471
SingleTileKernelT, class 
# 472
FillAndResetDrainKernelT> 
# 473
__attribute((always_inline)) ::cudaError_t 
# 474
InvokePasses(ReduceKernelT 
# 475
reduce_kernel, SingleTileKernelT 
# 476
single_tile_kernel, FillAndResetDrainKernelT 
# 477
prepare_drain_kernel) 
# 478
{ 
# 485
::cudaError error = cudaSuccess; 
# 486
do 
# 487
{ 
# 489
int device_ordinal; 
# 490
if (cub::Debug(error = cudaGetDevice(&device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 490)) { break; }  
# 493
int sm_count; 
# 494
if (cub::Debug(error = cudaDeviceGetAttribute(&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 494)) { break; }  
# 497
::cub::KernelConfig reduce_config; 
# 498
if (::cub::Debug(error = (reduce_config.template Init< typename ActivePolicyT::ReducePolicy> (reduce_kernel)), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 498)) { break; }  
# 499
int reduce_device_occupancy = (reduce_config.sm_occupancy) * sm_count; 
# 502
int max_blocks = reduce_device_occupancy * (((ptx_version) >= 300) ? 5 : (((ptx_version) >= 200) ? 3 : 10)); 
# 503
GridEvenShare< OffsetT>  even_share(num_items, max_blocks, reduce_config.tile_size); 
# 506
void *allocations[2]; 
# 507
::size_t allocation_sizes[2] = {max_blocks * sizeof(OutputT), GridQueue< int> ::AllocationSize()}; 
# 514
if (cub::Debug(error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 514)) { break; }  
# 515
if ((d_temp_storage) == (__null)) 
# 516
{ 
# 518
return cudaSuccess; 
# 519
}  
# 522
OutputT *d_block_reductions = (OutputT *)((allocations)[0]); 
# 525
GridQueue< OffsetT>  queue((allocations)[1]); 
# 528
int reduce_grid_size; 
# 529
if (ActivePolicyT::ReducePolicy::GRID_MAPPING == GRID_MAPPING_EVEN_SHARE) 
# 530
{ 
# 532
reduce_grid_size = (even_share.grid_size); 
# 533
} else { 
# 534
if (ActivePolicyT::ReducePolicy::GRID_MAPPING == GRID_MAPPING_DYNAMIC) 
# 535
{ 
# 537
int num_tiles = (((num_items) + (reduce_config.tile_size)) - 1) / (reduce_config.tile_size); 
# 538
reduce_grid_size = ((num_tiles < reduce_device_occupancy) ? num_tiles : reduce_device_occupancy); 
# 543
if (debug_synchronous) { printf("Invoking prepare_drain_kernel<<<1, 1, 0, %lld>>>()\n", (long long)(stream)); }  ; 
# 546
(::cudaConfigureCall(1, 1, 0, stream)) ? (void)0 : prepare_drain_kernel(queue, num_items); 
# 549
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 549)) { break; }  
# 552
if ((debug_synchronous) && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 552))) { break; }  
# 553
} else 
# 555
{ 
# 556
error = cub::Debug(cudaErrorNotSupported, "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 556); break; 
# 557
}  }  
# 560
if (debug_synchronous) { printf("Invoking DeviceReduceKernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n", reduce_grid_size, ActivePolicyT::ReducePolicy::BLOCK_THREADS, (long long)(stream), ActivePolicyT::ReducePolicy::ITEMS_PER_THREAD, reduce_config.sm_occupancy); }  
# 565
; 
# 568
(::cudaConfigureCall(reduce_grid_size, ActivePolicyT::ReducePolicy::BLOCK_THREADS, 0, stream)) ? (void)0 : reduce_kernel(d_in, d_block_reductions, num_items, even_share, queue, reduction_op); 
# 577
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 577)) { break; }  
# 580
if ((debug_synchronous) && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 580))) { break; }  
# 583
if (debug_synchronous) { printf("Invoking DeviceReduceSingleTileKernel<<<1, %d, 0, %lld>>>(), %d items per thread\n", ActivePolicyT::SingleTilePolicy::BLOCK_THREADS, (long long)(stream), ActivePolicyT::SingleTilePolicy::ITEMS_PER_THREAD); }  
# 586
; 
# 589
(::cudaConfigureCall(1, ActivePolicyT::SingleTilePolicy::BLOCK_THREADS, 0, stream)) ? (void)0 : single_tile_kernel(d_block_reductions, d_out, reduce_grid_size, reduction_op, init); 
# 597
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 597)) { break; }  
# 600
if ((debug_synchronous) && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 600))) { break; }  
# 601
} 
# 602
while (0); 
# 604
return error; 
# 608
} 
# 616
template< class ActivePolicyT> 
# 617
__attribute((always_inline)) ::cudaError_t 
# 618
Invoke() 
# 619
{ 
# 620
typedef typename ActivePolicyT::SingleTilePolicy SingleTilePolicyT; 
# 621
typedef typename ::cub::DispatchReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy MaxPolicyT; 
# 624
if ((num_items) <= (SingleTilePolicyT::BLOCK_THREADS * SingleTilePolicyT::ITEMS_PER_THREAD)) 
# 625
{ 
# 627
return InvokeSingleTile< ActivePolicyT> (DeviceReduceSingleTileKernel< typename ::cub::DispatchReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT, OutputT> ); 
# 629
} else 
# 631
{ 
# 633
return InvokePasses< ActivePolicyT> (DeviceReduceKernel< typename ::cub::DispatchReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy, InputIteratorT, OutputT *, OffsetT, ReductionOpT> , DeviceReduceSingleTileKernel< typename ::cub::DispatchReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy, OutputT *, OutputIteratorT, OffsetT, ReductionOpT, OutputT> , FillAndResetDrainKernel< OffsetT> ); 
# 637
}  
# 638
} 
# 648
__attribute((always_inline)) static ::cudaError_t 
# 649
Dispatch(void *
# 650
d_temp_storage, ::size_t &
# 651
temp_storage_bytes, InputIteratorT 
# 652
d_in, OutputIteratorT 
# 653
d_out, OffsetT 
# 654
num_items, ReductionOpT 
# 655
reduction_op, OutputT 
# 656
init, ::cudaStream_t 
# 657
stream, bool 
# 658
debug_synchronous) 
# 659
{ 
# 660
typedef typename ::cub::DispatchReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy MaxPolicyT; 
# 662
::cudaError error = cudaSuccess; 
# 663
do 
# 664
{ 
# 666
int ptx_version; 
# 667
if (cub::Debug(error = PtxVersion(ptx_version), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 667)) { break; }  
# 670
DispatchReduce dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, init, stream, debug_synchronous, ptx_version); 
# 676
if (::cub::Debug(error = MaxPolicyT::Invoke(ptx_version, dispatch), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 676)) { break; }  
# 677
} 
# 678
while (0); 
# 680
return error; 
# 681
} 
# 682
}; 
# 693
template< class 
# 694
InputIteratorT, class 
# 695
OutputIteratorT, class 
# 696
OffsetT, class 
# 697
ReductionOpT> 
# 698
struct DispatchSegmentedReduce : public DeviceReducePolicy< typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT, ReductionOpT>  { 
# 709
typedef typename ::std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 716
void *d_temp_storage; 
# 717
::size_t &temp_storage_bytes; 
# 718
InputIteratorT d_in; 
# 719
OutputIteratorT d_out; 
# 720
OffsetT num_segments; 
# 721
OffsetT *d_begin_offsets; 
# 722
OffsetT *d_end_offsets; 
# 723
ReductionOpT reduction_op; 
# 724
OutputT init; 
# 725
::cudaStream_t stream; 
# 726
bool debug_synchronous; 
# 727
int ptx_version; 
# 734
__attribute((always_inline)) 
# 735
DispatchSegmentedReduce(void *
# 736
d_temp_storage, ::size_t &
# 737
temp_storage_bytes, InputIteratorT 
# 738
d_in, OutputIteratorT 
# 739
d_out, OffsetT 
# 740
num_segments, OffsetT *
# 741
d_begin_offsets, OffsetT *
# 742
d_end_offsets, ReductionOpT 
# 743
reduction_op, OutputT 
# 744
init, ::cudaStream_t 
# 745
stream, bool 
# 746
debug_synchronous, int 
# 747
ptx_version) : d_temp_storage(d_temp_storage), temp_storage_bytes(temp_storage_bytes), d_in(d_in), d_out(d_out), num_segments(num_segments), d_begin_offsets(d_begin_offsets), d_end_offsets(d_end_offsets), reduction_op(reduction_op), init(init), stream(stream), debug_synchronous(debug_synchronous), ptx_version(ptx_version) 
# 761
{ } 
# 770
template< class 
# 771
ActivePolicyT, class 
# 772
DeviceSegmentedReduceKernelT> 
# 773
__attribute((always_inline)) ::cudaError_t 
# 774
InvokePasses(DeviceSegmentedReduceKernelT 
# 775
segmented_reduce_kernel) 
# 776
{ 
# 782
::cudaError error = cudaSuccess; 
# 783
do 
# 784
{ 
# 786
if ((d_temp_storage) == (__null)) 
# 787
{ 
# 788
(temp_storage_bytes) = (1); 
# 789
return cudaSuccess; 
# 790
}  
# 793
::cub::KernelConfig segmented_reduce_config; 
# 794
if (::cub::Debug(error = (segmented_reduce_config.template Init< typename ActivePolicyT::SegmentedReducePolicy> (segmented_reduce_kernel)), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 794)) { break; }  
# 797
if (debug_synchronous) { printf("Invoking SegmentedDeviceReduceKernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n", num_segments, ActivePolicyT::SegmentedReducePolicy::BLOCK_THREADS, (long long)(stream), ActivePolicyT::SegmentedReducePolicy::ITEMS_PER_THREAD, segmented_reduce_config.sm_occupancy); }  
# 802
; 
# 805
(::cudaConfigureCall(num_segments, ActivePolicyT::SegmentedReducePolicy::BLOCK_THREADS, 0, stream)) ? (void)0 : segmented_reduce_kernel(d_in, d_out, d_begin_offsets, d_end_offsets, num_segments, reduction_op, init); 
# 815
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 815)) { break; }  
# 818
if ((debug_synchronous) && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 818))) { break; }  
# 819
} 
# 820
while (0); 
# 822
return error; 
# 826
} 
# 830
template< class ActivePolicyT> 
# 831
__attribute((always_inline)) ::cudaError_t 
# 832
Invoke() 
# 833
{ 
# 834
typedef typename ::cub::DispatchSegmentedReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy MaxPolicyT; 
# 837
return InvokePasses< ActivePolicyT> (DeviceSegmentedReduceKernel< typename ::cub::DispatchSegmentedReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT, OutputT> ); 
# 839
} 
# 849
__attribute((always_inline)) static ::cudaError_t 
# 850
Dispatch(void *
# 851
d_temp_storage, ::size_t &
# 852
temp_storage_bytes, InputIteratorT 
# 853
d_in, OutputIteratorT 
# 854
d_out, int 
# 855
num_segments, int *
# 856
d_begin_offsets, int *
# 857
d_end_offsets, ReductionOpT 
# 858
reduction_op, OutputT 
# 859
init, ::cudaStream_t 
# 860
stream, bool 
# 861
debug_synchronous) 
# 862
{ 
# 863
typedef typename ::cub::DispatchSegmentedReduce< InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT> ::MaxPolicy MaxPolicyT; 
# 865
if (num_segments <= 0) { 
# 866
return cudaSuccess; }  
# 868
::cudaError error = cudaSuccess; 
# 869
do 
# 870
{ 
# 872
int ptx_version; 
# 873
if (cub::Debug(error = PtxVersion(ptx_version), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 873)) { break; }  
# 876
DispatchSegmentedReduce dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_segments, d_begin_offsets, d_end_offsets, reduction_op, init, stream, debug_synchronous, ptx_version); 
# 884
if (::cub::Debug(error = MaxPolicyT::Invoke(ptx_version, dispatch), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce.cuh", 884)) { break; }  
# 885
} 
# 886
while (0); 
# 888
return error; 
# 889
} 
# 890
}; 
# 894
}
# 49 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
namespace cub { 
# 62
template< class 
# 63
T, class 
# 64
ScanOpT> 
# 65
struct BlockScanRunningPrefixOp { 
# 67
ScanOpT op; 
# 68
T running_total; 
# 71
__attribute((always_inline)) BlockScanRunningPrefixOp(ScanOpT op) : op(op) 
# 74
{int *volatile ___ = 0;(void)op;::free(___);}
#if 0
# 74
{ } 
#endif
# 77 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) BlockScanRunningPrefixOp(T 
# 78
starting_prefix, ScanOpT 
# 79
op) : op(op), running_total(starting_prefix) 
# 83
{int *volatile ___ = 0;(void)starting_prefix;(void)op;::free(___);}
#if 0
# 83
{ } 
#endif
# 88 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) T operator()(const T &
# 89
block_aggregate) 
# 90
{int volatile ___ = 1;(void)block_aggregate;
# 94
::exit(___);}
#if 0
# 90
{ 
# 91
T retval = running_total; 
# 92
(running_total) = (op)(running_total, block_aggregate); 
# 93
return retval; 
# 94
} 
#endif
# 95 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
}; 
# 105
enum ScanTileStatus { 
# 107
SCAN_TILE_OOB, 
# 108
SCAN_TILE_INVALID = 99, 
# 109
SCAN_TILE_PARTIAL, 
# 110
SCAN_TILE_INCLUSIVE
# 111
}; 
# 117
template< class 
# 118
T, bool 
# 119
SINGLE_WORD = Traits< T> ::PRIMITIVE> struct ScanTileState; 
# 128
template< class T> 
# 129
struct ScanTileState< T, true>  { 
# 138
typedef typename If< sizeof(T) == (8), long long, typename If< sizeof(T) == (4), int, typename If< sizeof(T) == (2), short, char> ::Type> ::Type> ::Type StatusWord; 
# 148
typedef typename If< sizeof(T) == (8), longlong2, typename If< sizeof(T) == (4), int2, typename If< sizeof(T) == (2), int, uchar2> ::Type> ::Type> ::Type TxnWord; 
# 152
struct TileDescriptor { 
# 154
StatusWord status; 
# 155
T value; 
# 156
}; 
# 161
enum { 
# 162
TILE_STATUS_PADDING = 1 << 5
# 163
}; 
# 167
TileDescriptor *d_tile_status; 
# 171
__attribute((always_inline)) 
# 172
ScanTileState() : d_tile_status((__null)) 
# 175
{ } 
# 179
__attribute((always_inline)) cudaError_t 
# 180
Init(int 
# 181
num_tiles, void *
# 182
d_temp_storage, size_t 
# 183
temp_storage_bytes) 
# 184
{ 
# 185
(d_tile_status) = (reinterpret_cast< TileDescriptor *>(d_temp_storage)); 
# 186
return cudaSuccess; 
# 187
} 
# 193
__attribute((always_inline)) static cudaError_t 
# 194
AllocationSize(int 
# 195
num_tiles, size_t &
# 196
temp_storage_bytes) 
# 197
{ 
# 198
temp_storage_bytes = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(TileDescriptor)); 
# 199
return cudaSuccess; 
# 200
} 
# 206
__attribute((always_inline)) void InitializeStatus(int num_tiles) 
# 207
{int volatile ___ = 1;(void)num_tiles;
# 220
::exit(___);}
#if 0
# 207
{ 
# 208
int tile_idx = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
# 209
if (tile_idx < num_tiles) 
# 210
{ 
# 212
(((d_tile_status)[(TILE_STATUS_PADDING) + tile_idx]).status) = ((StatusWord)SCAN_TILE_INVALID); 
# 213
}  
# 215
if (((__device_builtin_variable_blockIdx.x) == (0)) && ((__device_builtin_variable_threadIdx.x) < (TILE_STATUS_PADDING))) 
# 216
{ 
# 218
(((d_tile_status)[__device_builtin_variable_threadIdx.x]).status) = ((StatusWord)SCAN_TILE_OOB); 
# 219
}  
# 220
} 
#endif
# 226 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetInclusive(int tile_idx, T tile_inclusive) 
# 227
{int volatile ___ = 1;(void)tile_idx;(void)tile_inclusive;
# 235
::exit(___);}
#if 0
# 227
{ 
# 228
TileDescriptor tile_descriptor; 
# 229
(tile_descriptor.status) = SCAN_TILE_INCLUSIVE; 
# 230
(tile_descriptor.value) = tile_inclusive; 
# 232
TxnWord alias; 
# 233
(*(reinterpret_cast< TileDescriptor *>(&alias))) = tile_descriptor; 
# 234
ThreadStore< STORE_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx), alias); 
# 235
} 
#endif
# 241 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetPartial(int tile_idx, T tile_partial) 
# 242
{int volatile ___ = 1;(void)tile_idx;(void)tile_partial;
# 250
::exit(___);}
#if 0
# 242
{ 
# 243
TileDescriptor tile_descriptor; 
# 244
(tile_descriptor.status) = SCAN_TILE_PARTIAL; 
# 245
(tile_descriptor.value) = tile_partial; 
# 247
TxnWord alias; 
# 248
(*(reinterpret_cast< TileDescriptor *>(&alias))) = tile_descriptor; 
# 249
ThreadStore< STORE_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx), alias); 
# 250
} 
#endif
# 255 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void WaitForValid(int 
# 256
tile_idx, StatusWord &
# 257
status, T &
# 258
value) 
# 259
{int volatile ___ = 1;(void)tile_idx;(void)status;(void)value;
# 270
::exit(___);}
#if 0
# 259
{ 
# 260
TileDescriptor tile_descriptor; 
# 261
do 
# 262
{ 
# 263
TxnWord alias = ThreadLoad< LOAD_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx)); 
# 264
tile_descriptor = (reinterpret_cast< TileDescriptor &>(alias)); 
# 266
} while (WarpAny((tile_descriptor.status) == SCAN_TILE_INVALID)); 
# 268
status = (tile_descriptor.status); 
# 269
value = (tile_descriptor.value); 
# 270
} 
#endif
# 272 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
}; 
# 280
template< class T> 
# 281
struct ScanTileState< T, false>  { 
# 284
typedef char StatusWord; 
# 288
enum { 
# 289
TILE_STATUS_PADDING = 1 << 5
# 290
}; 
# 293
StatusWord *d_tile_status; 
# 294
T *d_tile_partial; 
# 295
T *d_tile_inclusive; 
# 298
__attribute((always_inline)) 
# 299
ScanTileState() : d_tile_status((__null)), d_tile_partial((__null)), d_tile_inclusive((__null)) 
# 304
{ } 
# 308
__attribute((always_inline)) cudaError_t 
# 309
Init(int 
# 310
num_tiles, void *
# 311
d_temp_storage, size_t 
# 312
temp_storage_bytes) 
# 313
{ 
# 314
cudaError_t error = cudaSuccess; 
# 315
do 
# 316
{ 
# 317
void *allocations[3]; 
# 318
size_t allocation_sizes[3]; 
# 320
((allocation_sizes)[0]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(StatusWord)); 
# 321
((allocation_sizes)[1]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(Uninitialized< T> )); 
# 322
((allocation_sizes)[2]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(Uninitialized< T> )); 
# 325
if (cub::Debug(error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes), "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh", 325)) { break; }  
# 328
(d_tile_status) = (reinterpret_cast< StatusWord *>((allocations)[0])); 
# 329
(d_tile_partial) = (reinterpret_cast< T *>((allocations)[1])); 
# 330
(d_tile_inclusive) = (reinterpret_cast< T *>((allocations)[2])); 
# 331
} 
# 332
while (0); 
# 334
return error; 
# 335
} 
# 341
__attribute((always_inline)) static cudaError_t 
# 342
AllocationSize(int 
# 343
num_tiles, size_t &
# 344
temp_storage_bytes) 
# 345
{ 
# 347
size_t allocation_sizes[3]; 
# 348
((allocation_sizes)[0]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(StatusWord)); 
# 349
((allocation_sizes)[1]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(Uninitialized< T> )); 
# 350
((allocation_sizes)[2]) = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(Uninitialized< T> )); 
# 353
void *allocations[3]; 
# 354
return cub::Debug(AliasTemporaries(__null, temp_storage_bytes, allocations, allocation_sizes), "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh", 354); 
# 355
} 
# 361
__attribute((always_inline)) void InitializeStatus(int num_tiles) 
# 362
{int volatile ___ = 1;(void)num_tiles;
# 375
::exit(___);}
#if 0
# 362
{ 
# 363
int tile_idx = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
# 364
if (tile_idx < num_tiles) 
# 365
{ 
# 367
((d_tile_status)[(TILE_STATUS_PADDING) + tile_idx]) = ((StatusWord)SCAN_TILE_INVALID); 
# 368
}  
# 370
if (((__device_builtin_variable_blockIdx.x) == (0)) && ((__device_builtin_variable_threadIdx.x) < (TILE_STATUS_PADDING))) 
# 371
{ 
# 373
((d_tile_status)[__device_builtin_variable_threadIdx.x]) = ((StatusWord)SCAN_TILE_OOB); 
# 374
}  
# 375
} 
#endif
# 381 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetInclusive(int tile_idx, T tile_inclusive) 
# 382
{int volatile ___ = 1;(void)tile_idx;(void)tile_inclusive;
# 391
::exit(___);}
#if 0
# 382
{ 
# 384
ThreadStore< STORE_CG> (((d_tile_inclusive) + (TILE_STATUS_PADDING)) + tile_idx, tile_inclusive); 
# 387
__threadfence(); 
# 390
ThreadStore< STORE_CG> (((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx, (StatusWord)SCAN_TILE_INCLUSIVE); 
# 391
} 
#endif
# 397 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetPartial(int tile_idx, T tile_partial) 
# 398
{int volatile ___ = 1;(void)tile_idx;(void)tile_partial;
# 407
::exit(___);}
#if 0
# 398
{ 
# 400
ThreadStore< STORE_CG> (((d_tile_partial) + (TILE_STATUS_PADDING)) + tile_idx, tile_partial); 
# 403
__threadfence(); 
# 406
ThreadStore< STORE_CG> (((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx, (StatusWord)SCAN_TILE_PARTIAL); 
# 407
} 
#endif
# 412 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void WaitForValid(int 
# 413
tile_idx, StatusWord &
# 414
status, T &
# 415
value) 
# 416
{int volatile ___ = 1;(void)tile_idx;(void)status;(void)value;
# 428
::exit(___);}
#if 0
# 416
{ 
# 417
do { 
# 418
status = ThreadLoad< LOAD_CG> (((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx); 
# 420
__threadfence(); 
# 422
} while (status == (SCAN_TILE_INVALID)); 
# 424
if (status == ((StatusWord)SCAN_TILE_PARTIAL)) { 
# 425
value = ThreadLoad< LOAD_CG> (((d_tile_partial) + (TILE_STATUS_PADDING)) + tile_idx); } else { 
# 427
value = ThreadLoad< LOAD_CG> (((d_tile_inclusive) + (TILE_STATUS_PADDING)) + tile_idx); }  
# 428
} 
#endif
# 429 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
}; 
# 440
template< class 
# 441
ValueT, class 
# 442
KeyT, bool 
# 443
SINGLE_WORD = Traits< ValueT> ::PRIMITIVE && ((sizeof(ValueT) + sizeof(KeyT)) < (16))> struct ReduceByKeyScanTileState; 
# 451
template< class 
# 452
ValueT, class 
# 453
KeyT> 
# 454
struct ReduceByKeyScanTileState< ValueT, KeyT, false>  : public ScanTileState< KeyValuePair< KeyT, ValueT> >  { 
# 457
typedef ScanTileState< KeyValuePair< KeyT, ValueT> >  SuperClass; 
# 460
__attribute((always_inline)) 
# 461
ReduceByKeyScanTileState() : SuperClass() { } 
# 462
}; 
# 469
template< class 
# 470
ValueT, class 
# 471
KeyT> 
# 472
struct ReduceByKeyScanTileState< ValueT, KeyT, true>  { 
# 474
typedef KeyValuePair< KeyT, ValueT>  KeyValuePairT; 
# 478
enum { 
# 479
PAIR_SIZE = sizeof(ValueT) + sizeof(KeyT), 
# 480
TXN_WORD_SIZE = 1 << Log2< (sizeof(ValueT) + sizeof(KeyT)) + (1)> ::VALUE, 
# 481
STATUS_WORD_SIZE = (1 << Log2< (sizeof(ValueT) + sizeof(KeyT)) + (1)> ::VALUE) - (sizeof(ValueT) + sizeof(KeyT)), 
# 483
TILE_STATUS_PADDING = 1 << 5
# 484
}; 
# 493
typedef typename If< (STATUS_WORD_SIZE) == 8, long long, typename If< (STATUS_WORD_SIZE) == 4, int, typename If< (STATUS_WORD_SIZE) == 2, short, char> ::Type> ::Type> ::Type StatusWord; 
# 500
typedef typename If< (TXN_WORD_SIZE) == 16, longlong2, typename If< (TXN_WORD_SIZE) == 8, long long, int> ::Type> ::Type TxnWord; 
# 503
struct TileDescriptorBigStatus { 
# 505
KeyT key; 
# 506
ValueT value; 
# 507
StatusWord status; 
# 508
}; 
# 511
struct TileDescriptorLittleStatus { 
# 513
ValueT value; 
# 514
StatusWord status; 
# 515
KeyT key; 
# 516
}; 
# 523
typedef typename If< sizeof(ValueT) == sizeof(KeyT), TileDescriptorBigStatus, TileDescriptorLittleStatus> ::Type TileDescriptor; 
# 527
TileDescriptor *d_tile_status; 
# 531
__attribute((always_inline)) 
# 532
ReduceByKeyScanTileState() : d_tile_status((__null)) 
# 535
{ } 
# 539
__attribute((always_inline)) cudaError_t 
# 540
Init(int 
# 541
num_tiles, void *
# 542
d_temp_storage, size_t 
# 543
temp_storage_bytes) 
# 544
{ 
# 545
(d_tile_status) = (reinterpret_cast< TileDescriptor *>(d_temp_storage)); 
# 546
return cudaSuccess; 
# 547
} 
# 553
__attribute((always_inline)) static cudaError_t 
# 554
AllocationSize(int 
# 555
num_tiles, size_t &
# 556
temp_storage_bytes) 
# 557
{ 
# 558
temp_storage_bytes = ((num_tiles + (TILE_STATUS_PADDING)) * sizeof(TileDescriptor)); 
# 559
return cudaSuccess; 
# 560
} 
# 566
__attribute((always_inline)) void InitializeStatus(int num_tiles) 
# 567
{int volatile ___ = 1;(void)num_tiles;
# 580
::exit(___);}
#if 0
# 567
{ 
# 568
int tile_idx = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
# 569
if (tile_idx < num_tiles) 
# 570
{ 
# 572
(((d_tile_status)[(TILE_STATUS_PADDING) + tile_idx]).status) = ((StatusWord)SCAN_TILE_INVALID); 
# 573
}  
# 575
if (((__device_builtin_variable_blockIdx.x) == (0)) && ((__device_builtin_variable_threadIdx.x) < (TILE_STATUS_PADDING))) 
# 576
{ 
# 578
(((d_tile_status)[__device_builtin_variable_threadIdx.x]).status) = ((StatusWord)SCAN_TILE_OOB); 
# 579
}  
# 580
} 
#endif
# 586 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetInclusive(int tile_idx, KeyValuePairT tile_inclusive) 
# 587
{int volatile ___ = 1;(void)tile_idx;(void)tile_inclusive;
# 596
::exit(___);}
#if 0
# 587
{ 
# 588
TileDescriptor tile_descriptor; 
# 589
(tile_descriptor.status) = SCAN_TILE_INCLUSIVE; 
# 590
(tile_descriptor.value) = (tile_inclusive.value); 
# 591
(tile_descriptor.key) = (tile_inclusive.key); 
# 593
TxnWord alias; 
# 594
(*(reinterpret_cast< TileDescriptor *>(&alias))) = tile_descriptor; 
# 595
ThreadStore< STORE_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx), alias); 
# 596
} 
#endif
# 602 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void SetPartial(int tile_idx, KeyValuePairT tile_partial) 
# 603
{int volatile ___ = 1;(void)tile_idx;(void)tile_partial;
# 612
::exit(___);}
#if 0
# 603
{ 
# 604
TileDescriptor tile_descriptor; 
# 605
(tile_descriptor.status) = SCAN_TILE_PARTIAL; 
# 606
(tile_descriptor.value) = (tile_partial.value); 
# 607
(tile_descriptor.key) = (tile_partial.key); 
# 609
TxnWord alias; 
# 610
(*(reinterpret_cast< TileDescriptor *>(&alias))) = tile_descriptor; 
# 611
ThreadStore< STORE_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx), alias); 
# 612
} 
#endif
# 617 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void WaitForValid(int 
# 618
tile_idx, StatusWord &
# 619
status, KeyValuePairT &
# 620
value) 
# 621
{int volatile ___ = 1;(void)tile_idx;(void)status;(void)value;
# 636
::exit(___);}
#if 0
# 621
{ 
# 622
TxnWord alias = ThreadLoad< LOAD_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx)); 
# 623
TileDescriptor tile_descriptor = reinterpret_cast< TileDescriptor &>(alias); 
# 625
while ((tile_descriptor.status) == SCAN_TILE_INVALID) 
# 626
{ 
# 627
__threadfence_block(); 
# 629
alias = ThreadLoad< LOAD_CG> (reinterpret_cast< TxnWord *>(((d_tile_status) + (TILE_STATUS_PADDING)) + tile_idx)); 
# 630
tile_descriptor = (reinterpret_cast< TileDescriptor &>(alias)); 
# 631
}  
# 633
status = (tile_descriptor.status); 
# 634
(value.value) = (tile_descriptor.value); 
# 635
(value.key) = (tile_descriptor.key); 
# 636
} 
#endif
# 638 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
}; 
# 651
template< class 
# 652
T, class 
# 653
ScanOpT, class 
# 654
ScanTileStateT> 
# 655
struct TilePrefixCallbackOp { 
# 658
typedef WarpReduce< T>  WarpReduceT; 
# 661
struct _TempStorage { 
# 663
typename WarpReduce< T> ::TempStorage warp_reduce; 
# 664
T exclusive_prefix; 
# 665
T inclusive_prefix; 
# 666
T block_aggregate; 
# 667
}; 
# 670
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 673
typedef typename ScanTileStateT::StatusWord StatusWord; 
# 676
_TempStorage &temp_storage; 
# 677
ScanTileStateT &tile_status; 
# 678
ScanOpT scan_op; 
# 679
int tile_idx; 
# 680
T exclusive_prefix; 
# 681
T inclusive_prefix; 
# 684
__attribute((always_inline)) 
# 685
TilePrefixCallbackOp(ScanTileStateT &
# 686
tile_status, TempStorage &
# 687
temp_storage, ScanOpT 
# 688
scan_op, int 
# 689
tile_idx) : temp_storage((temp_storage.Alias())), tile_status(tile_status), scan_op(scan_op), tile_idx(tile_idx) 
# 694
{int *volatile ___ = 0;(void)tile_status;(void)temp_storage;(void)scan_op;(void)tile_idx;::free(___);}
#if 0
# 694
{ } 
#endif
# 698 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) void 
# 699
ProcessWindow(int 
# 700
predecessor_idx, StatusWord &
# 701
predecessor_status, T &
# 702
window_aggregate) 
# 703
{int volatile ___ = 1;(void)predecessor_idx;(void)predecessor_status;(void)window_aggregate;
# 715
::exit(___);}
#if 0
# 703
{ 
# 704
T value; 
# 705
((tile_status).WaitForValid(predecessor_idx, predecessor_status, value)); 
# 710
int tail_flag = predecessor_status == ((StatusWord)SCAN_TILE_INCLUSIVE); 
# 711
window_aggregate = (((WarpReduceT)(((temp_storage).warp_reduce))).TailSegmentedReduce(value, tail_flag, ((SwizzleScanOp< ScanOpT> )(scan_op)))); 
# 715
} 
#endif
# 719 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) T 
# 720
operator()(T block_aggregate) 
# 721
{int volatile ___ = 1;(void)block_aggregate;
# 762
::exit(___);}
#if 0
# 721
{ 
# 722
((temp_storage).block_aggregate) = block_aggregate; 
# 725
if ((__device_builtin_variable_threadIdx.x) == (0)) 
# 726
{ 
# 727
((tile_status).SetPartial(tile_idx, block_aggregate)); 
# 728
}  
# 730
int predecessor_idx = ((tile_idx) - (__device_builtin_variable_threadIdx.x)) - (1); 
# 731
StatusWord predecessor_status; 
# 732
T window_aggregate; 
# 735
ProcessWindow(predecessor_idx, predecessor_status, window_aggregate); 
# 738
(exclusive_prefix) = window_aggregate; 
# 741
while (WarpAll(predecessor_status != ((StatusWord)SCAN_TILE_INCLUSIVE))) 
# 742
{ 
# 743
predecessor_idx -= (1 << 5); 
# 746
ProcessWindow(predecessor_idx, predecessor_status, window_aggregate); 
# 747
(exclusive_prefix) = (scan_op)(window_aggregate, exclusive_prefix); 
# 748
}  
# 751
if ((__device_builtin_variable_threadIdx.x) == (0)) 
# 752
{ 
# 753
(inclusive_prefix) = (scan_op)(exclusive_prefix, block_aggregate); 
# 754
((tile_status).SetInclusive(tile_idx, inclusive_prefix)); 
# 756
((temp_storage).exclusive_prefix) = (exclusive_prefix); 
# 757
((temp_storage).inclusive_prefix) = (inclusive_prefix); 
# 758
}  
# 761
return exclusive_prefix; 
# 762
} 
#endif
# 765 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) T 
# 766
GetExclusivePrefix() 
# 767
{int volatile ___ = 1;
# 769
::exit(___);}
#if 0
# 767
{ 
# 768
return (temp_storage).exclusive_prefix; 
# 769
} 
#endif
# 772 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) T 
# 773
GetInclusivePrefix() 
# 774
{int volatile ___ = 1;
# 776
::exit(___);}
#if 0
# 774
{ 
# 775
return (temp_storage).inclusive_prefix; 
# 776
} 
#endif
# 779 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
__attribute((always_inline)) T 
# 780
GetBlockAggregate() 
# 781
{int volatile ___ = 1;
# 783
::exit(___);}
#if 0
# 781
{ 
# 782
return (temp_storage).block_aggregate; 
# 783
} 
#endif
# 785 "/usr/local/cuda/include/cub/device/dispatch/../../agent/single_pass_scan_operators.cuh"
}; 
# 788
}
# 48 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
namespace cub { 
# 70
template< class 
# 71
T, int 
# 72
ITEMS_PER_THREAD, class 
# 73
OutputIteratorT> 
# 74
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectBlocked(int 
# 75
linear_tid, OutputIteratorT 
# 76
block_itr, T (&
# 77
items)[ITEMS_PER_THREAD]) 
# 78
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 85
::exit(___);}
#if 0
# 78
{ 
# 81
#pragma unroll
for (
# 81
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 82
{ 
# 83
(block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM]) = ((items)[ITEM]); 
# 84
}  
# 85
} 
#endif
# 97 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< class 
# 98
T, int 
# 99
ITEMS_PER_THREAD, class 
# 100
OutputIteratorT> 
# 101
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectBlocked(int 
# 102
linear_tid, OutputIteratorT 
# 103
block_itr, T (&
# 104
items)[ITEMS_PER_THREAD], int 
# 105
valid_items) 
# 106
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 116
::exit(___);}
#if 0
# 106
{ 
# 109
#pragma unroll
for (
# 109
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 110
{ 
# 111
if ((ITEM + (linear_tid * ITEMS_PER_THREAD)) < valid_items) 
# 112
{ 
# 113
(block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM]) = ((items)[ITEM]); 
# 114
}  
# 115
}  
# 116
} 
#endif
# 136 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< class 
# 137
T, int 
# 138
ITEMS_PER_THREAD> 
# 139
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectBlockedVectorized(int 
# 140
linear_tid, T *
# 141
block_ptr, T (&
# 142
items)[ITEMS_PER_THREAD]) 
# 143
{int volatile ___ = 1;(void)linear_tid;(void)block_ptr;(void)items;
# 176
::exit(___);}
#if 0
# 143
{ 
# 145
enum { 
# 147
MAX_VEC_SIZE = (ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4, 
# 150
VEC_SIZE = ((((((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4) - 1) & ((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4)) == 0) && ((ITEMS_PER_THREAD % ((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4)) == 0)) ? (ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4 : 1, 
# 154
VECTORS_PER_THREAD = ITEMS_PER_THREAD / (((((((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4) - 1) & ((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4)) == 0) && ((ITEMS_PER_THREAD % ((ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4)) == 0)) ? (ITEMS_PER_THREAD < 4) ? ITEMS_PER_THREAD : 4 : 1)
# 155
}; 
# 158
typedef typename CubVector< T, VEC_SIZE> ::Type Vector; 
# 161
Vector *block_ptr_vectors = reinterpret_cast< Vector *>(const_cast< T *>(block_ptr)); 
# 164
Vector raw_vector[VECTORS_PER_THREAD]; 
# 165
T *raw_items = reinterpret_cast< T *>(raw_vector); 
# 169
#pragma unroll
for (
# 169
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 170
{ 
# 171
(raw_items[ITEM]) = ((items)[ITEM]); 
# 172
}  
# 175
StoreDirectBlocked(linear_tid, block_ptr_vectors, raw_vector); 
# 176
} 
#endif
# 197 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< int 
# 198
BLOCK_THREADS, class 
# 199
T, int 
# 200
ITEMS_PER_THREAD, class 
# 201
OutputIteratorT> 
# 202
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectStriped(int 
# 203
linear_tid, OutputIteratorT 
# 204
block_itr, T (&
# 205
items)[ITEMS_PER_THREAD]) 
# 206
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 213
::exit(___);}
#if 0
# 206
{ 
# 209
#pragma unroll
for (
# 209
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 210
{ 
# 211
(block_itr[(ITEM * BLOCK_THREADS) + linear_tid]) = ((items)[ITEM]); 
# 212
}  
# 213
} 
#endif
# 226 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< int 
# 227
BLOCK_THREADS, class 
# 228
T, int 
# 229
ITEMS_PER_THREAD, class 
# 230
OutputIteratorT> 
# 231
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectStriped(int 
# 232
linear_tid, OutputIteratorT 
# 233
block_itr, T (&
# 234
items)[ITEMS_PER_THREAD], int 
# 235
valid_items) 
# 236
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 246
::exit(___);}
#if 0
# 236
{ 
# 239
#pragma unroll
for (
# 239
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 240
{ 
# 241
if (((ITEM * BLOCK_THREADS) + linear_tid) < valid_items) 
# 242
{ 
# 243
(block_itr[(ITEM * BLOCK_THREADS) + linear_tid]) = ((items)[ITEM]); 
# 244
}  
# 245
}  
# 246
} 
#endif
# 269 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< class 
# 270
T, int 
# 271
ITEMS_PER_THREAD, class 
# 272
OutputIteratorT> 
# 273
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectWarpStriped(int 
# 274
linear_tid, OutputIteratorT 
# 275
block_itr, T (&
# 276
items)[ITEMS_PER_THREAD]) 
# 277
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;
# 288
::exit(___);}
#if 0
# 277
{ 
# 278
int tid = linear_tid & ((1 << 5) - 1); 
# 279
int wid = linear_tid >> 5; 
# 280
int warp_offset = (wid * (1 << 5)) * ITEMS_PER_THREAD; 
# 284
#pragma unroll
for (
# 284
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 285
{ 
# 286
(block_itr[(warp_offset + tid) + (ITEM * (1 << 5))]) = ((items)[ITEM]); 
# 287
}  
# 288
} 
#endif
# 303 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< class 
# 304
T, int 
# 305
ITEMS_PER_THREAD, class 
# 306
OutputIteratorT> 
# 307
__attribute((always_inline)) __attribute__((unused)) inline void StoreDirectWarpStriped(int 
# 308
linear_tid, OutputIteratorT 
# 309
block_itr, T (&
# 310
items)[ITEMS_PER_THREAD], int 
# 311
valid_items) 
# 312
{int volatile ___ = 1;(void)linear_tid;(void)block_itr;(void)items;(void)valid_items;
# 326
::exit(___);}
#if 0
# 312
{ 
# 313
int tid = linear_tid & ((1 << 5) - 1); 
# 314
int wid = linear_tid >> 5; 
# 315
int warp_offset = (wid * (1 << 5)) * ITEMS_PER_THREAD; 
# 319
#pragma unroll
for (
# 319
int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++) 
# 320
{ 
# 321
if (((warp_offset + tid) + (ITEM * (1 << 5))) < valid_items) 
# 322
{ 
# 323
(block_itr[(warp_offset + tid) + (ITEM * (1 << 5))]) = ((items)[ITEM]); 
# 324
}  
# 325
}  
# 326
} 
#endif
# 342 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
enum BlockStoreAlgorithm { 
# 354
BLOCK_STORE_DIRECT, 
# 374
BLOCK_STORE_VECTORIZE, 
# 387
BLOCK_STORE_TRANSPOSE, 
# 404
BLOCK_STORE_WARP_TRANSPOSE, 
# 423
BLOCK_STORE_WARP_TRANSPOSE_TIMESLICED
# 425
}; 
# 495
template< class 
# 496
OutputIteratorT, int 
# 497
BLOCK_DIM_X, int 
# 498
ITEMS_PER_THREAD, BlockStoreAlgorithm 
# 499
ALGORITHM = BLOCK_STORE_DIRECT, int 
# 500
BLOCK_DIM_Y = 1, int 
# 501
BLOCK_DIM_Z = 1, int 
# 502
PTX_ARCH = 0> 
# 503
class BlockStore { 
# 512
enum { 
# 514
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 515
}; 
# 518
typedef typename std::iterator_traits< OutputIteratorT> ::value_type T; 
# 526
template< BlockStoreAlgorithm _POLICY, int DUMMY> struct StoreInternal; 
# 533
template< int DUMMY> 
# 534
struct StoreInternal< BLOCK_STORE_DIRECT, DUMMY>  { 
# 537
typedef NullType TempStorage; 
# 540
unsigned linear_tid; 
# 543
__attribute((always_inline)) StoreInternal(TempStorage &
# 544
temp_storage, unsigned 
# 545
linear_tid) : linear_tid(linear_tid) 
# 548
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 548
{ } 
#endif
# 551 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 552
block_itr, T (&
# 553
items)[ITEMS_PER_THREAD]) 
# 554
{int volatile ___ = 1;(void)block_itr;(void)items;
# 556
::exit(___);}
#if 0
# 554
{ 
# 555
StoreDirectBlocked(linear_tid, block_itr, items); 
# 556
} 
#endif
# 559 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 560
block_itr, T (&
# 561
items)[ITEMS_PER_THREAD], int 
# 562
valid_items) 
# 563
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 565
::exit(___);}
#if 0
# 563
{ 
# 564
StoreDirectBlocked(linear_tid, block_itr, items, valid_items); 
# 565
} 
#endif
# 566 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 572
template< int DUMMY> 
# 573
struct StoreInternal< BLOCK_STORE_VECTORIZE, DUMMY>  { 
# 576
typedef NullType TempStorage; 
# 579
unsigned linear_tid; 
# 582
__attribute((always_inline)) StoreInternal(TempStorage &
# 583
temp_storage, unsigned 
# 584
linear_tid) : linear_tid(linear_tid) 
# 587
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 587
{ } 
#endif
# 590 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(T *
# 591
block_ptr, T (&
# 592
items)[ITEMS_PER_THREAD]) 
# 593
{int volatile ___ = 1;(void)block_ptr;(void)items;
# 595
::exit(___);}
#if 0
# 593
{ 
# 594
StoreDirectBlockedVectorized(linear_tid, block_ptr, items); 
# 595
} 
#endif
# 598 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
template< class _OutputIteratorT> 
# 599
__attribute((always_inline)) void Store(_OutputIteratorT 
# 600
block_itr, T (&
# 601
items)[ITEMS_PER_THREAD]) 
# 602
{int volatile ___ = 1;(void)block_itr;(void)items;
# 604
::exit(___);}
#if 0
# 602
{ 
# 603
StoreDirectBlocked(linear_tid, block_itr, items); 
# 604
} 
#endif
# 607 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 608
block_itr, T (&
# 609
items)[ITEMS_PER_THREAD], int 
# 610
valid_items) 
# 611
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 613
::exit(___);}
#if 0
# 611
{ 
# 612
StoreDirectBlocked(linear_tid, block_itr, items, valid_items); 
# 613
} 
#endif
# 614 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 620
template< int DUMMY> 
# 621
struct StoreInternal< BLOCK_STORE_TRANSPOSE, DUMMY>  { 
# 624
typedef cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 627
typedef typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 630
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 633
_TempStorage &temp_storage; 
# 636
unsigned linear_tid; 
# 639
__attribute((always_inline)) StoreInternal(TempStorage &
# 640
temp_storage, unsigned 
# 641
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 645
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 645
{ } 
#endif
# 648 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 649
block_itr, T (&
# 650
items)[ITEMS_PER_THREAD]) 
# 651
{int volatile ___ = 1;(void)block_itr;(void)items;
# 654
::exit(___);}
#if 0
# 651
{ 
# 652
(((BlockExchange)(temp_storage)).BlockedToStriped(items)); 
# 653
StoreDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, items); 
# 654
} 
#endif
# 657 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 658
block_itr, T (&
# 659
items)[ITEMS_PER_THREAD], int 
# 660
valid_items) 
# 661
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 664
::exit(___);}
#if 0
# 661
{ 
# 662
(((BlockExchange)(temp_storage)).BlockedToStriped(items)); 
# 663
StoreDirectStriped< BLOCK_THREADS> (linear_tid, block_itr, items, valid_items); 
# 664
} 
#endif
# 665 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 671
template< int DUMMY> 
# 672
struct StoreInternal< BLOCK_STORE_WARP_TRANSPOSE, DUMMY>  { 
# 675
enum { 
# 676
WARP_THREADS = 1 << 5
# 677
}; 
# 680
typedef int cub_static_assert680[(((BLOCK_THREADS) % (WARP_THREADS)) == 0) ? 1 : (-1)]; 
# 683
typedef cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 686
typedef typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 689
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, false, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 692
_TempStorage &temp_storage; 
# 695
unsigned linear_tid; 
# 698
__attribute((always_inline)) StoreInternal(TempStorage &
# 699
temp_storage, unsigned 
# 700
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 704
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 704
{ } 
#endif
# 707 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 708
block_itr, T (&
# 709
items)[ITEMS_PER_THREAD]) 
# 710
{int volatile ___ = 1;(void)block_itr;(void)items;
# 713
::exit(___);}
#if 0
# 710
{ 
# 711
(((BlockExchange)(temp_storage)).BlockedToWarpStriped(items)); 
# 712
StoreDirectWarpStriped(linear_tid, block_itr, items); 
# 713
} 
#endif
# 716 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 717
block_itr, T (&
# 718
items)[ITEMS_PER_THREAD], int 
# 719
valid_items) 
# 720
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 723
::exit(___);}
#if 0
# 720
{ 
# 721
(((BlockExchange)(temp_storage)).BlockedToWarpStriped(items)); 
# 722
StoreDirectWarpStriped(linear_tid, block_itr, items, valid_items); 
# 723
} 
#endif
# 724 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 730
template< int DUMMY> 
# 731
struct StoreInternal< BLOCK_STORE_WARP_TRANSPOSE_TIMESLICED, DUMMY>  { 
# 734
enum { 
# 735
WARP_THREADS = 1 << 5
# 736
}; 
# 739
typedef int cub_static_assert739[(((BLOCK_THREADS) % (WARP_THREADS)) == 0) ? 1 : (-1)]; 
# 742
typedef cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  BlockExchange; 
# 745
typedef typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage _TempStorage; 
# 748
struct TempStorage : public Uninitialized< typename cub::BlockExchange< typename std::iterator_traits< OutputIteratorT> ::value_type, BLOCK_DIM_X, ITEMS_PER_THREAD, true, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> ::TempStorage>  { }; 
# 751
_TempStorage &temp_storage; 
# 754
unsigned linear_tid; 
# 757
__attribute((always_inline)) StoreInternal(TempStorage &
# 758
temp_storage, unsigned 
# 759
linear_tid) : temp_storage((temp_storage.Alias())), linear_tid(linear_tid) 
# 763
{int *volatile ___ = 0;(void)temp_storage;(void)linear_tid;::free(___);}
#if 0
# 763
{ } 
#endif
# 766 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 767
block_itr, T (&
# 768
items)[ITEMS_PER_THREAD]) 
# 769
{int volatile ___ = 1;(void)block_itr;(void)items;
# 772
::exit(___);}
#if 0
# 769
{ 
# 770
(((BlockExchange)(temp_storage)).BlockedToWarpStriped(items)); 
# 771
StoreDirectWarpStriped(linear_tid, block_itr, items); 
# 772
} 
#endif
# 775 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 776
block_itr, T (&
# 777
items)[ITEMS_PER_THREAD], int 
# 778
valid_items) 
# 779
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 782
::exit(___);}
#if 0
# 779
{ 
# 780
(((BlockExchange)(temp_storage)).BlockedToWarpStriped(items)); 
# 781
StoreDirectWarpStriped(linear_tid, block_itr, items, valid_items); 
# 782
} 
#endif
# 783 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 790
typedef StoreInternal< ALGORITHM, 0>  InternalStore; 
# 794
typedef typename StoreInternal< ALGORITHM, 0> ::TempStorage _TempStorage; 
# 802
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 803
{int volatile ___ = 1;
# 806
::exit(___);}
#if 0
# 803
{ 
# 804
__attribute__((unused)) static _TempStorage private_storage; 
# 805
return private_storage; 
# 806
} 
#endif
# 814 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
_TempStorage &temp_storage; 
# 817
unsigned linear_tid; 
# 823
public: struct TempStorage : public Uninitialized< typename StoreInternal< ALGORITHM, 0> ::TempStorage>  { }; 
# 834
__attribute((always_inline)) BlockStore() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 838
{int *volatile ___ = 0;::free(___);}
#if 0
# 838
{ } 
#endif
# 844 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) BlockStore(TempStorage &
# 845
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 849
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 849
{ } 
#endif
# 899 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 900
block_itr, T (&
# 901
items)[ITEMS_PER_THREAD]) 
# 902
{int volatile ___ = 1;(void)block_itr;(void)items;
# 904
::exit(___);}
#if 0
# 902
{ 
# 903
(InternalStore(temp_storage, linear_tid).Store(block_itr, items)); 
# 904
} 
#endif
# 947 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
__attribute((always_inline)) void Store(OutputIteratorT 
# 948
block_itr, T (&
# 949
items)[ITEMS_PER_THREAD], int 
# 950
valid_items) 
# 951
{int volatile ___ = 1;(void)block_itr;(void)items;(void)valid_items;
# 953
::exit(___);}
#if 0
# 951
{ 
# 952
(InternalStore(temp_storage, linear_tid).Store(block_itr, items, valid_items)); 
# 953
} 
#endif
# 954 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_store.cuh"
}; 
# 957
}
# 43 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
namespace cub { 
# 55
template< int 
# 56
LENGTH, class 
# 57
T, class 
# 58
ScanOp> 
# 59
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanExclusive(T 
# 60
inclusive, T 
# 61
exclusive, T *
# 62
input, T *
# 63
output, ScanOp 
# 64
scan_op, Int2Type< LENGTH>  
# 65
length) 
# 66
{int volatile ___ = 1;(void)inclusive;(void)exclusive;(void)input;(void)output;(void)scan_op;(void)length;
# 73
::exit(___);}
#if 0
# 66
{ 
# 67
T addend = *input; 
# 68
inclusive = scan_op(exclusive, addend); 
# 69
(*output) = exclusive; 
# 70
exclusive = inclusive; 
# 72
return ThreadScanExclusive(inclusive, exclusive, input + 1, output + 1, scan_op, Int2Type< LENGTH - 1> ()); 
# 73
} 
#endif
# 75 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< class 
# 76
T, class 
# 77
ScanOp> 
# 78
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanExclusive(T 
# 79
inclusive, T 
# 80
exclusive, T *
# 81
input, T *
# 82
output, ScanOp 
# 83
scan_op, Int2Type< 0>  
# 84
length) 
# 85
{int volatile ___ = 1;(void)inclusive;(void)exclusive;(void)input;(void)output;(void)scan_op;(void)length;
# 87
::exit(___);}
#if 0
# 85
{ 
# 86
return inclusive; 
# 87
} 
#endif
# 97 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 98
LENGTH, class 
# 99
T, class 
# 100
ScanOp> 
# 101
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanExclusive(T *
# 102
input, T *
# 103
output, ScanOp 
# 104
scan_op, T 
# 105
prefix, bool 
# 106
apply_prefix = true) 
# 107
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)prefix;(void)apply_prefix;
# 117
::exit(___);}
#if 0
# 107
{ 
# 108
T inclusive = input[0]; 
# 109
if (apply_prefix) 
# 110
{ 
# 111
inclusive = scan_op(prefix, inclusive); 
# 112
}  
# 113
(output[0]) = prefix; 
# 114
T exclusive = inclusive; 
# 116
return ThreadScanExclusive(inclusive, exclusive, input + 1, output + 1, scan_op, Int2Type< LENGTH - 1> ()); 
# 117
} 
#endif
# 127 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 128
LENGTH, class 
# 129
T, class 
# 130
ScanOp> 
# 131
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanExclusive(T (&
# 132
input)[LENGTH], T (&
# 133
output)[LENGTH], ScanOp 
# 134
scan_op, T 
# 135
prefix, bool 
# 136
apply_prefix = true) 
# 137
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)prefix;(void)apply_prefix;
# 139
::exit(___);}
#if 0
# 137
{ 
# 138
return ThreadScanExclusive< LENGTH> ((T *)(input), (T *)(output), scan_op, prefix, apply_prefix); 
# 139
} 
#endif
# 149 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 150
LENGTH, class 
# 151
T, class 
# 152
ScanOp> 
# 153
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T 
# 154
inclusive, T *
# 155
input, T *
# 156
output, ScanOp 
# 157
scan_op, Int2Type< LENGTH>  
# 158
length) 
# 159
{int volatile ___ = 1;(void)inclusive;(void)input;(void)output;(void)scan_op;(void)length;
# 165
::exit(___);}
#if 0
# 159
{ 
# 160
T addend = *input; 
# 161
inclusive = scan_op(inclusive, addend); 
# 162
(output[0]) = inclusive; 
# 164
return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type< LENGTH - 1> ()); 
# 165
} 
#endif
# 167 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< class 
# 168
T, class 
# 169
ScanOp> 
# 170
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T 
# 171
inclusive, T *
# 172
input, T *
# 173
output, ScanOp 
# 174
scan_op, Int2Type< 0>  
# 175
length) 
# 176
{int volatile ___ = 1;(void)inclusive;(void)input;(void)output;(void)scan_op;(void)length;
# 178
::exit(___);}
#if 0
# 176
{ 
# 177
return inclusive; 
# 178
} 
#endif
# 188 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 189
LENGTH, class 
# 190
T, class 
# 191
ScanOp> 
# 192
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T *
# 193
input, T *
# 194
output, ScanOp 
# 195
scan_op) 
# 196
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 202
::exit(___);}
#if 0
# 196
{ 
# 197
T inclusive = input[0]; 
# 198
(output[0]) = inclusive; 
# 201
return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type< LENGTH - 1> ()); 
# 202
} 
#endif
# 212 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 213
LENGTH, class 
# 214
T, class 
# 215
ScanOp> 
# 216
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T (&
# 217
input)[LENGTH], T (&
# 218
output)[LENGTH], ScanOp 
# 219
scan_op) 
# 220
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 222
::exit(___);}
#if 0
# 220
{ 
# 221
return ThreadScanInclusive< LENGTH> ((T *)(input), (T *)(output), scan_op); 
# 222
} 
#endif
# 232 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 233
LENGTH, class 
# 234
T, class 
# 235
ScanOp> 
# 236
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T *
# 237
input, T *
# 238
output, ScanOp 
# 239
scan_op, T 
# 240
prefix, bool 
# 241
apply_prefix = true) 
# 242
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)prefix;(void)apply_prefix;
# 252
::exit(___);}
#if 0
# 242
{ 
# 243
T inclusive = input[0]; 
# 244
if (apply_prefix) 
# 245
{ 
# 246
inclusive = scan_op(prefix, inclusive); 
# 247
}  
# 248
(output[0]) = inclusive; 
# 251
return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op, Int2Type< LENGTH - 1> ()); 
# 252
} 
#endif
# 262 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
template< int 
# 263
LENGTH, class 
# 264
T, class 
# 265
ScanOp> 
# 266
__attribute((always_inline)) __attribute__((unused)) inline T ThreadScanInclusive(T (&
# 267
input)[LENGTH], T (&
# 268
output)[LENGTH], ScanOp 
# 269
scan_op, T 
# 270
prefix, bool 
# 271
apply_prefix = true) 
# 272
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)prefix;(void)apply_prefix;
# 274
::exit(___);}
#if 0
# 272
{ 
# 273
return ThreadScanInclusive< LENGTH> ((T *)(input), (T *)(output), scan_op, prefix, apply_prefix); 
# 274
} 
#endif
# 282 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../thread/thread_scan.cuh"
}
# 45 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
namespace cub { 
# 50
template< class 
# 51
T, int 
# 52
LOGICAL_WARP_THREADS, int 
# 53
PTX_ARCH> 
# 54
struct WarpScanShfl { 
# 61
enum { 
# 63
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 66
STEPS = Log2< LOGICAL_WARP_THREADS> ::VALUE, 
# 69
SHFL_C = (((-1) << (Log2< LOGICAL_WARP_THREADS> ::VALUE)) & 31) << 8
# 70
}; 
# 72
template< class S> 
# 73
struct IntegerTraits { 
# 75
enum { 
# 77
IS_SMALL_UNSIGNED = (Traits< S> ::CATEGORY == UNSIGNED_INTEGER) && (sizeof(S) <= sizeof(unsigned))
# 78
}; 
# 79
}; 
# 82
struct TempStorage { }; 
# 89
unsigned lane_id; 
# 96
__attribute((always_inline)) WarpScanShfl(TempStorage &
# 97
temp_storage) : lane_id((IS_ARCH_WARP) ? LaneId() : (LaneId() % (LOGICAL_WARP_THREADS))) 
# 102
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 102
{ } 
#endif
# 110 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) int InclusiveScanStep(int 
# 111
input, Sum 
# 112
scan_op, int 
# 113
first_lane, int 
# 114
offset) 
# 115
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 131
::exit(___);}
#if 0
# 115
{ 
# 116
int output; 
# 117
int shfl_c = first_lane | (SHFL_C); 
# 120
__asm__ volatile("{  .reg .s32 r0;  .reg .pred p;  shfl.up.b32 r0|p, %1, %2, %3;  @p add.s32 r0, r0, %4;  mov.s32 %0, r0;}" : "=r" (output) : "r" (input), "r" (offset), "r" (shfl_c), "r" (input)); 
# 130
return output; 
# 131
} 
#endif
# 134 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) unsigned InclusiveScanStep(unsigned 
# 135
input, Sum 
# 136
scan_op, int 
# 137
first_lane, int 
# 138
offset) 
# 139
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 155
::exit(___);}
#if 0
# 139
{ 
# 140
unsigned output; 
# 141
int shfl_c = first_lane | (SHFL_C); 
# 144
__asm__ volatile("{  .reg .u32 r0;  .reg .pred p;  shfl.up.b32 r0|p, %1, %2, %3;  @p add.u32 r0, r0, %4;  mov.u32 %0, r0;}" : "=r" (output) : "r" (input), "r" (offset), "r" (shfl_c), "r" (input)); 
# 154
return output; 
# 155
} 
#endif
# 159 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) float InclusiveScanStep(float 
# 160
input, Sum 
# 161
scan_op, int 
# 162
first_lane, int 
# 163
offset) 
# 164
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 180
::exit(___);}
#if 0
# 164
{ 
# 165
float output; 
# 166
int shfl_c = first_lane | (SHFL_C); 
# 169
__asm__ volatile("{  .reg .f32 r0;  .reg .pred p;  shfl.up.b32 r0|p, %1, %2, %3;  @p add.f32 r0, r0, %4;  mov.f32 %0, r0;}" : "=f" (output) : "f" (input), "r" (offset), "r" (shfl_c), "f" (input)); 
# 179
return output; 
# 180
} 
#endif
# 184 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) unsigned long long InclusiveScanStep(unsigned long long 
# 185
input, Sum 
# 186
scan_op, int 
# 187
first_lane, int 
# 188
offset) 
# 189
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 210
::exit(___);}
#if 0
# 189
{ 
# 190
unsigned long long output; 
# 191
int shfl_c = first_lane | (SHFL_C); 
# 194
__asm__ volatile("{  .reg .u64 r0;  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  mov.b64 {lo, hi}, %1;  shfl.up.b32 lo|p, lo, %2, %3;  shfl.up.b32" " hi|p, hi, %2, %3;  mov.b64 r0, {lo, hi};  @p add.u64 r0, r0, %4;  mov.u64 %0, r0;}" : "=l" (output) : "l" (input), "r" (offset), "r" (shfl_c), "l" (input)); 
# 209
return output; 
# 210
} 
#endif
# 214 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) long long InclusiveScanStep(long long 
# 215
input, Sum 
# 216
scan_op, int 
# 217
first_lane, int 
# 218
offset) 
# 219
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 240
::exit(___);}
#if 0
# 219
{ 
# 220
long long output; 
# 221
int shfl_c = first_lane | (SHFL_C); 
# 224
__asm__ volatile("{  .reg .s64 r0;  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  mov.b64 {lo, hi}, %1;  shfl.up.b32 lo|p, lo, %2, %3;  shfl.up.b32" " hi|p, hi, %2, %3;  mov.b64 r0, {lo, hi};  @p add.s64 r0, r0, %4;  mov.s64 %0, r0;}" : "=l" (output) : "l" (input), "r" (offset), "r" (shfl_c), "l" (input)); 
# 239
return output; 
# 240
} 
#endif
# 244 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) double InclusiveScanStep(double 
# 245
input, Sum 
# 246
scan_op, int 
# 247
first_lane, int 
# 248
offset) 
# 249
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 270
::exit(___);}
#if 0
# 249
{ 
# 250
double output; 
# 251
int shfl_c = first_lane | (SHFL_C); 
# 254
__asm__ volatile("{  .reg .u32 lo;  .reg .u32 hi;  .reg .pred p;  .reg .f64 r0;  mov.b64 %0, %1;  mov.b64 {lo, hi}, %1;  shfl.up.b32 lo|p, lo, %2," " %3;  shfl.up.b32 hi|p, hi, %2, %3;  mov.b64 r0, {lo, hi};  @p add.f64 %0, %0, r0;}" : "=d" (output) : "d" (input), "r" (offset), "r" (shfl_c)); 
# 269
return output; 
# 270
} 
#endif
# 295 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOpT> 
# 296
__attribute((always_inline)) _T InclusiveScanStep(_T 
# 297
input, ScanOpT 
# 298
scan_op, int 
# 299
first_lane, int 
# 300
offset) 
# 301
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;
# 310
::exit(___);}
#if 0
# 301
{ 
# 302
_T temp = ShuffleUp(input, offset, first_lane); 
# 305
_T output = scan_op(temp, input); 
# 306
if ((lane_id) < (first_lane + offset)) { 
# 307
output = input; }  
# 309
return output; 
# 310
} 
#endif
# 314 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOpT> 
# 315
__attribute((always_inline)) _T InclusiveScanStep(_T 
# 316
input, ScanOpT 
# 317
scan_op, int 
# 318
first_lane, int 
# 319
offset, Int2Type< 1>  
# 320
is_small_unsigned) 
# 321
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;(void)is_small_unsigned;
# 327
::exit(___);}
#if 0
# 321
{ 
# 322
unsigned temp = reinterpret_cast< unsigned &>(input); 
# 324
temp = InclusiveScanStep(temp, scan_op, first_lane, offset); 
# 326
return reinterpret_cast< _T &>(temp); 
# 327
} 
#endif
# 331 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOpT> 
# 332
__attribute((always_inline)) _T InclusiveScanStep(_T 
# 333
input, ScanOpT 
# 334
scan_op, int 
# 335
first_lane, int 
# 336
offset, Int2Type< 0>  
# 337
is_small_unsigned) 
# 338
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)offset;(void)is_small_unsigned;
# 340
::exit(___);}
#if 0
# 338
{ 
# 339
return InclusiveScanStep(input, scan_op, first_lane, offset); 
# 340
} 
#endif
# 346 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOp, int STEP> 
# 347
__attribute((always_inline)) void InclusiveScanStep(_T &
# 348
input, ScanOp 
# 349
scan_op, int 
# 350
first_lane, Int2Type< STEP>  
# 351
step) 
# 352
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)step;
# 356
::exit(___);}
#if 0
# 352
{ 
# 353
input = InclusiveScanStep(input, scan_op, first_lane, 1 << STEP, Int2Type< IntegerTraits< T> ::IS_SMALL_UNSIGNED> ()); 
# 355
InclusiveScanStep(input, scan_op, first_lane, Int2Type< STEP + 1> ()); 
# 356
} 
#endif
# 358 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOp> 
# 359
__attribute((always_inline)) void InclusiveScanStep(_T &
# 360
input, ScanOp 
# 361
scan_op, int 
# 362
first_lane, Int2Type< STEPS>  
# 363
step) 
# 364
{int volatile ___ = 1;(void)input;(void)scan_op;(void)first_lane;(void)step;::exit(___);}
#if 0
# 364
{ } 
#endif
# 376 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) T Broadcast(T 
# 377
input, int 
# 378
src_lane) 
# 379
{int volatile ___ = 1;(void)input;(void)src_lane;
# 381
::exit(___);}
#if 0
# 379
{ 
# 380
return ShuffleIndex(input, src_lane, LOGICAL_WARP_THREADS); 
# 381
} 
#endif
# 389 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class _T, class ScanOpT> 
# 390
__attribute((always_inline)) void InclusiveScan(_T 
# 391
input, _T &
# 392
inclusive_output, ScanOpT 
# 393
scan_op) 
# 394
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;
# 415
::exit(___);}
#if 0
# 394
{ 
# 395
inclusive_output = input; 
# 398
int segment_first_lane = 0; 
# 405
#pragma unroll
for (
# 405
int STEP = 0; STEP < (STEPS); STEP++) 
# 406
{ 
# 407
inclusive_output = InclusiveScanStep(inclusive_output, scan_op, segment_first_lane, 1 << STEP, Int2Type< IntegerTraits< T> ::IS_SMALL_UNSIGNED> ()); 
# 413
}  
# 415
} 
#endif
# 418 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class KeyT, class ValueT, class ReductionOpT> 
# 419
__attribute((always_inline)) void InclusiveScan(KeyValuePair< KeyT, ValueT>  
# 420
input, KeyValuePair< KeyT, ValueT>  &
# 421
inclusive_output, ReduceByKeyOp< ReductionOpT>  
# 422
scan_op) 
# 423
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;
# 450
::exit(___);}
#if 0
# 423
{ 
# 424
inclusive_output = input; 
# 426
KeyT pred_key = ShuffleUp((inclusive_output.key), 1); 
# 428
unsigned ballot = __ballot(pred_key != (inclusive_output.key)); 
# 431
ballot = (ballot & LaneMaskLe()); 
# 434
int segment_first_lane = ((31 - __clz(ballot)) > 0) ? 31 - __clz(ballot) : 0; 
# 441
#pragma unroll
for (
# 441
int STEP = 0; STEP < (STEPS); STEP++) 
# 442
{ 
# 443
(inclusive_output.value) = InclusiveScanStep((inclusive_output.value), (scan_op.op), segment_first_lane, 1 << STEP, Int2Type< IntegerTraits< T> ::IS_SMALL_UNSIGNED> ()); 
# 449
}  
# 450
} 
#endif
# 454 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class ScanOpT> 
# 455
__attribute((always_inline)) void InclusiveScan(T 
# 456
input, T &
# 457
inclusive_output, ScanOpT 
# 458
scan_op, T &
# 459
warp_aggregate) 
# 460
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;(void)warp_aggregate;
# 465
::exit(___);}
#if 0
# 460
{ 
# 461
InclusiveScan(input, inclusive_output, scan_op); 
# 464
warp_aggregate = ShuffleIndex(inclusive_output, LOGICAL_WARP_THREADS - 1, LOGICAL_WARP_THREADS); 
# 465
} 
#endif
# 473 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class ScanOpT, class IsIntegerT> 
# 474
__attribute((always_inline)) void Update(T 
# 475
input, T &
# 476
inclusive, T &
# 477
exclusive, ScanOpT 
# 478
scan_op, IsIntegerT 
# 479
is_integer) 
# 480
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)is_integer;
# 483
::exit(___);}
#if 0
# 480
{ 
# 482
exclusive = ShuffleUp(inclusive, 1); 
# 483
} 
#endif
# 486 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) void Update(T 
# 487
input, T &
# 488
inclusive, T &
# 489
exclusive, Sum 
# 490
scan_op, Int2Type< 1>  
# 491
is_integer) 
# 492
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)is_integer;
# 495
::exit(___);}
#if 0
# 492
{ 
# 494
exclusive = (inclusive - input); 
# 495
} 
#endif
# 498 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class ScanOpT, class IsIntegerT> 
# 499
__attribute((always_inline)) void Update(T 
# 500
input, T &
# 501
inclusive, T &
# 502
exclusive, ScanOpT 
# 503
scan_op, T 
# 504
initial_value, IsIntegerT 
# 505
is_integer) 
# 506
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)initial_value;(void)is_integer;
# 511
::exit(___);}
#if 0
# 506
{ 
# 507
inclusive = scan_op(initial_value, inclusive); 
# 508
exclusive = ShuffleUp(inclusive, 1); 
# 509
if ((lane_id) == (0)) { 
# 510
exclusive = initial_value; }  
# 511
} 
#endif
# 514 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
__attribute((always_inline)) void Update(T 
# 515
input, T &
# 516
inclusive, T &
# 517
exclusive, Sum 
# 518
scan_op, T 
# 519
initial_value, Int2Type< 1>  
# 520
is_integer) 
# 521
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)initial_value;(void)is_integer;
# 524
::exit(___);}
#if 0
# 521
{ 
# 522
inclusive = scan_op(initial_value, inclusive); 
# 523
exclusive = (inclusive - input); 
# 524
} 
#endif
# 528 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class ScanOpT, class IsIntegerT> 
# 529
__attribute((always_inline)) void Update(T 
# 530
input, T &
# 531
inclusive, T &
# 532
exclusive, T &
# 533
warp_aggregate, ScanOpT 
# 534
scan_op, IsIntegerT 
# 535
is_integer) 
# 536
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)warp_aggregate;(void)scan_op;(void)is_integer;
# 539
::exit(___);}
#if 0
# 536
{ 
# 537
warp_aggregate = ShuffleIndex(inclusive, LOGICAL_WARP_THREADS - 1, LOGICAL_WARP_THREADS); 
# 538
Update(input, inclusive, exclusive, scan_op, is_integer); 
# 539
} 
#endif
# 542 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
template< class ScanOpT, class IsIntegerT> 
# 543
__attribute((always_inline)) void Update(T 
# 544
input, T &
# 545
inclusive, T &
# 546
exclusive, T &
# 547
warp_aggregate, ScanOpT 
# 548
scan_op, T 
# 549
initial_value, IsIntegerT 
# 550
is_integer) 
# 551
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)warp_aggregate;(void)scan_op;(void)initial_value;(void)is_integer;
# 554
::exit(___);}
#if 0
# 551
{ 
# 552
warp_aggregate = ShuffleIndex(inclusive, LOGICAL_WARP_THREADS - 1, LOGICAL_WARP_THREADS); 
# 553
Update(input, inclusive, exclusive, scan_op, initial_value, is_integer); 
# 554
} 
#endif
# 558 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_shfl.cuh"
}; 
# 561
}
# 46 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
namespace cub { 
# 51
template< class 
# 52
T, int 
# 53
LOGICAL_WARP_THREADS, int 
# 54
PTX_ARCH> 
# 55
struct WarpScanSmem { 
# 62
enum { 
# 64
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 67
STEPS = Log2< LOGICAL_WARP_THREADS> ::VALUE, 
# 70
HALF_WARP_THREADS = 1 << ((Log2< LOGICAL_WARP_THREADS> ::VALUE) - 1), 
# 73
WARP_SMEM_ELEMENTS = LOGICAL_WARP_THREADS + (1 << ((Log2< LOGICAL_WARP_THREADS> ::VALUE) - 1))
# 74
}; 
# 77
typedef typename If< (Equals< T, char> ::VALUE || Equals< T, signed char> ::VALUE) && (PTX_ARCH < 200), int, T> ::Type CellT; 
# 80
typedef CellT _TempStorage[WARP_SMEM_ELEMENTS]; 
# 83
struct TempStorage : public Uninitialized< typename If< (Equals< T, char> ::VALUE || Equals< T, signed char> ::VALUE) && (PTX_ARCH < 200), int, T> ::Type [WARP_SMEM_ELEMENTS]>  { }; 
# 90
_TempStorage &temp_storage; 
# 91
unsigned lane_id; 
# 99
__attribute((always_inline)) WarpScanSmem(TempStorage &
# 100
temp_storage) : temp_storage((temp_storage.Alias())), lane_id((IS_ARCH_WARP) ? LaneId() : (LaneId() % (LOGICAL_WARP_THREADS))) 
# 106
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 106
{ } 
#endif
# 114 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< bool 
# 115
HAS_IDENTITY, int 
# 116
STEP, class 
# 117
ScanOp> 
# 118
__attribute((always_inline)) void ScanStep(T &
# 119
partial, ScanOp 
# 120
scan_op, Int2Type< STEP>  
# 121
step) 
# 122
{int volatile ___ = 1;(void)partial;(void)scan_op;(void)step;
# 136
::exit(___);}
#if 0
# 122
{ 
# 123
const int OFFSET = (1 << STEP); 
# 126
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)partial); 
# 129
if (HAS_IDENTITY || ((lane_id) >= OFFSET)) 
# 130
{ 
# 131
T addend = (T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - OFFSET])); 
# 132
partial = scan_op(addend, partial); 
# 133
}  
# 135
ScanStep< HAS_IDENTITY> (partial, scan_op, Int2Type< STEP + 1> ()); 
# 136
} 
#endif
# 140 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< bool 
# 141
HAS_IDENTITY, class 
# 142
ScanOp> 
# 143
__attribute((always_inline)) void ScanStep(T &
# 144
partial, ScanOp 
# 145
scan_op, Int2Type< STEPS>  
# 146
step) 
# 147
{int volatile ___ = 1;(void)partial;(void)scan_op;(void)step;::exit(___);}
#if 0
# 147
{ } 
#endif
# 151 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
__attribute((always_inline)) void InclusiveScan(T 
# 152
input, T &
# 153
output, Sum 
# 154
scan_op, Int2Type< 1>  
# 155
is_primitive) 
# 156
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)is_primitive;
# 163
::exit(___);}
#if 0
# 156
{ 
# 157
T identity = (0); 
# 158
ThreadStore< STORE_VOLATILE> (&((temp_storage)[lane_id]), (CellT)identity); 
# 161
output = input; 
# 162
ScanStep< true> (output, scan_op, Int2Type< 0> ()); 
# 163
} 
#endif
# 167 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOp, int IS_PRIMITIVE> 
# 168
__attribute((always_inline)) void InclusiveScan(T 
# 169
input, T &
# 170
output, ScanOp 
# 171
scan_op, Int2Type< IS_PRIMITIVE>  
# 172
is_primitive) 
# 173
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)is_primitive;
# 177
::exit(___);}
#if 0
# 173
{ 
# 175
output = input; 
# 176
ScanStep< false> (output, scan_op, Int2Type< 0> ()); 
# 177
} 
#endif
# 189 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
__attribute((always_inline)) T Broadcast(T 
# 190
input, unsigned 
# 191
src_lane) 
# 192
{int volatile ___ = 1;(void)input;(void)src_lane;
# 199
::exit(___);}
#if 0
# 192
{ 
# 193
if ((lane_id) == src_lane) 
# 194
{ 
# 195
ThreadStore< STORE_VOLATILE> (temp_storage, (CellT)input); 
# 196
}  
# 198
return (T)ThreadLoad< LOAD_VOLATILE> (temp_storage); 
# 199
} 
#endif
# 207 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOp> 
# 208
__attribute((always_inline)) void InclusiveScan(T 
# 209
input, T &
# 210
inclusive_output, ScanOp 
# 211
scan_op) 
# 212
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;
# 214
::exit(___);}
#if 0
# 212
{ 
# 213
InclusiveScan(input, inclusive_output, scan_op, Int2Type< Traits< T> ::PRIMITIVE> ()); 
# 214
} 
#endif
# 218 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOp> 
# 219
__attribute((always_inline)) void InclusiveScan(T 
# 220
input, T &
# 221
inclusive_output, ScanOp 
# 222
scan_op, T &
# 223
warp_aggregate) 
# 224
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;(void)warp_aggregate;
# 230
::exit(___);}
#if 0
# 224
{ 
# 225
InclusiveScan(input, inclusive_output, scan_op); 
# 228
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive_output); 
# 229
warp_aggregate = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[(WARP_SMEM_ELEMENTS) - 1]))); 
# 230
} 
#endif
# 238 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOpT, class IsIntegerT> 
# 239
__attribute((always_inline)) void Update(T 
# 240
input, T &
# 241
inclusive, T &
# 242
exclusive, ScanOpT 
# 243
scan_op, IsIntegerT 
# 244
is_integer) 
# 245
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)is_integer;
# 249
::exit(___);}
#if 0
# 245
{ 
# 247
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive); 
# 248
exclusive = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - 1]))); 
# 249
} 
#endif
# 252 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
__attribute((always_inline)) void Update(T 
# 253
input, T &
# 254
inclusive, T &
# 255
exclusive, Sum 
# 256
scan_op, Int2Type< 1>  
# 257
is_integer) 
# 258
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)is_integer;
# 261
::exit(___);}
#if 0
# 258
{ 
# 260
exclusive = (inclusive - input); 
# 261
} 
#endif
# 264 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOpT, class IsIntegerT> 
# 265
__attribute((always_inline)) void Update(T 
# 266
input, T &
# 267
inclusive, T &
# 268
exclusive, ScanOpT 
# 269
scan_op, T 
# 270
initial_value, IsIntegerT 
# 271
is_integer) 
# 272
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)initial_value;(void)is_integer;
# 278
::exit(___);}
#if 0
# 272
{ 
# 273
inclusive = scan_op(initial_value, inclusive); 
# 274
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive); 
# 275
exclusive = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - 1]))); 
# 276
if ((lane_id) == (0)) { 
# 277
exclusive = initial_value; }  
# 278
} 
#endif
# 281 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
__attribute((always_inline)) void Update(T 
# 282
input, T &
# 283
inclusive, T &
# 284
exclusive, Sum 
# 285
scan_op, T 
# 286
initial_value, Int2Type< 1>  
# 287
is_integer) 
# 288
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)scan_op;(void)initial_value;(void)is_integer;
# 291
::exit(___);}
#if 0
# 288
{ 
# 289
inclusive = scan_op(initial_value, inclusive); 
# 290
exclusive = (inclusive - input); 
# 291
} 
#endif
# 295 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOpT, class IsIntegerT> 
# 296
__attribute((always_inline)) void Update(T 
# 297
input, T &
# 298
inclusive, T &
# 299
exclusive, T &
# 300
warp_aggregate, ScanOpT 
# 301
scan_op, IsIntegerT 
# 302
is_integer) 
# 303
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)warp_aggregate;(void)scan_op;(void)is_integer;
# 308
::exit(___);}
#if 0
# 303
{ 
# 305
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive); 
# 306
exclusive = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - 1]))); 
# 307
warp_aggregate = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[(WARP_SMEM_ELEMENTS) - 1]))); 
# 308
} 
#endif
# 311 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
__attribute((always_inline)) void Update(T 
# 312
input, T &
# 313
inclusive, T &
# 314
exclusive, T &
# 315
warp_aggregate, Sum 
# 316
scan_op, Int2Type< 1>  
# 317
is_integer) 
# 318
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)warp_aggregate;(void)scan_op;(void)is_integer;
# 323
::exit(___);}
#if 0
# 318
{ 
# 320
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive); 
# 321
warp_aggregate = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[(WARP_SMEM_ELEMENTS) - 1]))); 
# 322
exclusive = (inclusive - input); 
# 323
} 
#endif
# 326 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
template< class ScanOpT, class IsIntegerT> 
# 327
__attribute((always_inline)) void Update(T 
# 328
input, T &
# 329
inclusive, T &
# 330
exclusive, T &
# 331
warp_aggregate, ScanOpT 
# 332
scan_op, T 
# 333
initial_value, IsIntegerT 
# 334
is_integer) 
# 335
{int volatile ___ = 1;(void)input;(void)inclusive;(void)exclusive;(void)warp_aggregate;(void)scan_op;(void)initial_value;(void)is_integer;
# 349
::exit(___);}
#if 0
# 335
{ 
# 337
ThreadStore< STORE_VOLATILE> (&((temp_storage)[(HALF_WARP_THREADS) + (lane_id)]), (CellT)inclusive); 
# 338
warp_aggregate = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[(WARP_SMEM_ELEMENTS) - 1]))); 
# 341
inclusive = scan_op(initial_value, inclusive); 
# 344
ThreadStore< STORE_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - 1]), (CellT)inclusive); 
# 345
exclusive = ((T)ThreadLoad< LOAD_VOLATILE> (&((temp_storage)[((HALF_WARP_THREADS) + (lane_id)) - 2]))); 
# 347
if ((lane_id) == (0)) { 
# 348
exclusive = initial_value; }  
# 349
} 
#endif
# 352 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/specializations/warp_scan_smem.cuh"
}; 
# 355
}
# 47 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
namespace cub { 
# 142
template< class 
# 143
T, int 
# 144
LOGICAL_WARP_THREADS = 32, int 
# 145
PTX_ARCH = 0> 
# 146
class WarpScan { 
# 155
enum { 
# 157
IS_ARCH_WARP = LOGICAL_WARP_THREADS == (1 << 5), 
# 160
IS_POW_OF_TWO = (LOGICAL_WARP_THREADS & (LOGICAL_WARP_THREADS - 1)) == 0, 
# 163
IS_INTEGER = (Traits< T> ::CATEGORY == SIGNED_INTEGER) || (Traits< T> ::CATEGORY == UNSIGNED_INTEGER)
# 164
}; 
# 169
typedef typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpScanShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpScanSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type InternalWarpScan; 
# 172
typedef typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpScanShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpScanSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type::TempStorage _TempStorage; 
# 180
_TempStorage &temp_storage; 
# 181
unsigned lane_id; 
# 192
public: struct TempStorage : public Uninitialized< typename If< (PTX_ARCH >= 300) && (IS_POW_OF_TWO), WarpScanShfl< T, LOGICAL_WARP_THREADS, PTX_ARCH> , WarpScanSmem< T, LOGICAL_WARP_THREADS, PTX_ARCH> > ::Type::TempStorage>  { }; 
# 203
__attribute((always_inline)) WarpScan(TempStorage &
# 204
temp_storage) : temp_storage((temp_storage.Alias())), lane_id((IS_ARCH_WARP) ? LaneId() : (LaneId() % (LOGICAL_WARP_THREADS))) 
# 210
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 210
{ } 
#endif
# 254 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
__attribute((always_inline)) void InclusiveSum(T 
# 255
input, T &
# 256
inclusive_output) 
# 257
{int volatile ___ = 1;(void)input;(void)inclusive_output;
# 259
::exit(___);}
#if 0
# 257
{ 
# 258
InclusiveScan(input, inclusive_output, Sum()); 
# 259
} 
#endif
# 297 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
__attribute((always_inline)) void InclusiveSum(T 
# 298
input, T &
# 299
inclusive_output, T &
# 300
warp_aggregate) 
# 301
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)warp_aggregate;
# 303
::exit(___);}
#if 0
# 301
{ 
# 302
InclusiveScan(input, inclusive_output, Sum(), warp_aggregate); 
# 303
} 
#endif
# 349 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
__attribute((always_inline)) void ExclusiveSum(T 
# 350
input, T &
# 351
exclusive_output) 
# 352
{int volatile ___ = 1;(void)input;(void)exclusive_output;
# 355
::exit(___);}
#if 0
# 352
{ 
# 353
T initial_value = (0); 
# 354
ExclusiveScan(input, exclusive_output, initial_value, Sum()); 
# 355
} 
#endif
# 394 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
__attribute((always_inline)) void ExclusiveSum(T 
# 395
input, T &
# 396
exclusive_output, T &
# 397
warp_aggregate) 
# 398
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)warp_aggregate;
# 401
::exit(___);}
#if 0
# 398
{ 
# 399
T initial_value = (0); 
# 400
ExclusiveScan(input, exclusive_output, initial_value, Sum(), warp_aggregate); 
# 401
} 
#endif
# 446 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 447
__attribute((always_inline)) void InclusiveScan(T 
# 448
input, T &
# 449
inclusive_output, ScanOp 
# 450
scan_op) 
# 451
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;
# 453
::exit(___);}
#if 0
# 451
{ 
# 452
(((InternalWarpScan)(temp_storage)).InclusiveScan(input, inclusive_output, scan_op)); 
# 453
} 
#endif
# 496 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 497
__attribute((always_inline)) void InclusiveScan(T 
# 498
input, T &
# 499
inclusive_output, ScanOp 
# 500
scan_op, T &
# 501
warp_aggregate) 
# 502
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;(void)warp_aggregate;
# 504
::exit(___);}
#if 0
# 502
{ 
# 503
(((InternalWarpScan)(temp_storage)).InclusiveScan(input, inclusive_output, scan_op, warp_aggregate)); 
# 504
} 
#endif
# 550 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 551
__attribute((always_inline)) void ExclusiveScan(T 
# 552
input, T &
# 553
exclusive_output, ScanOp 
# 554
scan_op) 
# 555
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;
# 567
::exit(___);}
#if 0
# 555
{ 
# 556
InternalWarpScan internal(temp_storage); 
# 558
T inclusive_output; 
# 559
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 561
(internal.Update(input, inclusive_output, exclusive_output, scan_op, Int2Type< IS_INTEGER> ())); 
# 567
} 
#endif
# 606 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 607
__attribute((always_inline)) void ExclusiveScan(T 
# 608
input, T &
# 609
exclusive_output, T 
# 610
initial_value, ScanOp 
# 611
scan_op) 
# 612
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)initial_value;(void)scan_op;
# 625
::exit(___);}
#if 0
# 612
{ 
# 613
InternalWarpScan internal(temp_storage); 
# 615
T inclusive_output; 
# 616
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 618
(internal.Update(input, inclusive_output, exclusive_output, scan_op, initial_value, Int2Type< IS_INTEGER> ())); 
# 625
} 
#endif
# 667 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 668
__attribute((always_inline)) void ExclusiveScan(T 
# 669
input, T &
# 670
exclusive_output, ScanOp 
# 671
scan_op, T &
# 672
warp_aggregate) 
# 673
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;(void)warp_aggregate;
# 686
::exit(___);}
#if 0
# 673
{ 
# 674
InternalWarpScan internal(temp_storage); 
# 676
T inclusive_output; 
# 677
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 679
(internal.Update(input, inclusive_output, exclusive_output, warp_aggregate, scan_op, Int2Type< IS_INTEGER> ())); 
# 686
} 
#endif
# 728 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 729
__attribute((always_inline)) void ExclusiveScan(T 
# 730
input, T &
# 731
exclusive_output, T 
# 732
initial_value, ScanOp 
# 733
scan_op, T &
# 734
warp_aggregate) 
# 735
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)initial_value;(void)scan_op;(void)warp_aggregate;
# 749
::exit(___);}
#if 0
# 735
{ 
# 736
InternalWarpScan internal(temp_storage); 
# 738
T inclusive_output; 
# 739
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 741
(internal.Update(input, inclusive_output, exclusive_output, warp_aggregate, scan_op, initial_value, Int2Type< IS_INTEGER> ())); 
# 749
} 
#endif
# 798 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 799
__attribute((always_inline)) void Scan(T 
# 800
input, T &
# 801
inclusive_output, T &
# 802
exclusive_output, ScanOp 
# 803
scan_op) 
# 804
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)exclusive_output;(void)scan_op;
# 815
::exit(___);}
#if 0
# 804
{ 
# 805
InternalWarpScan internal(temp_storage); 
# 807
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 809
(internal.Update(input, inclusive_output, exclusive_output, scan_op, Int2Type< IS_INTEGER> ())); 
# 815
} 
#endif
# 857 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
template< class ScanOp> 
# 858
__attribute((always_inline)) void Scan(T 
# 859
input, T &
# 860
inclusive_output, T &
# 861
exclusive_output, T 
# 862
initial_value, ScanOp 
# 863
scan_op) 
# 864
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)exclusive_output;(void)initial_value;(void)scan_op;
# 876
::exit(___);}
#if 0
# 864
{ 
# 865
InternalWarpScan internal(temp_storage); 
# 867
(internal.InclusiveScan(input, inclusive_output, scan_op)); 
# 869
(internal.Update(input, inclusive_output, exclusive_output, scan_op, initial_value, Int2Type< IS_INTEGER> ())); 
# 876
} 
#endif
# 922 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
__attribute((always_inline)) T Broadcast(T 
# 923
input, unsigned 
# 924
src_lane) 
# 925
{int volatile ___ = 1;(void)input;(void)src_lane;
# 927
::exit(___);}
#if 0
# 925
{ 
# 926
return (((InternalWarpScan)(temp_storage)).Broadcast(input, src_lane)); 
# 927
} 
#endif
# 931 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/../../warp/warp_scan.cuh"
}; 
# 935
}
# 49 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
namespace cub { 
# 55
template< class 
# 56
T, int 
# 57
BLOCK_DIM_X, int 
# 58
BLOCK_DIM_Y, int 
# 59
BLOCK_DIM_Z, bool 
# 60
MEMOIZE, int 
# 61
PTX_ARCH> 
# 62
struct BlockScanRaking { 
# 70
enum { 
# 72
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 73
}; 
# 76
typedef cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH>  BlockRakingLayout; 
# 80
enum { 
# 82
RAKING_THREADS = cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::RAKING_THREADS, 
# 85
SEGMENT_LENGTH = cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::SEGMENT_LENGTH, 
# 88
WARP_SYNCHRONOUS = ((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) == (cub::BlockRakingLayout< T, (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, PTX_ARCH> ::RAKING_THREADS)
# 89
}; 
# 92
typedef cub::WarpScan< T, RAKING_THREADS, PTX_ARCH>  WarpScan; 
# 95
struct _TempStorage { 
# 97
typename cub::WarpScan< T, RAKING_THREADS, PTX_ARCH> ::TempStorage warp_scan; 
# 98
typename cub::BlockRakingLayout< T, BLOCK_THREADS, PTX_ARCH> ::TempStorage raking_grid; 
# 99
T block_aggregate; 
# 100
}; 
# 104
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 112
_TempStorage &temp_storage; 
# 113
unsigned linear_tid; 
# 114
T cached_segment[SEGMENT_LENGTH]; 
# 122
template< int ITERATION, class ScanOp> 
# 123
__attribute((always_inline)) T GuardedReduce(T *
# 124
raking_ptr, ScanOp 
# 125
scan_op, T 
# 126
raking_partial, Int2Type< ITERATION>  
# 127
iteration) 
# 128
{int volatile ___ = 1;(void)raking_ptr;(void)scan_op;(void)raking_partial;(void)iteration;
# 136
::exit(___);}
#if 0
# 128
{ 
# 129
if (BlockRakingLayout::UNGUARDED || ((((linear_tid) * (SEGMENT_LENGTH)) + ITERATION) < (BLOCK_THREADS))) 
# 130
{ 
# 131
T addend = raking_ptr[ITERATION]; 
# 132
raking_partial = scan_op(raking_partial, addend); 
# 133
}  
# 135
return GuardedReduce(raking_ptr, scan_op, raking_partial, Int2Type< ITERATION + 1> ()); 
# 136
} 
#endif
# 140 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 141
__attribute((always_inline)) T GuardedReduce(T *
# 142
raking_ptr, ScanOp 
# 143
scan_op, T 
# 144
raking_partial, Int2Type< SEGMENT_LENGTH>  
# 145
iteration) 
# 146
{int volatile ___ = 1;(void)raking_ptr;(void)scan_op;(void)raking_partial;(void)iteration;
# 148
::exit(___);}
#if 0
# 146
{ 
# 147
return raking_partial; 
# 148
} 
#endif
# 152 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< int ITERATION> 
# 153
__attribute((always_inline)) void CopySegment(T *
# 154
out, T *
# 155
in, Int2Type< ITERATION>  
# 156
iteration) 
# 157
{int volatile ___ = 1;(void)out;(void)in;(void)iteration;
# 160
::exit(___);}
#if 0
# 157
{ 
# 158
(out[ITERATION]) = (in[ITERATION]); 
# 159
CopySegment(out, in, Int2Type< ITERATION + 1> ()); 
# 160
} 
#endif
# 164 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
__attribute((always_inline)) void CopySegment(T *
# 165
out, T *
# 166
in, Int2Type< SEGMENT_LENGTH>  
# 167
iteration) 
# 168
{int volatile ___ = 1;(void)out;(void)in;(void)iteration;::exit(___);}
#if 0
# 168
{ } 
#endif
# 172 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 173
__attribute((always_inline)) T Upsweep(ScanOp 
# 174
scan_op) 
# 175
{int volatile ___ = 1;(void)scan_op;
# 184
::exit(___);}
#if 0
# 175
{ 
# 176
T *smem_raking_ptr = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 179
CopySegment(cached_segment, smem_raking_ptr, Int2Type< 0> ()); 
# 181
T raking_partial = (cached_segment)[0]; 
# 183
return GuardedReduce(cached_segment, scan_op, raking_partial, Int2Type< 1> ()); 
# 184
} 
#endif
# 188 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 189
__attribute((always_inline)) void ExclusiveDownsweep(ScanOp 
# 190
scan_op, T 
# 191
raking_partial, bool 
# 192
apply_prefix = true) 
# 193
{int volatile ___ = 1;(void)scan_op;(void)raking_partial;(void)apply_prefix;
# 206
::exit(___);}
#if 0
# 193
{ 
# 194
T *smem_raking_ptr = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 197
if (!MEMOIZE) 
# 198
{ 
# 199
CopySegment(cached_segment, smem_raking_ptr, Int2Type< 0> ()); 
# 200
}  
# 202
ThreadScanExclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix); 
# 205
CopySegment(smem_raking_ptr, cached_segment, Int2Type< 0> ()); 
# 206
} 
#endif
# 210 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 211
__attribute((always_inline)) void InclusiveDownsweep(ScanOp 
# 212
scan_op, T 
# 213
raking_partial, bool 
# 214
apply_prefix = true) 
# 215
{int volatile ___ = 1;(void)scan_op;(void)raking_partial;(void)apply_prefix;
# 228
::exit(___);}
#if 0
# 215
{ 
# 216
T *smem_raking_ptr = BlockRakingLayout::RakingPtr(((temp_storage).raking_grid), linear_tid); 
# 219
if (!MEMOIZE) 
# 220
{ 
# 221
CopySegment(cached_segment, smem_raking_ptr, Int2Type< 0> ()); 
# 222
}  
# 224
ThreadScanInclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix); 
# 227
CopySegment(smem_raking_ptr, cached_segment, Int2Type< 0> ()); 
# 228
} 
#endif
# 236 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
__attribute((always_inline)) BlockScanRaking(TempStorage &
# 237
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 241
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 241
{ } 
#endif
# 249 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 250
__attribute((always_inline)) void ExclusiveScan(T 
# 251
input, T &
# 252
exclusive_output, ScanOp 
# 253
scan_op) 
# 254
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;
# 287
::exit(___);}
#if 0
# 254
{ 
# 255
if (WARP_SYNCHRONOUS) 
# 256
{ 
# 258
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(input, exclusive_output, scan_op)); 
# 259
} else 
# 261
{ 
# 263
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 264
(*placement_ptr) = input; 
# 266
__syncthreads(); 
# 269
if ((linear_tid) < (RAKING_THREADS)) 
# 270
{ 
# 272
T upsweep_partial = Upsweep(scan_op); 
# 275
T exclusive_partial; 
# 276
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(upsweep_partial, exclusive_partial, scan_op)); 
# 279
ExclusiveDownsweep(scan_op, exclusive_partial, (linear_tid) != (0)); 
# 280
}  
# 282
__syncthreads(); 
# 285
exclusive_output = (*placement_ptr); 
# 286
}  
# 287
} 
#endif
# 290 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 291
__attribute((always_inline)) void ExclusiveScan(T 
# 292
input, T &
# 293
output, const T &
# 294
initial_value, ScanOp 
# 295
scan_op) 
# 296
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;
# 329
::exit(___);}
#if 0
# 296
{ 
# 297
if (WARP_SYNCHRONOUS) 
# 298
{ 
# 300
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(input, output, initial_value, scan_op)); 
# 301
} else 
# 303
{ 
# 305
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 306
(*placement_ptr) = input; 
# 308
__syncthreads(); 
# 311
if ((linear_tid) < (RAKING_THREADS)) 
# 312
{ 
# 314
T upsweep_partial = Upsweep(scan_op); 
# 317
T exclusive_partial; 
# 318
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(upsweep_partial, exclusive_partial, initial_value, scan_op)); 
# 321
ExclusiveDownsweep(scan_op, exclusive_partial); 
# 322
}  
# 324
__syncthreads(); 
# 327
output = (*placement_ptr); 
# 328
}  
# 329
} 
#endif
# 333 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 334
__attribute((always_inline)) void ExclusiveScan(T 
# 335
input, T &
# 336
output, ScanOp 
# 337
scan_op, T &
# 338
block_aggregate) 
# 339
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 380
::exit(___);}
#if 0
# 339
{ 
# 340
if (WARP_SYNCHRONOUS) 
# 341
{ 
# 343
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(input, output, scan_op, block_aggregate)); 
# 344
} else 
# 346
{ 
# 348
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 349
(*placement_ptr) = input; 
# 351
__syncthreads(); 
# 354
if ((linear_tid) < (RAKING_THREADS)) 
# 355
{ 
# 357
T upsweep_partial = Upsweep(scan_op); 
# 360
T inclusive_partial; 
# 361
T exclusive_partial; 
# 362
(((WarpScan)(((temp_storage).warp_scan))).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op)); 
# 365
ExclusiveDownsweep(scan_op, exclusive_partial, (linear_tid) != (0)); 
# 368
if ((linear_tid) == ((RAKING_THREADS) - 1)) { 
# 369
((temp_storage).block_aggregate) = inclusive_partial; }  
# 370
}  
# 372
__syncthreads(); 
# 375
output = (*placement_ptr); 
# 378
block_aggregate = ((temp_storage).block_aggregate); 
# 379
}  
# 380
} 
#endif
# 384 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 385
__attribute((always_inline)) void ExclusiveScan(T 
# 386
input, T &
# 387
output, const T &
# 388
initial_value, ScanOp 
# 389
scan_op, T &
# 390
block_aggregate) 
# 391
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;(void)block_aggregate;
# 430
::exit(___);}
#if 0
# 391
{ 
# 392
if (WARP_SYNCHRONOUS) 
# 393
{ 
# 395
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(input, output, initial_value, scan_op, block_aggregate)); 
# 396
} else 
# 398
{ 
# 400
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 401
(*placement_ptr) = input; 
# 403
__syncthreads(); 
# 406
if ((linear_tid) < (RAKING_THREADS)) 
# 407
{ 
# 409
T upsweep_partial = Upsweep(scan_op); 
# 412
T exclusive_partial; 
# 413
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(upsweep_partial, exclusive_partial, initial_value, scan_op, block_aggregate)); 
# 416
ExclusiveDownsweep(scan_op, exclusive_partial); 
# 419
((temp_storage).block_aggregate) = block_aggregate; 
# 420
}  
# 422
__syncthreads(); 
# 425
output = (*placement_ptr); 
# 428
block_aggregate = ((temp_storage).block_aggregate); 
# 429
}  
# 430
} 
#endif
# 434 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class 
# 435
ScanOp, class 
# 436
BlockPrefixCallbackOp> 
# 437
__attribute((always_inline)) void ExclusiveScan(T 
# 438
input, T &
# 439
output, ScanOp 
# 440
scan_op, BlockPrefixCallbackOp &
# 441
block_prefix_callback_op) 
# 442
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 496
::exit(___);}
#if 0
# 442
{ 
# 443
if (WARP_SYNCHRONOUS) 
# 444
{ 
# 446
T block_aggregate; 
# 447
WarpScan warp_scan(((temp_storage).warp_scan)); 
# 448
(warp_scan.ExclusiveScan(input, output, scan_op, block_aggregate)); 
# 451
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 452
block_prefix = (warp_scan.Broadcast(block_prefix, 0)); 
# 454
output = scan_op(block_prefix, output); 
# 455
if ((linear_tid) == (0)) { 
# 456
output = block_prefix; }  
# 457
} else 
# 459
{ 
# 461
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 462
(*placement_ptr) = input; 
# 464
__syncthreads(); 
# 467
if ((linear_tid) < (RAKING_THREADS)) 
# 468
{ 
# 469
WarpScan warp_scan(((temp_storage).warp_scan)); 
# 472
T upsweep_partial = Upsweep(scan_op); 
# 475
T exclusive_partial, block_aggregate; 
# 476
(warp_scan.ExclusiveScan(upsweep_partial, exclusive_partial, scan_op, block_aggregate)); 
# 479
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 480
block_prefix = (warp_scan.Broadcast(block_prefix, 0)); 
# 483
T downsweep_prefix = scan_op(block_prefix, exclusive_partial); 
# 484
if ((linear_tid) == (0)) { 
# 485
downsweep_prefix = block_prefix; }  
# 488
ExclusiveDownsweep(scan_op, downsweep_prefix); 
# 489
}  
# 491
__syncthreads(); 
# 494
output = (*placement_ptr); 
# 495
}  
# 496
} 
#endif
# 504 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 505
__attribute((always_inline)) void InclusiveScan(T 
# 506
input, T &
# 507
output, ScanOp 
# 508
scan_op) 
# 509
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 542
::exit(___);}
#if 0
# 509
{ 
# 510
if (WARP_SYNCHRONOUS) 
# 511
{ 
# 513
(((WarpScan)(((temp_storage).warp_scan))).InclusiveScan(input, output, scan_op)); 
# 514
} else 
# 516
{ 
# 518
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 519
(*placement_ptr) = input; 
# 521
__syncthreads(); 
# 524
if ((linear_tid) < (RAKING_THREADS)) 
# 525
{ 
# 527
T upsweep_partial = Upsweep(scan_op); 
# 530
T exclusive_partial; 
# 531
(((WarpScan)(((temp_storage).warp_scan))).ExclusiveScan(upsweep_partial, exclusive_partial, scan_op)); 
# 534
InclusiveDownsweep(scan_op, exclusive_partial, (linear_tid) != (0)); 
# 535
}  
# 537
__syncthreads(); 
# 540
output = (*placement_ptr); 
# 541
}  
# 542
} 
#endif
# 546 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class ScanOp> 
# 547
__attribute((always_inline)) void InclusiveScan(T 
# 548
input, T &
# 549
output, ScanOp 
# 550
scan_op, T &
# 551
block_aggregate) 
# 552
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 593
::exit(___);}
#if 0
# 552
{ 
# 553
if (WARP_SYNCHRONOUS) 
# 554
{ 
# 556
(((WarpScan)(((temp_storage).warp_scan))).InclusiveScan(input, output, scan_op, block_aggregate)); 
# 557
} else 
# 559
{ 
# 561
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 562
(*placement_ptr) = input; 
# 564
__syncthreads(); 
# 567
if ((linear_tid) < (RAKING_THREADS)) 
# 568
{ 
# 570
T upsweep_partial = Upsweep(scan_op); 
# 573
T inclusive_partial; 
# 574
T exclusive_partial; 
# 575
(((WarpScan)(((temp_storage).warp_scan))).Scan(upsweep_partial, inclusive_partial, exclusive_partial, scan_op)); 
# 578
InclusiveDownsweep(scan_op, exclusive_partial, (linear_tid) != (0)); 
# 581
if ((linear_tid) == ((RAKING_THREADS) - 1)) { 
# 582
((temp_storage).block_aggregate) = inclusive_partial; }  
# 583
}  
# 585
__syncthreads(); 
# 588
output = (*placement_ptr); 
# 591
block_aggregate = ((temp_storage).block_aggregate); 
# 592
}  
# 593
} 
#endif
# 597 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
template< class 
# 598
ScanOp, class 
# 599
BlockPrefixCallbackOp> 
# 600
__attribute((always_inline)) void InclusiveScan(T 
# 601
input, T &
# 602
output, ScanOp 
# 603
scan_op, BlockPrefixCallbackOp &
# 604
block_prefix_callback_op) 
# 605
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 658
::exit(___);}
#if 0
# 605
{ 
# 606
if (WARP_SYNCHRONOUS) 
# 607
{ 
# 609
T block_aggregate; 
# 610
WarpScan warp_scan(((temp_storage).warp_scan)); 
# 611
(warp_scan.InclusiveScan(input, output, scan_op, block_aggregate)); 
# 614
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 615
block_prefix = (warp_scan.Broadcast(block_prefix, 0)); 
# 618
output = scan_op(block_prefix, output); 
# 619
} else 
# 621
{ 
# 623
T *placement_ptr = BlockRakingLayout::PlacementPtr(((temp_storage).raking_grid), linear_tid); 
# 624
(*placement_ptr) = input; 
# 626
__syncthreads(); 
# 629
if ((linear_tid) < (RAKING_THREADS)) 
# 630
{ 
# 631
WarpScan warp_scan(((temp_storage).warp_scan)); 
# 634
T upsweep_partial = Upsweep(scan_op); 
# 637
T exclusive_partial, block_aggregate; 
# 638
(warp_scan.ExclusiveScan(upsweep_partial, exclusive_partial, scan_op, block_aggregate)); 
# 641
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 642
block_prefix = (warp_scan.Broadcast(block_prefix, 0)); 
# 645
T downsweep_prefix = scan_op(block_prefix, exclusive_partial); 
# 646
if ((linear_tid) == (0)) { 
# 647
downsweep_prefix = block_prefix; }  
# 650
InclusiveDownsweep(scan_op, downsweep_prefix); 
# 651
}  
# 653
__syncthreads(); 
# 656
output = (*placement_ptr); 
# 657
}  
# 658
} 
#endif
# 660 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_raking.cuh"
}; 
# 663
}
# 45 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
namespace cub { 
# 50
template< class 
# 51
T, int 
# 52
BLOCK_DIM_X, int 
# 53
BLOCK_DIM_Y, int 
# 54
BLOCK_DIM_Z, int 
# 55
PTX_ARCH> 
# 56
struct BlockScanWarpScans { 
# 64
enum { 
# 66
WARP_THREADS = 1 << 5, 
# 69
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z, 
# 72
WARPS = ((((BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z) + (1 << 5)) - 1) / (1 << 5)
# 73
}; 
# 76
typedef WarpScan< T, WARP_THREADS, PTX_ARCH>  WarpScanT; 
# 79
typedef WarpScan< T, WARPS, PTX_ARCH>  WarpAggregateScan; 
# 83
struct __attribute((aligned(32))) _TempStorage { 
# 85
T warp_aggregates[WARPS]; 
# 86
typename WarpScan< T, WARP_THREADS, PTX_ARCH> ::TempStorage warp_scan[WARPS]; 
# 87
T block_prefix; 
# 88
}; 
# 92
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 100
_TempStorage &temp_storage; 
# 101
unsigned linear_tid; 
# 102
unsigned warp_id; 
# 103
unsigned lane_id; 
# 111
__attribute((always_inline)) BlockScanWarpScans(TempStorage &
# 112
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)), warp_id(((WARPS) == 1) ? 0 : ((linear_tid) / (WARP_THREADS))), lane_id(LaneId()) 
# 118
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 118
{ } 
#endif
# 125 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp, int WARP> 
# 126
__attribute((always_inline)) void ApplyWarpAggregates(T &
# 127
warp_prefix, ScanOp 
# 128
scan_op, T &
# 129
block_aggregate, Int2Type< WARP>  
# 130
addend_warp) 
# 131
{int volatile ___ = 1;(void)warp_prefix;(void)scan_op;(void)block_aggregate;(void)addend_warp;
# 139
::exit(___);}
#if 0
# 131
{ 
# 132
if ((warp_id) == (WARP)) { 
# 133
warp_prefix = block_aggregate; }  
# 135
T addend = ((temp_storage).warp_aggregates)[WARP]; 
# 136
block_aggregate = scan_op(block_aggregate, addend); 
# 138
ApplyWarpAggregates(warp_prefix, scan_op, block_aggregate, Int2Type< WARP + 1> ()); 
# 139
} 
#endif
# 141 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 142
__attribute((always_inline)) void ApplyWarpAggregates(T &
# 143
warp_prefix, ScanOp 
# 144
scan_op, T &
# 145
block_aggregate, Int2Type< WARPS>  
# 146
addend_warp) 
# 147
{int volatile ___ = 1;(void)warp_prefix;(void)scan_op;(void)block_aggregate;(void)addend_warp;::exit(___);}
#if 0
# 147
{ } 
#endif
# 151 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 152
__attribute((always_inline)) T ComputeWarpPrefix(ScanOp 
# 153
scan_op, T 
# 154
warp_aggregate, T &
# 155
block_aggregate) 
# 156
{int volatile ___ = 1;(void)scan_op;(void)warp_aggregate;(void)block_aggregate;
# 182
::exit(___);}
#if 0
# 156
{ 
# 158
if ((lane_id) == ((WARP_THREADS) - 1)) { 
# 159
(((temp_storage).warp_aggregates)[warp_id]) = warp_aggregate; }  
# 161
__syncthreads(); 
# 164
T warp_prefix; 
# 165
block_aggregate = (((temp_storage).warp_aggregates)[0]); 
# 168
ApplyWarpAggregates(warp_prefix, scan_op, block_aggregate, Int2Type< 1> ()); 
# 181
return warp_prefix; 
# 182
} 
#endif
# 186 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 187
__attribute((always_inline)) T ComputeWarpPrefix(ScanOp 
# 188
scan_op, T 
# 189
warp_aggregate, T &
# 190
block_aggregate, const T &
# 191
initial_value) 
# 192
{int volatile ___ = 1;(void)scan_op;(void)warp_aggregate;(void)block_aggregate;(void)initial_value;
# 201
::exit(___);}
#if 0
# 192
{ 
# 193
T warp_prefix = ComputeWarpPrefix(scan_op, warp_aggregate, block_aggregate); 
# 195
warp_prefix = scan_op(initial_value, warp_prefix); 
# 197
if ((warp_id) == (0)) { 
# 198
warp_prefix = initial_value; }  
# 200
return warp_prefix; 
# 201
} 
#endif
# 208 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 209
__attribute((always_inline)) void ExclusiveScan(T 
# 210
input, T &
# 211
exclusive_output, ScanOp 
# 212
scan_op) 
# 213
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;
# 217
::exit(___);}
#if 0
# 213
{ 
# 215
T block_aggregate; 
# 216
ExclusiveScan(input, exclusive_output, scan_op, block_aggregate); 
# 217
} 
#endif
# 221 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 222
__attribute((always_inline)) void ExclusiveScan(T 
# 223
input, T &
# 224
exclusive_output, const T &
# 225
initial_value, ScanOp 
# 226
scan_op) 
# 227
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)initial_value;(void)scan_op;
# 230
::exit(___);}
#if 0
# 227
{ 
# 228
T block_aggregate; 
# 229
ExclusiveScan(input, exclusive_output, initial_value, scan_op, block_aggregate); 
# 230
} 
#endif
# 234 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 235
__attribute((always_inline)) void ExclusiveScan(T 
# 236
input, T &
# 237
exclusive_output, ScanOp 
# 238
scan_op, T &
# 239
block_aggregate) 
# 240
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;(void)block_aggregate;
# 255
::exit(___);}
#if 0
# 240
{ 
# 242
T inclusive_output; 
# 243
(((WarpScanT)(((temp_storage).warp_scan)[warp_id])).Scan(input, inclusive_output, exclusive_output, scan_op)); 
# 246
T warp_prefix = ComputeWarpPrefix(scan_op, inclusive_output, block_aggregate); 
# 249
if ((warp_id) != (0)) 
# 250
{ 
# 251
exclusive_output = scan_op(warp_prefix, exclusive_output); 
# 252
if ((lane_id) == (0)) { 
# 253
exclusive_output = warp_prefix; }  
# 254
}  
# 255
} 
#endif
# 259 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 260
__attribute((always_inline)) void ExclusiveScan(T 
# 261
input, T &
# 262
exclusive_output, const T &
# 263
initial_value, ScanOp 
# 264
scan_op, T &
# 265
block_aggregate) 
# 266
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)initial_value;(void)scan_op;(void)block_aggregate;
# 278
::exit(___);}
#if 0
# 266
{ 
# 268
T inclusive_output; 
# 269
(((WarpScanT)(((temp_storage).warp_scan)[warp_id])).Scan(input, inclusive_output, exclusive_output, scan_op)); 
# 272
T warp_prefix = ComputeWarpPrefix(scan_op, inclusive_output, block_aggregate, initial_value); 
# 275
exclusive_output = scan_op(warp_prefix, exclusive_output); 
# 276
if ((lane_id) == (0)) { 
# 277
exclusive_output = warp_prefix; }  
# 278
} 
#endif
# 282 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class 
# 283
ScanOp, class 
# 284
BlockPrefixCallbackOp> 
# 285
__attribute((always_inline)) void ExclusiveScan(T 
# 286
input, T &
# 287
exclusive_output, ScanOp 
# 288
scan_op, BlockPrefixCallbackOp &
# 289
block_prefix_callback_op) 
# 290
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;(void)block_prefix_callback_op;
# 315
::exit(___);}
#if 0
# 290
{ 
# 292
T block_aggregate; 
# 293
ExclusiveScan(input, exclusive_output, scan_op, block_aggregate); 
# 296
if ((warp_id) == (0)) 
# 297
{ 
# 298
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 299
if ((lane_id) == (0)) 
# 300
{ 
# 302
((temp_storage).block_prefix) = block_prefix; 
# 303
exclusive_output = block_prefix; 
# 304
}  
# 305
}  
# 307
__syncthreads(); 
# 310
T block_prefix = (((temp_storage).block_prefix)); 
# 311
if ((linear_tid) > (0)) 
# 312
{ 
# 313
exclusive_output = scan_op(block_prefix, exclusive_output); 
# 314
}  
# 315
} 
#endif
# 323 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 324
__attribute((always_inline)) void InclusiveScan(T 
# 325
input, T &
# 326
inclusive_output, ScanOp 
# 327
scan_op) 
# 328
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;
# 331
::exit(___);}
#if 0
# 328
{ 
# 329
T block_aggregate; 
# 330
InclusiveScan(input, inclusive_output, scan_op, block_aggregate); 
# 331
} 
#endif
# 335 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class ScanOp> 
# 336
__attribute((always_inline)) void InclusiveScan(T 
# 337
input, T &
# 338
inclusive_output, ScanOp 
# 339
scan_op, T &
# 340
block_aggregate) 
# 341
{int volatile ___ = 1;(void)input;(void)inclusive_output;(void)scan_op;(void)block_aggregate;
# 352
::exit(___);}
#if 0
# 341
{ 
# 342
(((WarpScanT)(((temp_storage).warp_scan)[warp_id])).InclusiveScan(input, inclusive_output, scan_op)); 
# 345
T warp_prefix = ComputeWarpPrefix(scan_op, inclusive_output, block_aggregate); 
# 348
if ((warp_id) != (0)) 
# 349
{ 
# 350
inclusive_output = scan_op(warp_prefix, inclusive_output); 
# 351
}  
# 352
} 
#endif
# 356 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
template< class 
# 357
ScanOp, class 
# 358
BlockPrefixCallbackOp> 
# 359
__attribute((always_inline)) void InclusiveScan(T 
# 360
input, T &
# 361
exclusive_output, ScanOp 
# 362
scan_op, BlockPrefixCallbackOp &
# 363
block_prefix_callback_op) 
# 364
{int volatile ___ = 1;(void)input;(void)exclusive_output;(void)scan_op;(void)block_prefix_callback_op;
# 384
::exit(___);}
#if 0
# 364
{ 
# 365
T block_aggregate; 
# 366
InclusiveScan(input, exclusive_output, scan_op, block_aggregate); 
# 369
if ((warp_id) == (0)) 
# 370
{ 
# 371
T block_prefix = block_prefix_callback_op(block_aggregate); 
# 372
if ((lane_id) == (0)) 
# 373
{ 
# 375
((temp_storage).block_prefix) = block_prefix; 
# 376
}  
# 377
}  
# 379
__syncthreads(); 
# 382
T block_prefix = (((temp_storage).block_prefix)); 
# 383
exclusive_output = scan_op(block_prefix, exclusive_output); 
# 384
} 
#endif
# 387 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/specializations/block_scan_warp_scans.cuh"
}; 
# 390
}
# 47 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
namespace cub { 
# 57
enum BlockScanAlgorithm { 
# 78
BLOCK_SCAN_RAKING, 
# 88
BLOCK_SCAN_RAKING_MEMOIZE, 
# 108
BLOCK_SCAN_WARP_SCANS
# 109
}; 
# 186
template< class 
# 187
T, int 
# 188
BLOCK_DIM_X, BlockScanAlgorithm 
# 189
ALGORITHM = BLOCK_SCAN_RAKING, int 
# 190
BLOCK_DIM_Y = 1, int 
# 191
BLOCK_DIM_Z = 1, int 
# 192
PTX_ARCH = 0> 
# 193
class BlockScan { 
# 203
enum { 
# 205
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 206
}; 
# 214
static const BlockScanAlgorithm SAFE_ALGORITHM = ((((ALGORITHM) == (BLOCK_SCAN_WARP_SCANS)) && (((BLOCK_THREADS) % (1 << 5)) != 0)) ? BLOCK_SCAN_RAKING : ALGORITHM); 
# 219
typedef BlockScanWarpScans< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH>  WarpScans; 
# 220
typedef BlockScanRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, SAFE_ALGORITHM == (BLOCK_SCAN_RAKING_MEMOIZE), PTX_ARCH>  Raking; 
# 225
typedef typename If< SAFE_ALGORITHM == (BLOCK_SCAN_WARP_SCANS), BlockScanWarpScans< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockScanRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, SAFE_ALGORITHM == (BLOCK_SCAN_RAKING_MEMOIZE), PTX_ARCH> > ::Type InternalBlockScan; 
# 228
typedef typename If< SAFE_ALGORITHM == (BLOCK_SCAN_WARP_SCANS), BlockScanWarpScans< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockScanRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, SAFE_ALGORITHM == (BLOCK_SCAN_RAKING_MEMOIZE), PTX_ARCH> > ::Type::TempStorage _TempStorage; 
# 236
_TempStorage &temp_storage; 
# 239
unsigned linear_tid; 
# 247
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 248
{int volatile ___ = 1;
# 251
::exit(___);}
#if 0
# 248
{ 
# 249
__attribute__((unused)) static _TempStorage private_storage; 
# 250
return private_storage; 
# 251
} 
#endif
# 260 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
public: struct TempStorage : public Uninitialized< typename If< SAFE_ALGORITHM == (BLOCK_SCAN_WARP_SCANS), BlockScanWarpScans< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, PTX_ARCH> , BlockScanRaking< T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z, SAFE_ALGORITHM == (BLOCK_SCAN_RAKING_MEMOIZE), PTX_ARCH> > ::Type::TempStorage>  { }; 
# 271
__attribute((always_inline)) BlockScan() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 275
{int *volatile ___ = 0;::free(___);}
#if 0
# 275
{ } 
#endif
# 281 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
__attribute((always_inline)) BlockScan(TempStorage &
# 282
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 286
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 286
{ } 
#endif
# 333 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
__attribute((always_inline)) void ExclusiveSum(T 
# 334
input, T &
# 335
output) 
# 336
{int volatile ___ = 1;(void)input;(void)output;
# 339
::exit(___);}
#if 0
# 336
{ 
# 337
T initial_value = (0); 
# 338
ExclusiveScan(input, output, initial_value, Sum()); 
# 339
} 
#endif
# 380 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
__attribute((always_inline)) void ExclusiveSum(T 
# 381
input, T &
# 382
output, T &
# 383
block_aggregate) 
# 384
{int volatile ___ = 1;(void)input;(void)output;(void)block_aggregate;
# 387
::exit(___);}
#if 0
# 384
{ 
# 385
T initial_value = (0); 
# 386
ExclusiveScan(input, output, initial_value, Sum(), block_aggregate); 
# 387
} 
#endif
# 464 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class BlockPrefixCallbackOp> 
# 465
__attribute((always_inline)) void ExclusiveSum(T 
# 466
input, T &
# 467
output, BlockPrefixCallbackOp &
# 468
block_prefix_callback_op) 
# 469
{int volatile ___ = 1;(void)input;(void)output;(void)block_prefix_callback_op;
# 471
::exit(___);}
#if 0
# 469
{ 
# 470
ExclusiveScan(input, output, Sum(), block_prefix_callback_op); 
# 471
} 
#endif
# 520 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int ITEMS_PER_THREAD> 
# 521
__attribute((always_inline)) void ExclusiveSum(T (&
# 522
input)[ITEMS_PER_THREAD], T (&
# 523
output)[ITEMS_PER_THREAD]) 
# 524
{int volatile ___ = 1;(void)input;(void)output;
# 527
::exit(___);}
#if 0
# 524
{ 
# 525
T initial_value = (0); 
# 526
ExclusiveScan(input, output, initial_value, Sum()); 
# 527
} 
#endif
# 571 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int ITEMS_PER_THREAD> 
# 572
__attribute((always_inline)) void ExclusiveSum(T (&
# 573
input)[ITEMS_PER_THREAD], T (&
# 574
output)[ITEMS_PER_THREAD], T &
# 575
block_aggregate) 
# 576
{int volatile ___ = 1;(void)input;(void)output;(void)block_aggregate;
# 580
::exit(___);}
#if 0
# 576
{ 
# 578
T initial_value = (0); 
# 579
ExclusiveScan(input, output, initial_value, Sum(), block_aggregate); 
# 580
} 
#endif
# 670 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 671
ITEMS_PER_THREAD, class 
# 672
BlockPrefixCallbackOp> 
# 673
__attribute((always_inline)) void ExclusiveSum(T (&
# 674
input)[ITEMS_PER_THREAD], T (&
# 675
output)[ITEMS_PER_THREAD], BlockPrefixCallbackOp &
# 676
block_prefix_callback_op) 
# 677
{int volatile ___ = 1;(void)input;(void)output;(void)block_prefix_callback_op;
# 679
::exit(___);}
#if 0
# 677
{ 
# 678
ExclusiveScan(input, output, Sum(), block_prefix_callback_op); 
# 679
} 
#endif
# 727 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 728
__attribute((always_inline)) void ExclusiveScan(T 
# 729
input, T &
# 730
output, T 
# 731
initial_value, ScanOp 
# 732
scan_op) 
# 733
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;
# 735
::exit(___);}
#if 0
# 733
{ 
# 734
(((InternalBlockScan)(temp_storage)).ExclusiveScan(input, output, initial_value, scan_op)); 
# 735
} 
#endif
# 777 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 778
__attribute((always_inline)) void ExclusiveScan(T 
# 779
input, T &
# 780
output, T 
# 781
initial_value, ScanOp 
# 782
scan_op, T &
# 783
block_aggregate) 
# 784
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;(void)block_aggregate;
# 786
::exit(___);}
#if 0
# 784
{ 
# 785
(((InternalBlockScan)(temp_storage)).ExclusiveScan(input, output, initial_value, scan_op, block_aggregate)); 
# 786
} 
#endif
# 864 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class 
# 865
ScanOp, class 
# 866
BlockPrefixCallbackOp> 
# 867
__attribute((always_inline)) void ExclusiveScan(T 
# 868
input, T &
# 869
output, ScanOp 
# 870
scan_op, BlockPrefixCallbackOp &
# 871
block_prefix_callback_op) 
# 872
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 874
::exit(___);}
#if 0
# 872
{ 
# 873
(((InternalBlockScan)(temp_storage)).ExclusiveScan(input, output, scan_op, block_prefix_callback_op)); 
# 874
} 
#endif
# 926 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 927
ITEMS_PER_THREAD, class 
# 928
ScanOp> 
# 929
__attribute((always_inline)) void ExclusiveScan(T (&
# 930
input)[ITEMS_PER_THREAD], T (&
# 931
output)[ITEMS_PER_THREAD], T 
# 932
initial_value, ScanOp 
# 933
scan_op) 
# 934
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;
# 943
::exit(___);}
#if 0
# 934
{ 
# 936
T thread_prefix = ThreadReduce(input, scan_op); 
# 939
ExclusiveScan(thread_prefix, thread_prefix, initial_value, scan_op); 
# 942
ThreadScanExclusive(input, output, scan_op, thread_prefix); 
# 943
} 
#endif
# 988 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 989
ITEMS_PER_THREAD, class 
# 990
ScanOp> 
# 991
__attribute((always_inline)) void ExclusiveScan(T (&
# 992
input)[ITEMS_PER_THREAD], T (&
# 993
output)[ITEMS_PER_THREAD], T 
# 994
initial_value, ScanOp 
# 995
scan_op, T &
# 996
block_aggregate) 
# 997
{int volatile ___ = 1;(void)input;(void)output;(void)initial_value;(void)scan_op;(void)block_aggregate;
# 1006
::exit(___);}
#if 0
# 997
{ 
# 999
T thread_prefix = ThreadReduce(input, scan_op); 
# 1002
ExclusiveScan(thread_prefix, thread_prefix, initial_value, scan_op, block_aggregate); 
# 1005
ThreadScanExclusive(input, output, scan_op, thread_prefix); 
# 1006
} 
#endif
# 1095 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1096
ITEMS_PER_THREAD, class 
# 1097
ScanOp, class 
# 1098
BlockPrefixCallbackOp> 
# 1099
__attribute((always_inline)) void ExclusiveScan(T (&
# 1100
input)[ITEMS_PER_THREAD], T (&
# 1101
output)[ITEMS_PER_THREAD], ScanOp 
# 1102
scan_op, BlockPrefixCallbackOp &
# 1103
block_prefix_callback_op) 
# 1104
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 1113
::exit(___);}
#if 0
# 1104
{ 
# 1106
T thread_prefix = ThreadReduce(input, scan_op); 
# 1109
ExclusiveScan(thread_prefix, thread_prefix, scan_op, block_prefix_callback_op); 
# 1112
ThreadScanExclusive(input, output, scan_op, thread_prefix); 
# 1113
} 
#endif
# 1135 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 1136
__attribute((always_inline)) void ExclusiveScan(T 
# 1137
input, T &
# 1138
output, ScanOp 
# 1139
scan_op) 
# 1140
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 1142
::exit(___);}
#if 0
# 1140
{ 
# 1141
(((InternalBlockScan)(temp_storage)).ExclusiveScan(input, output, scan_op)); 
# 1142
} 
#endif
# 1155 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 1156
__attribute((always_inline)) void ExclusiveScan(T 
# 1157
input, T &
# 1158
output, ScanOp 
# 1159
scan_op, T &
# 1160
block_aggregate) 
# 1161
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 1163
::exit(___);}
#if 0
# 1161
{ 
# 1162
(((InternalBlockScan)(temp_storage)).ExclusiveScan(input, output, scan_op, block_aggregate)); 
# 1163
} 
#endif
# 1184 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1185
ITEMS_PER_THREAD, class 
# 1186
ScanOp> 
# 1187
__attribute((always_inline)) void ExclusiveScan(T (&
# 1188
input)[ITEMS_PER_THREAD], T (&
# 1189
output)[ITEMS_PER_THREAD], ScanOp 
# 1190
scan_op) 
# 1191
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 1200
::exit(___);}
#if 0
# 1191
{ 
# 1193
T thread_partial = ThreadReduce(input, scan_op); 
# 1196
ExclusiveScan(thread_partial, thread_partial, scan_op); 
# 1199
ThreadScanExclusive(input, output, scan_op, thread_partial, (linear_tid) != (0)); 
# 1200
} 
#endif
# 1215 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1216
ITEMS_PER_THREAD, class 
# 1217
ScanOp> 
# 1218
__attribute((always_inline)) void ExclusiveScan(T (&
# 1219
input)[ITEMS_PER_THREAD], T (&
# 1220
output)[ITEMS_PER_THREAD], ScanOp 
# 1221
scan_op, T &
# 1222
block_aggregate) 
# 1223
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 1232
::exit(___);}
#if 0
# 1223
{ 
# 1225
T thread_partial = ThreadReduce(input, scan_op); 
# 1228
ExclusiveScan(thread_partial, thread_partial, scan_op, block_aggregate); 
# 1231
ThreadScanExclusive(input, output, scan_op, thread_partial, (linear_tid) != (0)); 
# 1232
} 
#endif
# 1279 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
__attribute((always_inline)) void InclusiveSum(T 
# 1280
input, T &
# 1281
output) 
# 1282
{int volatile ___ = 1;(void)input;(void)output;
# 1284
::exit(___);}
#if 0
# 1282
{ 
# 1283
InclusiveScan(input, output, Sum()); 
# 1284
} 
#endif
# 1324 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
__attribute((always_inline)) void InclusiveSum(T 
# 1325
input, T &
# 1326
output, T &
# 1327
block_aggregate) 
# 1328
{int volatile ___ = 1;(void)input;(void)output;(void)block_aggregate;
# 1330
::exit(___);}
#if 0
# 1328
{ 
# 1329
InclusiveScan(input, output, Sum(), block_aggregate); 
# 1330
} 
#endif
# 1407 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class BlockPrefixCallbackOp> 
# 1408
__attribute((always_inline)) void InclusiveSum(T 
# 1409
input, T &
# 1410
output, BlockPrefixCallbackOp &
# 1411
block_prefix_callback_op) 
# 1412
{int volatile ___ = 1;(void)input;(void)output;(void)block_prefix_callback_op;
# 1414
::exit(___);}
#if 0
# 1412
{ 
# 1413
InclusiveScan(input, output, Sum(), block_prefix_callback_op); 
# 1414
} 
#endif
# 1462 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int ITEMS_PER_THREAD> 
# 1463
__attribute((always_inline)) void InclusiveSum(T (&
# 1464
input)[ITEMS_PER_THREAD], T (&
# 1465
output)[ITEMS_PER_THREAD]) 
# 1466
{int volatile ___ = 1;(void)input;(void)output;
# 1483
::exit(___);}
#if 0
# 1466
{ 
# 1467
if (ITEMS_PER_THREAD == 1) 
# 1468
{ 
# 1469
InclusiveSum((input)[0], (output)[0]); 
# 1470
} else 
# 1472
{ 
# 1474
Sum scan_op; 
# 1475
T thread_prefix = ThreadReduce(input, scan_op); 
# 1478
ExclusiveSum(thread_prefix, thread_prefix); 
# 1481
ThreadScanInclusive(input, output, scan_op, thread_prefix, (linear_tid) != (0)); 
# 1482
}  
# 1483
} 
#endif
# 1529 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int ITEMS_PER_THREAD> 
# 1530
__attribute((always_inline)) void InclusiveSum(T (&
# 1531
input)[ITEMS_PER_THREAD], T (&
# 1532
output)[ITEMS_PER_THREAD], T &
# 1533
block_aggregate) 
# 1534
{int volatile ___ = 1;(void)input;(void)output;(void)block_aggregate;
# 1551
::exit(___);}
#if 0
# 1534
{ 
# 1535
if (ITEMS_PER_THREAD == 1) 
# 1536
{ 
# 1537
InclusiveSum((input)[0], (output)[0], block_aggregate); 
# 1538
} else 
# 1540
{ 
# 1542
Sum scan_op; 
# 1543
T thread_prefix = ThreadReduce(input, scan_op); 
# 1546
ExclusiveSum(thread_prefix, thread_prefix, block_aggregate); 
# 1549
ThreadScanInclusive(input, output, scan_op, thread_prefix, (linear_tid) != (0)); 
# 1550
}  
# 1551
} 
#endif
# 1639 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1640
ITEMS_PER_THREAD, class 
# 1641
BlockPrefixCallbackOp> 
# 1642
__attribute((always_inline)) void InclusiveSum(T (&
# 1643
input)[ITEMS_PER_THREAD], T (&
# 1644
output)[ITEMS_PER_THREAD], BlockPrefixCallbackOp &
# 1645
block_prefix_callback_op) 
# 1646
{int volatile ___ = 1;(void)input;(void)output;(void)block_prefix_callback_op;
# 1663
::exit(___);}
#if 0
# 1646
{ 
# 1647
if (ITEMS_PER_THREAD == 1) 
# 1648
{ 
# 1649
InclusiveSum((input)[0], (output)[0], block_prefix_callback_op); 
# 1650
} else 
# 1652
{ 
# 1654
Sum scan_op; 
# 1655
T thread_prefix = ThreadReduce(input, scan_op); 
# 1658
ExclusiveSum(thread_prefix, thread_prefix, block_prefix_callback_op); 
# 1661
ThreadScanInclusive(input, output, scan_op, thread_prefix); 
# 1662
}  
# 1663
} 
#endif
# 1710 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 1711
__attribute((always_inline)) void InclusiveScan(T 
# 1712
input, T &
# 1713
output, ScanOp 
# 1714
scan_op) 
# 1715
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 1717
::exit(___);}
#if 0
# 1715
{ 
# 1716
(((InternalBlockScan)(temp_storage)).InclusiveScan(input, output, scan_op)); 
# 1717
} 
#endif
# 1759 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class ScanOp> 
# 1760
__attribute((always_inline)) void InclusiveScan(T 
# 1761
input, T &
# 1762
output, ScanOp 
# 1763
scan_op, T &
# 1764
block_aggregate) 
# 1765
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 1767
::exit(___);}
#if 0
# 1765
{ 
# 1766
(((InternalBlockScan)(temp_storage)).InclusiveScan(input, output, scan_op, block_aggregate)); 
# 1767
} 
#endif
# 1845 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< class 
# 1846
ScanOp, class 
# 1847
BlockPrefixCallbackOp> 
# 1848
__attribute((always_inline)) void InclusiveScan(T 
# 1849
input, T &
# 1850
output, ScanOp 
# 1851
scan_op, BlockPrefixCallbackOp &
# 1852
block_prefix_callback_op) 
# 1853
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 1855
::exit(___);}
#if 0
# 1853
{ 
# 1854
(((InternalBlockScan)(temp_storage)).InclusiveScan(input, output, scan_op, block_prefix_callback_op)); 
# 1855
} 
#endif
# 1905 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1906
ITEMS_PER_THREAD, class 
# 1907
ScanOp> 
# 1908
__attribute((always_inline)) void InclusiveScan(T (&
# 1909
input)[ITEMS_PER_THREAD], T (&
# 1910
output)[ITEMS_PER_THREAD], ScanOp 
# 1911
scan_op) 
# 1912
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;
# 1928
::exit(___);}
#if 0
# 1912
{ 
# 1913
if (ITEMS_PER_THREAD == 1) 
# 1914
{ 
# 1915
InclusiveScan((input)[0], (output)[0], scan_op); 
# 1916
} else 
# 1918
{ 
# 1920
T thread_prefix = ThreadReduce(input, scan_op); 
# 1923
ExclusiveScan(thread_prefix, thread_prefix, scan_op); 
# 1926
ThreadScanInclusive(input, output, scan_op, thread_prefix, (linear_tid) != (0)); 
# 1927
}  
# 1928
} 
#endif
# 1975 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 1976
ITEMS_PER_THREAD, class 
# 1977
ScanOp> 
# 1978
__attribute((always_inline)) void InclusiveScan(T (&
# 1979
input)[ITEMS_PER_THREAD], T (&
# 1980
output)[ITEMS_PER_THREAD], ScanOp 
# 1981
scan_op, T &
# 1982
block_aggregate) 
# 1983
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_aggregate;
# 1999
::exit(___);}
#if 0
# 1983
{ 
# 1984
if (ITEMS_PER_THREAD == 1) 
# 1985
{ 
# 1986
InclusiveScan((input)[0], (output)[0], scan_op, block_aggregate); 
# 1987
} else 
# 1989
{ 
# 1991
T thread_prefix = ThreadReduce(input, scan_op); 
# 1994
ExclusiveScan(thread_prefix, thread_prefix, scan_op, block_aggregate); 
# 1997
ThreadScanInclusive(input, output, scan_op, thread_prefix, (linear_tid) != (0)); 
# 1998
}  
# 1999
} 
#endif
# 2088 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
template< int 
# 2089
ITEMS_PER_THREAD, class 
# 2090
ScanOp, class 
# 2091
BlockPrefixCallbackOp> 
# 2092
__attribute((always_inline)) void InclusiveScan(T (&
# 2093
input)[ITEMS_PER_THREAD], T (&
# 2094
output)[ITEMS_PER_THREAD], ScanOp 
# 2095
scan_op, BlockPrefixCallbackOp &
# 2096
block_prefix_callback_op) 
# 2097
{int volatile ___ = 1;(void)input;(void)output;(void)scan_op;(void)block_prefix_callback_op;
# 2113
::exit(___);}
#if 0
# 2097
{ 
# 2098
if (ITEMS_PER_THREAD == 1) 
# 2099
{ 
# 2100
InclusiveScan((input)[0], (output)[0], scan_op, block_prefix_callback_op); 
# 2101
} else 
# 2103
{ 
# 2105
T thread_prefix = ThreadReduce(input, scan_op); 
# 2108
ExclusiveScan(thread_prefix, thread_prefix, scan_op, block_prefix_callback_op); 
# 2111
ThreadScanInclusive(input, output, scan_op, thread_prefix); 
# 2112
}  
# 2113
} 
#endif
# 2118 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_scan.cuh"
}; 
# 2124
}
# 50 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
namespace cub { 
# 60
template< int 
# 61
_BLOCK_THREADS, int 
# 62
_ITEMS_PER_THREAD, BlockLoadAlgorithm 
# 63
_LOAD_ALGORITHM, CacheLoadModifier 
# 64
_LOAD_MODIFIER, BlockStoreAlgorithm 
# 65
_STORE_ALGORITHM, BlockScanAlgorithm 
# 66
_SCAN_ALGORITHM> 
# 67
struct AgentScanPolicy { 
# 70
enum { 
# 71
BLOCK_THREADS = _BLOCK_THREADS, 
# 72
ITEMS_PER_THREAD = _ITEMS_PER_THREAD
# 73
}; 
# 75
static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM; 
# 76
static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER; 
# 77
static const BlockStoreAlgorithm STORE_ALGORITHM = _STORE_ALGORITHM; 
# 78
static const BlockScanAlgorithm SCAN_ALGORITHM = _SCAN_ALGORITHM; 
# 79
}; 
# 91
template< class 
# 92
AgentScanPolicyT, class 
# 93
InputIteratorT, class 
# 94
OutputIteratorT, class 
# 95
ScanOpT, class 
# 96
InitValueT, class 
# 97
OffsetT> 
# 98
struct AgentScan { 
# 105
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputT; 
# 106
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 109
typedef ScanTileState< typename std::iterator_traits< OutputIteratorT> ::value_type>  ScanTileStateT; 
# 115
typedef typename If< IsPointer< InputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentScanPolicyT::LOAD_MODIFIER, typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT> , InputIteratorT> ::Type WrappedInputIteratorT; 
# 119
enum { 
# 120
IS_INCLUSIVE = Equals< InitValueT, NullType> ::VALUE, 
# 121
BLOCK_THREADS = AgentScanPolicyT::BLOCK_THREADS, 
# 122
ITEMS_PER_THREAD = AgentScanPolicyT::ITEMS_PER_THREAD, 
# 123
TILE_ITEMS = (AgentScanPolicyT::BLOCK_THREADS) * (AgentScanPolicyT::ITEMS_PER_THREAD)
# 124
}; 
# 132
typedef BlockLoad< typename If< IsPointer< InputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentScanPolicyT::LOAD_MODIFIER, typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT> , InputIteratorT> ::Type, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::ITEMS_PER_THREAD, AgentScanPolicyT::LOAD_ALGORITHM>  BlockLoadT; 
# 140
typedef BlockStore< OutputIteratorT, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::ITEMS_PER_THREAD, AgentScanPolicyT::STORE_ALGORITHM>  BlockStoreT; 
# 147
typedef BlockScan< typename std::iterator_traits< OutputIteratorT> ::value_type, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::SCAN_ALGORITHM>  BlockScanT; 
# 154
typedef TilePrefixCallbackOp< typename std::iterator_traits< OutputIteratorT> ::value_type, ScanOpT, ScanTileState< typename std::iterator_traits< OutputIteratorT> ::value_type> >  TilePrefixCallbackOpT; 
# 160
typedef BlockScanRunningPrefixOp< typename std::iterator_traits< OutputIteratorT> ::value_type, ScanOpT>  RunningPrefixCallbackOp; 
# 163
union _TempStorage { 
# 165
typename BlockLoad< typename If< IsPointer< InputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentScanPolicyT::LOAD_MODIFIER, typename std::iterator_traits< InputIteratorT> ::value_type, OffsetT> , InputIteratorT> ::Type, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::ITEMS_PER_THREAD, AgentScanPolicyT::LOAD_ALGORITHM> ::TempStorage load; 
# 166
typename BlockStore< OutputIteratorT, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::ITEMS_PER_THREAD, AgentScanPolicyT::STORE_ALGORITHM> ::TempStorage store; 
# 169
struct { 
# 170
typename TilePrefixCallbackOp< typename std::iterator_traits< OutputIteratorT> ::value_type, ScanOpT, ScanTileState< typename std::iterator_traits< OutputIteratorT> ::value_type> > ::TempStorage prefix; 
# 171
typename BlockScan< typename std::iterator_traits< OutputIteratorT> ::value_type, AgentScanPolicyT::BLOCK_THREADS, AgentScanPolicyT::SCAN_ALGORITHM> ::TempStorage scan; 
# 172
}; 
# 173
}; 
# 176
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 183
_TempStorage &temp_storage; 
# 184
WrappedInputIteratorT d_in; 
# 185
OutputIteratorT d_out; 
# 186
ScanOpT scan_op; 
# 187
InitValueT init_value; 
# 197
__attribute((always_inline)) void 
# 198
ScanTile(OutputT (&
# 199
items)[ITEMS_PER_THREAD], OutputT 
# 200
init_value, ScanOpT 
# 201
scan_op, OutputT &
# 202
block_aggregate, Int2Type< 0>  
# 203
is_inclusive) 
# 204
{int volatile ___ = 1;(void)items;(void)init_value;(void)scan_op;(void)block_aggregate;(void)is_inclusive;
# 207
::exit(___);}
#if 0
# 204
{ 
# 205
(((BlockScanT)(((temp_storage).scan))).ExclusiveScan(items, items, init_value, scan_op, block_aggregate)); 
# 206
block_aggregate = scan_op(init_value, block_aggregate); 
# 207
} 
#endif
# 213 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
__attribute((always_inline)) void 
# 214
ScanTile(OutputT (&
# 215
items)[ITEMS_PER_THREAD], InitValueT 
# 216
init_value, ScanOpT 
# 217
scan_op, OutputT &
# 218
block_aggregate, Int2Type< 1>  
# 219
is_inclusive) 
# 220
{int volatile ___ = 1;(void)items;(void)init_value;(void)scan_op;(void)block_aggregate;(void)is_inclusive;
# 222
::exit(___);}
#if 0
# 220
{ 
# 221
(((BlockScanT)(((temp_storage).scan))).InclusiveScan(items, items, scan_op, block_aggregate)); 
# 222
} 
#endif
# 228 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
template< class PrefixCallback> 
# 229
__attribute((always_inline)) void 
# 230
ScanTile(OutputT (&
# 231
items)[ITEMS_PER_THREAD], ScanOpT 
# 232
scan_op, PrefixCallback &
# 233
prefix_op, Int2Type< 0>  
# 234
is_inclusive) 
# 235
{int volatile ___ = 1;(void)items;(void)scan_op;(void)prefix_op;(void)is_inclusive;
# 237
::exit(___);}
#if 0
# 235
{ 
# 236
(((BlockScanT)(((temp_storage).scan))).ExclusiveScan(items, items, scan_op, prefix_op)); 
# 237
} 
#endif
# 243 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
template< class PrefixCallback> 
# 244
__attribute((always_inline)) void 
# 245
ScanTile(OutputT (&
# 246
items)[ITEMS_PER_THREAD], ScanOpT 
# 247
scan_op, PrefixCallback &
# 248
prefix_op, Int2Type< 1>  
# 249
is_inclusive) 
# 250
{int volatile ___ = 1;(void)items;(void)scan_op;(void)prefix_op;(void)is_inclusive;
# 252
::exit(___);}
#if 0
# 250
{ 
# 251
(((BlockScanT)(((temp_storage).scan))).InclusiveScan(items, items, scan_op, prefix_op)); 
# 252
} 
#endif
# 260 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
__attribute((always_inline)) 
# 261
AgentScan(TempStorage &
# 262
temp_storage, InputIteratorT 
# 263
d_in, OutputIteratorT 
# 264
d_out, ScanOpT 
# 265
scan_op, InitValueT 
# 266
init_value) : temp_storage((temp_storage.Alias())), d_in(d_in), d_out(d_out), scan_op(scan_op), init_value(init_value) 
# 273
{int *volatile ___ = 0;(void)temp_storage;(void)d_in;(void)d_out;(void)scan_op;(void)init_value;::free(___);}
#if 0
# 273
{ } 
#endif
# 283 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
template< bool IS_LAST_TILE> 
# 284
__attribute((always_inline)) void ConsumeTile(OffsetT 
# 285
num_remaining, int 
# 286
tile_idx, OffsetT 
# 287
tile_offset, ScanTileStateT &
# 288
tile_state) 
# 289
{int volatile ___ = 1;(void)num_remaining;(void)tile_idx;(void)tile_offset;(void)tile_state;
# 323
::exit(___);}
#if 0
# 289
{ 
# 291
OutputT items[ITEMS_PER_THREAD]; 
# 293
if (IS_LAST_TILE) { 
# 294
(((BlockLoadT)(((temp_storage).load))).Load((d_in) + tile_offset, items, num_remaining)); } else { 
# 296
(((BlockLoadT)(((temp_storage).load))).Load((d_in) + tile_offset, items)); }  
# 298
__syncthreads(); 
# 301
if (tile_idx == 0) 
# 302
{ 
# 304
OutputT block_aggregate; 
# 305
ScanTile(items, init_value, scan_op, block_aggregate, Int2Type< IS_INCLUSIVE> ()); 
# 306
if ((!IS_LAST_TILE) && ((__device_builtin_variable_threadIdx.x) == (0))) { 
# 307
(tile_state.SetInclusive(0, block_aggregate)); }  
# 308
} else 
# 310
{ 
# 312
TilePrefixCallbackOpT prefix_op(tile_state, ((temp_storage).prefix), scan_op, tile_idx); 
# 313
ScanTile(items, scan_op, prefix_op, Int2Type< IS_INCLUSIVE> ()); 
# 314
}  
# 316
__syncthreads(); 
# 319
if (IS_LAST_TILE) { 
# 320
(((BlockStoreT)(((temp_storage).store))).Store((d_out) + tile_offset, items, num_remaining)); } else { 
# 322
(((BlockStoreT)(((temp_storage).store))).Store((d_out) + tile_offset, items)); }  
# 323
} 
#endif
# 329 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
__attribute((always_inline)) void ConsumeRange(int 
# 330
num_items, ScanTileStateT &
# 331
tile_state, int 
# 332
start_tile) 
# 333
{int volatile ___ = 1;(void)num_items;(void)tile_state;(void)start_tile;
# 349
::exit(___);}
#if 0
# 333
{ 
# 335
int tile_idx = start_tile + (__device_builtin_variable_blockIdx.x); 
# 336
OffsetT tile_offset = ((OffsetT)(TILE_ITEMS)) * tile_idx; 
# 337
OffsetT num_remaining = num_items - tile_offset; 
# 339
if (num_remaining > (TILE_ITEMS)) 
# 340
{ 
# 342
ConsumeTile< false> (num_remaining, tile_idx, tile_offset, tile_state); 
# 343
} else { 
# 344
if (num_remaining > 0) 
# 345
{ 
# 347
ConsumeTile< true> (num_remaining, tile_idx, tile_offset, tile_state); 
# 348
}  }  
# 349
} 
#endif
# 359 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
template< bool 
# 360
IS_FIRST_TILE, bool 
# 361
IS_LAST_TILE> 
# 362
__attribute((always_inline)) void ConsumeTile(OffsetT 
# 363
tile_offset, RunningPrefixCallbackOp &
# 364
prefix_op, int 
# 365
valid_items = TILE_ITEMS) 
# 366
{int volatile ___ = 1;(void)tile_offset;(void)prefix_op;(void)valid_items;
# 396
::exit(___);}
#if 0
# 366
{ 
# 368
OutputT items[ITEMS_PER_THREAD]; 
# 370
if (IS_LAST_TILE) { 
# 371
(((BlockLoadT)(((temp_storage).load))).Load((d_in) + tile_offset, items, valid_items)); } else { 
# 373
(((BlockLoadT)(((temp_storage).load))).Load((d_in) + tile_offset, items)); }  
# 375
__syncthreads(); 
# 378
if (IS_FIRST_TILE) 
# 379
{ 
# 380
OutputT block_aggregate; 
# 381
ScanTile(items, init_value, scan_op, block_aggregate, Int2Type< IS_INCLUSIVE> ()); 
# 382
(prefix_op.running_total) = block_aggregate; 
# 383
} else 
# 385
{ 
# 386
ScanTile(items, scan_op, prefix_op, Int2Type< IS_INCLUSIVE> ()); 
# 387
}  
# 389
__syncthreads(); 
# 392
if (IS_LAST_TILE) { 
# 393
(((BlockStoreT)(((temp_storage).store))).Store((d_out) + tile_offset, items, valid_items)); } else { 
# 395
(((BlockStoreT)(((temp_storage).store))).Store((d_out) + tile_offset, items)); }  
# 396
} 
#endif
# 402 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
__attribute((always_inline)) void ConsumeRange(OffsetT 
# 403
range_offset, OffsetT 
# 404
range_end) 
# 405
{int volatile ___ = 1;(void)range_offset;(void)range_end;
# 434
::exit(___);}
#if 0
# 405
{ 
# 406
BlockScanRunningPrefixOp< typename std::iterator_traits< OutputIteratorT> ::value_type, ScanOpT>  prefix_op(scan_op); 
# 408
if ((range_offset + (TILE_ITEMS)) <= range_end) 
# 409
{ 
# 411
ConsumeTile< true, true> (range_offset, prefix_op); 
# 412
range_offset += (TILE_ITEMS); 
# 415
while ((range_offset + (TILE_ITEMS)) <= range_end) 
# 416
{ 
# 417
ConsumeTile< false, true> (range_offset, prefix_op); 
# 418
range_offset += (TILE_ITEMS); 
# 419
}  
# 422
if (range_offset < range_end) 
# 423
{ 
# 424
int valid_items = range_end - range_offset; 
# 425
ConsumeTile< false, false> (range_offset, prefix_op, valid_items); 
# 426
}  
# 427
} else 
# 429
{ 
# 431
int valid_items = range_end - range_offset; 
# 432
ConsumeTile< true, false> (range_offset, prefix_op, valid_items); 
# 433
}  
# 434
} 
#endif
# 440 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
__attribute((always_inline)) void ConsumeRange(OffsetT 
# 441
range_offset, OffsetT 
# 442
range_end, OutputT 
# 443
prefix) 
# 444
{int volatile ___ = 1;(void)range_offset;(void)range_end;(void)prefix;
# 460
::exit(___);}
#if 0
# 444
{ 
# 445
BlockScanRunningPrefixOp< typename std::iterator_traits< OutputIteratorT> ::value_type, ScanOpT>  prefix_op(prefix, scan_op); 
# 448
while ((range_offset + (TILE_ITEMS)) <= range_end) 
# 449
{ 
# 450
ConsumeTile< true, false> (range_offset, prefix_op); 
# 451
range_offset += (TILE_ITEMS); 
# 452
}  
# 455
if (range_offset < range_end) 
# 456
{ 
# 457
int valid_items = range_end - range_offset; 
# 458
ConsumeTile< false, false> (range_offset, prefix_op, valid_items); 
# 459
}  
# 460
} 
#endif
# 462 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_scan.cuh"
}; 
# 465
}
# 52 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
namespace cub { 
# 62
template< class 
# 63
ScanTileStateT> static void 
# 64
__wrapper__device_stub_DeviceScanInitKernel(ScanTileStateT &
# 65
tile_state, int &
# 66
num_tiles) {exit(1);}
#if 0
# 67
{ 
# 69
(tile_state.InitializeStatus(num_tiles)); 
# 70
} 
#endif
# 62 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 63
ScanTileStateT> void 
# 64
DeviceScanInitKernel(ScanTileStateT 
# 65
tile_state, int 
# 66
num_tiles) 
# 67
{__wrapper__device_stub_DeviceScanInitKernel<ScanTileStateT>(tile_state,num_tiles);
# 70
return;}
#if 0
# 67
{ 
# 69
(tile_state.InitializeStatus(num_tiles)); 
# 70
} 
#endif
# 75 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 76
ScanTileStateT, class 
# 77
NumSelectedIteratorT> static void 
# 78
__wrapper__device_stub_DeviceCompactInitKernel(ScanTileStateT &
# 79
tile_state, int &
# 80
num_tiles, NumSelectedIteratorT &
# 81
d_num_selected_out) {exit(1);}
#if 0
# 82
{ 
# 84
(tile_state.InitializeStatus(num_tiles)); 
# 87
if (((__device_builtin_variable_blockIdx.x) == (0)) && ((__device_builtin_variable_threadIdx.x) == (0))) { 
# 88
(*d_num_selected_out) = 0; }  
# 89
} 
#endif
# 75 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 76
ScanTileStateT, class 
# 77
NumSelectedIteratorT> void 
# 78
DeviceCompactInitKernel(ScanTileStateT 
# 79
tile_state, int 
# 80
num_tiles, NumSelectedIteratorT 
# 81
d_num_selected_out) 
# 82
{__wrapper__device_stub_DeviceCompactInitKernel<ScanTileStateT,NumSelectedIteratorT>(tile_state,num_tiles,d_num_selected_out);
# 89
return;}
#if 0
# 82
{ 
# 84
(tile_state.InitializeStatus(num_tiles)); 
# 87
if (((__device_builtin_variable_blockIdx.x) == (0)) && ((__device_builtin_variable_threadIdx.x) == (0))) { 
# 88
(*d_num_selected_out) = 0; }  
# 89
} 
#endif
# 95 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 96
ScanPolicyT, class 
# 97
InputIteratorT, class 
# 98
OutputIteratorT, class 
# 99
ScanTileStateT, class 
# 100
ScanOpT, class 
# 101
InitValueT, class 
# 102
OffsetT> static void 
# 104
__wrapper__device_stub_DeviceScanKernel(InputIteratorT &
# 105
d_in, OutputIteratorT &
# 106
d_out, ScanTileStateT &
# 107
tile_state, int &
# 108
start_tile, ScanOpT &
# 109
scan_op, InitValueT &
# 110
init_value, OffsetT &
# 111
num_items) {exit(1);}
#if 0
# 112
{ 
# 120
typedef AgentScan< ScanPolicyT, InputIteratorT, OutputIteratorT, ScanOpT, InitValueT, OffsetT>  AgentScanT; 
# 123
__attribute__((unused)) static typename AgentScan< ScanPolicyT, InputIteratorT, OutputIteratorT, ScanOpT, InitValueT, OffsetT> ::TempStorage temp_storage; 
# 126
(AgentScanT(temp_storage, d_in, d_out, scan_op, init_value).ConsumeRange(num_items, tile_state, start_tile)); 
# 130
} 
#endif
# 95 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 96
ScanPolicyT, class 
# 97
InputIteratorT, class 
# 98
OutputIteratorT, class 
# 99
ScanTileStateT, class 
# 100
ScanOpT, class 
# 101
InitValueT, class 
# 102
OffsetT> void 
# 104
DeviceScanKernel(InputIteratorT 
# 105
d_in, OutputIteratorT 
# 106
d_out, ScanTileStateT 
# 107
tile_state, int 
# 108
start_tile, ScanOpT 
# 109
scan_op, InitValueT 
# 110
init_value, OffsetT 
# 111
num_items) 
# 112
{__wrapper__device_stub_DeviceScanKernel<ScanPolicyT,InputIteratorT,OutputIteratorT,ScanTileStateT,ScanOpT,InitValueT,OffsetT>(d_in,d_out,tile_state,start_tile,scan_op,init_value,num_items);
# 130
return;}
#if 0
# 112
{ 
# 120
typedef AgentScan< ScanPolicyT, InputIteratorT, OutputIteratorT, ScanOpT, InitValueT, OffsetT>  AgentScanT; 
# 123
__attribute__((unused)) static typename AgentScan< ScanPolicyT, InputIteratorT, OutputIteratorT, ScanOpT, InitValueT, OffsetT> ::TempStorage temp_storage; 
# 126
(AgentScanT(temp_storage, d_in, d_out, scan_op, init_value).ConsumeRange(num_items, tile_state, start_tile)); 
# 130
} 
#endif
# 143 "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh"
template< class 
# 144
InputIteratorT, class 
# 145
OutputIteratorT, class 
# 146
ScanOpT, class 
# 147
InitValueT, class 
# 148
OffsetT> 
# 149
struct DispatchScan { 
# 156
enum { 
# 157
INIT_KERNEL_THREADS = 128
# 158
}; 
# 161
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputT; 
# 162
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 165
typedef ScanTileState< typename std::iterator_traits< OutputIteratorT> ::value_type>  ScanTileStateT; 
# 174
struct Policy520 { 
# 183
typedef AgentScanPolicy< (((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2), ((((((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1)) < (12 * 2)) ? (((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1) : (12 * 2)), BLOCK_LOAD_DIRECT, LOAD_LDG, BLOCK_STORE_WARP_TRANSPOSE, BLOCK_SCAN_WARP_SCANS>  ScanPolicyT; 
# 184
}; 
# 188
struct Policy350 { 
# 197
typedef AgentScanPolicy< (((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2), ((((((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1)) < (12 * 2)) ? (((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1) : (12 * 2)), BLOCK_LOAD_DIRECT, LOAD_LDG, BLOCK_STORE_WARP_TRANSPOSE_TIMESLICED, BLOCK_SCAN_RAKING>  ScanPolicyT; 
# 198
}; 
# 201
struct Policy300 { 
# 209
typedef AgentScanPolicy< (((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2), ((((((((9 * 256) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((9 * 256) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1)) < (9 * 2)) ? (((((9 * 256) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2))) > (1)) ? (((9 * 256) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4))) < (256 * 2)) ? (1 << 5) * (((((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((256 / (1 << 5)) * 3) / 4)) ? ((256 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((256 / (1 << 5)) * 3) / 4)) : (256 * 2)) : (1) : (9 * 2)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_STORE_WARP_TRANSPOSE, BLOCK_SCAN_WARP_SCANS>  ScanPolicyT; 
# 210
}; 
# 213
struct Policy200 { 
# 222
typedef AgentScanPolicy< (((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2), ((((((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1)) < (12 * 2)) ? (((((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2))) > (1)) ? (((12 * 128) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4))) < (128 * 2)) ? (1 << 5) * (((((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((128 / (1 << 5)) * 3) / 4)) ? ((128 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((128 / (1 << 5)) * 3) / 4)) : (128 * 2)) : (1) : (12 * 2)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_STORE_WARP_TRANSPOSE, BLOCK_SCAN_WARP_SCANS>  ScanPolicyT; 
# 223
}; 
# 226
struct Policy130 { 
# 234
typedef AgentScanPolicy< (((1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4))) < (96 * 2)) ? (1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4)) : (96 * 2), ((((((((21 * 96) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4))) < (96 * 2)) ? (1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4)) : (96 * 2))) > (1)) ? (((21 * 96) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4))) < (96 * 2)) ? (1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4)) : (96 * 2)) : (1)) < (21 * 2)) ? (((((21 * 96) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4))) < (96 * 2)) ? (1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4)) : (96 * 2))) > (1)) ? (((21 * 96) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4))) < (96 * 2)) ? (1 << 5) * (((((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((96 / (1 << 5)) * 3) / 4)) ? ((96 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((96 / (1 << 5)) * 3) / 4)) : (96 * 2)) : (1) : (21 * 2)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_STORE_WARP_TRANSPOSE, BLOCK_SCAN_RAKING_MEMOIZE>  ScanPolicyT; 
# 235
}; 
# 238
struct Policy100 { 
# 246
typedef AgentScanPolicy< (((1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4))) < (64 * 2)) ? (1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4)) : (64 * 2), ((((((((9 * 64) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4))) < (64 * 2)) ? (1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4)) : (64 * 2))) > (1)) ? (((9 * 64) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4))) < (64 * 2)) ? (1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4)) : (64 * 2)) : (1)) < (9 * 2)) ? (((((9 * 64) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4))) < (64 * 2)) ? (1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4)) : (64 * 2))) > (1)) ? (((9 * 64) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) / ((((1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4))) < (64 * 2)) ? (1 << 5) * (((((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type)) > (((64 / (1 << 5)) * 3) / 4)) ? ((64 / (1 << 5)) * 4) / sizeof(typename std::iterator_traits< OutputIteratorT> ::value_type) : (((64 / (1 << 5)) * 3) / 4)) : (64 * 2)) : (1) : (9 * 2)), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_STORE_WARP_TRANSPOSE, BLOCK_SCAN_WARP_SCANS>  ScanPolicyT; 
# 247
}; 
# 270
typedef Policy100 PtxPolicy; 
# 275
struct PtxAgentScanPolicy : public Policy100::ScanPolicyT { }; 
# 285
template< class KernelConfig> 
# 286
__attribute((always_inline)) static void 
# 287
InitConfigs(int 
# 288
ptx_version, KernelConfig &
# 289
scan_kernel_config) 
# 290
{ 
# 299
if (ptx_version >= 520) 
# 300
{ 
# 301
(scan_kernel_config.template Init< typename Policy520::ScanPolicyT> ()); 
# 302
} else { 
# 303
if (ptx_version >= 350) 
# 304
{ 
# 305
(scan_kernel_config.template Init< typename Policy350::ScanPolicyT> ()); 
# 306
} else { 
# 307
if (ptx_version >= 300) 
# 308
{ 
# 309
(scan_kernel_config.template Init< typename Policy300::ScanPolicyT> ()); 
# 310
} else { 
# 311
if (ptx_version >= 200) 
# 312
{ 
# 313
(scan_kernel_config.template Init< typename Policy200::ScanPolicyT> ()); 
# 314
} else { 
# 315
if (ptx_version >= 130) 
# 316
{ 
# 317
(scan_kernel_config.template Init< typename Policy130::ScanPolicyT> ()); 
# 318
} else 
# 320
{ 
# 321
(scan_kernel_config.template Init< typename Policy100::ScanPolicyT> ()); 
# 322
}  }  }  }  }  
# 325
} 
# 331
struct KernelConfig { 
# 333
int block_threads; 
# 334
int items_per_thread; 
# 335
int tile_items; 
# 337
template< class PolicyT> 
# 338
__attribute((always_inline)) void 
# 339
Init() 
# 340
{ 
# 341
(block_threads) = PolicyT::BLOCK_THREADS; 
# 342
(items_per_thread) = PolicyT::ITEMS_PER_THREAD; 
# 343
(tile_items) = ((block_threads) * (items_per_thread)); 
# 344
} 
# 345
}; 
# 356
template< class 
# 357
ScanInitKernelPtrT, class 
# 358
ScanSweepKernelPtrT> 
# 359
__attribute((always_inline)) static cudaError_t 
# 360
Dispatch(void *
# 361
d_temp_storage, size_t &
# 362
temp_storage_bytes, InputIteratorT 
# 363
d_in, OutputIteratorT 
# 364
d_out, ScanOpT 
# 365
scan_op, InitValueT 
# 366
init_value, OffsetT 
# 367
num_items, cudaStream_t 
# 368
stream, bool 
# 369
debug_synchronous, int 
# 370
ptx_version, ScanInitKernelPtrT 
# 371
init_kernel, ScanSweepKernelPtrT 
# 372
scan_kernel, KernelConfig 
# 373
scan_kernel_config) 
# 374
{ 
# 382
cudaError error = cudaSuccess; 
# 383
do 
# 384
{ 
# 386
int device_ordinal; 
# 387
if (cub::Debug(error = cudaGetDevice(&device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 387)) { break; }  
# 390
int sm_count; 
# 391
if (cub::Debug(error = cudaDeviceGetAttribute(&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 391)) { break; }  
# 394
int tile_size = (scan_kernel_config.block_threads) * (scan_kernel_config.items_per_thread); 
# 395
int num_tiles = ((num_items + tile_size) - 1) / tile_size; 
# 398
size_t allocation_sizes[1]; 
# 399
if (cub::Debug(error = ScanTileStateT::AllocationSize(num_tiles, (allocation_sizes)[0]), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 399)) { break; }  
# 402
void *allocations[1]; 
# 403
if (cub::Debug(error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 403)) { break; }  
# 404
if (d_temp_storage == (__null)) 
# 405
{ 
# 407
break; 
# 408
}  
# 411
if (num_items == 0) { 
# 412
break; }  
# 415
ScanTileStateT tile_state; 
# 416
if (cub::Debug(error = (tile_state.Init(num_tiles, (allocations)[0], (allocation_sizes)[0])), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 416)) { break; }  
# 419
int init_grid_size = ((num_tiles + (INIT_KERNEL_THREADS)) - 1) / (INIT_KERNEL_THREADS); 
# 420
if (debug_synchronous) { printf("Invoking init_kernel<<<%d, %d, 0, %lld>>>()\n", init_grid_size, INIT_KERNEL_THREADS, (long long)stream); }  ; 
# 423
(cudaConfigureCall(init_grid_size, INIT_KERNEL_THREADS, 0, stream)) ? (void)0 : init_kernel(tile_state, num_tiles); 
# 428
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 428)) { break; }  
# 431
if (debug_synchronous && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 431))) { break; }  
# 434
int scan_sm_occupancy; 
# 435
if (cub::Debug(error = MaxSmOccupancy(scan_sm_occupancy, scan_kernel, (scan_kernel_config.block_threads)), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 438)) { 
# 438
break; }  
# 441
int max_dim_x; 
# 442
if (cub::Debug(error = cudaDeviceGetAttribute(&max_dim_x, cudaDevAttrMaxGridDimX, device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 442)) { break; }  ; 
# 445
int scan_grid_size = (max_dim_x < num_tiles) ? max_dim_x : num_tiles; 
# 446
for (int start_tile = 0; start_tile < num_tiles; start_tile += scan_grid_size) 
# 447
{ 
# 449
if (debug_synchronous) { printf("Invoking %d scan_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n", start_tile, scan_grid_size, (scan_kernel_config.block_threads), (long long)stream, (scan_kernel_config.items_per_thread), scan_sm_occupancy); }  
# 450
; 
# 453
(cudaConfigureCall(scan_grid_size, ((scan_kernel_config.block_threads)), 0, stream)) ? (void)0 : scan_kernel(d_in, d_out, tile_state, start_tile, scan_op, init_value, num_items); 
# 463
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 463)) { break; }  
# 466
if (debug_synchronous && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 466))) { break; }  
# 467
}  
# 468
} 
# 469
while (0); 
# 471
return error; 
# 474
} 
# 480
__attribute((always_inline)) static cudaError_t 
# 481
Dispatch(void *
# 482
d_temp_storage, size_t &
# 483
temp_storage_bytes, InputIteratorT 
# 484
d_in, OutputIteratorT 
# 485
d_out, ScanOpT 
# 486
scan_op, InitValueT 
# 487
init_value, OffsetT 
# 488
num_items, cudaStream_t 
# 489
stream, bool 
# 490
debug_synchronous) 
# 491
{ 
# 492
cudaError error = cudaSuccess; 
# 493
do 
# 494
{ 
# 496
int ptx_version; 
# 497
if (cub::Debug(error = PtxVersion(ptx_version), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 497)) { break; }  
# 500
KernelConfig scan_kernel_config; 
# 501
InitConfigs(ptx_version, scan_kernel_config); 
# 504
if (cub::Debug(error = Dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, scan_op, init_value, num_items, stream, debug_synchronous, ptx_version, DeviceScanInitKernel< ScanTileStateT> , DeviceScanKernel< PtxAgentScanPolicy, InputIteratorT, OutputIteratorT, ScanTileStateT, ScanOpT, InitValueT, OffsetT> , scan_kernel_config), "/usr/local/cuda/include/cub/device/dispatch/dispatch_scan.cuh", 517)) { 
# 517
break; }  
# 518
} 
# 519
while (0); 
# 521
return error; 
# 522
} 
# 523
}; 
# 527
}
# 44 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
namespace cub { 
# 102
template< class 
# 103
T, int 
# 104
BLOCK_DIM_X, int 
# 105
BLOCK_DIM_Y = 1, int 
# 106
BLOCK_DIM_Z = 1, int 
# 107
PTX_ARCH = 0> 
# 108
class BlockDiscontinuity { 
# 118
enum { 
# 120
BLOCK_THREADS = (BLOCK_DIM_X * BLOCK_DIM_Y) * BLOCK_DIM_Z
# 121
}; 
# 125
struct _TempStorage { 
# 127
T first_items[BLOCK_THREADS]; 
# 128
T last_items[BLOCK_THREADS]; 
# 129
}; 
# 137
__attribute((always_inline)) _TempStorage &PrivateStorage() 
# 138
{int volatile ___ = 1;
# 141
::exit(___);}
#if 0
# 138
{ 
# 139
__attribute__((unused)) static _TempStorage private_storage; 
# 140
return private_storage; 
# 141
} 
#endif
# 145 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< class FlagOp, bool HAS_PARAM = BinaryOpHasIdxParam< T, FlagOp> ::HAS_PARAM> 
# 146
struct ApplyOp { 
# 149
__attribute((always_inline)) static bool FlagT(FlagOp flag_op, const T &a, const T &b, int idx) 
# 150
{int volatile ___ = 1;(void)flag_op;(void)a;(void)b;(void)idx;
# 152
::exit(___);}
#if 0
# 150
{ 
# 151
return flag_op(a, b, idx); 
# 152
} 
#endif
# 153 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
}; 
# 156
template< class FlagOp> 
# 157
struct ApplyOp< FlagOp, false>  { 
# 160
__attribute((always_inline)) static bool FlagT(FlagOp flag_op, const T &a, const T &b, int idx) 
# 161
{int volatile ___ = 1;(void)flag_op;(void)a;(void)b;(void)idx;
# 163
::exit(___);}
#if 0
# 161
{ 
# 162
return flag_op(a, b); 
# 163
} 
#endif
# 164 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
}; 
# 167
template< int ITERATION, int MAX_ITERATIONS> 
# 168
struct Iterate { 
# 171
template< int 
# 172
ITEMS_PER_THREAD, class 
# 173
FlagT, class 
# 174
FlagOp> 
# 175
__attribute((always_inline)) static void FlagHeads(int 
# 176
linear_tid, FlagT (&
# 177
flags)[ITEMS_PER_THREAD], T (&
# 178
input)[ITEMS_PER_THREAD], T (&
# 179
preds)[ITEMS_PER_THREAD], FlagOp 
# 180
flag_op) 
# 181
{int volatile ___ = 1;(void)linear_tid;(void)flags;(void)input;(void)preds;(void)flag_op;
# 191
::exit(___);}
#if 0
# 181
{ 
# 182
((preds)[ITERATION]) = ((input)[ITERATION - 1]); 
# 184
((flags)[ITERATION]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[ITERATION], (input)[ITERATION], (linear_tid * ITEMS_PER_THREAD) + ITERATION); 
# 190
Iterate< ITERATION + 1, MAX_ITERATIONS> ::FlagHeads(linear_tid, flags, input, preds, flag_op); 
# 191
} 
#endif
# 194 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 195
ITEMS_PER_THREAD, class 
# 196
FlagT, class 
# 197
FlagOp> 
# 198
__attribute((always_inline)) static void FlagTails(int 
# 199
linear_tid, FlagT (&
# 200
flags)[ITEMS_PER_THREAD], T (&
# 201
input)[ITEMS_PER_THREAD], FlagOp 
# 202
flag_op) 
# 203
{int volatile ___ = 1;(void)linear_tid;(void)flags;(void)input;(void)flag_op;
# 211
::exit(___);}
#if 0
# 203
{ 
# 204
((flags)[ITERATION]) = ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITERATION], (input)[ITERATION + 1], ((linear_tid * ITEMS_PER_THREAD) + ITERATION) + 1); 
# 210
Iterate< ITERATION + 1, MAX_ITERATIONS> ::FlagTails(linear_tid, flags, input, flag_op); 
# 211
} 
#endif
# 213 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
}; 
# 216
template< int MAX_ITERATIONS> 
# 217
struct Iterate< MAX_ITERATIONS, MAX_ITERATIONS>  { 
# 220
template< int 
# 221
ITEMS_PER_THREAD, class 
# 222
FlagT, class 
# 223
FlagOp> 
# 224
__attribute((always_inline)) static void FlagHeads(int 
# 225
linear_tid, FlagT (&
# 226
flags)[ITEMS_PER_THREAD], T (&
# 227
input)[ITEMS_PER_THREAD], T (&
# 228
preds)[ITEMS_PER_THREAD], FlagOp 
# 229
flag_op) 
# 230
{int volatile ___ = 1;(void)linear_tid;(void)flags;(void)input;(void)preds;(void)flag_op;::exit(___);}
#if 0
# 230
{ } 
#endif
# 233 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 234
ITEMS_PER_THREAD, class 
# 235
FlagT, class 
# 236
FlagOp> 
# 237
__attribute((always_inline)) static void FlagTails(int 
# 238
linear_tid, FlagT (&
# 239
flags)[ITEMS_PER_THREAD], T (&
# 240
input)[ITEMS_PER_THREAD], FlagOp 
# 241
flag_op) 
# 242
{int volatile ___ = 1;(void)linear_tid;(void)flags;(void)input;(void)flag_op;::exit(___);}
#if 0
# 242
{ } 
#endif
# 243 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
}; 
# 251
_TempStorage &temp_storage; 
# 254
unsigned linear_tid; 
# 260
public: struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 271
__attribute((always_inline)) BlockDiscontinuity() : temp_storage(PrivateStorage()), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 275
{int *volatile ___ = 0;::free(___);}
#if 0
# 275
{ } 
#endif
# 281 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
__attribute((always_inline)) BlockDiscontinuity(TempStorage &
# 282
temp_storage) : temp_storage((temp_storage.Alias())), linear_tid(RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)) 
# 286
{int *volatile ___ = 0;(void)temp_storage;::free(___);}
#if 0
# 286
{ } 
#endif
# 298 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 299
ITEMS_PER_THREAD, class 
# 300
FlagT, class 
# 301
FlagOp> 
# 302
__attribute((always_inline)) void FlagHeads(FlagT (&
# 303
head_flags)[ITEMS_PER_THREAD], T (&
# 304
input)[ITEMS_PER_THREAD], T (&
# 305
preds)[ITEMS_PER_THREAD], FlagOp 
# 306
flag_op) 
# 307
{int volatile ___ = 1;(void)head_flags;(void)input;(void)preds;(void)flag_op;
# 326
::exit(___);}
#if 0
# 307
{ 
# 309
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 311
__syncthreads(); 
# 313
if ((linear_tid) == (0)) 
# 314
{ 
# 316
((head_flags)[0]) = 1; 
# 317
} else 
# 319
{ 
# 320
((preds)[0]) = (((temp_storage).last_items)[(linear_tid) - (1)]); 
# 321
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 322
}  
# 325
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 326
} 
#endif
# 328 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 329
ITEMS_PER_THREAD, class 
# 330
FlagT, class 
# 331
FlagOp> 
# 332
__attribute((always_inline)) void FlagHeads(FlagT (&
# 333
head_flags)[ITEMS_PER_THREAD], T (&
# 334
input)[ITEMS_PER_THREAD], T (&
# 335
preds)[ITEMS_PER_THREAD], FlagOp 
# 336
flag_op, T 
# 337
tile_predecessor_item) 
# 338
{int volatile ___ = 1;(void)head_flags;(void)input;(void)preds;(void)flag_op;(void)tile_predecessor_item;
# 353
::exit(___);}
#if 0
# 338
{ 
# 340
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 342
__syncthreads(); 
# 345
((preds)[0]) = (((linear_tid) == (0)) ? tile_predecessor_item : (((temp_storage).last_items)[(linear_tid) - (1)])); 
# 349
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 352
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 353
} 
#endif
# 407 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 408
ITEMS_PER_THREAD, class 
# 409
FlagT, class 
# 410
FlagOp> 
# 411
__attribute((always_inline)) void FlagHeads(FlagT (&
# 412
head_flags)[ITEMS_PER_THREAD], T (&
# 413
input)[ITEMS_PER_THREAD], FlagOp 
# 414
flag_op) 
# 415
{int volatile ___ = 1;(void)head_flags;(void)input;(void)flag_op;
# 418
::exit(___);}
#if 0
# 415
{ 
# 416
T preds[ITEMS_PER_THREAD]; 
# 417
FlagHeads(head_flags, input, preds, flag_op); 
# 418
} 
#endif
# 476 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 477
ITEMS_PER_THREAD, class 
# 478
FlagT, class 
# 479
FlagOp> 
# 480
__attribute((always_inline)) void FlagHeads(FlagT (&
# 481
head_flags)[ITEMS_PER_THREAD], T (&
# 482
input)[ITEMS_PER_THREAD], FlagOp 
# 483
flag_op, T 
# 484
tile_predecessor_item) 
# 485
{int volatile ___ = 1;(void)head_flags;(void)input;(void)flag_op;(void)tile_predecessor_item;
# 488
::exit(___);}
#if 0
# 485
{ 
# 486
T preds[ITEMS_PER_THREAD]; 
# 487
FlagHeads(head_flags, input, preds, flag_op, tile_predecessor_item); 
# 488
} 
#endif
# 549 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 550
ITEMS_PER_THREAD, class 
# 551
FlagT, class 
# 552
FlagOp> 
# 553
__attribute((always_inline)) void FlagTails(FlagT (&
# 554
tail_flags)[ITEMS_PER_THREAD], T (&
# 555
input)[ITEMS_PER_THREAD], FlagOp 
# 556
flag_op) 
# 557
{int volatile ___ = 1;(void)tail_flags;(void)input;(void)flag_op;
# 574
::exit(___);}
#if 0
# 557
{ 
# 559
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 561
__syncthreads(); 
# 564
((tail_flags)[ITEMS_PER_THREAD - 1]) = (((linear_tid) == ((BLOCK_THREADS) - 1)) ? 1 : ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], ((temp_storage).first_items)[(linear_tid) + (1)], ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD))); 
# 573
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 574
} 
#endif
# 633 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 634
ITEMS_PER_THREAD, class 
# 635
FlagT, class 
# 636
FlagOp> 
# 637
__attribute((always_inline)) void FlagTails(FlagT (&
# 638
tail_flags)[ITEMS_PER_THREAD], T (&
# 639
input)[ITEMS_PER_THREAD], FlagOp 
# 640
flag_op, T 
# 641
tile_successor_item) 
# 642
{int volatile ___ = 1;(void)tail_flags;(void)input;(void)flag_op;(void)tile_successor_item;
# 661
::exit(___);}
#if 0
# 642
{ 
# 644
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 646
__syncthreads(); 
# 649
T successor_item = ((linear_tid) == ((BLOCK_THREADS) - 1)) ? tile_successor_item : (((temp_storage).first_items)[(linear_tid) + (1)]); 
# 653
((tail_flags)[ITEMS_PER_THREAD - 1]) = ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], successor_item, ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD)); 
# 660
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 661
} 
#endif
# 731 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 732
ITEMS_PER_THREAD, class 
# 733
FlagT, class 
# 734
FlagOp> 
# 735
__attribute((always_inline)) void FlagHeadsAndTails(FlagT (&
# 736
head_flags)[ITEMS_PER_THREAD], FlagT (&
# 737
tail_flags)[ITEMS_PER_THREAD], T (&
# 738
input)[ITEMS_PER_THREAD], FlagOp 
# 739
flag_op) 
# 740
{int volatile ___ = 1;(void)head_flags;(void)tail_flags;(void)input;(void)flag_op;
# 779
::exit(___);}
#if 0
# 740
{ 
# 742
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 743
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 745
__syncthreads(); 
# 747
T preds[ITEMS_PER_THREAD]; 
# 750
((preds)[0]) = (((temp_storage).last_items)[(linear_tid) - (1)]); 
# 751
if ((linear_tid) == (0)) 
# 752
{ 
# 753
((head_flags)[0]) = 1; 
# 754
} else 
# 756
{ 
# 757
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 762
}  
# 766
((tail_flags)[ITEMS_PER_THREAD - 1]) = (((linear_tid) == ((BLOCK_THREADS) - 1)) ? 1 : ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], ((temp_storage).first_items)[(linear_tid) + (1)], ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD))); 
# 775
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 778
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 779
} 
#endif
# 847 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 848
ITEMS_PER_THREAD, class 
# 849
FlagT, class 
# 850
FlagOp> 
# 851
__attribute((always_inline)) void FlagHeadsAndTails(FlagT (&
# 852
head_flags)[ITEMS_PER_THREAD], FlagT (&
# 853
tail_flags)[ITEMS_PER_THREAD], T 
# 854
tile_successor_item, T (&
# 855
input)[ITEMS_PER_THREAD], FlagOp 
# 856
flag_op) 
# 857
{int volatile ___ = 1;(void)head_flags;(void)tail_flags;(void)tile_successor_item;(void)input;(void)flag_op;
# 897
::exit(___);}
#if 0
# 857
{ 
# 859
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 860
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 862
__syncthreads(); 
# 864
T preds[ITEMS_PER_THREAD]; 
# 867
if ((linear_tid) == (0)) 
# 868
{ 
# 869
((head_flags)[0]) = 1; 
# 870
} else 
# 872
{ 
# 873
((preds)[0]) = (((temp_storage).last_items)[(linear_tid) - (1)]); 
# 874
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 879
}  
# 882
T successor_item = ((linear_tid) == ((BLOCK_THREADS) - 1)) ? tile_successor_item : (((temp_storage).first_items)[(linear_tid) + (1)]); 
# 886
((tail_flags)[ITEMS_PER_THREAD - 1]) = ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], successor_item, ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD)); 
# 893
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 896
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 897
} 
#endif
# 971 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 972
ITEMS_PER_THREAD, class 
# 973
FlagT, class 
# 974
FlagOp> 
# 975
__attribute((always_inline)) void FlagHeadsAndTails(FlagT (&
# 976
head_flags)[ITEMS_PER_THREAD], T 
# 977
tile_predecessor_item, FlagT (&
# 978
tail_flags)[ITEMS_PER_THREAD], T (&
# 979
input)[ITEMS_PER_THREAD], FlagOp 
# 980
flag_op) 
# 981
{int volatile ___ = 1;(void)head_flags;(void)tile_predecessor_item;(void)tail_flags;(void)input;(void)flag_op;
# 1015
::exit(___);}
#if 0
# 981
{ 
# 983
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 984
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 986
__syncthreads(); 
# 988
T preds[ITEMS_PER_THREAD]; 
# 991
((preds)[0]) = (((linear_tid) == (0)) ? tile_predecessor_item : (((temp_storage).last_items)[(linear_tid) - (1)])); 
# 995
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 1002
((tail_flags)[ITEMS_PER_THREAD - 1]) = (((linear_tid) == ((BLOCK_THREADS) - 1)) ? 1 : ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], ((temp_storage).first_items)[(linear_tid) + (1)], ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD))); 
# 1011
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 1014
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 1015
} 
#endif
# 1090 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
template< int 
# 1091
ITEMS_PER_THREAD, class 
# 1092
FlagT, class 
# 1093
FlagOp> 
# 1094
__attribute((always_inline)) void FlagHeadsAndTails(FlagT (&
# 1095
head_flags)[ITEMS_PER_THREAD], T 
# 1096
tile_predecessor_item, FlagT (&
# 1097
tail_flags)[ITEMS_PER_THREAD], T 
# 1098
tile_successor_item, T (&
# 1099
input)[ITEMS_PER_THREAD], FlagOp 
# 1100
flag_op) 
# 1101
{int volatile ___ = 1;(void)head_flags;(void)tile_predecessor_item;(void)tail_flags;(void)tile_successor_item;(void)input;(void)flag_op;
# 1137
::exit(___);}
#if 0
# 1101
{ 
# 1103
(((temp_storage).first_items)[linear_tid]) = ((input)[0]); 
# 1104
(((temp_storage).last_items)[linear_tid]) = ((input)[ITEMS_PER_THREAD - 1]); 
# 1106
__syncthreads(); 
# 1108
T preds[ITEMS_PER_THREAD]; 
# 1111
((preds)[0]) = (((linear_tid) == (0)) ? tile_predecessor_item : (((temp_storage).last_items)[(linear_tid) - (1)])); 
# 1115
((head_flags)[0]) = ApplyOp< FlagOp> ::FlagT(flag_op, (preds)[0], (input)[0], (linear_tid) * (ITEMS_PER_THREAD)); 
# 1122
T successor_item = ((linear_tid) == ((BLOCK_THREADS) - 1)) ? tile_successor_item : (((temp_storage).first_items)[(linear_tid) + (1)]); 
# 1126
((tail_flags)[ITEMS_PER_THREAD - 1]) = ApplyOp< FlagOp> ::FlagT(flag_op, (input)[ITEMS_PER_THREAD - 1], successor_item, ((linear_tid) * (ITEMS_PER_THREAD)) + (ITEMS_PER_THREAD)); 
# 1133
Iterate< 1, ITEMS_PER_THREAD> ::FlagHeads(linear_tid, head_flags, input, preds, flag_op); 
# 1136
Iterate< 0, ITEMS_PER_THREAD - 1> ::FlagTails(linear_tid, tail_flags, input, flag_op); 
# 1137
} 
#endif
# 1144 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../block/block_discontinuity.cuh"
}; 
# 1147
}
# 54 "/usr/local/cuda/include/cub/device/dispatch/../../agent/../iterator/constant_input_iterator.cuh"
namespace cub { 
# 93
template< class 
# 94
ValueType, class 
# 95
OffsetT = ptrdiff_t> 
# 96
class ConstantInputIterator { 
# 101
public: typedef ConstantInputIterator self_type; 
# 102
typedef OffsetT difference_type; 
# 103
typedef ValueType value_type; 
# 104
typedef ValueType *pointer; 
# 105
typedef ValueType reference; 
# 114
typedef typename thrust::detail::iterator_facade_category< thrust::any_system_tag, thrust::random_access_traversal_tag, ValueType, ValueType> ::type iterator_category; 
# 121
private: ValueType val; 
# 122
OffsetT offset; 
# 130
public: __attribute((always_inline)) ConstantInputIterator(ValueType 
# 131
val, OffsetT 
# 132
offset = 0) : val(val), offset(offset) 
# 136
{ } 
# 139
__attribute((always_inline)) self_type operator++(int) 
# 140
{ 
# 141
self_type retval = *this; 
# 142
(offset)++; 
# 143
return retval; 
# 144
} 
# 147
__attribute((always_inline)) self_type operator++() 
# 148
{ 
# 149
(offset)++; 
# 150
return *this; 
# 151
} 
# 154
__attribute((always_inline)) reference operator*() const 
# 155
{ 
# 156
return val; 
# 157
} 
# 160
template< class Distance> 
# 161
__attribute((always_inline)) self_type operator+(Distance n) const 
# 162
{ 
# 163
self_type retval(val, (offset) + n); 
# 164
return retval; 
# 165
} 
# 168
template< class Distance> 
# 169
__attribute((always_inline)) self_type &operator+=(Distance n) 
# 170
{ 
# 171
(offset) += n; 
# 172
return *this; 
# 173
} 
# 176
template< class Distance> 
# 177
__attribute((always_inline)) self_type operator-(Distance n) const 
# 178
{ 
# 179
self_type retval(val, (offset) - n); 
# 180
return retval; 
# 181
} 
# 184
template< class Distance> 
# 185
__attribute((always_inline)) self_type &operator-=(Distance n) 
# 186
{ 
# 187
(offset) -= n; 
# 188
return *this; 
# 189
} 
# 192
__attribute((always_inline)) difference_type operator-(self_type other) const 
# 193
{ 
# 194
return (offset) - (other.offset); 
# 195
} 
# 198
template< class Distance> 
# 199
__attribute((always_inline)) reference operator[](Distance n) const 
# 200
{ 
# 201
return val; 
# 202
} 
# 205
__attribute((always_inline)) pointer operator->() 
# 206
{ 
# 207
return &(val); 
# 208
} 
# 211
__attribute((always_inline)) bool operator==(const self_type &rhs) 
# 212
{ 
# 213
return ((offset) == (rhs.offset)) && ((val) == (rhs.val)); 
# 214
} 
# 217
__attribute((always_inline)) bool operator!=(const self_type &rhs) 
# 218
{ 
# 219
return ((offset) != (rhs.offset)) || ((val) != (rhs.val)); 
# 220
} 
# 223
friend inline std::ostream &operator<<(std::ostream &os, const self_type &itr) 
# 224
{ 
# 225
(((((os << ("["))) << (itr.val)) << ",") << (itr.offset)) << "]"; 
# 226
return os; 
# 227
} 
# 229
}; 
# 234
}
# 51 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
namespace cub { 
# 61
template< int 
# 62
_BLOCK_THREADS, int 
# 63
_ITEMS_PER_THREAD, BlockLoadAlgorithm 
# 64
_LOAD_ALGORITHM, CacheLoadModifier 
# 65
_LOAD_MODIFIER, BlockScanAlgorithm 
# 66
_SCAN_ALGORITHM> 
# 67
struct AgentReduceByKeyPolicy { 
# 70
enum { 
# 71
BLOCK_THREADS = _BLOCK_THREADS, 
# 72
ITEMS_PER_THREAD = _ITEMS_PER_THREAD
# 73
}; 
# 75
static const BlockLoadAlgorithm LOAD_ALGORITHM = _LOAD_ALGORITHM; 
# 76
static const CacheLoadModifier LOAD_MODIFIER = _LOAD_MODIFIER; 
# 77
static const BlockScanAlgorithm SCAN_ALGORITHM = _SCAN_ALGORITHM; 
# 78
}; 
# 88
template< class 
# 89
AgentReduceByKeyPolicyT, class 
# 90
KeysInputIteratorT, class 
# 91
UniqueOutputIteratorT, class 
# 92
ValuesInputIteratorT, class 
# 93
AggregatesOutputIteratorT, class 
# 94
NumRunsOutputIteratorT, class 
# 95
EqualityOpT, class 
# 96
ReductionOpT, class 
# 97
OffsetT> 
# 98
struct AgentReduceByKey { 
# 105
typedef typename std::iterator_traits< KeysInputIteratorT> ::value_type KeyT; 
# 108
typedef typename std::iterator_traits< ValuesInputIteratorT> ::value_type ValueT; 
# 111
typedef KeyValuePair< OffsetT, typename std::iterator_traits< ValuesInputIteratorT> ::value_type>  OffsetValuePairT; 
# 114
typedef KeyValuePair< typename std::iterator_traits< KeysInputIteratorT> ::value_type, typename std::iterator_traits< ValuesInputIteratorT> ::value_type>  KeyValuePairT; 
# 117
typedef ReduceByKeyScanTileState< typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT>  ScanTileStateT; 
# 120
template< class _EqualityOpT> 
# 121
struct GuardedInequalityWrapper { 
# 123
_EqualityOpT op; 
# 124
int num_remaining; 
# 127
__attribute((always_inline)) 
# 128
GuardedInequalityWrapper(_EqualityOpT op, int num_remaining) : op(op), num_remaining(num_remaining) { } 
# 131
template< class T> 
# 132
__attribute((always_inline)) bool operator()(const T &a, const T &b, int idx) const 
# 133
{ 
# 134
if (idx < (num_remaining)) { 
# 135
return !(op)(a, b); }  
# 138
return idx == (num_remaining); 
# 139
} 
# 140
}; 
# 145
enum { 
# 146
BLOCK_THREADS = AgentReduceByKeyPolicyT::BLOCK_THREADS, 
# 147
ITEMS_PER_THREAD = AgentReduceByKeyPolicyT::ITEMS_PER_THREAD, 
# 148
TILE_ITEMS = (AgentReduceByKeyPolicyT::BLOCK_THREADS) * (AgentReduceByKeyPolicyT::ITEMS_PER_THREAD), 
# 149
TWO_PHASE_SCATTER = (AgentReduceByKeyPolicyT::ITEMS_PER_THREAD) > 1, 
# 152
HAS_IDENTITY_ZERO = Equals< ReductionOpT, Sum> ::VALUE && Traits< typename std::iterator_traits< ValuesInputIteratorT> ::value_type> ::PRIMITIVE
# 153
}; 
# 159
typedef typename If< IsPointer< KeysInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< KeysInputIteratorT> ::value_type, OffsetT> , KeysInputIteratorT> ::Type WrappedKeysInputIteratorT; 
# 165
typedef typename If< IsPointer< ValuesInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> , ValuesInputIteratorT> ::Type WrappedValuesInputIteratorT; 
# 171
typedef typename If< IsPointer< AggregatesOutputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> , AggregatesOutputIteratorT> ::Type WrappedFixupInputIteratorT; 
# 174
typedef ReduceBySegmentOp< ReductionOpT>  ReduceBySegmentOpT; 
# 182
typedef BlockLoad< typename If< IsPointer< KeysInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< KeysInputIteratorT> ::value_type, OffsetT> , KeysInputIteratorT> ::Type, BLOCK_THREADS, ITEMS_PER_THREAD, AgentReduceByKeyPolicyT::LOAD_ALGORITHM>  BlockLoadKeysT; 
# 190
typedef BlockLoad< typename If< IsPointer< ValuesInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> , ValuesInputIteratorT> ::Type, BLOCK_THREADS, ITEMS_PER_THREAD, AgentReduceByKeyPolicyT::LOAD_ALGORITHM>  BlockLoadValuesT; 
# 196
typedef BlockDiscontinuity< typename std::iterator_traits< KeysInputIteratorT> ::value_type, BLOCK_THREADS>  BlockDiscontinuityKeys; 
# 203
typedef BlockScan< KeyValuePair< OffsetT, typename std::iterator_traits< ValuesInputIteratorT> ::value_type> , BLOCK_THREADS, AgentReduceByKeyPolicyT::SCAN_ALGORITHM>  BlockScanT; 
# 210
typedef TilePrefixCallbackOp< KeyValuePair< OffsetT, typename std::iterator_traits< ValuesInputIteratorT> ::value_type> , ReduceBySegmentOp< ReductionOpT> , ReduceByKeyScanTileState< typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> >  TilePrefixCallbackOpT; 
# 213
typedef KeyT KeyExchangeT[(TILE_ITEMS) + 1]; 
# 214
typedef ValueT ValueExchangeT[(TILE_ITEMS) + 1]; 
# 217
union _TempStorage { 
# 220
struct { 
# 221
typename BlockScan< KeyValuePair< OffsetT, typename std::iterator_traits< ValuesInputIteratorT> ::value_type> , BLOCK_THREADS, AgentReduceByKeyPolicyT::SCAN_ALGORITHM> ::TempStorage scan; 
# 222
typename TilePrefixCallbackOp< KeyValuePair< OffsetT, typename std::iterator_traits< ValuesInputIteratorT> ::value_type> , ReduceBySegmentOp< ReductionOpT> , ReduceByKeyScanTileState< typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> > ::TempStorage prefix; 
# 223
typename BlockDiscontinuity< typename std::iterator_traits< KeysInputIteratorT> ::value_type, BLOCK_THREADS> ::TempStorage discontinuity; 
# 224
}; 
# 227
typename BlockLoad< typename If< IsPointer< KeysInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< KeysInputIteratorT> ::value_type, OffsetT> , KeysInputIteratorT> ::Type, BLOCK_THREADS, ITEMS_PER_THREAD, AgentReduceByKeyPolicyT::LOAD_ALGORITHM> ::TempStorage load_keys; 
# 230
typename BlockLoad< typename If< IsPointer< ValuesInputIteratorT> ::VALUE, CacheModifiedInputIterator< AgentReduceByKeyPolicyT::LOAD_MODIFIER, typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT> , ValuesInputIteratorT> ::Type, BLOCK_THREADS, ITEMS_PER_THREAD, AgentReduceByKeyPolicyT::LOAD_ALGORITHM> ::TempStorage load_values; 
# 233
Uninitialized< KeyValuePair< typename std::iterator_traits< KeysInputIteratorT> ::value_type, typename std::iterator_traits< ValuesInputIteratorT> ::value_type>  [(TILE_ITEMS) + 1]>  raw_exchange; 
# 234
}; 
# 237
struct TempStorage : public Uninitialized< _TempStorage>  { }; 
# 244
_TempStorage &temp_storage; 
# 245
WrappedKeysInputIteratorT d_keys_in; 
# 246
UniqueOutputIteratorT d_unique_out; 
# 247
WrappedValuesInputIteratorT d_values_in; 
# 248
AggregatesOutputIteratorT d_aggregates_out; 
# 249
NumRunsOutputIteratorT d_num_runs_out; 
# 250
EqualityOpT equality_op; 
# 251
ReductionOpT reduction_op; 
# 252
ReduceBySegmentOpT scan_op; 
# 260
__attribute((always_inline)) 
# 261
AgentReduceByKey(TempStorage &
# 262
temp_storage, KeysInputIteratorT 
# 263
d_keys_in, UniqueOutputIteratorT 
# 264
d_unique_out, ValuesInputIteratorT 
# 265
d_values_in, AggregatesOutputIteratorT 
# 266
d_aggregates_out, NumRunsOutputIteratorT 
# 267
d_num_runs_out, EqualityOpT 
# 268
equality_op, ReductionOpT 
# 269
reduction_op) : temp_storage((temp_storage.Alias())), d_keys_in(d_keys_in), d_unique_out(d_unique_out), d_values_in(d_values_in), d_aggregates_out(d_aggregates_out), d_num_runs_out(d_num_runs_out), equality_op(equality_op), reduction_op(reduction_op), scan_op(reduction_op) 
# 280
{int *volatile ___ = 0;(void)temp_storage;(void)d_keys_in;(void)d_unique_out;(void)d_values_in;(void)d_aggregates_out;(void)d_num_runs_out;(void)equality_op;(void)reduction_op;::free(___);}
#if 0
# 280
{ } 
#endif
# 290 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
__attribute((always_inline)) void ScatterDirect(KeyValuePairT (&
# 291
scatter_items)[ITEMS_PER_THREAD], OffsetT (&
# 292
segment_flags)[ITEMS_PER_THREAD], OffsetT (&
# 293
segment_indices)[ITEMS_PER_THREAD]) 
# 294
{int volatile ___ = 1;(void)scatter_items;(void)segment_flags;(void)segment_indices;
# 305
::exit(___);}
#if 0
# 294
{ 
# 297
#pragma unroll
for (
# 297
int ITEM = 0; ITEM < (ITEMS_PER_THREAD); ++ITEM) 
# 298
{ 
# 299
if ((segment_flags)[ITEM]) 
# 300
{ 
# 301
((d_unique_out)[(segment_indices)[ITEM]]) = (((scatter_items)[ITEM]).key); 
# 302
((d_aggregates_out)[(segment_indices)[ITEM]]) = (((scatter_items)[ITEM]).value); 
# 303
}  
# 304
}  
# 305
} 
#endif
# 314 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
__attribute((always_inline)) void ScatterTwoPhase(KeyValuePairT (&
# 315
scatter_items)[ITEMS_PER_THREAD], OffsetT (&
# 316
segment_flags)[ITEMS_PER_THREAD], OffsetT (&
# 317
segment_indices)[ITEMS_PER_THREAD], OffsetT 
# 318
num_tile_segments, OffsetT 
# 319
num_tile_segments_prefix) 
# 320
{int volatile ___ = 1;(void)scatter_items;(void)segment_flags;(void)segment_indices;(void)num_tile_segments;(void)num_tile_segments_prefix;
# 341
::exit(___);}
#if 0
# 320
{ 
# 321
__syncthreads(); 
# 325
#pragma unroll
for (
# 325
int ITEM = 0; ITEM < (ITEMS_PER_THREAD); ++ITEM) 
# 326
{ 
# 327
if ((segment_flags)[ITEM]) 
# 328
{ 
# 329
((((temp_storage).raw_exchange).Alias())[((segment_indices)[ITEM]) - num_tile_segments_prefix]) = ((scatter_items)[ITEM]); 
# 330
}  
# 331
}  
# 333
__syncthreads(); 
# 335
for (int item = __device_builtin_variable_threadIdx.x; item < num_tile_segments; item += (BLOCK_THREADS)) 
# 336
{ 
# 337
KeyValuePairT pair = (((temp_storage).raw_exchange).Alias())[item]; 
# 338
((d_unique_out)[num_tile_segments_prefix + item]) = (pair.key); 
# 339
((d_aggregates_out)[num_tile_segments_prefix + item]) = (pair.value); 
# 340
}  
# 341
} 
#endif
# 347 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
__attribute((always_inline)) void Scatter(KeyValuePairT (&
# 348
scatter_items)[ITEMS_PER_THREAD], OffsetT (&
# 349
segment_flags)[ITEMS_PER_THREAD], OffsetT (&
# 350
segment_indices)[ITEMS_PER_THREAD], OffsetT 
# 351
num_tile_segments, OffsetT 
# 352
num_tile_segments_prefix) 
# 353
{int volatile ___ = 1;(void)scatter_items;(void)segment_flags;(void)segment_indices;(void)num_tile_segments;(void)num_tile_segments_prefix;
# 371
::exit(___);}
#if 0
# 353
{ 
# 355
if ((TWO_PHASE_SCATTER) && (num_tile_segments > (BLOCK_THREADS))) 
# 356
{ 
# 357
ScatterTwoPhase(scatter_items, segment_flags, segment_indices, num_tile_segments, num_tile_segments_prefix); 
# 363
} else 
# 365
{ 
# 366
ScatterDirect(scatter_items, segment_flags, segment_indices); 
# 370
}  
# 371
} 
#endif
# 381 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
template< bool IS_LAST_TILE> 
# 382
__attribute((always_inline)) void ConsumeTile(OffsetT 
# 383
num_remaining, int 
# 384
tile_idx, OffsetT 
# 385
tile_offset, ScanTileStateT &
# 386
tile_state) 
# 387
{int volatile ___ = 1;(void)num_remaining;(void)tile_idx;(void)tile_offset;(void)tile_state;
# 501
::exit(___);}
#if 0
# 387
{ 
# 388
KeyT keys[ITEMS_PER_THREAD]; 
# 389
KeyT prev_keys[ITEMS_PER_THREAD]; 
# 390
ValueT values[ITEMS_PER_THREAD]; 
# 391
OffsetT head_flags[ITEMS_PER_THREAD]; 
# 392
OffsetT segment_indices[ITEMS_PER_THREAD]; 
# 393
OffsetValuePairT scan_items[ITEMS_PER_THREAD]; 
# 394
KeyValuePairT scatter_items[ITEMS_PER_THREAD]; 
# 397
if (IS_LAST_TILE) { 
# 398
(((BlockLoadKeysT)(((temp_storage).load_keys))).Load((d_keys_in) + tile_offset, keys, num_remaining)); } else { 
# 400
(((BlockLoadKeysT)(((temp_storage).load_keys))).Load((d_keys_in) + tile_offset, keys)); }  
# 403
KeyT tile_predecessor; 
# 404
if ((__device_builtin_variable_threadIdx.x) == (0)) 
# 405
{ 
# 406
tile_predecessor = ((tile_idx == 0) ? (keys)[0] : ((d_keys_in)[tile_offset - 1])); 
# 409
}  
# 411
__syncthreads(); 
# 414
if (IS_LAST_TILE) { 
# 415
(((BlockLoadValuesT)(((temp_storage).load_values))).Load((d_values_in) + tile_offset, values, num_remaining)); } else { 
# 417
(((BlockLoadValuesT)(((temp_storage).load_values))).Load((d_values_in) + tile_offset, values)); }  
# 419
__syncthreads(); 
# 422
if (IS_LAST_TILE) 
# 423
{ 
# 425
GuardedInequalityWrapper< EqualityOpT>  flag_op(equality_op, num_remaining); 
# 426
(((BlockDiscontinuityKeys)(((temp_storage).discontinuity))).FlagHeads(head_flags, keys, prev_keys, flag_op, tile_predecessor)); 
# 428
} else 
# 430
{ 
# 431
InequalityWrapper< EqualityOpT>  flag_op(equality_op); 
# 432
(((BlockDiscontinuityKeys)(((temp_storage).discontinuity))).FlagHeads(head_flags, keys, prev_keys, flag_op, tile_predecessor)); 
# 434
}  
# 438
#pragma unroll
for (
# 438
int ITEM = 0; ITEM < (ITEMS_PER_THREAD); ++ITEM) 
# 439
{ 
# 440
(((scan_items)[ITEM]).value) = ((values)[ITEM]); 
# 441
(((scan_items)[ITEM]).key) = ((head_flags)[ITEM]); 
# 442
}  
# 445
OffsetValuePairT block_aggregate; 
# 446
OffsetT num_segments_prefix; 
# 447
if (tile_idx == 0) 
# 448
{ 
# 450
(((BlockScanT)(((temp_storage).scan))).ExclusiveScan(scan_items, scan_items, scan_op, block_aggregate)); 
# 451
num_segments_prefix = 0; 
# 454
if ((!IS_LAST_TILE) && ((__device_builtin_variable_threadIdx.x) == (0))) { 
# 455
(tile_state.SetInclusive(0, block_aggregate)); }  
# 456
} else 
# 458
{ 
# 460
TilePrefixCallbackOpT prefix_op(tile_state, ((temp_storage).prefix), scan_op, tile_idx); 
# 461
(((BlockScanT)(((temp_storage).scan))).ExclusiveScan(scan_items, scan_items, scan_op, prefix_op)); 
# 463
num_segments_prefix = ((prefix_op.GetExclusivePrefix()).key); 
# 464
block_aggregate = (prefix_op.GetBlockAggregate()); 
# 465
}  
# 469
#pragma unroll
for (
# 469
int ITEM = 0; ITEM < (ITEMS_PER_THREAD); ++ITEM) 
# 470
{ 
# 471
(((scatter_items)[ITEM]).key) = ((prev_keys)[ITEM]); 
# 472
(((scatter_items)[ITEM]).value) = (((scan_items)[ITEM]).value); 
# 473
((segment_indices)[ITEM]) = (((scan_items)[ITEM]).key); 
# 474
}  
# 482
OffsetT num_tile_segments = ((block_aggregate.key)); 
# 483
Scatter(scatter_items, head_flags, segment_indices, num_tile_segments, num_segments_prefix); 
# 486
if (IS_LAST_TILE && ((__device_builtin_variable_threadIdx.x) == ((BLOCK_THREADS) - 1))) 
# 487
{ 
# 488
OffsetT num_segments = num_segments_prefix + num_tile_segments; 
# 491
if (num_remaining == (TILE_ITEMS)) 
# 492
{ 
# 493
((d_unique_out)[num_segments]) = (keys[(ITEMS_PER_THREAD) - 1]); 
# 494
((d_aggregates_out)[num_segments]) = (block_aggregate.value); 
# 495
num_segments++; 
# 496
}  
# 499
(*(d_num_runs_out)) = num_segments; 
# 500
}  
# 501
} 
#endif
# 507 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
__attribute((always_inline)) void ConsumeRange(int 
# 508
num_items, ScanTileStateT &
# 509
tile_state, int 
# 510
start_tile) 
# 511
{int volatile ___ = 1;(void)num_items;(void)tile_state;(void)start_tile;
# 527
::exit(___);}
#if 0
# 511
{ 
# 513
int tile_idx = start_tile + (__device_builtin_variable_blockIdx.x); 
# 514
OffsetT tile_offset = ((OffsetT)(TILE_ITEMS)) * tile_idx; 
# 515
OffsetT num_remaining = num_items - tile_offset; 
# 517
if (num_remaining > (TILE_ITEMS)) 
# 518
{ 
# 520
ConsumeTile< false> (num_remaining, tile_idx, tile_offset, tile_state); 
# 521
} else { 
# 522
if (num_remaining > 0) 
# 523
{ 
# 525
ConsumeTile< true> (num_remaining, tile_idx, tile_offset, tile_state); 
# 526
}  }  
# 527
} 
#endif
# 529 "/usr/local/cuda/include/cub/device/dispatch/../../agent/agent_reduce_by_key.cuh"
}; 
# 532
}
# 51 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh"
namespace cub { 
# 60
template< class 
# 61
AgentReduceByKeyPolicyT, class 
# 62
KeysInputIteratorT, class 
# 63
UniqueOutputIteratorT, class 
# 64
ValuesInputIteratorT, class 
# 65
AggregatesOutputIteratorT, class 
# 66
NumRunsOutputIteratorT, class 
# 67
ScanTileStateT, class 
# 68
EqualityOpT, class 
# 69
ReductionOpT, class 
# 70
OffsetT> static void 
# 72
__wrapper__device_stub_DeviceReduceByKeyKernel(KeysInputIteratorT &
# 73
d_keys_in, UniqueOutputIteratorT &
# 74
d_unique_out, ValuesInputIteratorT &
# 75
d_values_in, AggregatesOutputIteratorT &
# 76
d_aggregates_out, NumRunsOutputIteratorT &
# 77
d_num_runs_out, ScanTileStateT &
# 78
tile_state, int &
# 79
start_tile, EqualityOpT &
# 80
equality_op, ReductionOpT &
# 81
reduction_op, OffsetT &
# 82
num_items) {exit(1);}
#if 0
# 83
{ 
# 95
typedef AgentReduceByKey< AgentReduceByKeyPolicyT, KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, EqualityOpT, ReductionOpT, OffsetT>  AgentReduceByKeyT; 
# 98
__attribute__((unused)) static typename AgentReduceByKey< AgentReduceByKeyPolicyT, KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, EqualityOpT, ReductionOpT, OffsetT> ::TempStorage temp_storage; 
# 101
(AgentReduceByKeyT(temp_storage, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, equality_op, reduction_op).ConsumeRange(num_items, tile_state, start_tile)); 
# 105
} 
#endif
# 60 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh"
template< class 
# 61
AgentReduceByKeyPolicyT, class 
# 62
KeysInputIteratorT, class 
# 63
UniqueOutputIteratorT, class 
# 64
ValuesInputIteratorT, class 
# 65
AggregatesOutputIteratorT, class 
# 66
NumRunsOutputIteratorT, class 
# 67
ScanTileStateT, class 
# 68
EqualityOpT, class 
# 69
ReductionOpT, class 
# 70
OffsetT> void 
# 72
DeviceReduceByKeyKernel(KeysInputIteratorT 
# 73
d_keys_in, UniqueOutputIteratorT 
# 74
d_unique_out, ValuesInputIteratorT 
# 75
d_values_in, AggregatesOutputIteratorT 
# 76
d_aggregates_out, NumRunsOutputIteratorT 
# 77
d_num_runs_out, ScanTileStateT 
# 78
tile_state, int 
# 79
start_tile, EqualityOpT 
# 80
equality_op, ReductionOpT 
# 81
reduction_op, OffsetT 
# 82
num_items) 
# 83
{__wrapper__device_stub_DeviceReduceByKeyKernel<AgentReduceByKeyPolicyT,KeysInputIteratorT,UniqueOutputIteratorT,ValuesInputIteratorT,AggregatesOutputIteratorT,NumRunsOutputIteratorT,ScanTileStateT,EqualityOpT,ReductionOpT,OffsetT>(d_keys_in,d_unique_out,d_values_in,d_aggregates_out,d_num_runs_out,tile_state,start_tile,equality_op,reduction_op,num_items);
# 105
return;}
#if 0
# 83
{ 
# 95
typedef AgentReduceByKey< AgentReduceByKeyPolicyT, KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, EqualityOpT, ReductionOpT, OffsetT>  AgentReduceByKeyT; 
# 98
__attribute__((unused)) static typename AgentReduceByKey< AgentReduceByKeyPolicyT, KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, EqualityOpT, ReductionOpT, OffsetT> ::TempStorage temp_storage; 
# 101
(AgentReduceByKeyT(temp_storage, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, equality_op, reduction_op).ConsumeRange(num_items, tile_state, start_tile)); 
# 105
} 
#endif
# 117 "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh"
template< class 
# 118
KeysInputIteratorT, class 
# 119
UniqueOutputIteratorT, class 
# 120
ValuesInputIteratorT, class 
# 121
AggregatesOutputIteratorT, class 
# 122
NumRunsOutputIteratorT, class 
# 123
EqualityOpT, class 
# 124
ReductionOpT, class 
# 125
OffsetT> 
# 126
struct DispatchReduceByKey { 
# 133
typedef typename std::iterator_traits< KeysInputIteratorT> ::value_type KeyT; 
# 136
typedef typename std::iterator_traits< ValuesInputIteratorT> ::value_type ValueT; 
# 139
enum { 
# 140
INIT_KERNEL_THREADS = 128, 
# 141
MAX_INPUT_BYTES = (sizeof(ValueT) > sizeof(KeyT)) ? sizeof(ValueT) : sizeof(KeyT), 
# 142
COMBINED_INPUT_BYTES = sizeof(KeyT) + sizeof(ValueT)
# 143
}; 
# 146
typedef ReduceByKeyScanTileState< typename std::iterator_traits< ValuesInputIteratorT> ::value_type, OffsetT>  ScanTileStateT; 
# 154
struct Policy350 { 
# 156
enum { 
# 157
NOMINAL_4B_ITEMS_PER_THREAD = 6, 
# 158
ITEMS_PER_THREAD = (((sizeof(ValueT) > sizeof(KeyT)) ? sizeof(ValueT) : sizeof(KeyT)) <= 8) ? 6 : (((((((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1) < (6)) ? ((((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1 : (6))
# 159
}; 
# 167
typedef AgentReduceByKeyPolicy< 128, (ITEMS_PER_THREAD), BLOCK_LOAD_DIRECT, LOAD_LDG, BLOCK_SCAN_WARP_SCANS>  ReduceByKeyPolicyT; 
# 168
}; 
# 171
struct Policy300 { 
# 173
enum { 
# 174
NOMINAL_4B_ITEMS_PER_THREAD = 6, 
# 175
ITEMS_PER_THREAD = ((((((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1) < (6)) ? ((((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((6) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1 : (6)
# 176
}; 
# 184
typedef AgentReduceByKeyPolicy< 128, (ITEMS_PER_THREAD), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_SCAN_WARP_SCANS>  ReduceByKeyPolicyT; 
# 185
}; 
# 188
struct Policy200 { 
# 190
enum { 
# 191
NOMINAL_4B_ITEMS_PER_THREAD = 11, 
# 192
ITEMS_PER_THREAD = ((((((((11) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((11) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1) < (11)) ? ((((((11) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((11) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1 : (11)
# 193
}; 
# 201
typedef AgentReduceByKeyPolicy< 128, (ITEMS_PER_THREAD), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_SCAN_WARP_SCANS>  ReduceByKeyPolicyT; 
# 202
}; 
# 205
struct Policy130 { 
# 207
enum { 
# 208
NOMINAL_4B_ITEMS_PER_THREAD = 7, 
# 209
ITEMS_PER_THREAD = ((((((((7) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((7) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1) < (7)) ? ((((((7) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((((7) * 8) + (sizeof(KeyT) + sizeof(ValueT))) - 1) / (sizeof(KeyT) + sizeof(ValueT)) : 1 : (7)
# 210
}; 
# 218
typedef AgentReduceByKeyPolicy< 128, (ITEMS_PER_THREAD), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_SCAN_WARP_SCANS>  ReduceByKeyPolicyT; 
# 219
}; 
# 222
struct Policy110 { 
# 224
enum { 
# 225
NOMINAL_4B_ITEMS_PER_THREAD = 5, 
# 226
ITEMS_PER_THREAD = ((((((5) * 8) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((5) * 8) / (sizeof(KeyT) + sizeof(ValueT)) : 1) < (5)) ? ((((5) * 8) / (sizeof(KeyT) + sizeof(ValueT))) > 1) ? ((5) * 8) / (sizeof(KeyT) + sizeof(ValueT)) : 1 : (5)
# 227
}; 
# 235
typedef AgentReduceByKeyPolicy< 64, (ITEMS_PER_THREAD), BLOCK_LOAD_WARP_TRANSPOSE, LOAD_DEFAULT, BLOCK_SCAN_RAKING>  ReduceByKeyPolicyT; 
# 236
}; 
# 256
typedef Policy110 PtxPolicy; 
# 261
struct PtxReduceByKeyPolicy : public Policy110::ReduceByKeyPolicyT { }; 
# 271
template< class KernelConfig> 
# 272
__attribute((always_inline)) static void 
# 273
InitConfigs(int 
# 274
ptx_version, KernelConfig &
# 275
reduce_by_key_config) 
# 276
{ 
# 285
if (ptx_version >= 350) 
# 286
{ 
# 287
(reduce_by_key_config.template Init< typename Policy350::ReduceByKeyPolicyT> ()); 
# 288
} else { 
# 289
if (ptx_version >= 300) 
# 290
{ 
# 291
(reduce_by_key_config.template Init< typename Policy300::ReduceByKeyPolicyT> ()); 
# 292
} else { 
# 293
if (ptx_version >= 200) 
# 294
{ 
# 295
(reduce_by_key_config.template Init< typename Policy200::ReduceByKeyPolicyT> ()); 
# 296
} else { 
# 297
if (ptx_version >= 130) 
# 298
{ 
# 299
(reduce_by_key_config.template Init< typename Policy130::ReduceByKeyPolicyT> ()); 
# 300
} else 
# 302
{ 
# 303
(reduce_by_key_config.template Init< typename Policy110::ReduceByKeyPolicyT> ()); 
# 304
}  }  }  }  
# 307
} 
# 313
struct KernelConfig { 
# 315
int block_threads; 
# 316
int items_per_thread; 
# 317
int tile_items; 
# 319
template< class PolicyT> 
# 320
__attribute((always_inline)) void 
# 321
Init() 
# 322
{ 
# 323
(block_threads) = PolicyT::BLOCK_THREADS; 
# 324
(items_per_thread) = PolicyT::ITEMS_PER_THREAD; 
# 325
(tile_items) = ((block_threads) * (items_per_thread)); 
# 326
} 
# 327
}; 
# 338
template< class 
# 339
ScanInitKernelT, class 
# 340
ReduceByKeyKernelT> 
# 341
__attribute((always_inline)) static cudaError_t 
# 342
Dispatch(void *
# 343
d_temp_storage, size_t &
# 344
temp_storage_bytes, KeysInputIteratorT 
# 345
d_keys_in, UniqueOutputIteratorT 
# 346
d_unique_out, ValuesInputIteratorT 
# 347
d_values_in, AggregatesOutputIteratorT 
# 348
d_aggregates_out, NumRunsOutputIteratorT 
# 349
d_num_runs_out, EqualityOpT 
# 350
equality_op, ReductionOpT 
# 351
reduction_op, OffsetT 
# 352
num_items, cudaStream_t 
# 353
stream, bool 
# 354
debug_synchronous, int 
# 355
ptx_version, ScanInitKernelT 
# 356
init_kernel, ReduceByKeyKernelT 
# 357
reduce_by_key_kernel, KernelConfig 
# 358
reduce_by_key_config) 
# 359
{ 
# 368
cudaError error = cudaSuccess; 
# 369
do 
# 370
{ 
# 372
int device_ordinal; 
# 373
if (cub::Debug(error = cudaGetDevice(&device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 373)) { break; }  
# 376
int sm_count; 
# 377
if (cub::Debug(error = cudaDeviceGetAttribute(&sm_count, cudaDevAttrMultiProcessorCount, device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 377)) { break; }  
# 380
int tile_size = (reduce_by_key_config.block_threads) * (reduce_by_key_config.items_per_thread); 
# 381
int num_tiles = ((num_items + tile_size) - 1) / tile_size; 
# 384
size_t allocation_sizes[1]; 
# 385
if (cub::Debug(error = ScanTileStateT::AllocationSize(num_tiles, (allocation_sizes)[0]), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 385)) { break; }  
# 388
void *allocations[1]; 
# 389
if (cub::Debug(error = AliasTemporaries(d_temp_storage, temp_storage_bytes, allocations, allocation_sizes), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 389)) { break; }  
# 390
if (d_temp_storage == (__null)) 
# 391
{ 
# 393
break; 
# 394
}  
# 397
ScanTileStateT tile_state; 
# 398
if (cub::Debug(error = (tile_state.Init(num_tiles, (allocations)[0], (allocation_sizes)[0])), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 398)) { break; }  
# 401
int init_grid_size = ((((num_tiles + (INIT_KERNEL_THREADS)) - 1) / (INIT_KERNEL_THREADS)) > 1) ? ((num_tiles + (INIT_KERNEL_THREADS)) - 1) / (INIT_KERNEL_THREADS) : 1; 
# 402
if (debug_synchronous) { printf("Invoking init_kernel<<<%d, %d, 0, %lld>>>()\n", init_grid_size, INIT_KERNEL_THREADS, (long long)stream); }  ; 
# 405
(cudaConfigureCall(init_grid_size, INIT_KERNEL_THREADS, 0, stream)) ? (void)0 : init_kernel(tile_state, num_tiles, d_num_runs_out); 
# 411
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 411)) { break; }  
# 414
if (debug_synchronous && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 414))) { break; }  
# 417
if (num_items == 0) { 
# 418
break; }  
# 421
int reduce_by_key_sm_occupancy; 
# 422
if (cub::Debug(error = MaxSmOccupancy(reduce_by_key_sm_occupancy, reduce_by_key_kernel, (reduce_by_key_config.block_threads)), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 425)) { 
# 425
break; }  
# 428
int max_dim_x; 
# 429
if (cub::Debug(error = cudaDeviceGetAttribute(&max_dim_x, cudaDevAttrMaxGridDimX, device_ordinal), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 429)) { break; }  ; 
# 432
int scan_grid_size = (max_dim_x < num_tiles) ? max_dim_x : num_tiles; 
# 433
for (int start_tile = 0; start_tile < num_tiles; start_tile += scan_grid_size) 
# 434
{ 
# 436
if (debug_synchronous) { printf("Invoking %d reduce_by_key_kernel<<<%d, %d, 0, %lld>>>(), %d items per thread, %d SM occupancy\n", start_tile, scan_grid_size, (reduce_by_key_config.block_threads), (long long)stream, (reduce_by_key_config.items_per_thread), reduce_by_key_sm_occupancy); }  
# 437
; 
# 440
(cudaConfigureCall(scan_grid_size, ((reduce_by_key_config.block_threads)), 0, stream)) ? (void)0 : reduce_by_key_kernel(d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, tile_state, start_tile, equality_op, reduction_op, num_items); 
# 453
if (cub::Debug(error = cudaPeekAtLastError(), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 453)) { break; }  
# 456
if (debug_synchronous && (cub::Debug(error = SyncStream(stream), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 456))) { break; }  
# 457
}  
# 458
} 
# 459
while (0); 
# 461
return error; 
# 464
} 
# 470
__attribute((always_inline)) static cudaError_t 
# 471
Dispatch(void *
# 472
d_temp_storage, size_t &
# 473
temp_storage_bytes, KeysInputIteratorT 
# 474
d_keys_in, UniqueOutputIteratorT 
# 475
d_unique_out, ValuesInputIteratorT 
# 476
d_values_in, AggregatesOutputIteratorT 
# 477
d_aggregates_out, NumRunsOutputIteratorT 
# 478
d_num_runs_out, EqualityOpT 
# 479
equality_op, ReductionOpT 
# 480
reduction_op, OffsetT 
# 481
num_items, cudaStream_t 
# 482
stream, bool 
# 483
debug_synchronous) 
# 484
{ 
# 485
cudaError error = cudaSuccess; 
# 486
do 
# 487
{ 
# 489
int ptx_version; 
# 491
if (cub::Debug(error = PtxVersion(ptx_version), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 491)) { break; }  
# 497
KernelConfig reduce_by_key_config; 
# 498
InitConfigs(ptx_version, reduce_by_key_config); 
# 501
if (cub::Debug(error = Dispatch(d_temp_storage, temp_storage_bytes, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, equality_op, reduction_op, num_items, stream, debug_synchronous, ptx_version, DeviceCompactInitKernel< ScanTileStateT, NumRunsOutputIteratorT> , DeviceReduceByKeyKernel< PtxReduceByKeyPolicy, KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, ScanTileStateT, EqualityOpT, ReductionOpT, OffsetT> , reduce_by_key_config), "/usr/local/cuda/include/cub/device/dispatch/dispatch_reduce_by_key.cuh", 517)) { 
# 517
break; }  
# 518
} 
# 519
while (0); 
# 521
return error; 
# 522
} 
# 523
}; 
# 525
}
# 50 "/usr/local/cuda/include/cub/device/device_reduce.cuh"
namespace cub { 
# 84
struct DeviceReduce { 
# 137
template< class 
# 138
InputIteratorT, class 
# 139
OutputIteratorT, class 
# 140
ReductionOpT, class 
# 141
T> static cudaError_t 
# 143
Reduce(void *
# 144
d_temp_storage, size_t &
# 145
temp_storage_bytes, InputIteratorT 
# 146
d_in, OutputIteratorT 
# 147
d_out, int 
# 148
num_items, ReductionOpT 
# 149
reduction_op, T 
# 150
init, cudaStream_t 
# 151
stream = 0, bool 
# 152
debug_synchronous = false) 
# 153
{ 
# 154
typedef int OffsetT; 
# 156
return DispatchReduce< InputIteratorT, OutputIteratorT, int, ReductionOpT> ::Dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, init, stream, debug_synchronous); 
# 166
} 
# 214
template< class 
# 215
InputIteratorT, class 
# 216
OutputIteratorT> static cudaError_t 
# 218
Sum(void *
# 219
d_temp_storage, size_t &
# 220
temp_storage_bytes, InputIteratorT 
# 221
d_in, OutputIteratorT 
# 222
d_out, int 
# 223
num_items, cudaStream_t 
# 224
stream = 0, bool 
# 225
debug_synchronous = false) 
# 226
{ 
# 227
typedef int OffsetT; 
# 228
typedef typename std::iterator_traits< InputIteratorT> ::value_type T; 
# 230
return DispatchReduce< InputIteratorT, OutputIteratorT, int, cub::Sum> ::Dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, cub::Sum(), T(), stream, debug_synchronous); 
# 240
} 
# 281
template< class 
# 282
InputIteratorT, class 
# 283
OutputIteratorT> static cudaError_t 
# 285
Min(void *
# 286
d_temp_storage, size_t &
# 287
temp_storage_bytes, InputIteratorT 
# 288
d_in, OutputIteratorT 
# 289
d_out, int 
# 290
num_items, cudaStream_t 
# 291
stream = 0, bool 
# 292
debug_synchronous = false) 
# 293
{ 
# 294
typedef int OffsetT; 
# 295
typedef typename std::iterator_traits< InputIteratorT> ::value_type T; 
# 297
return DispatchReduce< InputIteratorT, OutputIteratorT, int, cub::Min> ::Dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, cub::Min(), Traits< typename std::iterator_traits< InputIteratorT> ::value_type> ::Max(), stream, debug_synchronous); 
# 307
} 
# 350
template< class 
# 351
InputIteratorT, class 
# 352
OutputIteratorT> static cudaError_t 
# 354
ArgMin(void *
# 355
d_temp_storage, size_t &
# 356
temp_storage_bytes, InputIteratorT 
# 357
d_in, OutputIteratorT 
# 358
d_out, int 
# 359
num_items, cudaStream_t 
# 360
stream = 0, bool 
# 361
debug_synchronous = false) 
# 362
{ 
# 364
typedef int OffsetT; 
# 367
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 368
typedef typename std::iterator_traits< OutputIteratorT> ::value_type::Value OutputValueT; 
# 369
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputValueT; 
# 372
typedef ArgIndexInputIterator< InputIteratorT, int, typename std::iterator_traits< OutputIteratorT> ::value_type::Value>  ArgIndexInputIteratorT; 
# 373
ArgIndexInputIteratorT d_indexed_in(d_in); 
# 376
OutputT initial_value = {(1), Traits< typename std::iterator_traits< InputIteratorT> ::value_type> ::Max()}; 
# 378
return DispatchReduce< ArgIndexInputIterator< InputIteratorT, int, typename std::iterator_traits< OutputIteratorT> ::value_type::Value> , OutputIteratorT, int, cub::ArgMin> ::Dispatch(d_temp_storage, temp_storage_bytes, d_indexed_in, d_out, num_items, cub::ArgMin(), initial_value, stream, debug_synchronous); 
# 388
} 
# 429
template< class 
# 430
InputIteratorT, class 
# 431
OutputIteratorT> static cudaError_t 
# 433
Max(void *
# 434
d_temp_storage, size_t &
# 435
temp_storage_bytes, InputIteratorT 
# 436
d_in, OutputIteratorT 
# 437
d_out, int 
# 438
num_items, cudaStream_t 
# 439
stream = 0, bool 
# 440
debug_synchronous = false) 
# 441
{ 
# 442
typedef int OffsetT; 
# 443
typedef typename std::iterator_traits< InputIteratorT> ::value_type T; 
# 445
return DispatchReduce< InputIteratorT, OutputIteratorT, int, cub::Max> ::Dispatch(d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, cub::Max(), Traits< typename std::iterator_traits< InputIteratorT> ::value_type> ::Lowest(), stream, debug_synchronous); 
# 455
} 
# 498
template< class 
# 499
InputIteratorT, class 
# 500
OutputIteratorT> static cudaError_t 
# 502
ArgMax(void *
# 503
d_temp_storage, size_t &
# 504
temp_storage_bytes, InputIteratorT 
# 505
d_in, OutputIteratorT 
# 506
d_out, int 
# 507
num_items, cudaStream_t 
# 508
stream = 0, bool 
# 509
debug_synchronous = false) 
# 510
{ 
# 512
typedef int OffsetT; 
# 515
typedef typename std::iterator_traits< OutputIteratorT> ::value_type OutputT; 
# 516
typedef typename std::iterator_traits< OutputIteratorT> ::value_type::Value OutputValueT; 
# 517
typedef typename std::iterator_traits< InputIteratorT> ::value_type InputValueT; 
# 520
typedef ArgIndexInputIterator< InputIteratorT, int, typename std::iterator_traits< OutputIteratorT> ::value_type::Value>  ArgIndexInputIteratorT; 
# 521
ArgIndexInputIteratorT d_indexed_in(d_in); 
# 524
OutputT initial_value = {(1), Traits< typename std::iterator_traits< InputIteratorT> ::value_type> ::Lowest()}; 
# 526
return DispatchReduce< ArgIndexInputIterator< InputIteratorT, int, typename std::iterator_traits< OutputIteratorT> ::value_type::Value> , OutputIteratorT, int, cub::ArgMax> ::Dispatch(d_temp_storage, temp_storage_bytes, d_indexed_in, d_out, num_items, cub::ArgMax(), initial_value, stream, debug_synchronous); 
# 536
} 
# 620
template< class 
# 621
KeysInputIteratorT, class 
# 622
UniqueOutputIteratorT, class 
# 623
ValuesInputIteratorT, class 
# 624
AggregatesOutputIteratorT, class 
# 625
NumRunsOutputIteratorT, class 
# 626
ReductionOpT> 
# 627
__attribute((always_inline)) static cudaError_t 
# 628
ReduceByKey(void *
# 629
d_temp_storage, size_t &
# 630
temp_storage_bytes, KeysInputIteratorT 
# 631
d_keys_in, UniqueOutputIteratorT 
# 632
d_unique_out, ValuesInputIteratorT 
# 633
d_values_in, AggregatesOutputIteratorT 
# 634
d_aggregates_out, NumRunsOutputIteratorT 
# 635
d_num_runs_out, ReductionOpT 
# 636
reduction_op, int 
# 637
num_items, cudaStream_t 
# 638
stream = 0, bool 
# 639
debug_synchronous = false) 
# 640
{ 
# 641
typedef int OffsetT; 
# 642
typedef NullType *FlagIterator; 
# 643
typedef NullType SelectOp; 
# 644
typedef Equality EqualityOp; 
# 646
return DispatchReduceByKey< KeysInputIteratorT, UniqueOutputIteratorT, ValuesInputIteratorT, AggregatesOutputIteratorT, NumRunsOutputIteratorT, Equality, ReductionOpT, int> ::Dispatch(d_temp_storage, temp_storage_bytes, d_keys_in, d_unique_out, d_values_in, d_aggregates_out, d_num_runs_out, EqualityOp(), reduction_op, num_items, stream, debug_synchronous); 
# 659
} 
# 661
}; 
# 667
}
# 21 "./cub_utils.cuh"
cub::CachingDeviceAllocator g_allocator(true); 
# 25
inline cudaError_t device_init(const int dev = 0) 
# 26
{ 
# 27
const cudaError_t error = cub::Debug(cudaSetDevice(dev), "./cub_utils.cuh", 27); 
# 28
if (error != (cudaSuccess)) { exit(1); }  
# 30
return error; 
# 31
} 
# 33
inline cudaError_t device_properties(const int dev = 0) 
# 34
{ 
# 35
cudaError_t error = cudaSuccess; 
# 37
cudaDeviceProp deviceProp; 
# 38
float device_giga_bandwidth; 
# 39
size_t device_free_physmem; 
# 40
size_t device_total_physmem; 
# 42
if (cub::Debug(cudaMemGetInfo(&device_free_physmem, &device_total_physmem), "./cub_utils.cuh", 42)) { exit(1); }  ; 
# 44
int ptx_version; 
# 45
error = cub::Debug(cub::PtxVersion(ptx_version), "./cub_utils.cuh", 45); 
# 46
if (error != (cudaSuccess)) { exit(1); }  
# 48
error = cub::Debug(cudaGetDeviceProperties(&deviceProp, dev), "./cub_utils.cuh", 48); 
# 49
if (error != (cudaSuccess)) { exit(1); }  
# 51
error = cub::Debug(cudaGetDeviceProperties(&deviceProp, dev), "./cub_utils.cuh", 51); 
# 52
if (error != (cudaSuccess)) { exit(1); }  
# 54
if ((deviceProp.major) < 1) 
# 55
{ 
# 56
fprintf(stderr, "Device does not support CUDA.\n"); 
# 57
exit(1); 
# 58
}  
# 60
device_giga_bandwidth = (((((((float)(deviceProp.memoryBusWidth)) * (deviceProp.memoryClockRate)) * (2)) / (8)) / (1000)) / (1000)); 
# 62
printf("Using device %d: %s (PTX version %d, SM%d, %d SMs, %lld free / %lld total MB physmem, %.3f GB/s @ %d kHz mem clock, ECC %s)\n", dev, deviceProp.name, ptx_version, ((deviceProp.major) * 100) + ((deviceProp.minor) * 10), deviceProp.multiProcessorCount, (((unsigned long long)device_free_physmem) / (1024)) / (1024), (((unsigned long long)device_total_physmem) / (1024)) / (1024), device_giga_bandwidth, deviceProp.memoryClockRate, (deviceProp.ECCEnabled) ? "on" : ("off")); 
# 75
fflush(stdout); 
# 76
return error; 
# 77
} 
# 86
template< class T> inline T cub_reduce(T *d_in, size_t n) 
# 87
{ 
# 89
T sum, *d_out = (__null); 
# 90
if (cub::Debug((g_allocator.DeviceAllocate((void **)(&d_out), sizeof(T) * (1))), "./cub_utils.cuh", 90)) { exit(1); }  ; 
# 93
T *d_temp_storage = (__null); 
# 94
size_t temp_storage_bytes = (0); 
# 95
if (cub::Debug(cub::DeviceReduce::Sum(d_temp_storage, temp_storage_bytes, d_in, d_out, n), "./cub_utils.cuh", 95)) { exit(1); }  ; 
# 96
printf("CUB bytes requested: %lu / %lu\n", temp_storage_bytes, n * sizeof(T)); 
# 97
if (cub::Debug(g_allocator.DeviceAllocate((void **)(&d_temp_storage), temp_storage_bytes), "./cub_utils.cuh", 97)) { exit(1); }  ; 
# 104
if (cub::Debug(cub::DeviceReduce::Sum(d_temp_storage, temp_storage_bytes, d_in, d_out, n), "./cub_utils.cuh", 104)) { exit(1); }  ; 
# 107
cudaMemcpy(&sum, d_out, sizeof(T), cudaMemcpyDeviceToHost); 
# 109
return sum; 
# 110
} 
# 120
template< class T> inline T cub_reduce(T *d_in, size_t n, T *d_temp_storage) 
# 121
{ 
# 123
T sum, *d_out = (__null); 
# 124
if (cub::Debug((g_allocator.DeviceAllocate((void **)(&d_out), sizeof(T) * (1))), "./cub_utils.cuh", 124)) { exit(1); }  ; 
# 127
size_t temp_storage_bytes = (0); 
# 128
if (cub::Debug(cub::DeviceReduce::Sum(d_temp_storage, temp_storage_bytes, d_in, d_out, n), "./cub_utils.cuh", 128)) { exit(1); }  ; 
# 131
if (cub::Debug(cub::DeviceReduce::Sum(d_temp_storage, temp_storage_bytes, d_in, d_out, n), "./cub_utils.cuh", 131)) { exit(1); }  ; 
# 134
cudaMemcpy(&sum, d_out, sizeof(T), cudaMemcpyDeviceToHost); 
# 136
return sum; 
# 137
} 
# 11 "./reductions.cuh"
static inline int opt_threads(int new_blocks, int threads, int current_size) 
# 12
{ 
# 13
int new_threads; 
# 14
if (new_blocks == 1) 
# 15
{ 
# 16
new_threads = 2; 
# 17
while (new_threads < threads) 
# 18
{ 
# 19
if (new_threads >= current_size) { break; }  
# 20
new_threads *= 2; 
# 21
}  
# 22
} else { 
# 23
new_threads = threads; }  
# 24
return new_threads; 
# 25
} 
# 27
template< unsigned block_size, class T> __attribute__((unused)) inline void 
# 28
warpReduce(volatile T *sdata, unsigned tid) 
# 29
{int volatile ___ = 1;(void)sdata;(void)tid;
# 36
::exit(___);}
#if 0
# 29
{ 
# 30
if (block_size >= (64)) { (sdata[tid]) += (sdata[tid + (32)]); }  
# 31
if (block_size >= (32)) { (sdata[tid]) += (sdata[tid + (16)]); }  
# 32
if (block_size >= (16)) { (sdata[tid]) += (sdata[tid + (8)]); }  
# 33
if (block_size >= (8)) { (sdata[tid]) += (sdata[tid + (4)]); }  
# 34
if (block_size >= (4)) { (sdata[tid]) += (sdata[tid + (2)]); }  
# 35
if (block_size >= (2)) { (sdata[tid]) += (sdata[tid + (1)]); }  
# 36
} 
#endif
# 38 "./reductions.cuh"
template< unsigned block_size, class T> static void 
# 39
__wrapper__device_stub___reduce_kernel__(T *&g_idata, T *&g_odata, int &n) {exit(1);}
#if 0
# 40
{ 
# 41
__attribute__((unused)) extern T sdata[]; 
# 42
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 43
unsigned i = ((__device_builtin_variable_blockIdx.x) * ((__device_builtin_variable_blockDim.x) * (2))) + (__device_builtin_variable_threadIdx.x); 
# 44
unsigned ishift = i + (__device_builtin_variable_blockDim.x); 
# 46
if (ishift < n) { ((sdata)[tid]) = ((g_idata[i]) + (g_idata[ishift])); } else { 
# 47
if (i < n) { ((sdata)[tid]) = (g_idata[i]); } else { 
# 48
((sdata)[tid]) = (0.0); }  }  
# 49
__syncthreads(); 
# 51
if (block_size >= (1024)) { if (tid < (512)) { ((sdata)[tid]) += ((sdata)[tid + (512)]); }  __syncthreads(); }  
# 52
if (block_size >= (512)) { if (tid < (256)) { ((sdata)[tid]) += ((sdata)[tid + (256)]); }  __syncthreads(); }  
# 53
if (block_size >= (256)) { if (tid < (128)) { ((sdata)[tid]) += ((sdata)[tid + (128)]); }  __syncthreads(); }  
# 54
if (block_size >= (128)) { if (tid < (64)) { ((sdata)[tid]) += ((sdata)[tid + (64)]); }  __syncthreads(); }  
# 55
if (tid < (32)) { warpReduce< block_size, T> (sdata, tid); }  
# 57
if (tid == (0)) { (g_odata[__device_builtin_variable_blockIdx.x]) = ((sdata)[0]); }  
# 58
} 
#endif
# 38 "./reductions.cuh"
template< unsigned block_size, class T> void 
# 39
__reduce_kernel__(T *g_idata, T *g_odata, int n) 
# 40
{__wrapper__device_stub___reduce_kernel__<block_size,T>(g_idata,g_odata,n);
# 58
return;}
#if 0
# 40
{ 
# 41
__attribute__((unused)) extern T sdata[]; 
# 42
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 43
unsigned i = ((__device_builtin_variable_blockIdx.x) * ((__device_builtin_variable_blockDim.x) * (2))) + (__device_builtin_variable_threadIdx.x); 
# 44
unsigned ishift = i + (__device_builtin_variable_blockDim.x); 
# 46
if (ishift < n) { ((sdata)[tid]) = ((g_idata[i]) + (g_idata[ishift])); } else { 
# 47
if (i < n) { ((sdata)[tid]) = (g_idata[i]); } else { 
# 48
((sdata)[tid]) = (0.0); }  }  
# 49
__syncthreads(); 
# 51
if (block_size >= (1024)) { if (tid < (512)) { ((sdata)[tid]) += ((sdata)[tid + (512)]); }  __syncthreads(); }  
# 52
if (block_size >= (512)) { if (tid < (256)) { ((sdata)[tid]) += ((sdata)[tid + (256)]); }  __syncthreads(); }  
# 53
if (block_size >= (256)) { if (tid < (128)) { ((sdata)[tid]) += ((sdata)[tid + (128)]); }  __syncthreads(); }  
# 54
if (block_size >= (128)) { if (tid < (64)) { ((sdata)[tid]) += ((sdata)[tid + (64)]); }  __syncthreads(); }  
# 55
if (tid < (32)) { warpReduce< block_size, T> (sdata, tid); }  
# 57
if (tid == (0)) { (g_odata[__device_builtin_variable_blockIdx.x]) = ((sdata)[0]); }  
# 58
} 
#endif
# 60 "./reductions.cuh"
template< class T> static inline void 
# 61
call_reduction_kernel(int dim_grid, int dim_block, int size, T *d_idata, T *d_odata, cudaStream_t stream) 
# 62
{ 
# 63
int smemSize = dim_block * sizeof(double); 
# 64
switch (dim_block) 
# 65
{ 
# 66
case 1024:  
# 67
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (__reduce_kernel__< 1024, T> )(d_idata, d_odata, size); break; 
# 68
case 512:  
# 69
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (__reduce_kernel__< 512, T> )(d_idata, d_odata, size); break; 
# 70
case 256:  
# 71
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (__reduce_kernel__< 256, T> )(d_idata, d_odata, size); break; 
# 72
case 128:  
# 73
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (__reduce_kernel__< 128, T> )(d_idata, d_odata, size); break; 
# 74
case 64:  
# 75
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (__reduce_kernel__< 64, T> )(d_idata, d_odata, size); break; 
# 76
}  
# 77
} 
# 89
template< class T> inline T 
# 90
block_reduce(T *array, int size, T *partial_sums = 0, int threads = 1024, cudaStream_t stream = 0) 
# 91
{ 
# 92
if (!partial_sums) { partial_sums = array; }  
# 94
int blocks = (int)ceil(((float)size) / threads); 
# 95
unsigned lthreads = threads / 2; 
# 96
if (lthreads < (64)) { lthreads = (64); }  
# 97
unsigned new_blocks, current_size; 
# 100
call_reduction_kernel< T> (blocks, lthreads, size, array, partial_sums, stream); 
# 103
current_size = blocks; 
# 104
while (current_size > (1)) 
# 105
{ 
# 106
new_blocks = ((int)ceil(((float)current_size) / threads)); 
# 107
lthreads = (opt_threads(new_blocks, threads, current_size) / 2); 
# 108
if (lthreads < (64)) { lthreads = (64); }  
# 109
call_reduction_kernel< T> (new_blocks, lthreads, current_size, partial_sums, partial_sums, stream); 
# 110
current_size = new_blocks; 
# 111
}  
# 113
T result; 
# 114
cudaMemcpy(&result, partial_sums, sizeof(T), cudaMemcpyDeviceToHost); 
# 116
return result; 
# 117
} 
# 126
template< unsigned block_size> static void 
# 127
__wrapper__device_stub_kernel_DZdreduce(double *&entity, cuDoubleComplex *&psi, double *&d_wrk_mem, int &n) {exit(1);}
#if 0
# 128
{ 
# 129
__attribute__((unused)) extern double sdata[]; 
# 130
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 131
unsigned i = ((__device_builtin_variable_blockIdx.x) * ((__device_builtin_variable_blockDim.x) * (2))) + (__device_builtin_variable_threadIdx.x); 
# 132
unsigned ishift = i + (__device_builtin_variable_blockDim.x); 
# 135
if (ishift < n) { ((sdata)[tid]) = (((entity[i]) * ((((psi[i]).x) * ((psi[i]).x)) + (((psi[i]).y) * ((psi[i]).y)))) + ((entity[ishift]) * ((((psi[ishift]).x) * ((psi[ishift]).x)) + (((psi[ishift]).y) * ((psi[ishift]).y))))); } else { 
# 137
if (i < n) { ((sdata)[tid]) = ((entity[i]) * ((((psi[i]).x) * ((psi[i]).x)) + (((psi[i]).y) * ((psi[i]).y)))); } else { 
# 138
((sdata)[tid]) = (0.0); }  }  
# 139
__syncthreads(); 
# 141
if (block_size >= (1024)) { if (tid < (512)) { ((sdata)[tid]) += ((sdata)[tid + (512)]); }  __syncthreads(); }  
# 142
if (block_size >= (512)) { if (tid < (256)) { ((sdata)[tid]) += ((sdata)[tid + (256)]); }  __syncthreads(); }  
# 143
if (block_size >= (256)) { if (tid < (128)) { ((sdata)[tid]) += ((sdata)[tid + (128)]); }  __syncthreads(); }  
# 144
if (block_size >= (128)) { if (tid < (64)) { ((sdata)[tid]) += ((sdata)[tid + (64)]); }  __syncthreads(); }  
# 145
if (tid < (32)) { warpReduce< block_size, double> (sdata, tid); }  
# 147
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((sdata)[0]); }  
# 148
} 
#endif
# 126 "./reductions.cuh"
template< unsigned block_size> void 
# 127
kernel_DZdreduce(double *entity, cuDoubleComplex *psi, double *d_wrk_mem, int n) 
# 128
{__wrapper__device_stub_kernel_DZdreduce<block_size>(entity,psi,d_wrk_mem,n);
# 148
return;}
#if 0
# 128
{ 
# 129
__attribute__((unused)) extern double sdata[]; 
# 130
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 131
unsigned i = ((__device_builtin_variable_blockIdx.x) * ((__device_builtin_variable_blockDim.x) * (2))) + (__device_builtin_variable_threadIdx.x); 
# 132
unsigned ishift = i + (__device_builtin_variable_blockDim.x); 
# 135
if (ishift < n) { ((sdata)[tid]) = (((entity[i]) * ((((psi[i]).x) * ((psi[i]).x)) + (((psi[i]).y) * ((psi[i]).y)))) + ((entity[ishift]) * ((((psi[ishift]).x) * ((psi[ishift]).x)) + (((psi[ishift]).y) * ((psi[ishift]).y))))); } else { 
# 137
if (i < n) { ((sdata)[tid]) = ((entity[i]) * ((((psi[i]).x) * ((psi[i]).x)) + (((psi[i]).y) * ((psi[i]).y)))); } else { 
# 138
((sdata)[tid]) = (0.0); }  }  
# 139
__syncthreads(); 
# 141
if (block_size >= (1024)) { if (tid < (512)) { ((sdata)[tid]) += ((sdata)[tid + (512)]); }  __syncthreads(); }  
# 142
if (block_size >= (512)) { if (tid < (256)) { ((sdata)[tid]) += ((sdata)[tid + (256)]); }  __syncthreads(); }  
# 143
if (block_size >= (256)) { if (tid < (128)) { ((sdata)[tid]) += ((sdata)[tid + (128)]); }  __syncthreads(); }  
# 144
if (block_size >= (128)) { if (tid < (64)) { ((sdata)[tid]) += ((sdata)[tid + (64)]); }  __syncthreads(); }  
# 145
if (tid < (32)) { warpReduce< block_size, double> (sdata, tid); }  
# 147
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((sdata)[0]); }  
# 148
} 
#endif
# 151 "./reductions.cuh"
static inline void call_DZdreduction(int dim_grid, int dim_block, int size, double *d_entity, cuDoubleComplex *d_psi, double *d_wrk_mem, cudaStream_t stream) 
# 152
{ 
# 153
int smemSize = dim_block * sizeof(double); 
# 154
switch (dim_block) 
# 155
{ 
# 156
case 1024:  
# 157
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (kernel_DZdreduce< 1024U> )(d_entity, d_psi, d_wrk_mem, size); 
# 158
break; 
# 159
case 512:  
# 160
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (kernel_DZdreduce< 512U> )(d_entity, d_psi, d_wrk_mem, size); 
# 161
break; 
# 162
case 256:  
# 163
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (kernel_DZdreduce< 256U> )(d_entity, d_psi, d_wrk_mem, size); 
# 164
break; 
# 165
case 128:  
# 166
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (kernel_DZdreduce< 128U> )(d_entity, d_psi, d_wrk_mem, size); 
# 167
break; 
# 168
case 64:  
# 169
(cudaConfigureCall(dim_grid, dim_block, smemSize, stream)) ? (void)0 : (kernel_DZdreduce< 64U> )(d_entity, d_psi, d_wrk_mem, size); 
# 170
break; 
# 171
}  
# 172
} 
# 10 "./thread_fence_reductions.cuh"
static unsigned retirementCount; 
# 12
cudaError_t setRetirementCount(int retCnt) 
# 13
{ 
# 14
return cudaMemcpyToSymbol(retirementCount, &retCnt, sizeof(unsigned), 0, cudaMemcpyHostToDevice); 
# 15
} 
# 20
bool isPow2(unsigned x) { return (x & (x - (1))) == (0); } 
# 22
template< class T, unsigned block_size> __attribute__((unused)) inline void 
# 23
reduce_block(volatile T *sdata, T sum, const unsigned tid) 
# 24
{int volatile ___ = 1;(void)sdata;(void)sum;(void)tid;
# 42
::exit(___);}
#if 0
# 24
{ 
# 25
(sdata[tid]) = sum; 
# 26
__syncthreads(); 
# 29
if (block_size >= (512)) { if (tid < (256)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (256)]))); }  __syncthreads(); }  
# 30
if (block_size >= (256)) { if (tid < (128)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (128)]))); }  __syncthreads(); }  
# 31
if (block_size >= (128)) { if (tid < (64)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (64)]))); }  __syncthreads(); }  
# 33
if (tid < (32)) 
# 34
{ 
# 35
if (block_size >= (64)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (32)]))); }  
# 36
if (block_size >= (32)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (16)]))); }  
# 37
if (block_size >= (16)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (8)]))); }  
# 38
if (block_size >= (8)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (4)]))); }  
# 39
if (block_size >= (4)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (2)]))); }  
# 40
if (block_size >= (2)) { (sdata[tid]) = (sum = (sum + (sdata[tid + (1)]))); }  
# 41
}  
# 42
} 
#endif
# 63 "./thread_fence_reductions.cuh"
template< class T, unsigned block_size, bool nIsPow2> static void 
# 64
__wrapper__device_stub_kernel_reduce_threadfence(const T *&d_arr_in, T *&d_wrk_mem, unsigned &n) {exit(1);}
#if 0
# 65
{ 
# 66
__attribute__((unused)) extern T smem[]; 
# 67
__attribute__((unused)) static bool amLast; 
# 69
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 70
unsigned i = ((__device_builtin_variable_blockIdx.x) * (block_size * (2))) + (__device_builtin_variable_threadIdx.x); 
# 71
unsigned gridSize = (block_size * (2)) * (__device_builtin_variable_gridDim.x); 
# 79
T sum = (0); 
# 80
while (i < n) 
# 81
{ 
# 82
sum += (d_arr_in[i]); 
# 85
if (nIsPow2 || ((i + block_size) < n)) { 
# 86
sum += (d_arr_in[i + block_size]); }  
# 88
i += gridSize; 
# 89
}  
# 94
reduce_block< T, block_size> (smem, sum, tid); 
# 97
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((smem)[0]); }  
# 103
if ((__device_builtin_variable_gridDim.x) > (1)) 
# 104
{ 
# 109
__threadfence(); 
# 112
if (tid == (0)) { unsigned ticket = atomicInc(&retirementCount, __device_builtin_variable_gridDim.x); amLast = (ticket == ((__device_builtin_variable_gridDim.x) - (1))); }  
# 113
__syncthreads(); 
# 116
if (amLast) 
# 117
{ 
# 118
int i = tid; 
# 119
while (i < (__device_builtin_variable_gridDim.x)) { sum += (d_wrk_mem[i]); i += block_size; }  
# 120
reduce_block< T, block_size> (smem, sum, tid); 
# 121
if (tid == (0)) { (d_wrk_mem[0]) = ((smem)[0]); retirementCount = (0); }  
# 122
}  
# 123
}  
# 124
} 
#endif
# 63 "./thread_fence_reductions.cuh"
template< class T, unsigned block_size, bool nIsPow2> void 
# 64
kernel_reduce_threadfence(const T *d_arr_in, T *d_wrk_mem, unsigned n) 
# 65
{__wrapper__device_stub_kernel_reduce_threadfence<T,block_size,nIsPow2>(d_arr_in,d_wrk_mem,n);
# 124
return;}
#if 0
# 65
{ 
# 66
__attribute__((unused)) extern T smem[]; 
# 67
__attribute__((unused)) static bool amLast; 
# 69
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 70
unsigned i = ((__device_builtin_variable_blockIdx.x) * (block_size * (2))) + (__device_builtin_variable_threadIdx.x); 
# 71
unsigned gridSize = (block_size * (2)) * (__device_builtin_variable_gridDim.x); 
# 79
T sum = (0); 
# 80
while (i < n) 
# 81
{ 
# 82
sum += (d_arr_in[i]); 
# 85
if (nIsPow2 || ((i + block_size) < n)) { 
# 86
sum += (d_arr_in[i + block_size]); }  
# 88
i += gridSize; 
# 89
}  
# 94
reduce_block< T, block_size> (smem, sum, tid); 
# 97
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((smem)[0]); }  
# 103
if ((__device_builtin_variable_gridDim.x) > (1)) 
# 104
{ 
# 109
__threadfence(); 
# 112
if (tid == (0)) { unsigned ticket = atomicInc(&retirementCount, __device_builtin_variable_gridDim.x); amLast = (ticket == ((__device_builtin_variable_gridDim.x) - (1))); }  
# 113
__syncthreads(); 
# 116
if (amLast) 
# 117
{ 
# 118
int i = tid; 
# 119
while (i < (__device_builtin_variable_gridDim.x)) { sum += (d_wrk_mem[i]); i += block_size; }  
# 120
reduce_block< T, block_size> (smem, sum, tid); 
# 121
if (tid == (0)) { (d_wrk_mem[0]) = ((smem)[0]); retirementCount = (0); }  
# 122
}  
# 123
}  
# 124
} 
#endif
# 126 "./thread_fence_reductions.cuh"
template< class T> T 
# 127
threadfence_reduce(T *d_data, T *d_wrk_mem, const int size, int threads = 256) 
# 128
{ 
# 129
int blocks = (int)ceil(((float)size) / threads); 
# 130
dim3 dimBlock(threads, 1, 1); 
# 131
dim3 dimGrid(blocks, 1, 1); 
# 132
int smemSize = threads * sizeof(T); 
# 135
if (isPow2(size)) 
# 136
{ 
# 137
switch (threads) 
# 138
{ 
# 139
case 512:  
# 140
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 512, true> )(d_data, d_wrk_mem, size); 
# 141
break; 
# 143
case 256:  
# 144
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 256, true> )(d_data, d_wrk_mem, size); 
# 145
break; 
# 147
case 128:  
# 148
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 128, true> )(d_data, d_wrk_mem, size); 
# 149
break; 
# 151
case 64:  
# 152
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 64, true> )(d_data, d_wrk_mem, size); 
# 153
break; 
# 155
case 32:  
# 156
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 32, true> )(d_data, d_wrk_mem, size); 
# 157
break; 
# 159
case 16:  
# 160
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 16, true> )(d_data, d_wrk_mem, size); 
# 161
break; 
# 163
case 8:  
# 164
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 8, true> )(d_data, d_wrk_mem, size); 
# 165
break; 
# 167
case 4:  
# 168
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 4, true> )(d_data, d_wrk_mem, size); 
# 169
break; 
# 171
case 2:  
# 172
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 2, true> )(d_data, d_wrk_mem, size); 
# 173
break; 
# 175
case 1:  
# 176
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 1, true> )(d_data, d_wrk_mem, size); 
# 177
break; 
# 178
}  
# 179
} else 
# 181
{ 
# 182
switch (threads) 
# 183
{ 
# 184
case 512:  
# 185
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 512, false> )(d_data, d_wrk_mem, size); 
# 186
break; 
# 188
case 256:  
# 189
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 256, false> )(d_data, d_wrk_mem, size); 
# 190
break; 
# 192
case 128:  
# 193
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 128, false> )(d_data, d_wrk_mem, size); 
# 194
break; 
# 196
case 64:  
# 197
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 64, false> )(d_data, d_wrk_mem, size); 
# 198
break; 
# 200
case 32:  
# 201
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 32, false> )(d_data, d_wrk_mem, size); 
# 202
break; 
# 204
case 16:  
# 205
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 16, false> )(d_data, d_wrk_mem, size); 
# 206
break; 
# 208
case 8:  
# 209
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 8, false> )(d_data, d_wrk_mem, size); 
# 210
break; 
# 212
case 4:  
# 213
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 4, false> )(d_data, d_wrk_mem, size); 
# 214
break; 
# 216
case 2:  
# 217
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 2, false> )(d_data, d_wrk_mem, size); 
# 218
break; 
# 220
case 1:  
# 221
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_reduce_threadfence< T, 1, false> )(d_data, d_wrk_mem, size); 
# 222
break; 
# 223
}  
# 224
}  
# 226
T gpu_result; 
# 227
cudaMemcpy(&gpu_result, d_wrk_mem, sizeof(T), cudaMemcpyDeviceToHost); 
# 228
return gpu_result; 
# 229
} 
# 247
template< class T, unsigned block_size, bool nIsPow2> static void 
# 248
__wrapper__device_stub_kernel_DZdreduce_threadfence(const T *&d_arr_in, cuDoubleComplex *&d_psi, T *&d_wrk_mem, unsigned &n) {exit(1);}
#if 0
# 249
{ 
# 250
__attribute__((unused)) extern T smem[]; 
# 251
__attribute__((unused)) static bool amLast; 
# 253
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 254
unsigned i = ((__device_builtin_variable_blockIdx.x) * (block_size * (2))) + (__device_builtin_variable_threadIdx.x); 
# 255
unsigned gridSize = (block_size * (2)) * (__device_builtin_variable_gridDim.x); 
# 263
T sum = (0); 
# 264
while (i < n) 
# 265
{ 
# 266
sum += ((d_arr_in[i]) * ((((d_psi[i]).x) * ((d_psi[i]).x)) + (((d_psi[i]).y) * ((d_psi[i]).y)))); 
# 269
if (nIsPow2 || ((i + block_size) < n)) { 
# 270
sum += ((d_arr_in[i + block_size]) * ((((d_psi[i + block_size]).x) * ((d_psi[i + block_size]).x)) + (((d_psi[i + block_size]).y) * ((d_psi[i + block_size]).y)))); }  
# 273
i += gridSize; 
# 274
}  
# 279
reduce_block< T, block_size> (smem, sum, tid); 
# 282
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((smem)[0]); }  
# 288
if ((__device_builtin_variable_gridDim.x) > (1)) 
# 289
{ 
# 294
__threadfence(); 
# 297
if (tid == (0)) { unsigned ticket = atomicInc(&retirementCount, __device_builtin_variable_gridDim.x); amLast = (ticket == ((__device_builtin_variable_gridDim.x) - (1))); }  
# 298
__syncthreads(); 
# 301
if (amLast) 
# 302
{ 
# 303
int i = tid; 
# 304
while (i < (__device_builtin_variable_gridDim.x)) { sum += (d_wrk_mem[i]); i += block_size; }  
# 305
reduce_block< T, block_size> (smem, sum, tid); 
# 306
if (tid == (0)) { (d_wrk_mem[0]) = ((smem)[0]); retirementCount = (0); }  
# 307
}  
# 308
}  
# 309
} 
#endif
# 247 "./thread_fence_reductions.cuh"
template< class T, unsigned block_size, bool nIsPow2> void 
# 248
kernel_DZdreduce_threadfence(const T *d_arr_in, cuDoubleComplex *d_psi, T *d_wrk_mem, unsigned n) 
# 249
{__wrapper__device_stub_kernel_DZdreduce_threadfence<T,block_size,nIsPow2>(d_arr_in,d_psi,d_wrk_mem,n);
# 309
return;}
#if 0
# 249
{ 
# 250
__attribute__((unused)) extern T smem[]; 
# 251
__attribute__((unused)) static bool amLast; 
# 253
unsigned tid = __device_builtin_variable_threadIdx.x; 
# 254
unsigned i = ((__device_builtin_variable_blockIdx.x) * (block_size * (2))) + (__device_builtin_variable_threadIdx.x); 
# 255
unsigned gridSize = (block_size * (2)) * (__device_builtin_variable_gridDim.x); 
# 263
T sum = (0); 
# 264
while (i < n) 
# 265
{ 
# 266
sum += ((d_arr_in[i]) * ((((d_psi[i]).x) * ((d_psi[i]).x)) + (((d_psi[i]).y) * ((d_psi[i]).y)))); 
# 269
if (nIsPow2 || ((i + block_size) < n)) { 
# 270
sum += ((d_arr_in[i + block_size]) * ((((d_psi[i + block_size]).x) * ((d_psi[i + block_size]).x)) + (((d_psi[i + block_size]).y) * ((d_psi[i + block_size]).y)))); }  
# 273
i += gridSize; 
# 274
}  
# 279
reduce_block< T, block_size> (smem, sum, tid); 
# 282
if (tid == (0)) { (d_wrk_mem[__device_builtin_variable_blockIdx.x]) = ((smem)[0]); }  
# 288
if ((__device_builtin_variable_gridDim.x) > (1)) 
# 289
{ 
# 294
__threadfence(); 
# 297
if (tid == (0)) { unsigned ticket = atomicInc(&retirementCount, __device_builtin_variable_gridDim.x); amLast = (ticket == ((__device_builtin_variable_gridDim.x) - (1))); }  
# 298
__syncthreads(); 
# 301
if (amLast) 
# 302
{ 
# 303
int i = tid; 
# 304
while (i < (__device_builtin_variable_gridDim.x)) { sum += (d_wrk_mem[i]); i += block_size; }  
# 305
reduce_block< T, block_size> (smem, sum, tid); 
# 306
if (tid == (0)) { (d_wrk_mem[0]) = ((smem)[0]); retirementCount = (0); }  
# 307
}  
# 308
}  
# 309
} 
#endif
# 311 "./thread_fence_reductions.cuh"
template< class T> T 
# 312
threadfence_DZdreduce(T *d_data, cuDoubleComplex *d_psi, T *d_wrk_mem, const int size, int threads) 
# 313
{ 
# 314
int blocks = (int)ceil(((float)size) / threads); 
# 315
dim3 dimBlock(threads, 1, 1); 
# 316
dim3 dimGrid(blocks, 1, 1); 
# 317
int smemSize = threads * sizeof(T); 
# 320
if (isPow2(size)) 
# 321
{ 
# 322
switch (threads) 
# 323
{ 
# 324
case 512:  
# 325
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 512, true> )(d_data, d_psi, d_wrk_mem, size); 
# 326
break; 
# 328
case 256:  
# 329
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 256, true> )(d_data, d_psi, d_wrk_mem, size); 
# 330
break; 
# 332
case 128:  
# 333
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 128, true> )(d_data, d_psi, d_wrk_mem, size); 
# 334
break; 
# 336
case 64:  
# 337
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 64, true> )(d_data, d_psi, d_wrk_mem, size); 
# 338
break; 
# 340
case 32:  
# 341
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 32, true> )(d_data, d_psi, d_wrk_mem, size); 
# 342
break; 
# 344
case 16:  
# 345
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 16, true> )(d_data, d_psi, d_wrk_mem, size); 
# 346
break; 
# 348
case 8:  
# 349
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 8, true> )(d_data, d_psi, d_wrk_mem, size); 
# 350
break; 
# 352
case 4:  
# 353
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 4, true> )(d_data, d_psi, d_wrk_mem, size); 
# 354
break; 
# 356
case 2:  
# 357
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 2, true> )(d_data, d_psi, d_wrk_mem, size); 
# 358
break; 
# 360
case 1:  
# 361
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 1, true> )(d_data, d_psi, d_wrk_mem, size); 
# 362
break; 
# 363
}  
# 364
} else 
# 366
{ 
# 367
switch (threads) 
# 368
{ 
# 369
case 512:  
# 370
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 512, false> )(d_data, d_psi, d_wrk_mem, size); 
# 371
break; 
# 373
case 256:  
# 374
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 256, false> )(d_data, d_psi, d_wrk_mem, size); 
# 375
break; 
# 377
case 128:  
# 378
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 128, false> )(d_data, d_psi, d_wrk_mem, size); 
# 379
break; 
# 381
case 64:  
# 382
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 64, false> )(d_data, d_psi, d_wrk_mem, size); 
# 383
break; 
# 385
case 32:  
# 386
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 32, false> )(d_data, d_psi, d_wrk_mem, size); 
# 387
break; 
# 389
case 16:  
# 390
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 16, false> )(d_data, d_psi, d_wrk_mem, size); 
# 391
break; 
# 393
case 8:  
# 394
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 8, false> )(d_data, d_psi, d_wrk_mem, size); 
# 395
break; 
# 397
case 4:  
# 398
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 4, false> )(d_data, d_psi, d_wrk_mem, size); 
# 399
break; 
# 401
case 2:  
# 402
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 2, false> )(d_data, d_psi, d_wrk_mem, size); 
# 403
break; 
# 405
case 1:  
# 406
(cudaConfigureCall(dimGrid, dimBlock, smemSize)) ? (void)0 : (kernel_DZdreduce_threadfence< T, 1, false> )(d_data, d_psi, d_wrk_mem, size); 
# 407
break; 
# 408
}  
# 409
}  
# 411
T gpu_result; 
# 412
cudaMemcpy(&gpu_result, d_wrk_mem, sizeof(T), cudaMemcpyDeviceToHost); 
# 413
return gpu_result; 
# 414
} 
# 30 "./Integration.hpp"
template< int nx, int ny, int nz, int strides> static void 
# 31
__wrapper__device_stub_kernel_RC_mult(const double *__restrict__ &entity, const cuDoubleComplex *__restrict__ &
# 32
arr_in, cuDoubleComplex *__restrict__ &
# 33
arr_out) {exit(1);}
#if 0
# 34
{ 
# 35
size_t ixyz = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
# 37
while (ixyz < ((((size_t)nx) * ((size_t)ny)) * ((size_t)nz))) 
# 38
{ 
# 40
((arr_out[ixyz]).x) = ((entity[ixyz]) * ((arr_in[ixyz]).x)); 
# 41
((arr_out[ixyz]).y) = ((entity[ixyz]) * ((arr_in[ixyz]).y)); 
# 47
ixyz += (((((size_t)nx) * ((size_t)ny)) * ((size_t)nz)) / (strides)); 
# 48
}  
# 49
} 
#endif
# 30 "./Integration.hpp"
template< int nx, int ny, int nz, int strides> void 
# 31
kernel_RC_mult(const double *__restrict__ entity, const cuDoubleComplex *__restrict__ 
# 32
arr_in, cuDoubleComplex *__restrict__ 
# 33
arr_out) 
# 34
{__wrapper__device_stub_kernel_RC_mult<nx,ny,nz,strides>(entity,arr_in,arr_out);
# 49
return;}
#if 0
# 34
{ 
# 35
size_t ixyz = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
# 37
while (ixyz < ((((size_t)nx) * ((size_t)ny)) * ((size_t)nz))) 
# 38
{ 
# 40
((arr_out[ixyz]).x) = ((entity[ixyz]) * ((arr_in[ixyz]).x)); 
# 41
((arr_out[ixyz]).y) = ((entity[ixyz]) * ((arr_in[ixyz]).y)); 
# 47
ixyz += (((((size_t)nx) * ((size_t)ny)) * ((size_t)nz)) / (strides)); 
# 48
}  
# 49
} 
#endif
# 58 "./Integration.hpp"
struct evaluate_functional : public thrust::binary_function< double, double2, double>  { 
# 61
double operator()(double entity, cuDoubleComplex psi) 
# 62
{ 
# 66
return ((double)entity) * (((psi.x) * (psi.x)) + ((psi.y) * (psi.y))); 
# 67
} 
# 68
}; 
# 74
template< int nx, int ny, int nz> 
# 75
class Integration { 
# 79
cublasHandle_t cublas_handle; 
# 80
double *d_norm, h_norm; 
# 81
cuDoubleComplex *d_int_val; 
# 82
cuDoubleComplex h_int_val; 
# 83
const size_t nxyz; 
# 86
void *d_wrk_mem; 
# 87
double *d_wrk_memD; 
# 88
cuDoubleComplex *d_wrk_memZ; 
# 94
public: Integration() : nxyz(((nx * ny) * nz)) 
# 95
{ 
# 96
printf("Constructing integration utility for lattice %dx%dx%d\n", nx, ny, nz); 
# 99
_cuErrCheck(cudaMalloc((void **)(&(d_wrk_mem)), ((((size_t)nx) * ((size_t)ny)) * ((size_t)nz)) * sizeof(cuDoubleComplex)), "./Integration.hpp", 99); 
# 100
(d_wrk_memD) = ((double *)(d_wrk_mem)); 
# 101
(d_wrk_memZ) = ((cuDoubleComplex *)(d_wrk_mem)); 
# 102
_cuErrCheck(cudaMalloc((void **)(&(d_int_val)), sizeof(cuDoubleComplex)), "./Integration.hpp", 102); 
# 103
_cuErrCheck(cudaMalloc((void **)(&(d_norm)), sizeof(double)), "./Integration.hpp", 103); 
# 106
_cuErrCheck(cudaMemset((void *)(d_int_val), 0, (size_t)sizeof(cuDoubleComplex)), "./Integration.hpp", 106); 
# 107
_cuErrCheck(cudaMemset((void *)(d_wrk_memZ), 0, ((((size_t)nx) * ((size_t)ny)) * ((size_t)nz)) * sizeof(cuDoubleComplex)), "./Integration.hpp", 107); 
# 110
CheckCublas(cublasCreate_v2(&(cublas_handle)), "./Integration.hpp", 110); 
# 111
CheckCublas(cublasSetPointerMode_v2(cublas_handle, CUBLAS_POINTER_MODE_DEVICE), "./Integration.hpp", 111); 
# 113
} 
# 117
~Integration() 
# 118
{ 
# 120
CheckCublas(cublasDestroy_v2(cublas_handle), "./Integration.hpp", 120); 
# 122
if (d_wrk_mem) { cudaFree(d_wrk_mem); }  
# 123
} 
# 132
double get_norm_cublas(const cuDoubleComplex *__restrict__ arr) 
# 133
{ 
# 134
CheckCublas(cublasDznrm2_v2(cublas_handle, (nx * ny) * nz, arr, 1, d_norm), "./Integration.hpp", 134); 
# 135
_cuErrCheck(cudaMemcpy(&(h_norm), d_norm, sizeof(double), cudaMemcpyDeviceToHost), "./Integration.hpp", 135); 
# 136
return h_norm; 
# 137
} 
# 139
double normalize_cublas(cuDoubleComplex *arr, double norm_scale = (1.0)) 
# 140
{ 
# 142
(h_norm) = this->get_norm_cublas(arr); 
# 143
(h_norm) = (norm_scale / (h_norm)); 
# 144
_cuErrCheck(cudaMemcpy(d_norm, &(h_norm), sizeof(double), cudaMemcpyHostToDevice), "./Integration.hpp", 144); 
# 146
CheckCublas(cublasZdscal_v2(cublas_handle, (nx * ny) * nz, d_norm, arr, 1), "./Integration.hpp", 146); 
# 148
return (1.0) / (h_norm); 
# 149
} 
# 156
cuDoubleComplex get_exp_val_rect_cublas(double *entity, cuDoubleComplex *psi) 
# 157
{ 
# 159
int nthreads = 1024; 
# 160
dim3 gpu_threads(nthreads); 
# 161
dim3 gpu_blocks(((((nx * ny) * nz) + nthreads) + 1) / nthreads); 
# 162
(cudaConfigureCall((int)ceilf(((float)((nx * ny) * nz)) / nthreads), nthreads)) ? (void)0 : (kernel_RC_mult< nx, ny, nz, 1> )(entity, psi, d_wrk_memZ); 
# 165
CheckCublas(cublasZdotc_v2(cublas_handle, (nx * ny) * nz, psi, 1, d_wrk_memZ, 1, d_int_val), "./Integration.hpp", 165); 
# 167
_cuErrCheck(cudaMemcpy(&(h_int_val), d_int_val, sizeof(cuDoubleComplex), cudaMemcpyDeviceToHost), "./Integration.hpp", 167); 
# 169
return h_int_val; 
# 170
} 
# 175
double get_exp_val_rect_thrust(double *d_array1, cuDoubleComplex *d_array2) 
# 176
{ 
# 177
thrust::plus< double>  op_plus; 
# 178
evaluate_functional op_func; 
# 183
return thrust::inner_product(thrust::device_pointer_cast< double> (d_array1), ((thrust::device_pointer_cast< double> (d_array1)) + (nxyz)), thrust::device_pointer_cast< double2> (d_array2), 0, op_plus, op_func); 
# 185
} 
# 199
double get_exp_val_rect_custom(double *d_entity, cuDoubleComplex *d_psi, const int 
# 200
threads = 1024, cudaStream_t stream = 0) 
# 201
{ 
# 203
int blocks = (int)ceil(((float)(nxyz)) / threads); 
# 204
unsigned lthreads = threads / 2; 
# 205
if (lthreads < (64)) { lthreads = (64); }  
# 206
unsigned new_blocks, current_size; 
# 209
call_DZdreduction(blocks, lthreads, nxyz, d_entity, d_psi, d_wrk_memD, stream); 
# 212
current_size = blocks; 
# 213
while (current_size > (1)) 
# 214
{ 
# 215
new_blocks = ((int)ceil(((float)current_size) / threads)); 
# 216
lthreads = (opt_threads(new_blocks, threads, current_size) / 2); 
# 217
if (lthreads < (64)) { lthreads = (64); }  
# 218
call_reduction_kernel< double> (new_blocks, lthreads, current_size, d_wrk_memD, d_wrk_memD, stream); 
# 219
current_size = new_blocks; 
# 220
}  
# 222
double result; 
# 223
cudaMemcpy(&result, d_wrk_memD, sizeof(double), cudaMemcpyDeviceToHost); 
# 225
return result; 
# 226
} 
# 228
double get_exp_val_rect_threadfence(double *d_entity, cuDoubleComplex *d_psi, const int threads = 256) 
# 229
{ 
# 230
return threadfence_DZdreduce< double> (d_entity, d_psi, d_wrk_memD, nxyz, threads); 
# 231
} 
# 234
}; 
# 51 "expected_val.cu"
inline double __complex__ gaussian3D(double x, double y, double z, double sigma) 
# 52
{ 
# 53
return cexp(((-(1.0)) * (((x * x) + (y * y)) + (z * z))) / (((2.0) * sigma) * sigma)); 
# 54
} 
# 56
inline void fill_array(double __complex__ *psi, double *params) 
# 57
{ 
# 58
printf("%lf\n", params[0]); 
#pragma omp parallel for num_threads(8)
for (int ix = 0; ix < 128; ix++) { 
# 61
for (int iy = 0; iy < 128; iy++) { 
# 62
for (int iz = 0; iz < 128; iz++) 
# 63
{ 
# 65
(psi[iz + (128 * (iy + (128 * ix)))]) = gaussian3D(((double)ix) - (128 / 2), ((double)iy) - (128 / 2), ((double)iz) - (128 / 2), params[0]); 
# 67
}  }  }  
# 68
} 
# 70
inline void potential(double *V, double *params) 
# 71
{ 
#pragma omp parallel for num_threads(8)
for (int ix = 0; ix < 128; ix++) { 
# 74
for (int iy = 0; iy < 128; iy++) { 
# 75
for (int iz = 0; iz < 128; iz++) 
# 76
{ 
# 78
(V[iz + (128 * (iy + (128 * ix)))]) = (1.0); 
# 80
}  }  }  
# 81
} 
# 83
template< class T> inline void 
# 84
save_file(const char *filename, void *data, size_t size) 
# 85
{ 
# 86
FILE *file = fopen(filename, "wb"); 
# 87
fwrite(data, ((size_t)size) * sizeof(T), 1, file); 
# 88
fclose(file); 
# 89
} 
# 91
int main(int argc, char *argv[]) 
# 92
{ 
# 93
double __complex__ *h_psi; 
# 94
cuDoubleComplex *d_psi; 
# 95
double *h_entity, *d_entity; 
# 96
_cuErrCheck(cudaMallocHost((void **)(&h_psi), ((size_t)((128 * 128) * 128)) * sizeof(double __complex__)), "expected_val.cu", 96); 
# 97
_cuErrCheck(cudaMallocHost((void **)(&h_entity), ((size_t)((128 * 128) * 128)) * sizeof(double)), "expected_val.cu", 97); 
# 98
_cuErrCheck(cudaMalloc((void **)(&d_psi), ((size_t)((128 * 128) * 128)) * sizeof(cuDoubleComplex)), "expected_val.cu", 98); 
# 99
_cuErrCheck(cudaMalloc((void **)(&d_entity), ((size_t)((128 * 128) * 128)) * sizeof(double)), "expected_val.cu", 99); 
# 102
Integration< 128, 128, 128>  *integ = new Integration< 128, 128, 128> (); 
# 106
double sigma = (5.0); 
# 107
fill_array(h_psi, &sigma); 
# 108
potential(h_entity, &sigma); 
# 109
save_file< double __complex__> ("orginal.bin", (void *)h_psi, (128 * 128) * 128); 
# 110
_cuErrCheck(cudaMemcpy(d_psi, h_psi, ((((size_t)128) * (128)) * (128)) * sizeof(cuDoubleComplex), cudaMemcpyHostToDevice), "expected_val.cu", 110); 
# 111
_cuErrCheck(cudaMemcpy(d_entity, h_entity, ((((size_t)128) * (128)) * (128)) * sizeof(double), cudaMemcpyHostToDevice), "expected_val.cu", 111); 
# 114
double val = (0.0); 
# 116
printf("Integrating custom...\n"); 
# 117
for (int it = 0; it < 100; it++) { 
# 118
val = integ->get_exp_val_rect_custom(d_entity, d_psi); }  
# 119
printf("%e\t/\t%e\n", val, (0.5) * pow(sqrt((3.141592653589793116)) * sigma, 3)); 
# 120
printf("\n"); 
# 123
printf("Integrating custom...\n"); 
# 124
for (int it = 0; it < 100; it++) { 
# 125
val = integ->get_exp_val_rect_threadfence(d_entity, d_psi, 128); }  
# 126
printf("%e\t/\t%e\n", val, (0.5) * pow(sqrt((3.141592653589793116)) * sigma, 3)); 
# 127
printf("\n"); 
# 130
printf("Integrating Thrust...\n"); 
# 131
for (int it = 0; it < 100; it++) { 
# 132
val = integ->get_exp_val_rect_thrust(d_entity, d_psi); }  
# 133
printf("%e\t/\t%e\n", val, (0.5) * pow(sqrt((3.141592653589793116)) * sigma, 3)); 
# 134
printf("\n"); 
# 138
printf("Integrating CUBLAS...\n"); 
# 139
cuDoubleComplex c_val; 
# 140
for (int it = 0; it < 100; it++) { 
# 141
c_val = integ->get_exp_val_rect_cublas(d_entity, d_psi); }  
# 142
printf("%lf+%lfj\t/\t%lf\n", c_val.x, c_val.y, (0.5) * pow(sqrt((3.141592653589793116)) * sigma, 3)); 
# 143
printf("\n"); 
# 145
delete integ; 
# 146
cudaFree(d_psi); 
# 147
cudaFree(d_entity); 
# 148
cudaFreeHost(h_psi); 
# 149
cudaFreeHost(h_entity); 
# 151
return 0; 
# 152
} 

# 1 "expected_val.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__20_expected_val_cpp1_ii_71016e90
# 1 "expected_val.cudafe1.stub.c"
#include "expected_val.cudafe1.stub.c"
# 1 "expected_val.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
